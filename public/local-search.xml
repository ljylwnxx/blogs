<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack迁移vite</title>
    <link href="/2023/03/29/webpack%E8%BF%81%E7%A7%BBvite/"/>
    <url>/2023/03/29/webpack%E8%BF%81%E7%A7%BBvite/</url>
    
    <content type="html"><![CDATA[<h1 id="一、迁移流程"><a href="#一、迁移流程" class="headerlink" title="一、迁移流程"></a>一、迁移流程</h1><p>1.先创建新的vite项目<br>2.新版vite项目默认是支持vue3的，需要把vue改成vue2版本后配置vite-plugin-vue2插件来支持vue2<br>3.把项目代码改成vue2写法，确保新vite项目可以正常运行vue2<br>4.把原webpack项目生产环境依赖复制到vite项目，剔除掉webpack相关的插件依赖<br>5.复制原项目src文件代码和其他业务相关代码到新vite项目。<br>6.新vite项目配置开发环境启动命令，根据报错信息来进行调整。<br>7.在测试开发和打包环境都没问题后，替换原先的项目。</p><h1 id="二、迁移业务代码到vite项目"><a href="#二、迁移业务代码到vite项目" class="headerlink" title="二、迁移业务代码到vite项目"></a>二、迁移业务代码到vite项目</h1><h2 id="2-1创建新的vite项目"><a href="#2-1创建新的vite项目" class="headerlink" title="2.1创建新的vite项目"></a>2.1创建新的vite项目</h2><p>由于原先项目没有用ts，所以创建项目不选ts版本，包管理工具也依然选择是npm。<br>npm init vite@latest my-vue-app – –template vue<br>创建完成后，使用vs code打开，打开命令行，执行npm i安装依赖<br>npm i<br>安装依赖完成后，使用npm run dev启动项目<br>此时基本的vite2+vue3项目已经启动成功了，但此时vite支持的还是vue3版本的，我们需要让vite支持vue2版本。</p><h2 id="2-2配置vite支持vue2"><a href="#2-2配置vite支持vue2" class="headerlink" title="2.2配置vite支持vue2"></a>2.2配置vite支持vue2</h2><p>此时打开vite.config.js,里面的代码为<br>import { defineConfig } from ‘vite’<br>import vue from ‘@vitejs/plugin-vue’<br>​<br>// <a href="https://vitejs.dev/config/">https://vitejs.dev/config/</a><br>export default defineConfig({<br>  plugins: [vue()]<br>})<br>@vitejs/plugin-vue插件是对vue3语法做支持，如果要支持vue2，需要用vite-plugin-vue2<br>第一步，从vite中删除 @vitejs/plugin-vue配置，从package.json文件中也删除。<br>npm uninstall @vitejs/plugin-vue -D<br>第二步,安装vite-plugin-vue2依赖<br>npm install vite-plugin-vue2 -D<br>第三步,在vite.config.js文件配置vite-plugin-vue2<br>import { defineConfig } from ‘vite’<br>import { createVuePlugin } from “vite-plugin-vue2”;<br>​<br>// <a href="https://vitejs.dev/config/">https://vitejs.dev/config/</a><br>export default defineConfig({<br>  plugins: [createVuePlugin()]<br>})<br>第四步，修改vue版本由3改为2版本<br>npm install vue@2 -S<br>第五步, 修改main.js，创建根vue实例写法改为vue2写法<br>import Vue from ‘vue’<br>import App from ‘./App.vue’<br>​<br>new Vue({<br>  render: h =&gt; h(App),<br>}).$mount(‘#app’)<br>第六步，修改main.js完成后，修改App.vue文件代码为vue2格式代码<br>执行npm run dev，即可看到启动成功,代表此时vite已经支持vue2语法了，可以开始项目迁移工作了。</p><h2 id="2-3复制原项目业务代码"><a href="#2-3复制原项目业务代码" class="headerlink" title="2.3复制原项目业务代码"></a>2.3复制原项目业务代码</h2><p>第一步，复制原项目静态目录static下文件到vite项目public文件夹下<br>第二步，复制原项目index.html文件内容替换vite项目的index.html内容(注意本地静态资源引入的路径)替换后需要在body结束标签前添加 <script type="module" src="/src/main.js"></script><br>第三步, 复制package.json中生产环境依赖到新vite项目,去除webpack相关配置依赖<br>第四步，复制原项目src业务文件代码，直接替换vite项目src文件</p><h1 id="三、项目开发阶段报错处理"><a href="#三、项目开发阶段报错处理" class="headerlink" title="三、项目开发阶段报错处理"></a>三、项目开发阶段报错处理</h1>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微前端-qiankun</title>
    <link href="/2023/03/29/%E5%BE%AE%E5%89%8D%E7%AB%AF-qiankun/"/>
    <url>/2023/03/29/%E5%BE%AE%E5%89%8D%E7%AB%AF-qiankun/</url>
    
    <content type="html"><![CDATA[<p>qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p><h1 id="qiankun-的核心设计理念"><a href="#qiankun-的核心设计理念" class="headerlink" title="qiankun 的核心设计理念"></a>qiankun 的核心设计理念</h1><p>1.简单<br>由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。<br>2.解耦/技术栈无关<br>微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。</p><h1 id="为什么不是-iframe"><a href="#为什么不是-iframe" class="headerlink" title="为什么不是 iframe"></a>为什么不是 iframe</h1><p>为什么不用 iframe，这几乎是所有微前端方案第一个会被 challenge 的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 “炫技” 或者刻意追求 “特立独行”。<br>如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。<br>iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。<br>url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。<br>UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..<br>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。<br>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。<br>其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>1.基于 single-spa 封装，提供了更加开箱即用的 API。<br>2.技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。<br>3.HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。<br>4.样式隔离，确保微应用之间样式互相不干扰。<br>5.JS 沙箱，确保微应用之间 全局变量/事件 不冲突。<br>6.资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。<br>7.umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。</p>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Webpack5搭建一个Vue-Cli</title>
    <link href="/2023/03/27/Vue-Cli/"/>
    <url>/2023/03/27/Vue-Cli/</url>
    
    <content type="html"><![CDATA[<p>大家平时在进行Vue开发的时候，大部分人都是使用 Vue-cli 这个现成的Vue脚手架来进行开发的，但是用它用了这么久，你难道不想自己搭一个属于自己的 Vue-cli 吗？</p><h1 id="1、建一个文件夹"><a href="#1、建一个文件夹" class="headerlink" title="1、建一个文件夹"></a>1、建一个文件夹</h1><p>新建一个文件夹my-vue-cli用来存放项目</p><h1 id="2、初始化npm"><a href="#2、初始化npm" class="headerlink" title="2、初始化npm"></a>2、初始化npm</h1><p>在终端中输入 npm init<br>然后一直回车就行，这样能使项目拥有一个npm管理环境，之后可以在此环境上安装我们所需要的包</p><h1 id="3、webpack、webpack-cli"><a href="#3、webpack、webpack-cli" class="headerlink" title="3、webpack、webpack-cli"></a>3、webpack、webpack-cli</h1><p>安装 webpack、webpack-cli<br>webpack ：打包的工具<br>webpack-cli ：为webpack提供命令行的工具<br>npm i webpack webpack-cli -D</p><h1 id="4、src、public"><a href="#4、src、public" class="headerlink" title="4、src、public"></a>4、src、public</h1><p>在根目录下新建 src、public 这两个文件夹，前者用来放置项目主要代码，后者用来放项目公用静态资源</p><p>public/index.html<br><!DOCTYPE html></p><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>my-vue-cli</title></head><body><div id="app"></div></body></html><p>src/main.js<br>import { add } from ‘./tools/add.js’<br>console.log(add(1, 2))<br>console.log(‘我是main.js’)</p><p>src/tools/add.js<br>export const add = (a, b) =&gt; {<br>return a + b<br>}</p><h1 id="5、入口文件"><a href="#5、入口文件" class="headerlink" title="5、入口文件"></a>5、入口文件</h1><p>刚刚的 main.js 就是我们的入口文件，也就相当于整个引用树的根节点，webpack打包需要从入口文件开始查找，一直到打包所有引用文件。<br>进行入口文件的配置，在根目录下新建 webpack.config.js ：<br>const path = require(‘path’)<br>module.exports = {<br>  // 模式 开发模式<br>  mode: ‘development’,<br>  // 入口文件 main.js<br>  entry: {<br>    main: ‘./src/main.js’<br>  },<br>  // 输出<br>  output: {<br>    // 输出到 dist文件夹<br>    path: path.resolve(__dirname, ‘./dist’),<br>    // js文件下<br>    filename: ‘js/chunk-[contenthash].js’,<br>    // 每次打包前自动清除旧的dist<br>    clean: true,<br>  }<br>}</p><h1 id="6、配置打包命令"><a href="#6、配置打包命令" class="headerlink" title="6、配置打包命令"></a>6、配置打包命令</h1><p>到 package.json 里配置打包命令：</p><p>“scripts”: {<br>    “build”: “webpack”<br>},<br>现在我们到终端输入 npm run build ，就能发现打包成功：<br>但是这其实不是我们要的目的，我们的目的是将这个打包后的最终js文件，插入到刚刚的 index.html 中，因为js文件得让html文件引用，才有意义嘛！所以我们不仅要打包js，还要打包html<br>小知识：loader和plugin<br>loader ：使webpack拥有解析非js文件的能力，如css、png、ts等等<br>plugin ：拓展webpack的打包功能，如优化体积、显示进度条等等</p><h1 id="7、打包html"><a href="#7、打包html" class="headerlink" title="7、打包html"></a>7、打包html</h1><p>打包html需要用到 html-webpack-plugin 这个插件，也就是plugin，所以需要安装一下：<br>npm i html-webpack-plugin -D<br>并且需要在 webpack.config.js 中配置一下<br>const HtmlWebpackPlugin = require(‘html-webpack-plugin’)</p><p>module.exports = {<br>  // 刚刚的代码…</p><p>  // 插件都放 plugins 中<br>  plugins: [<br>    new HtmlWebpackPlugin({<br>      // 选择模板 public/index.html<br>      template: ‘./public/index.html’,<br>      // 打包后的名字<br>      filename: ‘index.html’,<br>      // js文件插入 body里<br>      inject: ‘body’,<br>    }),<br>  ]<br>}<br>现在我们可以在终端中执行打包命令 npm run build 可以看到html被打包了，且打包后的html自动引入打包后的js文件<br>现在我们可以打开打包后的 index.html ，发现控制台可以输出，说明成功了！</p><h2 id="打包CSS"><a href="#打包CSS" class="headerlink" title="打包CSS"></a>打包CSS</h2><p>在 src 下新建 styles 文件夹，用来存放样式文件文件src/styles/index.scss<br>body {<br>background-color: blue;<br>}<br>然后我们在入口文件 main.js 中引入<br>import ‘./styles/index.scss’<br>// 刚刚的代码…<br>我们的目的是，打包 index.scss 这个文件，并且让 index.html 自动引入打包后的css文件，所以我们需要安装以下几个东<br>sass、sass-loader ：可以将scss代码转成css<br>css-loader ：使webpack具有打包css的能力<br>sass-resources-loader ：可选，支持打包全局公共scss文件<br>mini-css-extract-plugin ：可将css代码打包成一个单独的css文件<br>我们安装一下这些插件<br>npm i sass sass-loader sass-resources-loader mini-css-extract-plugin -D<br>然后配置一下 webpack.config.js<br>// 刚才的代码…<br>const MiniCssExtractPlugin = require(‘mini-css-extract-plugin’)<br>module.exports = {<br>  // 刚才的代码…<br>  plugins: [<br>    // 刚才的代码…<br>    new MiniCssExtractPlugin({<br>      // 将css代码输出到dist/styles文件夹下<br>      filename: ‘styles/chunk-[contenthash].css’,<br>      ignoreOrder: true,<br>    }),<br>  ],<br>  module: {<br>    rules: [<br>      {<br>        // 匹配文件后缀的规则<br>        test: /.(css|s[cs]ss)$/,<br>        use: [<br>          // loader执行顺序是从右到左<br>          MiniCssExtractPlugin.loader,<br>          ‘css-loader’,<br>          ‘sass-loader’,<br>          // {<br>          //   loader: ‘sass-resources-loader’,<br>          //   options: {<br>          //     resources: [<br>          //       // 放置全局引入的公共scss文件<br>          //     ],<br>          //   },<br>          // },<br>        ],<br>      },<br>    ]<br>  }<br>}<br>此时我们重新执行打包命令 npm run build ，可以发现出现了打包后的css文件，且 index.html 中自动引入了css文件：<br>我们可以看看页面，可以看到，body的背景已经变成蓝色，说明有效果了.</p><h2 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h2><p>webpack5中已经废弃了 url-loader ，打包图片可以使用 asset-module ，我们先放置一张图片在 src/assets/images 中：并且改写一下 index.css<br>body {<br>  width: 100vw;<br>  height: 100vh;<br>  // 引入背景图片<br>  background-image: url(‘../assets/images/guang.png’);<br>  background-size: 100% 100%;<br>}<br>然后我们在 webpack.config.js 中添加打包图片的配置<br>  module: {<br>    rules: [<br>      // 刚刚的代码…<br>      {<br>        // 匹配文件后缀的规则<br>        test: /.(png|jpe?g|gif|svg|webp)$/,<br>        type: ‘asset’,<br>        parser: {<br>          // 转base64的条件<br>          dataUrlCondition: {<br>             maxSize: 25 * 1024, // 25kb<br>          }<br>        },<br>        generator: {<br>          // 打包到 dist/image 文件下<br>         filename: ‘images/[contenthash][ext][query]’,<br>        },<br>     }<br>    ]<br>  }<br>  我们现在重新运行一下 npm run build ，发现dist下已经有了 images 这个文件夹<br>  我们看一下页面背景图片已经生效，说明打包成功了！</p><h2 id="配置babel"><a href="#配置babel" class="headerlink" title="配置babel"></a>配置babel</h2><p>babel 可以将我们项目中的高级语法转化成比较低级的语法，比如可以将 ES6 转为 ES5 ，这样可以兼容一些低版本浏览器，所以是很有必要的</p><p>首先安装所需的包：<br>@babel/core、babel-loader ：转换语法的工具<br>@babel/preset-env ：转换的一套现成规则<br>@babel/plugin-transform-runtime ：转换async/await所需插件</p><p>npm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime -D<br>由于 babel 是针对js文件的语法转换，所以我们需要在 webpack.config.js 中去针对js进行操作<br>module: {<br>  rules: [<br>    // 刚刚的代码…<br>    {<br>      // 匹配js后缀文件<br>      test: /.js$/,<br>      // 排除node_modules中的js<br>      exclude: /node_modules/,<br>      use: [<br>        ‘babel-loader’<br>      ],<br>    }<br>  ]<br>}<br>单单配置了 babel-loader 还是不够的，我们还需要配置 babel 转换的规则，所以需要在根目录下创建 babel.config.js<br>// babel.config.js</p><p>module.exports = {<br>presets: [<br>  // 配置规则<br>  “@babel/preset-env”<br>],<br>// 配置插件<br>plugins: [“@babel/plugin-transform-runtime”]<br>}<br>此时我们重新运行打包 npm run build ，我们可以发现打包后的js代码中，已经把刚刚代码中的 ES6 语法转成 ES5 语法了！可以看到刚刚代码中的 const 已经转成 ES5 语法了</p><h2 id="打包Vue"><a href="#打包Vue" class="headerlink" title="打包Vue"></a>打包Vue</h2><p>打包Vue需要用到以下几个包：<br>vue ：Vue开发所需的依赖<br>vue-loader ：解析 .vue 文件的loader<br>vue-template-compiler ：解析vue中模板的工具<br>@vue/babel-preset-jsx ：支持解析vue中的jsx语法<br>注意： vue 和 vue-template-compiler 版本需要一致，这里我使用 2.6.14 这个版本， vue-loader 这里我使用了 15.9.8 这个版本<br>所以我们先安装一下：<br>npm i<br><a href="mailto:&#x76;&#x75;&#x65;&#64;&#50;&#x2e;&#x36;&#46;&#49;&#52;">&#x76;&#x75;&#x65;&#64;&#50;&#x2e;&#x36;&#46;&#49;&#52;</a> <a href="mailto:&#118;&#117;&#x65;&#x2d;&#x74;&#x65;&#x6d;&#x70;&#x6c;&#x61;&#116;&#101;&#x2d;&#x63;&#111;&#x6d;&#112;&#105;&#x6c;&#x65;&#x72;&#x40;&#x32;&#46;&#54;&#46;&#49;&#x34;">&#118;&#117;&#x65;&#x2d;&#x74;&#x65;&#x6d;&#x70;&#x6c;&#x61;&#116;&#101;&#x2d;&#x63;&#111;&#x6d;&#112;&#105;&#x6c;&#x65;&#x72;&#x40;&#x32;&#46;&#54;&#46;&#49;&#x34;</a> <a href="mailto:&#118;&#x75;&#x65;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#114;&#64;&#x31;&#53;&#x2e;&#x39;&#46;&#x38;">&#118;&#x75;&#x65;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#114;&#64;&#x31;&#53;&#x2e;&#x39;&#46;&#x38;</a> @vue/babel-preset-jsx -D<br>然后我们需要去 webpack.config.js 中配置对 .vue 文件的解析<br>// 刚才的代码…<br>const { VueLoaderPlugin } = require(‘vue-loader’)</p><p>module.exports = {<br>  // 刚才的代码…<br>  plugins: [<br>    // 刚才的代码…<br>    new VueLoaderPlugin()<br>  ],<br>  module: {<br>    rules: [<br>      // 刚才的代码…<br>      {<br>        test: /.vue$/,<br>        use: ‘vue-loader’,<br>      }<br>    ]<br>  }<br>}<br>并且到 babel.config.js 中配置一下，让webpack支持 .vue 文件中的 jsx 语法<br>module.exports = {<br>  presets: [<br>    “@babel/preset-env”,<br>    // 支持vue中的jsx语法<br>    “@vue/babel-preset-jsx”<br>  ],<br>  plugins: [“@babel/plugin-transform-runtime”]<br>}<br>现在我们可以在 src 下新建一个 App.vue<br><template><br>  <div class="box">我是App哈哈哈哈</div><br></template></p><script>export default {}</script><style lang="scss">.box {  width: 500px;  height: 200px;  color: #fff;  background-color: #000;}</style><p>然后改写一下 src/main.js<br>import Vue from ‘vue’<br>import App from ‘./App.vue’</p><p>new Vue({<br>  render: (h) =&gt; h(App),<br>}).$mount(‘#app’)<br>此时我们重新运行 npm run build ，我们可以看看页面的效果，说明打包成功啦！</p><h2 id="配置路径别名"><a href="#配置路径别名" class="headerlink" title="配置路径别名"></a>配置路径别名</h2><p>有时候文件引用搁着太多层，引用起来会看起来很不明确，比如<br>../../../../../App.vue ，所以我们可以配置一下别名 alia</p><p>module.exports = {<br>  // 刚才的代码…<br>  resolve: {<br>    // 路径别名<br>    alias: {<br>      ‘@’: path.resolve(‘./src’),<br>      assets: ‘<del>/assets’,<br>      tools: ‘</del>/tools’<br>    },<br>    // 引入文件时省略后缀<br>    extensions: [‘.js’, ‘.ts’, ‘.less’, ‘.vue’],<br>  },<br>}<br>现在别名配置完成啦：<br>配置前： ../../../../../App.vue<br>配置后： @/App.vue</p><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>刚刚我们发现，每改一次代码就得重新打包一次，非常繁琐，有没有可以改代码自动重新打包的呢？这就要用到 webpack-dev-server</p><p>npm i webpack-dev-server -D<br>到 webpack.config.js 中配置 devServer</p><p>  devServer: {<br>    // 自定义端口号<br>    // port:7000,<br>    // 自动打开浏览器<br>    open: true<br>  },<br>然后到 package.json 中配置一下启动命令</p><p>  “scripts”: {<br>    “build”: “webpack”,<br>    “serve”: “webpack serve”<br>  },<br>此时我们运行 npm run serve 就可以启动项目啦！</p><h2 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h2><p>我们不能把所有配置都配置在一个 webpack.config.js 中，因为我们有两个环境 development(开发环境)、production(生产环境) ，所以我们在根目录下创建 build文件夹 ，并创建三个文件<br>webpack.base.js ：两个环境共用配置<br>入口，输出配置<br>各种文件的处理<br>进度条展示<br>路径别名<br>webpack.dev.js ：开发环境独有配置<br>webpack-dev-server<br>不同的source-map模式<br>不同的环境变量<br>webpack.prod.js ：生产环境独有配置<br>不同的source-map模式<br>不同的环境变量<br>我们需要先安装一个合并插件 webpack-merge ，用于两个环境的配置可以合并公共的配置<br>npm i webpack-merge -D<br>然后我们在根目录下新建一个 build文件夹 ，并在此文件夹下新建 webpack.base.js、webpack.dev.js、webpack.config.js<br>// 公共配置</p><p>const path = require(‘path’)<br>const HtmlWebpackPlugin = require(‘html-webpack-plugin’)<br>const MiniCssExtractPlugin = require(‘mini-css-extract-plugin’)<br>const { VueLoaderPlugin } = require(‘vue-loader’)<br>module.exports = {<br>// 入口文件 main.js<br>entry: {<br>  main: ‘./src/main.js’<br>},<br>// 输出<br>output: {<br>  // 输出到 dist文件夹<br>  // 记得改路径<br>  path: path.resolve(__dirname, ‘../dist’),<br>  // js文件下<br>  filename: ‘js/chunk-[contenthash].js’,<br>  // 每次打包前自动清除旧的dist<br>  clean: true,<br>},<br>plugins: [<br>  new HtmlWebpackPlugin({<br>    // 选择模板 public/index.html<br>    template: ‘./public/index.html’,<br>    // 打包后的名字<br>    filename: ‘index.html’,<br>    // js文件插入 body里<br>    inject: ‘body’,<br>  }),<br>  new MiniCssExtractPlugin({<br>    // 将css代码输出到dist/styles文件夹下<br>    filename: ‘styles/chunk-[contenthash].css’,<br>    ignoreOrder: true,<br>  }),<br>  new VueLoaderPlugin()<br>],<br>module: {<br>  rules: [<br>    {<br>      // 匹配文件后缀的规则<br>      test: /.(css|s[cs]ss)$/,<br>      use: [<br>        // loader执行顺序是从右到左<br>        MiniCssExtractPlugin.loader,<br>        ‘css-loader’,<br>        ‘sass-loader’,<br>        // {<br>        //   loader: ‘sass-resources-loader’,<br>        //   options: {<br>        //     resources: [<br>        //       // 放置全局引入的公共scss文件<br>        //     ],<br>        //   },<br>        // },<br>      ],<br>    },<br>    {<br>      // 匹配文件后缀的规则<br>      test: /.(png|jpe?g|gif|svg|webp)$/,<br>      type: ‘asset’,<br>      parser: {<br>        // 转base64的条件<br>        dataUrlCondition: {<br>          maxSize: 25 * 1024, // 25kb<br>        }<br>      },<br>      generator: {<br>        // 打包到 dist/image 文件下<br>        filename: ‘images/[contenthash][ext][query]’,<br>      },<br>    },<br>    {<br>      test: /.js$/,<br>      // 排除node_modules中的js<br>      exclude: /node_modules/,<br>      use: [<br>        ‘babel-loader’<br>      ],<br>    },<br>    {<br>      test: /.vue$/,<br>      use: ‘vue-loader’,<br>    }<br>  ]<br>},<br>resolve: {<br>  // 路径别名<br>  alias: {<br>    ‘@’: path.resolve(‘./src’),<br>    assets: ‘~/assets’<br>  },<br>  // 引入文件时省略后缀<br>  extensions: [‘.js’, ‘.ts’, ‘.less’, ‘.vue’]<br>},<br>}<br>webpack.dev.js</p><p>// 开发环境</p><p>const { merge } = require(‘webpack-merge’)<br>const base = require(‘./webpack.base’)</p><p>module.exports = merge(base, {<br>mode: ‘development’,<br>devServer: {<br>  open: true,<br>  // hot: true,<br>}<br>})<br>webpack.prod.js</p><p>// 生产环境</p><p>const { merge } = require(‘webpack-merge’)<br>const base = require(‘./webpack.base’)</p><p>module.exports = merge(base, {<br>mode: ‘production’<br>})<br>然后我们到 package.json 修改一下指令</p><p>  “scripts”: {<br>    “serve”: “webpack serve –config ./build/webpack.dev”,<br>    “build”: “webpack –config ./build/webpack.prod”<br>  },<br>接下来我们运行这两个命令，发现都成功了：</p><p>npm run build<br>npm run serve</p><h2 id="构建进度条"><a href="#构建进度条" class="headerlink" title="构建进度条"></a>构建进度条</h2><p>无论是启动项目时还是打包时，都需要进度条的展示，所以需要把进度条配置在 webpack.base 中，我们需要先安装进度条的插件 progress-bar-webpack-plugin</p><p>npm i progress-bar-webpack-plugin -D<br>// webpack.base.js</p><p>// 刚刚的代码…<br>const ProgressBarPlugin = require(‘progress-bar-webpack-plugin’)<br>const chalk = require(‘chalk’)</p><p>module.exports = {<br>  // 刚刚的代码…<br>  plugins: [<br>    // 刚刚的代码…<br>    new ProgressBarPlugin({<br>      format: <code> build [:bar] $&#123;chalk.green.bold(&#39;:percent&#39;)&#125; (:elapsed seconds)</code>,<br>    })<br>  ],<br>  // 刚刚的代码…<br>}<br>现在我们可以看到无论启动项目或者打包，都会有进度条了</p><h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><p>source-map 的作用：代码报错时，能快速定位到出错位置， webpack5 的所有 source-map模式 可以看webpack官网：<a href="https://webpack.docschina.org/">https://webpack.docschina.org</a>…</p><p>这里我使用两种模式：<br>development ：使用 eval-cheap-module-source-map 模式，能具体定位到源码位置和源码展示，适合开发模式，体积较小<br>production ：使用 nosources-source-map ，只能定位源码位置，不能源码展示，体积较小，适合生产模式<br>所以我们开始配置 source-map</p><p>webpack.dev.js<br>// 刚才的代码…<br>module.exports = merge(base, {<br>// 刚才的代码…<br>devtool: ‘eval-cheap-module-source-map’<br>})<br>webpack.prod.js<br>// 刚才的代码…<br>module.exports = merge(base, {<br>// 刚才的代码…<br>devtool: ‘nosources-source-map’<br>})</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>配置 devlopment、production 这两个环境的环境变量<br>webpack.dev.js<br>// 刚才的代码…<br>const webpack = require(‘webpack’)<br>module.exports = merge(base, {<br>// 刚才的代码…<br>plugins: [<br>  // 定义全局变量<br>  new webpack.DefinePlugin({<br>    process: {<br>      env: {<br>        NODE_DEV: JSON.stringify(‘development’),<br>        // 这里可以定义你的环境变量<br>        // VUE_APP_URL: JSON.stringify(‘<a href="https://xxx.com&/#39;">https://xxx.com&#39;</a>)<br>      },<br>    },<br>  }),<br>]<br>})<br>webpack.prod.js</p><p>// 刚才的代码…<br>const webpack = require(‘webpack’)</p><p>module.exports = merge(base, {<br>// 刚才的代码…<br>plugins: [<br>  // 定义全局变量<br>  new webpack.DefinePlugin({<br>    process: {<br>      env: {<br>        NODE_DEV: JSON.stringify(‘prodction’),<br>        // 这里可以定义你的环境变量<br>        // VUE_APP_URL: JSON.stringify(‘<a href="https://xxx.com&/#39;">https://xxx.com&#39;</a>)<br>      },<br>    },<br>  }),<br>]<br>})</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微前端</title>
    <link href="/2023/03/27/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    <url>/2023/03/27/%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h1><p>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化web应用的技术手段及方法策略。<br>微前端可以将多个小型应用整合成一个完整的应用。每个小型应用都是独立开发、独立运行、独立部署的，这就意味着可以多团队并行开发 且有无冲突、无阻塞等特点。</p><h1 id="微前端架构具备以下几个核心价值："><a href="#微前端架构具备以下几个核心价值：" class="headerlink" title="微前端架构具备以下几个核心价值："></a>微前端架构具备以下几个核心价值：</h1><p>1.技术栈无关<br>主框架不限制接入应用的技术栈，微应用具备完全自主权<br>2.独立开发、独立部署<br>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新<br>3.增量升级<br>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略<br>4.独立运行时<br>每个微应用之间状态隔离，运行时状态不共享</p><h1 id="常见的微前端实现方式"><a href="#常见的微前端实现方式" class="headerlink" title="常见的微前端实现方式"></a>常见的微前端实现方式</h1><p>1.路由分发<br>简单来说，其实就是通过网关/代理对路由进行监听，对不同的路由路径导向不同的前端资源入口。<br>例如：<br>使用 Nginx 代理了 localhost:80；<br>然后访问路径为 /app1 的时候，返回 html/app1/index.html 的文件；<br>访问路径为 /app2 的时候，返回 html/app2/index.html 的文件。<br>这种方式由于是多页面应用，所以用户体验不好，而且比较依赖于后端，应用之间存在着耦合问题。</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>开发成本低<br>配置简单</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>多应用之间切换时，每个应用都会重新加载，影响体验（可以思考 传统页面 和 SPA 区别）<br>多应用间不能共享数据<br>多应用间通信困难<br>多应用公共依赖重复加载</p><h2 id="2-iframe"><a href="#2-iframe" class="headerlink" title="2.iframe"></a>2.iframe</h2><p>它的作用就是在网页中嵌套另一个网页，那么通过这种特性就可以实现微前端了。<br>但实际上个大微前端框架，就没有一个是用iframe去做的，因为iframe有着很多的问题，其中一些甚至是无法解决的。</p><h2 id="优点：完美支持js隔离，样式隔离"><a href="#优点：完美支持js隔离，样式隔离" class="headerlink" title="优点：完美支持js隔离，样式隔离"></a>优点：完美支持js隔离，样式隔离</h2><h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><p>url 不同步， 浏览器刷新时，iframe中的url 状态会丢失<br>iframe局部弹框<br>内外通信效率低下，变量不能共享<br>每次进入，资源都会被重新加载，速度较慢</p><h2 id="3-Web-Components"><a href="#3-Web-Components" class="headerlink" title="3.Web Components"></a>3.Web Components</h2><p>Web Components 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。<br>(1)Custom elements（自定义元素） 一组 JavaScript API，允许您定义custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。<br>(2)Shadow DOM（影子 DOM） ：一组JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。<br>(3)HTML templates（HTML 模板）： <template> 和 <slot> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</p><h2 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h2><p>每个服务拥有独立的脚本和样式</p><h2 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h2><p>改造成本大<br>各个浏览器兼容不友好<br>多应用公共依赖重复加载</p><h2 id="4-single-SPA"><a href="#4-single-SPA" class="headerlink" title="4.single-SPA"></a>4.single-SPA</h2><p>single-spa 提供了一种基于路由的基座化的微前端方案，它将应用分为两类：基座应用和子应用。其中，子应用对应前面我们讲到的需要聚合的应用，基座应用是另外一个单独的应用，用于聚合子应用。在基座应用中，我们会维护一个路由注册表 - 每个路由对应一个子应用。基座应用启动以后，当我们切换路由时，如果是一个新的子应用，会动态获取子应用的 js 脚本，然后执行脚本并渲染出相应的页面；如果是一个已经访问过的子应用，那么就会从基座应用的缓存中获取已经缓存的子应用，激活子应用并渲染出对应的页面。</p><h2 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h2><p>良好的体验，多服务切换如同单体SPA<br>具备服务的生命周期<br>共享数据<br>兼容不同技术栈运行</p><h2 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h2><p>多应用间，无多应用沙箱机制<br>多应用间，样式命名不慎会导致冲突<br>js entry 导致子服务和基座强耦合</p><h2 id="5-qiankun"><a href="#5-qiankun" class="headerlink" title="5.qiankun"></a>5.qiankun</h2><p>乾坤是 @kuitos 大佬开发的，阿里出品。目前来说，是最完美的微前端解决方案，也是start最多的。<br>其代码写的很漂亮，建议大家去阅读，学习。</p><h2 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h2><p>基于single-SPA封装，开箱即用<br>技术无关，多技术栈可以共存<br>html entry接入，解耦基座和子服务<br>样式隔离<br>js沙箱机制<br>资源预加载<br>提供全局错误机制<br>提供跨服务通信机制<br>提供服务的生命周期<br>脱离基座，单个服务降级运行策略处理</p><h2 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h2><p>共享运行时缓存支持<br>不兼容ie系列 </p><h1 id="现有市面框架"><a href="#现有市面框架" class="headerlink" title="现有市面框架"></a>现有市面框架</h1><p>1.single-spa 将多个单页面应用聚合为一个整体应用的JavaScript 微前端框架<br>2.qiankun 蚂蚁金服，在 single-spa 的基础上封装<br>3.MicroApp 京东，一款基于WebComponent的思想，轻量、高效、功能强大的微前端框架<br>4.无界 腾讯无界微前端方案基于 WebComponent 容器 + iframe 沙箱<br>5.EMP YY语音，基于Webpack5 Module Federation 除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力<br>6.icestark 阿里出品，是一个面向大型系统的微前端解决方案<br>7.garfish 字节跳动<br>8.magic-microservices 一款基于 Web Components 的轻量级的微前端工厂函数</p><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。<br>更多关于微前端的相关介绍，推荐大家可以去看这几篇文章：<br>Micro Frontends [<a href="https://micro-frontends.org/]">https://micro-frontends.org/]</a><br>Micro Frontends from martinfowler.com [<a href="https://martinfowler.com/articles/micro-frontends.html]">https://martinfowler.com/articles/micro-frontends.html]</a></p>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>component动态组件</title>
    <link href="/2023/03/23/component%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/03/23/component%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是动态组件？"><a href="#一、什么是动态组件？" class="headerlink" title="一、什么是动态组件？"></a>一、什么是动态组件？</h1><p>定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。<br>书写形式：<component :is="componentName"></component><br>内置组件：<br>component：是vue里面的一个内置组件。作用是：配合is动态渲染组件。<br>vue内置的组件还包括：<br>transition：作为单个元素/组件的过渡效果。<br>transition-group：作为多个元素/组件的过渡效果。<br>keep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。<br>slot：作为组件模板之中的内容分发插槽。</p><h1 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h1><p>通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。<br>如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。<br>1.在不同组件之间进行动态切换<br>component动态组件就是通过控制currentTabComponent来切换不同的组件。</p><div @click="reload">点击切换</div> <component :is="currentTabComponent"></component><script>import childOne from './childOne'import childTwo from './childTwo'export default {    componets:{        childOne,        childTwo    },    data(){        currentTabComponent: 'childOne'    },    methods:{        reload(){            this.currentTabComponent = 'childTwo'        }    }}</script><h1 id="三、动态组件的缓存"><a href="#三、动态组件的缓存" class="headerlink" title="三、动态组件的缓存"></a>三、动态组件的缓存</h1><p>使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br><keep-alive><br>    <component :is="componentName"></component><br></keep-alive></p>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组，对象遍历的用法总结</title>
    <link href="/2023/03/21/%E6%95%B0%E7%BB%84%EF%BC%8C%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/21/%E6%95%B0%E7%BB%84%EF%BC%8C%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。<br>前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。</p><h1 id="一、遍历数组"><a href="#一、遍历数组" class="headerlink" title="一、遍历数组"></a>一、遍历数组</h1><h2 id="方法一：for循环"><a href="#方法一：for循环" class="headerlink" title="方法一：for循环"></a>方法一：for循环</h2><h3 id="for-循环是使用最多，也是性能优化最好的一种遍历方式。"><a href="#for-循环是使用最多，也是性能优化最好的一种遍历方式。" class="headerlink" title="for 循环是使用最多，也是性能优化最好的一种遍历方式。"></a>for 循环是使用最多，也是性能优化最好的一种遍历方式。</h3><p>var arr = [“a”, “b”, “c”]<br>for (var i = 0; i &lt; arr.length; i++) {<br>  console.log(arr[i])<br>}<br>// Expected output:a b c</p><h2 id="方法二：for-of-遍历"><a href="#方法二：for-of-遍历" class="headerlink" title="方法二：for-of 遍历"></a>方法二：for-of 遍历</h2><p>var arr = [“a”, “b”, “c”]<br>for (let item of arr) {<br>  console.log(item)<br>}<br>// Expected output:a b c</p><h2 id="方法三：数组方法"><a href="#方法三：数组方法" class="headerlink" title="方法三：数组方法"></a>方法三：数组方法</h2><h3 id="1-forEach-方法，对原数组没有影响"><a href="#1-forEach-方法，对原数组没有影响" class="headerlink" title="1.forEach()方法，对原数组没有影响"></a>1.forEach()方法，对原数组没有影响</h3><p>var arr = [“a”, “b”, “c”]<br>arr.forEach((index, item) =&gt; {<br>  console.log(index, item)<br>})<br>//Expected output:<br>// a 0<br>// b 1<br>// c 2</p><hr><h3 id="2-map-方法"><a href="#2-map-方法" class="headerlink" title="2.map()方法"></a>2.map()方法</h3><p>var arr = [1, 2, 3]<br>var newArr = arr.map(item =&gt; {<br>  return item * 2<br>});<br>console.log(newArr);<br>// Expected output:[2, 4, 6]</p><hr><h3 id="3-filter-方法，不改变原始数组"><a href="#3-filter-方法，不改变原始数组" class="headerlink" title="3.filter()方法，不改变原始数组"></a>3.filter()方法，不改变原始数组</h3><p>var arr = [1, 2, 3]<br>var newArr = arr.filter(item =&gt; {<br>  return item &gt; 1<br>});<br>console.log(newArr)<br>// Expected output:[2, 3]</p><hr><h3 id="4-reduce-方法"><a href="#4-reduce-方法" class="headerlink" title="4.reduce()方法"></a>4.reduce()方法</h3><p>var arr = [1, 2, 3]<br>var sum = arr.reduce((pre, cur) =&gt; {<br>  return pre + cur<br>});<br>console.log(sum)<br>// Expected output:6</p><hr><h3 id="5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。"><a href="#5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。" class="headerlink" title="5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。"></a>5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。</h3><p>var arr = [1, 2, 3]<br>var bool = arr.every(item =&gt; {<br>  return item &lt; 5<br>});<br>console.log(bool)<br>// Expected output:true</p><hr><h3 id="6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。"><a href="#6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。" class="headerlink" title="6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。"></a>6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。</h3><h4 id="下面的例子是检测数组元素是否存在-Number-类型。"><a href="#下面的例子是检测数组元素是否存在-Number-类型。" class="headerlink" title="下面的例子是检测数组元素是否存在 Number 类型。"></a>下面的例子是检测数组元素是否存在 Number 类型。</h4><p>var arr = [“a”, 1, “b”]<br>var bool = arr.some(item =&gt; {<br>  return typeof item === “number”<br>})<br>console.log(bool)<br>// Expected output:true</p><hr><h3 id="7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。"><a href="#7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。" class="headerlink" title="7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。"></a>7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。</h3><p>let arr = [1, 2, 3, 4, 5]<br>let find = arr.find((item) =&gt; {<br>  return item % 2 === 0<br>})<br>// Expected output:find =2</p><hr><p>var arr = [1, 2, 3]<br>var ret = arr.find(ele =&gt; ele &gt; 2)<br>console.log(ret)<br>// Expected output:3<br>console.log(arr)<br>// Expected output:[1, 2, 3]</p><hr><h3 id="8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。"><a href="#8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。" class="headerlink" title="8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。"></a>8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。</h3><p>let arr = [1, 2, 3, 4, 5]<br>let findIndex = arr.findIndex((item) =&gt; {<br>  return item % 2 === 0<br>})<br>// Expected output:findIndex = 1</p><hr><p>var arr = [1, 2, 3, 4 ,5]<br>var ret = arr.findIndex(ele =&gt; ele &gt; 2)<br>console.log(ret)<br>// Expected output:2<br> console.log(arr)<br>// Expected output:[1, 2, 3, 4, 5]</p><hr><h1 id="二、遍历对象"><a href="#二、遍历对象" class="headerlink" title="二、遍历对象"></a>二、遍历对象</h1><h2 id="方法一：for-in-循环"><a href="#方法一：for-in-循环" class="headerlink" title="方法一：for-in 循环"></a>方法一：for-in 循环</h2><p>var obj = { a: 2, b: 4, c: 6 }<br>for (let key in obj) {<br>  console.log(key)<br>}<br>// Expected output:a b c</p><h2 id="方法二：Object-keys-可理解为返回里面的key属性"><a href="#方法二：Object-keys-可理解为返回里面的key属性" class="headerlink" title="方法二：Object.keys() 可理解为返回里面的key属性"></a>方法二：Object.keys() 可理解为返回里面的key属性</h2><h3 id="1-处理对象时：返回可枚举的属性数组"><a href="#1-处理对象时：返回可枚举的属性数组" class="headerlink" title="1.处理对象时：返回可枚举的属性数组"></a>1.处理对象时：返回可枚举的属性数组</h3><p>var w_n = Object.keys({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[‘name’, ‘address’]</p><hr><h3 id="2-处理数组时：返回索引值数组"><a href="#2-处理数组时：返回索引值数组" class="headerlink" title="2.处理数组时：返回索引值数组"></a>2.处理数组时：返回索引值数组</h3><p>var w_n = Object.keys([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[‘0’,’1’,’2’,’3’]</p><hr><h3 id="3-处理字符串数据时：返回索引值数组"><a href="#3-处理字符串数据时：返回索引值数组" class="headerlink" title="3.处理字符串数据时：返回索引值数组"></a>3.处理字符串数据时：返回索引值数组</h3><p>var str=’hello’;<br>console.log(Object.keys(str))<br>// Expected output:[‘0’,’1’,’2’,’3’,’4’]</p><h2 id="方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。"><a href="#方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。" class="headerlink" title="方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。"></a>方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。</h2><h3 id="1-处理对象数据时：返回可枚举的值组成的数组"><a href="#1-处理对象数据时：返回可枚举的值组成的数组" class="headerlink" title="1.处理对象数据时：返回可枚举的值组成的数组"></a>1.处理对象数据时：返回可枚举的值组成的数组</h3><p>var w_n = Object.values({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[‘wn’, ‘中国’]</p><hr><h3 id="2-处理数组数据时：返回原数组"><a href="#2-处理数组数据时：返回原数组" class="headerlink" title="2.处理数组数据时：返回原数组"></a>2.处理数组数据时：返回原数组</h3><p>var w_n = Object.values([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[11,22,33,44]</p><hr><h3 id="属性名为数值的属性，是按照数值大小，从小到大遍历的。"><a href="#属性名为数值的属性，是按照数值大小，从小到大遍历的。" class="headerlink" title="属性名为数值的属性，是按照数值大小，从小到大遍历的。"></a>属性名为数值的属性，是按照数值大小，从小到大遍历的。</h3><p>const obj = {10 : “a”, 6 : “b”, 9 : “c”}<br>console.log(Object.values(obj))<br>// Expected output:[‘b’, ‘c’, ‘a’]</p><hr><h3 id="3-处理字符串数据时：返回每个字符组成的数组"><a href="#3-处理字符串数据时：返回每个字符组成的数组" class="headerlink" title="3.处理字符串数据时：返回每个字符组成的数组"></a>3.处理字符串数据时：返回每个字符组成的数组</h3><p>console.log(Object.values(‘hello’))<br>// Expected output:[‘h’, ‘e’, ‘l’, ‘l’, ‘o’]</p><hr><h3 id="4-Object-values会过滤属性名为-Symbol-值的属性"><a href="#4-Object-values会过滤属性名为-Symbol-值的属性" class="headerlink" title="4.Object.values会过滤属性名为 Symbol 值的属性"></a>4.Object.values会过滤属性名为 Symbol 值的属性</h3><p>Object.values({ [Symbol()]: 123, foo: ‘abc’ })<br>// Expected output:[‘abc’]</p><h2 id="方法四：Object-entries-方法"><a href="#方法四：Object-entries-方法" class="headerlink" title="方法四：Object.entries()方法"></a>方法四：Object.entries()方法</h2><h3 id="1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。"><a href="#1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。" class="headerlink" title="1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。"></a>1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。</h3><p>var w_n = Object.entries({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[[‘name’, ‘wn’], [‘address’, ‘中国’]]</p><hr><h3 id="2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。"><a href="#2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。" class="headerlink" title="2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。"></a>2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。</h3><p>var w_n = Object.entries([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[ [‘0’,11], [‘1’,22], [‘2’,33], [‘3’,44] ]</p><hr><h3 id="数组中包含对象："><a href="#数组中包含对象：" class="headerlink" title="数组中包含对象："></a>数组中包含对象：</h3><p>var w_n = Object.entries([{a:11},22,33,44])<br>console.log(w_n)<br>// Expected output:[ [‘0’,{a:11}], [‘1’,22], [‘2’,33], [‘3’,44] ]</p><hr><h3 id="3-处理字符串数据时：返回也是一个二维数组。"><a href="#3-处理字符串数据时：返回也是一个二维数组。" class="headerlink" title="3.处理字符串数据时：返回也是一个二维数组。"></a>3.处理字符串数据时：返回也是一个二维数组。</h3><p>var str=’hello’<br>console.log(Object.entries(str))<br>// Expected output:[ [‘0’,’h’], [‘1’,’e’], [‘2’,’l’], [‘3’,’l’] ,[‘4’,’o’] ]</p><h2 id="方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。"><a href="#方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。" class="headerlink" title="方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。"></a>方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</h2><h3 id="注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。"><a href="#注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。" class="headerlink" title="注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。"></a>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</h3><p>const target = { a: 1, b: 2 };<br>const source = { b: 4, c: 5 };<br>const returnedTarget = Object.assign(target, source);<br>console.log(target);<br>// Expected output: Object { a: 1, b: 4, c: 5 }</p><h2 id="方法六：Object-getOwnPropertyNames"><a href="#方法六：Object-getOwnPropertyNames" class="headerlink" title="方法六：Object.getOwnPropertyNames()"></a>方法六：Object.getOwnPropertyNames()</h2><h3 id="Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。"><a href="#Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。" class="headerlink" title="Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。"></a>Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。</h3><p>var arr = [“a”, “b”, “c”]<br>console.log(Object.getOwnPropertyNames(arr).sort())<br>// [“0”, “1”, “2”, “length”]</p><hr><h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="// 类数组对象"></a>// 类数组对象</h3><p>var obj = { 0: “a”, 1: “b”, 2: “c”}<br>console.log(Object.getOwnPropertyNames(obj).sort())<br>// Expected output:[“0”, “1”, “2”]</p><hr><h3 id="使用-Array-forEach-输出属性名和属性值"><a href="#使用-Array-forEach-输出属性名和属性值" class="headerlink" title="// 使用 Array.forEach 输出属性名和属性值"></a>// 使用 Array.forEach 输出属性名和属性值</h3><p>Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) {<br>  console.log(val + “ -&gt; “ + obj[val])<br>})<br>// Expected output:<br>// 0 -&gt; a<br>// 1 -&gt; b<br>// 2 -&gt; c</p><hr><h3 id="不可枚举属性"><a href="#不可枚举属性" class="headerlink" title="//不可枚举属性"></a>//不可枚举属性</h3><p>var my_obj = Object.create({}, {<br>  getFoo: {<br>    value: function() { return this.foo; },<br>    enumerable: false<br>  }<br>})<br>my_obj.foo = 1<br>console.log(Object.getOwnPropertyNames(my_obj).sort())<br>// Expected output:[“foo”, “getFoo”]</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析vue项目中npm run dev和npm run serve的区别</title>
    <link href="/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？"><a href="#先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？" class="headerlink" title="先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？"></a>先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？</h1><p>通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？</p><h2 id="在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。"><a href="#在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。" class="headerlink" title="在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。"></a>在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。</h2><h1 id="首先看看npm是什么？"><a href="#首先看看npm是什么？" class="headerlink" title="首先看看npm是什么？"></a>首先看看npm是什么？</h1><p>npm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本</p><h1 id="在看看npm-install命令"><a href="#在看看npm-install命令" class="headerlink" title="在看看npm install命令"></a>在看看npm install命令</h1><p>在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹<br>主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下</p><h1 id="然后看看运行npm-run-×××命令的原理"><a href="#然后看看运行npm-run-×××命令的原理" class="headerlink" title="然后看看运行npm run ×××命令的原理"></a>然后看看运行npm run ×××命令的原理</h1><p>大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？<br>在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段<br><img src="/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/npm%E5%8C%BA%E5%88%AB.png"></p><hr><p>我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？<br>答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目</p><h1 id="既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？"><a href="#既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？" class="headerlink" title="既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？"></a>既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？</h1><p>正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？<br>我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。</p>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3新语法细节</title>
    <link href="/2023/01/10/vue3%E6%96%B0%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"/>
    <url>/2023/01/10/vue3%E6%96%B0%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<p>1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。</p><p>2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。</p><p>3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。</p><p>4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。</p><p>5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。</p><p>6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。</p><p>7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。</p><p>8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。</p><p>9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。</p><p>10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。</p><p>11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 <code>@vitejs/plugin-vue-jsx</code> 插件来支持 JSX语法，那么定义函数式组件就更加方便了。</p><p>12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。</p><p>13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。</p><p>14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。</p><p>15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。</p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-axios</title>
    <link href="/2022/12/19/Vue-axios/"/>
    <url>/2022/12/19/Vue-axios/</url>
    
    <content type="html"><![CDATA[<p>众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。<br>说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？<br>在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。<br>如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～</p><h1 id="一、前端从后端获取数据的方式通常采用http-https的方式"><a href="#一、前端从后端获取数据的方式通常采用http-https的方式" class="headerlink" title="一、前端从后端获取数据的方式通常采用http/https的方式"></a>一、前端从后端获取数据的方式通常采用http/https的方式</h1><p>方法通常有GET、POST、PUT、DELETE、PATCH这五种；<br>GET==&gt;用来获取数据，<br>POST==&gt; 是用来新增数据表单提交或文件上传<br>DELETE==&gt;是用来删除数据<br>PUT==&gt;是用来更新数据（所有数据推送到后端）<br>PATCH==&gt;是用来更新数据（只将修改的数据推送到后端）</p><h1 id="二、从前端请求后端接口获取数据格式："><a href="#二、从前端请求后端接口获取数据格式：" class="headerlink" title="二、从前端请求后端接口获取数据格式："></a>二、从前端请求后端接口获取数据格式：</h1><p>GET方法：</p><h2 id="1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑"><a href="#1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑" class="headerlink" title="1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})"></a>1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><h2 id="2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑"><a href="#2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑" class="headerlink" title="2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})"></a>2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><p>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。</p><h2 id="POST方法（appcation-json或者form-data）："><a href="#POST方法（appcation-json或者form-data）：" class="headerlink" title="POST方法（appcation/json或者form-data）："></a>POST方法（appcation/json或者form-data）：</h2><h3 id="1、①appcation-json方式"><a href="#1、①appcation-json方式" class="headerlink" title="1、①appcation/json方式"></a>1、①appcation/json方式</h3><p>let data={id:12}<br>axios.post(url,data,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p><h3 id="②appcation-json方式："><a href="#②appcation-json方式：" class="headerlink" title="②appcation/json方式："></a>②appcation/json方式：</h3><p>let data={id:12}<br>axios({method:’post’,url,data:data,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p><h3 id="2、①form-data方式"><a href="#2、①form-data方式" class="headerlink" title="2、①form-data方式"></a>2、①form-data方式</h3><p>let data={id:12}<br>let formData = new FormData()<br>for(let key in data){<br>formData.append(key,data[key])<br>}<br>axios.post(url,formData,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p><h3 id="②form-data方式"><a href="#②form-data方式" class="headerlink" title="②form-data方式"></a>②form-data方式</h3><p>let data={id:12}<br>let formData = new FormData()<br>for(let key in data){<br>formData.append(key,data[key])<br>}<br>axios({method:’post’,url,formData:formData,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>post请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。</p><h2 id="PUT和PATCH方式："><a href="#PUT和PATCH方式：" class="headerlink" title="PUT和PATCH方式："></a>PUT和PATCH方式：</h2><p>put和patch跟post一样，就方法不一样而已，参考post方法。</p><h2 id="DELETE方式："><a href="#DELETE方式：" class="headerlink" title="DELETE方式："></a>DELETE方式：</h2><p>类似get方式，就方法不一样而已，参考get方法。<br>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，<br>注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。</p><h1 id="三、axios并发请求"><a href="#三、axios并发请求" class="headerlink" title="三、axios并发请求"></a>三、axios并发请求</h1><h2 id="并发请求：同时进行多个请求，并统一处理返回值。"><a href="#并发请求：同时进行多个请求，并统一处理返回值。" class="headerlink" title="并发请求：同时进行多个请求，并统一处理返回值。"></a>并发请求：同时进行多个请求，并统一处理返回值。</h2><p>比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。<br>这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。</p><h2 id="axios-all-和axios-spread-方法"><a href="#axios-all-和axios-spread-方法" class="headerlink" title="axios.all()和axios.spread()方法"></a>axios.all()和axios.spread()方法</h2><p>其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。<br>比如：arr[] =[axios.get(url),axios.post(url,data,config)]</p><h2 id="另一个axios-spread-A-B-gt"><a href="#另一个axios-spread-A-B-gt" class="headerlink" title="另一个axios.spread((A,B)=&gt;{})"></a>另一个axios.spread((A,B)=&gt;{})</h2><p>这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。<br>具体用法：<br>axios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=&gt;{}))</p><h1 id="四、axios实例"><a href="#四、axios实例" class="headerlink" title="四、axios实例"></a>四、axios实例</h1><p>你会不会有这样一个疑问，就是为什么要用axios实例呢？<br>那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，<br>那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。<br>具体用法：<br>let instance = axios.create(config);<br>instance.get(url).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p><h1 id="五、关于请求中的config"><a href="#五、关于请求中的config" class="headerlink" title="五、关于请求中的config"></a>五、关于请求中的config</h1><p>config的格式为：<br>{<br>baseURL:’http:/xxxxxx’, //基础url<br>timeout:6000, //超时时间<br>url:xxxxxx, //具体url<br>method:’get/post/put/patch/delete’, //请求方式<br>headers:{token:’xxxxx’等}, //请求头设置<br>params:{}, //请求参数对象，它会将请求参数拼接到url上<br>data:{} //请求参数对象，它会将请求参数放到请求体中<br>}</p><p>config应用场景</p><h2 id="1、全局配置"><a href="#1、全局配置" class="headerlink" title="1、全局配置"></a>1、全局配置</h2><p>axios.defaults.timeout = 1000<br>axios.defaults.baseURL = ‘<a href="http://xxxxx&/#39;">http://XXXXX&#39;</a></p><h2 id="2、实例配置"><a href="#2、实例配置" class="headerlink" title="2、实例配置"></a>2、实例配置</h2><p>在axios创建实例中配置<br>let instance = axios.create();<br>instance.defaults.timeout = 1000</p><h2 id="3、请求配置"><a href="#3、请求配置" class="headerlink" title="3、请求配置"></a>3、请求配置</h2><p>在请求中配置<br>axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>其中，配置优先级为：3&gt;2&gt;1</p><h1 id="六、axios拦截器"><a href="#六、axios拦截器" class="headerlink" title="六、axios拦截器"></a>六、axios拦截器</h1><h2 id="什么是拦截器？"><a href="#什么是拦截器？" class="headerlink" title="什么是拦截器？"></a>什么是拦截器？</h2><p>拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。<br>一般分为请求拦截器和响应拦截器两种。</p><h2 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h2><p>请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。<br>service.interceptors.request.use(<br>config =&gt; {<br>//在发送请求前的额外处理<br>return config<br>},<br>)</p><h2 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h2><p>响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。<br>service.interceptors.response.use(<br>res =&gt; {<br>//响应之后做一些额外操作<br>return res<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)<br>注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：<br>axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p><p>例子：发送请求前，在请求头中添加token，就可以用拦截器来实现<br>let instance = axios.create(config);<br>instance.interceptors.request.use(confit=&gt;{<br>config.headers.token=”sssssss”<br>return config<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)</p><h2 id="取消拦截器"><a href="#取消拦截器" class="headerlink" title="取消拦截器"></a>取消拦截器</h2><p>顾名思义就是取消掉已经配置的拦截器</p><p>例子：<br>let instance = axios.create(config);<br>instance.interceptors.request.use(<br>config=&gt;{<br>config.headers.token=”sssssss”<br>return config<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)<br>//取消拦截器操作：<br>axios.interceptors.request.eject(instance)</p><h1 id="七、取消请求"><a href="#七、取消请求" class="headerlink" title="七、取消请求"></a>七、取消请求</h1><p>取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，<br>这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法<br>例子：<br>axios.CancelToken.source()<br>axios.get(url,{CancelToken:source,token}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>//触发取消请求：<br>source.cancel(‘错误信息’)<br>就可以了</p>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3API</title>
    <link href="/2022/12/13/vue3API/"/>
    <url>/2022/12/13/vue3API/</url>
    
    <content type="html"><![CDATA[<p>为什么要使用setup组合?<br>Vue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。</p><p>Vue3中使用 setup 是如何解决这一问题的呢？<br>第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；<br>第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。</p><p>1、ref<br>作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。<br>背后：ref 的背后是使用 reactive 来实现的响应式.<br>语法：const x = ref(100)<br>访问：在 setup 中使用 .value 来访问。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B1.png"></p><p>2、isRef<br>作用：判断一个变量是否为一个ref对象。<br>语法：const bol = isRef(x)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B2.png"></p><p>3、unref<br>作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。<br>语法：const x = unref(y)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B3.png"></p><p>4、customRef<br>作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B4.png"></p><p>5、toRef<br>作用：把一个 reactive对象中的某个属性变成 ref 变量。<br>语法：const x = toRef(reactive(obj), ‘key’) // x.value<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B5.png"></p><p>6、toRefs<br>作用：把一个reactive响应式对象变成ref变量。<br>语法：const obj1 = toRefs(reactive(obj))<br>应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B6.png"></p><p>7、shallowRef<br>作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)<br>语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B7.png"></p><p>8、triggerRef<br>作用：强制更新一个 shallowRef对象的渲染。<br>语法：triggerRef(shallowRef对象)<br>参考代码：见shallowRef示例。</p><p>9、reactive<br>作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。<br>语法：const info = reactive([] | {})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B9.png"></p><p>10、readonly<br>作用：把一个对象，变成只读的。<br>语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B10.png"></p><p>11、isReadonly<br>作用: 判断一个变量是不是只读的。<br>语法：const bol = isReadonly(变量)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B11.png"></p><p>12、isReactive<br>作用：判断一变量是不是 reactive的。<br>注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B12.png"></p><p>13、isProxy<br>作用：判断一个变量是不是 readonly 或 reactive的。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B13.png"></p><p>14、toRaw<br>作用：得到返回 reactive变量或 readonly变量的”原始对象”。<br>语法:：const raw = toRaw(reactive变量或readonly变量)<br>说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B14.png"></p><p>15、markRaw<br>作用：把一个普通对象标记成”永久原始”，从此将无法再变成proxy了。<br>语法：const raw = markRaw({a,b})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B15.png"></p><p>16、shallowReactive<br>作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。<br>语法：const obj = shallowReactive({a:{b:9}})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B16.png"></p><p>17、shallowReadonly<br>作用：定义一个reactive变量，只有第一层是只读的。<br>语法：const obj = shallowReadonly({a:{b:9}})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B17.png"></p><p>18、computed<br>作用：对响应式变量进行缓存计算。<br>语法：const c = computed(fn / {get,set})<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B18.png"></p><p>19、watch<br>作用：用于监听响应式变量的变化，组件初始化时，它不执行。<br>语法：const stop = watch(x, (new,old)=&gt;{})，调用stop() 可以停止监听。<br>语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=&gt;{})，调用stop()可以停止监听。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B19.png"></p><p>20、watchEffect<br>作用：相当于是 react中的 useEffect()，用于执行各种副作用。<br>语法：const stop = watchEffect(fn)，默认其 flush:’pre’，前置执行的副作用。<br>watchPostEffect，等价于 watchEffect(fn, {flush:’post’})，后置执行的副作用。<br>watchSyncEffect，等价于 watchEffect(fn, {flush:’sync’})，同步执行的副作用。<br>特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B20.png"></p><p>21、生命周期钩子<br>选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。<br>选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。<br>新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。<br>在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B21.png"></p><p>22、provide / inject<br>作用：在组件树中自上而下地传递数据.<br>语法：provide(‘key’, value)<br>语法：const value = inject(‘key’, ‘默认值’)<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B22.png"></p><p>23、getCurrentInstance<br>作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。<br>语法：const app = getCurrentInstance()<br>场景：常用于访问 app.config.globalProperties 上的全局数据。<br><img src="/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B23.png"></p><p>24、关于setup代码范式<br>只使用 setup 及组合API，不要再使用vue选项了。<br>有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。<br>能用 vite就尽量使用vite，能用ts 就尽量使用ts。</p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hooks</title>
    <link href="/2022/12/08/Hooks/"/>
    <url>/2022/12/08/Hooks/</url>
    
    <content type="html"><![CDATA[<h1 id="1、为什么要封装-Hooks-？"><a href="#1、为什么要封装-Hooks-？" class="headerlink" title="1、为什么要封装 Hooks ？"></a>1、为什么要封装 Hooks ？</h1><p>众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。<br>我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。</p><h2 id="你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？"><a href="#你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？" class="headerlink" title="你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？"></a>你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？</h2><p>这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。<br>但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。</p><h2 id="哪什么是Hooks封装呢？"><a href="#哪什么是Hooks封装呢？" class="headerlink" title="哪什么是Hooks封装呢？"></a>哪什么是Hooks封装呢？</h2><p>Hooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。</p><h1 id="2、如何封装-Hooks-呢？"><a href="#2、如何封装-Hooks-呢？" class="headerlink" title="2、如何封装 Hooks 呢？"></a>2、如何封装 Hooks 呢？</h1><p>首先我们要在setup 组合的开发模式下，<br>然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，<br>提取到一个以 use* 开头的自定义函数中去。</p><h2 id="把它封装在以use-开头的Hooks函数中，有什么样的好处呢？"><a href="#把它封装在以use-开头的Hooks函数中，有什么样的好处呢？" class="headerlink" title="把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？"></a>把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？</h2><p>其一享受到封装带来的便利性，还有利于代码逻辑的复用。<br>其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。</p><h1 id="3、在哪些情况下需要封装-Hooks呢？我总结了两种场景："><a href="#3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：" class="headerlink" title="3、在哪些情况下需要封装 Hooks呢？我总结了两种场景："></a>3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：</h1><p>一种是功能类Hooks，即为了逻辑复用的封装；<br>另一种是业务类Hooks，即为了逻辑解耦的封装。<br>下面我给两组代码，说明这两种使用场景。</p><h1 id="4、示例：功能类-Hooks封装"><a href="#4、示例：功能类-Hooks封装" class="headerlink" title="4、示例：功能类 Hooks封装"></a>4、示例：功能类 Hooks封装</h1><p><img src="/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B1.png"></p><h1 id="5、示例：业务类-Hooks封装"><a href="#5、示例：业务类-Hooks封装" class="headerlink" title="5、示例：业务类 Hooks封装"></a>5、示例：业务类 Hooks封装</h1><p><img src="/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B2.png"></p><h2 id="封装Hooks不能为了封装而封装。要考虑以下几点："><a href="#封装Hooks不能为了封装而封装。要考虑以下几点：" class="headerlink" title="封装Hooks不能为了封装而封装。要考虑以下几点："></a>封装Hooks不能为了封装而封装。要考虑以下几点：</h2><ol><li>是否有复用的价值？</li><li>是否有利于逻辑的分离？</li><li>是否有助提升代码的可阅读性和可维护性？</li></ol>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3-hooks使用</title>
    <link href="/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="我们来说一下vue3-项目中的-hooks-的使用"><a href="#我们来说一下vue3-项目中的-hooks-的使用" class="headerlink" title="我们来说一下vue3 项目中的 hooks 的使用"></a>我们来说一下vue3 项目中的 hooks 的使用</h1><p>hooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。<br>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>这两者主要的区别，主要是 hooks 是函数。</p><h1 id="我们先看一下hooks优点有哪些？"><a href="#我们先看一下hooks优点有哪些？" class="headerlink" title="我们先看一下hooks优点有哪些？"></a>我们先看一下hooks优点有哪些？</h1><p>hooks 特点：</p><ol><li>vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。</li><li>vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。</li><li>hooks 函数可以与 mixin 连用，但是不建议。</li></ol><h1 id="hooks-基本使用"><a href="#hooks-基本使用" class="headerlink" title="hooks 基本使用"></a>hooks 基本使用</h1><p><img src="/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B1.png"><br>我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。<br>如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。<br>但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。</p><h1 id="我们针对上面的案例，我们使用-hooks-简单的实现一下。"><a href="#我们针对上面的案例，我们使用-hooks-简单的实现一下。" class="headerlink" title="我们针对上面的案例，我们使用 hooks 简单的实现一下。"></a>我们针对上面的案例，我们使用 hooks 简单的实现一下。</h1><p>首先，我们在 src 文件夹下创建一个 hooks 文件夹。<br>在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件<br>接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。<br><img src="/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B2.png"><br>然后在需要使用 hooks 的文件引入就可以使用了。<br><img src="/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B3.png"></p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3:Pinia使用</title>
    <link href="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。</p><h1 id="什么是-Pinia"><a href="#什么是-Pinia" class="headerlink" title="什么是 Pinia"></a>什么是 Pinia</h1><p>Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。</p><h1 id="Pinia-的优点"><a href="#Pinia-的优点" class="headerlink" title="Pinia 的优点"></a>Pinia 的优点</h1><p>Pinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：<br>pinia 符合直觉，易于学习。<br>pinia 是轻量级状态管理工具，大小只有1KB.<br>pinia 模块化设计，方便拆分。<br>pinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。<br>store 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。<br>支持多个 store。<br>支持 Vue devtools、SSR、webpack 代码拆分。</p><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>Pinia 中文网：<a href="https://pinia.web3doc.top/">https://pinia.web3doc.top/</a></p><h1 id="Pinia-安装"><a href="#Pinia-安装" class="headerlink" title="Pinia 安装"></a>Pinia 安装</h1><p>安装 pinia 就很简单了，直接命令安装就可以了。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E5%AE%89%E8%A3%85.png"></p><h1 id="Pinia-使用"><a href="#Pinia-使用" class="headerlink" title="Pinia 使用"></a>Pinia 使用</h1><p>安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia</p><h2 id="1-Pinia-导入"><a href="#1-Pinia-导入" class="headerlink" title="1.Pinia 导入"></a>1.Pinia 导入</h2><p>首先在 main.js 文件中引入<br> vue3 的写法：<br>import {createPinia} from ‘pinia’<br>然后，这个 pinia 就在项目中导入了<br>Pinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：<br>import {PiniaVuePlugin} from ‘pinia’<br>我们还是以 vue3 来介绍这个 Pinia<br>导入的时候是 hook ，我们需要调用一下<br>const state = createPinia()<br>调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。<br>app.use(state)</p><h2 id="2-Pinia-基本使用"><a href="#2-Pinia-基本使用" class="headerlink" title="2.Pinia 基本使用"></a>2.Pinia 基本使用</h2><h3 id="1-创建-index-ts-文件"><a href="#1-创建-index-ts-文件" class="headerlink" title="1.创建 index.ts 文件"></a>1.创建 index.ts 文件</h3><p>使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。<br>创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。</p><h3 id="2-编写-index-ts-文件"><a href="#2-编写-index-ts-文件" class="headerlink" title="2.编写 index.ts 文件"></a>2.编写 index.ts 文件</h3><p>首先我们先引入 pinia<br>import { defineStore } from “pinia”;<br>由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下<br>这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。<br>我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出<br>export const enum Names {<br>  TEST = “TEST”<br>}</p><hr><p>然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。<br> 这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。<br>state 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。<br>getters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。<br>actions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/indexts.png"><br>其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E7%BB%93%E6%9E%9C.png"></p><h3 id="3-修改-Pinia-的值"><a href="#3-修改-Pinia-的值" class="headerlink" title="3.修改 Pinia 的值"></a>3.修改 Pinia 的值</h3><p>修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值<br>修改值的方式呢，常见的有五种</p><h4 id="方式一：直接修改"><a href="#方式一：直接修改" class="headerlink" title="方式一：直接修改"></a>方式一：直接修改</h4><p><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E7%BB%93%E6%9E%9C.png"></p><h4 id="方式二：-patch-函数修改"><a href="#方式二：-patch-函数修改" class="headerlink" title="方式二：$patch 函数修改"></a>方式二：$patch 函数修改</h4><p>在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C1.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C2.png"></p><h4 id="方式三：-patch-函数修改"><a href="#方式三：-patch-函数修改" class="headerlink" title="方式三：$patch 函数修改"></a>方式三：$patch 函数修改</h4><p>咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE4%E4%BB%A3%E7%A0%81.png"><br>效果其实和方式二是一模一样的</p><h4 id="方式四：-state-方式"><a href="#方式四：-state-方式" class="headerlink" title="方式四：$state 方式"></a>方式四：$state 方式</h4><p><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE5%E4%BB%A3%E7%A0%81.png"></p><h4 id="方式五：-action-方式"><a href="#方式五：-action-方式" class="headerlink" title="方式五： action 方式"></a>方式五： action 方式</h4><p>这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%811.png"><br>写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%812.png"><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C1.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C2.png"><br>当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%811.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%812.png"><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C1.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C2.png"><br>以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用</p><h1 id="pinia-解构"><a href="#pinia-解构" class="headerlink" title="pinia 解构"></a>pinia 解构</h1><p>上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E4%BB%A3%E7%A0%81.png"><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E7%BB%93%E6%9E%9C.png"><br>我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。<br>但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。<br>做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png"><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png"><br>通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。<br>解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。<br>就是 storeToRefs，使用 storeToRefs 需要导入一下。<br>import { storeToRefs } from ‘pinia’<br>然后把我们解构的对象包裹一下就可以了<br>const { name, age } = storeToRefs(userInfo)<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E7%BB%93%E6%9E%9C.png"><br>或者我们换一个写法，直接操作结构后的数据，记得，要 .value<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%81.png"></p><h1 id="Pinia-的-actions"><a href="#Pinia-的-actions" class="headerlink" title="Pinia 的 actions"></a>Pinia 的 actions</h1><p>actions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步<br>接下来我们重点介绍一下actions异步<br>actions 异步<br>首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%811.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%812.png"><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C1.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C2.png"><br>actions 同步、异步连用<br>这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。<br>上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E4%BB%A3%E7%A0%81.png"><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E7%BB%93%E6%9E%9C.png"></p><h1 id="getter-函数"><a href="#getter-函数" class="headerlink" title="getter 函数"></a>getter 函数</h1><p>getters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。<br>有两种写法:<br>普通函数方式写法<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%811.png"><br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%812.png"><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C1.png"><br>然后我们点一下按钮，修改一下 name，然后看一下效果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C2.png"><br>我们可以看见，点击修改 name 之后getter 也会实时的渲染出来<br>相互调用<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E4%BB%A3%E7%A0%81.png"><br>查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C1.png"><br>然后我们点一下按钮，修改一下 name和 age，然后看一下效果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C2.png"></p><h1 id="API-的使用"><a href="#API-的使用" class="headerlink" title="API 的使用"></a>API 的使用</h1><p>$reset ：重置到初始值<br>这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E4%BB%A3%E7%A0%81.png"><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C1.png"><br>然后我们点一下$reset按钮，然后看一下效果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C2.png"><br>$subscribe：监听 state 数据变化<br>$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E4%BB%A3%E7%A0%81.png"><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C1.png"><br>控制台打印出监听到的变化结果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C2.png"><br>$onAction：一调用 actions 就触发<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E4%BB%A3%E7%A0%81.png"><br>控制台打印出监听到的变化结果<br><img src="/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3组件传值</title>
    <link href="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <url>/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="父子组件传值-props"><a href="#父子组件传值-props" class="headerlink" title="父子组件传值 props"></a>父子组件传值 props</h1><p>父组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png"><br>子组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E4%BC%A0%E7%88%B6%E7%BB%93%E6%9E%9C.png"></p><h1 id="祖孙组件传值-provide-和-inject"><a href="#祖孙组件传值-provide-和-inject" class="headerlink" title="祖孙组件传值 provide 和 inject"></a>祖孙组件传值 provide 和 inject</h1><p>父组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png"><br>子组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%A5%96%E5%AD%99%E7%BB%93%E6%9E%9C.png"></p><h1 id="父组件中点击按钮向子组件传值"><a href="#父组件中点击按钮向子组件传值" class="headerlink" title="父组件中点击按钮向子组件传值"></a>父组件中点击按钮向子组件传值</h1><p>父组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png"><br>子组件<br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%89%8D%E7%BB%93%E6%9E%9C.png"><br><img src="/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%90%8E%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3shallowRef和shallowReactive</title>
    <link href="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/"/>
    <url>/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/</url>
    
    <content type="html"><![CDATA[<h1 id="shallowRef-和-shallowReactive"><a href="#shallowRef-和-shallowReactive" class="headerlink" title="shallowRef 和 shallowReactive"></a>shallowRef 和 shallowReactive</h1><ol><li>shallowRef 函数，只处理基本类型数据。</li><li>shallowReactive 函数，只处理第一层数据。</li><li>两个在使用的时候都需要引入才可以。<br>ref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。<br>但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。</li></ol><h1 id="深度监听的问题："><a href="#深度监听的问题：" class="headerlink" title="深度监听的问题："></a>深度监听的问题：</h1><ol><li>无论 ref 函数还是 reactive 函数都是深度监听。</li><li>如果数据量过大，超级超级消耗性能。</li><li>如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。</li></ol><h1 id="使用-shallowReactive-非深度监听"><a href="#使用-shallowReactive-非深度监听" class="headerlink" title="使用 shallowReactive 非深度监听"></a>使用 shallowReactive 非深度监听</h1><p>记住一点，shallowReactive 函数，只能处理第一层数据。<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81.png"><br>我们分别点击两个按钮，看一下页面变化。<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png"><br>通过效果，我们稍微总结一下：</p><ol><li>shallowReactive只会包装第一层的数据</li><li>默认情况它只能够监听数据的第一层。</li><li>如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。</li></ol><h1 id="使用-shallowRef-非深度监听"><a href="#使用-shallowRef-非深度监听" class="headerlink" title="使用 shallowRef 非深度监听"></a>使用 shallowRef 非深度监听</h1><p>shallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81.png"><br>点击按钮，修改 boy 的值<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png"></p><p>有一个问题：shallowRef 函数，只处理基本类型数据吗？<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81.png"><br>在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。<br><img src="/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png"><br>所以说呢，shallowRef 函数，只能处理基本类型数据。</p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3侦听器watch</title>
    <link href="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/"/>
    <url>/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/</url>
    
    <content type="html"><![CDATA[<p>学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑</p><h1 id="watch-侦听器使用"><a href="#watch-侦听器使用" class="headerlink" title="watch 侦听器使用"></a>watch 侦听器使用</h1><p>watch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E4%BB%A3%E7%A0%81.png"><br>上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E7%BB%93%E6%9E%9C.png"><br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%8E%A7%E5%88%B6%E5%8F%B0.png"><br>上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。<br>watch API 至少需要指定两个参数: source 和 callback。<br>通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。</p><p>在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。</p><p>案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png"><br>我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。</p><h1 id="侦听器监听-reactive"><a href="#侦听器监听-reactive" class="headerlink" title="侦听器监听 reactive"></a>侦听器监听 reactive</h1><p><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E7%BB%93%E6%9E%9C.png"><br>在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？<br>如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。<br>如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BB%A3%E7%A0%81.png"><br>我们监听对象直接是 num.age， 监听年龄属性值<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E8%AD%A6%E5%91%8A.png"><br>我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。<br>当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png"><br>通过箭头函数，我们就可以实现对象属性的监听。<br>很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。<br>我们监听深层嵌套的 time 属性值。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BB%A3%E7%A0%81.png"><br>发现点击之后没有监听到<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E6%8A%A5%E9%94%99.png"><br>这个时候就可以加上 deep 深度监听。<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png"><br>加上深度监听 { deep:true }<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png"><br>我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。</p><p>监听多个参数执行各自逻辑<br>比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E5%A4%9A%E4%B8%AA%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BB%A3%E7%A0%81.png"></p><p>监听多个参数执行相同逻辑<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0.png"><br>修改 name 和 age 的值<br><img src="/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3计算属性</title>
    <link href="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="computed-计算属性说明"><a href="#computed-计算属性说明" class="headerlink" title="computed 计算属性说明"></a>computed 计算属性说明</h1><p>computed 表示计算属性，通常是用来进行数据处理。<br>比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型<br>但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。<br>计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。</p><h1 id="计算属性使用"><a href="#计算属性使用" class="headerlink" title="计算属性使用"></a>计算属性使用</h1><p>首先呢，使用 computed 需要引入<br><img src="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E5%BC%95%E5%85%A5.png"><br>我们编写一个案例<br><img src="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%B8%80.png"><br>但是有一点需要注意！<br>如果我们直接修改计算属性的值会报一个错误！<br><img src="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%BA%8C.png"><br>这个意思就是计算属性是只读的不允许修改<br>如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。<br>那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。<br><img src="/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%B1%82%E5%92%8C.png"><br>也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>vue.3.0 中要从vue 按需导入 computed 计算属性。</li><li>如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。</li><li>使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。</li><li>传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。</li><li>只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。</li><li>既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。</li></ol>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3toRef和toRefs函数</title>
    <link href="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="toRef-函数"><a href="#toRef-函数" class="headerlink" title="toRef 函数"></a>toRef 函数</h1><p>我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？</p><p>首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。<br>什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。<br>但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p><h1 id="toRef-函数使用"><a href="#toRef-函数使用" class="headerlink" title="toRef 函数使用"></a>toRef 函数使用</h1><h2 id="首先呢，-toRef-函数有两个参数"><a href="#首先呢，-toRef-函数有两个参数" class="headerlink" title="首先呢， toRef 函数有两个参数"></a>首先呢， toRef 函数有两个参数</h2><p>toRef(操作对象, 对象属性)</p><h2 id="接下来我们使用-toRef-函数写一个案例"><a href="#接下来我们使用-toRef-函数写一个案例" class="headerlink" title="接下来我们使用 toRef 函数写一个案例"></a>接下来我们使用 toRef 函数写一个案例</h2><p><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E9%A1%B5%E9%9D%A2%E6%88%90%E5%8A%9F.png"></p><p>我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png"><br>然后点击按钮看一下页面效果<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png"></p><p>通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。<br>这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%BA%90%E6%95%B0%E6%8D%AE.png"></p><p>toRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。<br>所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%89%93%E5%8D%B0body%E4%BB%A3%E7%A0%81.png"></p><p>刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/torefbody%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png"><br>发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。<br>记住了！<br>toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p><h1 id="ref-函数验证"><a href="#ref-函数验证" class="headerlink" title="ref 函数验证"></a>ref 函数验证</h1><p>那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81.png"><br>刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C.png"><br>所以再记住！<br>ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新</p><h1 id="toRefs-函数"><a href="#toRefs-函数" class="headerlink" title="toRefs 函数"></a>toRefs 函数</h1><p>toRefs 函数的使用呢，其实和 toRef 函数类似。<br>toRefs 函数用于批量设置多个数据为响应式数据。<br>toRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。<br>toRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。</p><h1 id="toRefs-函数使用"><a href="#toRefs-函数使用" class="headerlink" title="toRefs 函数使用"></a>toRefs 函数使用</h1><p><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%9C.png"><br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%A1%E6%81%AF.png"><br>修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value<br><img src="/%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png"><br>查看效果<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png"><br>现在可以看到数据显示正常啦！<br>这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？<br>这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/reactive%E4%BB%A3%E7%A0%81.png"><br>我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png"><br>我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？<br>其实是有原因的。<br>其实 toRefs 函数最大的用处在这里！<br>我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81.png"><br>在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png"><br>但是呢，深层次的对象依旧需要通过点来实现。<br>也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。<br>记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。<br>看下面代码：<br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E6%95%B0%E6%8D%AE%E6%BA%90%E7%BB%93%E6%9E%9C.png"><br>从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。<br>如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。<br>toRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。</p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3ref和reactive函数</title>
    <link href="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ref-函数介绍"><a href="#ref-函数介绍" class="headerlink" title="ref 函数介绍"></a>ref 函数介绍</h1><ol><li>ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。</li><li>通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。</li><li>在vue2当中，通过给元素添加 ref=’xxx’然后使用refs.xxx的方式来获取元素，vue3也可以。</li><li>当 ref 里面的值发生变化的时候，视图会自动更新数据。</li><li>ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。</li></ol><h2 id="ref-函数使用"><a href="#ref-函数使用" class="headerlink" title="ref 函数使用"></a>ref 函数使用</h2><p>使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。</p><h2 id="ref-函数处理基本数据类型"><a href="#ref-函数处理基本数据类型" class="headerlink" title="ref 函数处理基本数据类型"></a>ref 函数处理基本数据类型</h2><p>首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81.png"><br>刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E5%87%BA%E9%94%99.png"><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8F%B0.png"><br>为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E7%BB%93%E6%9E%84.png"><br>修改代码：<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png"><br>码刷新页面查看效果<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png"><br>有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。</p><h2 id="ref-函数处理复杂数据类型"><a href="#ref-函数处理复杂数据类型" class="headerlink" title="ref 函数处理复杂数据类型"></a>ref 函数处理复杂数据类型</h2><p>不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。<br>例如我们写一个案例，创建一个个人信息，放到对象里面展示<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png"><br>我们先看一下对象被 ref 函数包裹后的数据结构。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84.png"><br>我们修改也通过 value 进行操作<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png"><br>刷新页面，查看效果<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%88%90%E5%8A%9F.png"></p><h2 id="ref-函数获取单个DOM元素"><a href="#ref-函数获取单个DOM元素" class="headerlink" title="ref 函数获取单个DOM元素"></a>ref 函数获取单个DOM元素</h2><p>和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。<br>页面上有一个标签，点击按钮，获取标签的相关数据。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/refdom%E4%BB%A3%E7%A0%81.png"><br>运行效果<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%88%90%E5%8A%9F.png"><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%89%93%E5%8D%B0.png"></p><h1 id="reactive-函数介绍"><a href="#reactive-函数介绍" class="headerlink" title="reactive 函数介绍"></a>reactive 函数介绍</h1><p>上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。</p><h2 id="reactive-函数使用"><a href="#reactive-函数使用" class="headerlink" title="reactive 函数使用"></a>reactive 函数使用</h2><p>reactive 函数处理对象<br>reactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%9C.png"><br>有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png"></p><h2 id="reactive-函数处理数组"><a href="#reactive-函数处理数组" class="headerlink" title="reactive 函数处理数组"></a>reactive 函数处理数组</h2><p>处理数组的方式和处理对象的方式是一样一样的<br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81.png"><br><img src="/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3setup函数</title>
    <link href="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="vue2-和-vue3-开发的区别"><a href="#vue2-和-vue3-开发的区别" class="headerlink" title="vue2 和 vue3 开发的区别"></a>vue2 和 vue3 开发的区别</h1><p>首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。</p><p>vue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。</p><h1 id="使用-setup-原因"><a href="#使用-setup-原因" class="headerlink" title="使用 setup 原因"></a>使用 setup 原因</h1><p>在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。</p><p>为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。</p><h1 id="setup-用法"><a href="#setup-用法" class="headerlink" title="setup 用法"></a>setup 用法</h1><ol><li>setup 函数是组合式 API 的入口。</li><li>setup 函数是启动页面后自动执行的函数。</li><li>页面中所涉及的变量和方法等，都需要写在 setup 函数中。</li><li>在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。</li><li>setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。</li></ol><h1 id="setup-可以接受哪些参数"><a href="#setup-可以接受哪些参数" class="headerlink" title="setup 可以接受哪些参数"></a>setup 可以接受哪些参数</h1><p>setup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。</p><h1 id="setup-函数定义变量"><a href="#setup-函数定义变量" class="headerlink" title="setup 函数定义变量"></a>setup 函数定义变量</h1><p>组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。</p><h2 id="定义一个基本类型变量"><a href="#定义一个基本类型变量" class="headerlink" title="定义一个基本类型变量"></a>定义一个基本类型变量</h2><p>在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F.png"></p><p>上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%90%8D%E7%A7%B0%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5.png"><br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0.png"></p><p>出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/name.png"><br>将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%B8%B2%E6%9F%93%E6%88%90%E5%8A%9F.png"></p><p>同样，创建其他基本类型也是一样的编写方式。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png"><br>切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><h2 id="setup-创建复杂数据类型"><a href="#setup-创建复杂数据类型" class="headerlink" title="setup 创建复杂数据类型"></a>setup 创建复杂数据类型</h2><p>setup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png"><br>刷新页面，渲染正常<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><h1 id="setup-创建方法"><a href="#setup-创建方法" class="headerlink" title="setup 创建方法"></a>setup 创建方法</h1><p>除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。<br>创建方法的方式有两种：</p><h2 id="第一种就是很常见的通过-function-的方式创建"><a href="#第一种就是很常见的通过-function-的方式创建" class="headerlink" title="第一种就是很常见的通过 function 的方式创建"></a>第一种就是很常见的通过 function 的方式创建</h2><pre><code class="hljs">// 一、通过 function 的方式创建    function btn() &#123;        console.log(&#39;按钮被点击了&#39;)    &#125;</code></pre><h2 id="另一种使用过箭头函数的方式创建"><a href="#另一种使用过箭头函数的方式创建" class="headerlink" title="另一种使用过箭头函数的方式创建"></a>另一种使用过箭头函数的方式创建</h2><pre><code class="hljs">  // 二、通过箭头函数的方式创建  const btn = () =&gt; &#123;    console.log(&#39;按钮被点击了&#39;)  &#125;</code></pre><p>例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E7%82%B9%E5%87%BB%E4%BB%A3%E7%A0%81.png"><br>保存代码，刷新页面，点击按钮在控制台输出内容。<br><img src="/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E8%A2%AB%E7%82%B9%E5%87%BB.png"></p>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3</title>
    <link href="/2022/10/10/vue3/"/>
    <url>/2022/10/10/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="vue3-简介"><a href="#vue3-简介" class="headerlink" title="vue3 简介"></a>vue3 简介</h1><ol><li>vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。</li><li>3.0版本的vue，开发周期长达两年多。</li><li>3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。<h1 id="Vue3-的优势"><a href="#Vue3-的优势" class="headerlink" title="Vue3 的优势"></a>Vue3 的优势</h1></li><li>3比2要快将近两倍。</li><li>3加入了TS以及对PWA的支持。</li><li>3没有beforeCreate、created，用setup代替。</li><li>单独功能可以抽离，比如watch、component。</li><li>没有眼花缭乱的this。</li><li>强大的proxy实现响应式。</li><li>响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。</li><li>3的组合式API可以和2的 optionAPI同时存在。</li><li>代码更利于维护和封装。</li></ol>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域</title>
    <link href="/2022/09/30/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2022/09/30/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、跨域是什么？"><a href="#一、跨域是什么？" class="headerlink" title="一、跨域是什么？"></a>一、跨域是什么？</h1><h2 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h2><p>跨域问题其实就是浏览器的同源策略所导致的。<br>「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。<br>只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。</p><h1 id="二、如何解决跨域？"><a href="#二、如何解决跨域？" class="headerlink" title="二、如何解决跨域？"></a>二、如何解决跨域？</h1><p>方式一：使用 ajax 的 jsonp<br>使用该方式的缺点：请求方式只能是 get 请求</p><h1 id="方式二：使用-jQuery-的-jsonp-插件"><a href="#方式二：使用-jQuery-的-jsonp-插件" class="headerlink" title="方式二：使用 jQuery 的 jsonp 插件"></a>方式二：使用 jQuery 的 jsonp 插件</h1><p>特点： get 请求、 post 请求；<br>但从服务器从获取的数据，依然是 jsonp 格式。</p><h1 id="方式三：使用-cors"><a href="#方式三：使用-cors" class="headerlink" title="方式三：使用 cors"></a>方式三：使用 cors</h1><p>使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。</p><h1 id="方式四：使用-Nginx-反向代理"><a href="#方式四：使用-Nginx-反向代理" class="headerlink" title="方式四：使用 Nginx 反向代理"></a>方式四：使用 Nginx 反向代理</h1><p>Nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。</p>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2022/08/30/webpack/"/>
    <url>/2022/08/30/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack-打包原理是什么？"><a href="#webpack-打包原理是什么？" class="headerlink" title="webpack 打包原理是什么？"></a>webpack 打包原理是什么？</h1><h2 id="打包原理"><a href="#打包原理" class="headerlink" title="打包原理"></a>打包原理</h2><p>webpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当 webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。</p><h2 id="webpack构建流程："><a href="#webpack构建流程：" class="headerlink" title="webpack构建流程："></a>webpack构建流程：</h2><p>初始化参数—&gt;开始编译—-&gt;确定入口—-&gt;编译模块—&gt;完成编译—-&gt;输出数据—-&gt;输出完成</p><h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><p>代码层面：</p><ol><li>体积更小，加载更快</li><li>编译高级语言和语法</li><li>兼容性和错误检查<h2 id="研发流程层面："><a href="#研发流程层面：" class="headerlink" title="研发流程层面："></a>研发流程层面：</h2></li><li>统一高效的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测、上线）<h2 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h2>entry：入口，webpack的执行从entry开始，<br>output：出口，输出结果，webpack的输出位置，<br>loader：模块转换器，用于把webpack不能直接打包的文件类型转换<br>plugins：插件，用于把模块原内容按需求转换成新内容mode：通过选择development或者production来设置mode参数<br>chunk：代码块，即打包后输出的文件<h2 id="基本功能和工作原理"><a href="#基本功能和工作原理" class="headerlink" title="基本功能和工作原理"></a>基本功能和工作原理</h2>当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括</li><li>代码转换：将无法直接运行的文件代码编译成可以执行的代码</li><li>文件优化：压缩文件代码、压缩合并图片等</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载</li><li>模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件</li><li>自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器</li><li>代码校验：在代码被提交前需要校验代码格式等是否符合规范</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h3 id="1、loader和plugin的区别："><a href="#1、loader和plugin的区别：" class="headerlink" title="1、loader和plugin的区别："></a>1、loader和plugin的区别：</h3><h3 id="不同的作用："><a href="#不同的作用：" class="headerlink" title="不同的作用："></a>不同的作用：</h3>loader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具<br>plugins：插件，可以扩展fwebpack的功能，让其更具有灵活性<h3 id="不同的用法："><a href="#不同的用法：" class="headerlink" title="不同的用法："></a>不同的用法：</h3>loader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，<br>plugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入<h3 id="2、什么事模块化，为什么要用模块化"><a href="#2、什么事模块化，为什么要用模块化" class="headerlink" title="2、什么事模块化，为什么要用模块化"></a>2、什么事模块化，为什么要用模块化</h3>模块化是指把一个复杂的系统分解到多个模块以方便编码<br>不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码<h3 id="3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。"><a href="#3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。" class="headerlink" title="3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。"></a>3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。</h3>devServer: {<br>  contentBase: resolve(__dirname, ‘build’),<br>  compress: true,<br>  port: 3000,<br>  open: true,<br>  // 开启HMR功能<br>  // 当修改了webpack配置，新配置要想生效，必须重新webpack服务<br>  hot: true<br>}<h3 id="4、什么是HMR功能"><a href="#4、什么是HMR功能" class="headerlink" title="4、什么是HMR功能"></a>4、什么是HMR功能</h3>HMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览<br>优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式<h3 id="5、什么是Tree-sharking"><a href="#5、什么是Tree-sharking" class="headerlink" title="5、什么是Tree-sharking?"></a>5、什么是Tree-sharking?</h3>指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等<h3 id="6、babel和webpack的区别"><a href="#6、babel和webpack的区别" class="headerlink" title="6、babel和webpack的区别"></a>6、babel和webpack的区别</h3>babel JS新语法编译工具，只关心语法，不关心模块化<br>webpack -打包构建工具，是多个Loader plugin的集合<h3 id="7、类似webpack的工具还有哪些"><a href="#7、类似webpack的工具还有哪些" class="headerlink" title="7、类似webpack的工具还有哪些"></a>7、类似webpack的工具还有哪些</h3>(1)、webpack适用于大型复杂的前端站点构建<br>(2)、rollup适用于基础库的打包，如vue、react<br>(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel<h3 id="8、常见loader"><a href="#8、常见loader" class="headerlink" title="8、常见loader"></a>8、常见loader</h3>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<h3 id="9、常见的plugins"><a href="#9、常见的plugins" class="headerlink" title="9、常见的plugins"></a>9、常见的plugins</h3>define-plugin：定义环境变量<br>commons-chunk-plugin：提取公共代码<br>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li></ol>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深浅拷贝</title>
    <link href="/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h1><p>浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。<br>举个例子：<br>var  obj1={a:1,b:5,c:3};<br>var  obj2=obj1;<br>obj2.b=2;<br>console.log(obj1.b);  //2<br>console.log(obj2.b);  //2</p><hr><p>浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。</p><h1 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h1><p>深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。<br>举个例子：<br>var a=2;<br>var b=a;<br>b=3;<br>console.log(a);//2<br>console.log(b);//3</p><hr><p>深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。</p><h1 id="如何实现深拷贝？"><a href="#如何实现深拷贝？" class="headerlink" title="如何实现深拷贝？"></a>如何实现深拷贝？</h1><h2 id="①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据"><a href="#①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据" class="headerlink" title="①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据"></a>①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=JSON.Stringify（JSON.parse（obj1））;<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p><hr><h2 id="②展开运算符-…"><a href="#②展开运算符-…" class="headerlink" title="②展开运算符   …"></a>②展开运算符   …</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=(…obj1)<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p><hr><h2 id="③Object-asssign（target-sourse）"><a href="#③Object-asssign（target-sourse）" class="headerlink" title="③Object.asssign（target,sourse）"></a>③Object.asssign（target,sourse）</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=Object.assign({},obj1)<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p><hr><h2 id="④深拷贝函数，递归"><a href="#④深拷贝函数，递归" class="headerlink" title="④深拷贝函数，递归"></a>④深拷贝函数，递归</h2><pre><code class="hljs">        // target 要拷贝的对象        function deepClone(target)&#123;            //定义一个拷贝对象            let result;            // 判断拷贝目标是不是Object对象            if(typeof target===&#39;object&#39;)&#123;                // 判断是否是数组类型                if(Array.isArray(target))&#123;                    // 定义为数组                    result=[];                    for(let i in target)&#123;                        result.push(deepClone(target[i]));                    &#125;                &#125;else if(target===null)&#123;                    // 直接赋值                    result=null;                &#125;else if(target.constructor===RegExp)&#123;                    // 直接赋值                    result=target;                    // 不是特殊的对象                &#125;else&#123;                    result=&#123;&#125;;                    for(let i in target)&#123;                        // 递归                        result[i]=deepClone(target[i]);                    &#125;                &#125;                // 基本数据类型  直接赋值            &#125;else&#123;                result=target;            &#125;            return result;        &#125;</code></pre><hr><p>var obj1={<br>a:{z:1,c:null},<br>b:[1,2,3,5],<br>c:function(){console.log(this.a)}<br>}<br>var obj2=deepClone(obj1);<br>console.log(obj2);<br>obj2.b[0]=2;<br>obj2.a[0]=2;<br>console.log(obj1.a)<br>console.log(obj2.a)<br>console.log(obj1.b)<br>console.log(obj2.b)<br>console.log(obj2.c())<br><img src="/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深浅拷贝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2022/08/16/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/08/16/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h1><h1 id="2-初始化项目"><a href="#2-初始化项目" class="headerlink" title="2.初始化项目"></a>2.初始化项目</h1><h2 id="现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。"><a href="#现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。" class="headerlink" title="现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。"></a>现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。</h2><h2 id="初始化生成blog项目"><a href="#初始化生成blog项目" class="headerlink" title="// 初始化生成blog项目"></a>// 初始化生成blog项目</h2><p>hexo init blog</p><h1 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3.配置主题"></a>3.配置主题</h1><h2 id="hexo默认的主题是-landscape，现在我们将主题配置为-keep。"><a href="#hexo默认的主题是-landscape，现在我们将主题配置为-keep。" class="headerlink" title="hexo默认的主题是_landscape，现在我们将主题配置为 keep。"></a>hexo默认的主题是_landscape，现在我们将主题配置为 keep。</h2><h2 id="确认目录是否切换到了blog中，如果没有，则将目录切换到blog中"><a href="#确认目录是否切换到了blog中，如果没有，则将目录切换到blog中" class="headerlink" title="// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中"></a>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中</h2><p>cd blog</p><h2 id="安装keep主题"><a href="#安装keep主题" class="headerlink" title="// 安装keep主题"></a>// 安装keep主题</h2><p>npm install hexo-theme-keep</p><h2 id="修改-config-yml配置文件"><a href="#修改-config-yml配置文件" class="headerlink" title="// 修改_config.yml配置文件"></a>// 修改_config.yml配置文件</h2><p>theme: keep<br>##// 预览网站<br>hexo server<br>在浏览器中打开<a href="http://localhost:4000/">http://localhost:4000</a></p><h1 id="4-添加文章"><a href="#4-添加文章" class="headerlink" title="4.添加文章"></a>4.添加文章</h1><h2 id="现在，让我们新建一篇博客"><a href="#现在，让我们新建一篇博客" class="headerlink" title="现在，让我们新建一篇博客"></a>现在，让我们新建一篇博客</h2><h2 id="在blog项目中，执行如下命令：新建文章"><a href="#在blog项目中，执行如下命令：新建文章" class="headerlink" title="// 在blog项目中，执行如下命令：新建文章"></a>// 在blog项目中，执行如下命令：新建文章</h2><p>hexo new post xxxx</p><h2 id="新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。"><a href="#新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。" class="headerlink" title="新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。"></a>新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。</h2><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h2 id="添加正文"><a href="#添加正文" class="headerlink" title="添加正文"></a>添加正文</h2><h2 id="现在我们打开【xxxx-md】，写下我们的xxxxx。"><a href="#现在我们打开【xxxx-md】，写下我们的xxxxx。" class="headerlink" title="现在我们打开【xxxx.md】，写下我们的xxxxx。"></a>现在我们打开【xxxx.md】，写下我们的xxxxx。</h2><h2 id="然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了"><a href="#然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了" class="headerlink" title="然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了"></a>然后保存。刷新<a href="http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了">http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了</a></h2><h2 id="添加分类和标签"><a href="#添加分类和标签" class="headerlink" title="添加分类和标签"></a>添加分类和标签</h2><p>接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下<br>tags:xxxx<br>categories: xxxx</p><h2 id="然后，打开终端分别执行如下命令。"><a href="#然后，打开终端分别执行如下命令。" class="headerlink" title="然后，打开终端分别执行如下命令。"></a>然后，打开终端分别执行如下命令。</h2><p>hexo new page categories<br>hexo new page tags</p><h2 id="hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片"><a href="#hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片" class="headerlink" title="hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片"></a>hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。<a href="http://localhost:4000/categories/%E5%9B%BE%E7%89%87">http://localhost:4000/categories/图片</a>, <a href="http://localhost:4000/tags/%E5%9B%BE%E7%89%87">http://localhost:4000/tags/图片</a></h2><h2 id="为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改"><a href="#为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改" class="headerlink" title="为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:"></a>为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:</h2><p>menu:<br>  主页: /<br>  归档: /archives<br>  分类: /categories<br>  标签: /tags<br>再次刷新<a href="http://localhost:4000/">http://localhost:4000</a></p><h1 id="5-发布草稿"><a href="#5-发布草稿" class="headerlink" title="5.发布草稿"></a>5.发布草稿</h1><h2 id="如果你暂时还不想要文章被公开访问，可以先创建草稿。如下"><a href="#如果你暂时还不想要文章被公开访问，可以先创建草稿。如下" class="headerlink" title="如果你暂时还不想要文章被公开访问，可以先创建草稿。如下"></a>如果你暂时还不想要文章被公开访问，可以先创建草稿。如下</h2><p>hexo new draft xxxx<br>图片刷新<a href="http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令">http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令</a></p><h2 id="发布草稿"><a href="#发布草稿" class="headerlink" title="// 发布草稿"></a>// 发布草稿</h2><p>hexo publish draft xxxx</p><h2 id="现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片"><a href="#现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片" class="headerlink" title="现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片"></a>现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新<a href="http://localhost:4000，便可以看到这篇文章了图片">http://localhost:4000，便可以看到这篇文章了图片</a></h2><h1 id="6-部署博客"><a href="#6-部署博客" class="headerlink" title="6.部署博客"></a>6.部署博客</h1><h2 id="现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。"><a href="#现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。" class="headerlink" title="现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。"></a>现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。</h2><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>1.我们打开 github，然后点击New repository按钮<br>2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中<br>cd blog<br>// 安装部署插件<br>npm install hexo-deployer-git –save<br>// 修改_config.yml配置文件<br>// 将复制的地址，黏贴到如下repo字段中<br>deploy:<br> type: git<br>  repo: <a href="https://github.com/xxxx/xxxx.github.io.git">https://github.com/xxxx/xxxx.github.io.git</a><br> branch: master<br>// 部署网站到创建的仓库<br>hexo deploy<br>部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搭建博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
