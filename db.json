{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/cover.png","path":"images/cover.png","modified":1,"renderable":0},{"_id":"source/images/default.png","path":"images/default.png","modified":1,"renderable":0},{"_id":"source/images/defaultbgurl.png","path":"images/defaultbgurl.png","modified":1,"renderable":0},{"_id":"source/images/defaultimg.png","path":"images/defaultimg.png","modified":1,"renderable":0},{"_id":"source/images/defaultimg2.png","path":"images/defaultimg2.png","modified":1,"renderable":0},{"_id":"source/images/defaultimg1.png","path":"images/defaultimg1.png","modified":1,"renderable":0},{"_id":"source/images/defaultimg4.png","path":"images/defaultimg4.png","modified":1,"renderable":0},{"_id":"source/images/defaultimg3.png","path":"images/defaultimg3.png","modified":1,"renderable":0},{"_id":"source/images/defaultcover.png","path":"images/defaultcover.png","modified":1,"renderable":0},{"_id":"source/images/defaultimg5.png","path":"images/defaultimg5.png","modified":1,"renderable":0},{"_id":"source/images/defaultimg7.png","path":"images/defaultimg7.png","modified":1,"renderable":0},{"_id":"source/images/defaultimg6.png","path":"images/defaultimg6.png","modified":1,"renderable":0},{"_id":"source/images/logo.gif","path":"images/logo.gif","modified":1,"renderable":0},{"_id":"source/images/logo.png","path":"images/logo.png","modified":1,"renderable":0},{"_id":"source/images/namespacedcover.png","path":"images/namespacedcover.png","modified":1,"renderable":0},{"_id":"source/images/piniacover.png","path":"images/piniacover.png","modified":1,"renderable":0},{"_id":"source/images/qiankuncover.png","path":"images/qiankuncover.png","modified":1,"renderable":0},{"_id":"source/images/icon.png","path":"images/icon.png","modified":1,"renderable":0},{"_id":"source/images/vueclicover.png","path":"images/vueclicover.png","modified":1,"renderable":0},{"_id":"source/images/vueseocover.png","path":"images/vueseocover.png","modified":1,"renderable":0},{"_id":"source/images/vuexcover.png","path":"images/vuexcover.png","modified":1,"renderable":0},{"_id":"source/images/webpackcover.png","path":"images/webpackcover.png","modified":1,"renderable":0},{"_id":"source/images/性能优化cover.png","path":"images/性能优化cover.png","modified":1,"renderable":0},{"_id":"source/images/迁移vitecover.png","path":"images/迁移vitecover.png","modified":1,"renderable":0},{"_id":"themes/async/source/failure.png","path":"failure.png","modified":1,"renderable":1},{"_id":"themes/async/source/sw.js","path":"sw.js","modified":1,"renderable":1},{"_id":"themes/async/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/async/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/async/source/img/block.jpg","path":"img/block.jpg","modified":1,"renderable":1},{"_id":"themes/async/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/async/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/async/source/img/logo.gif","path":"img/logo.gif","modified":1,"renderable":1},{"_id":"themes/async/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/async/source/img/banner.png","path":"img/banner.png","modified":1,"renderable":1},{"_id":"themes/async/source/css/index.less","path":"css/index.less","modified":1,"renderable":1},{"_id":"themes/async/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/async/source/fonts/webfonts/fa-regular-400.woff2","path":"fonts/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/async/source/fonts/webfonts/fa-solid-900.woff2","path":"fonts/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/async/source/fonts/webfonts/fa-brands-400.woff2","path":"fonts/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/async/source/css/plugins/bootstrap.min.css","path":"css/plugins/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/async/source/css/plugins/bootstrap.row.css","path":"css/plugins/bootstrap.row.css","modified":1,"renderable":1},{"_id":"themes/async/source/css/plugins/locomotive-scroll.css","path":"css/plugins/locomotive-scroll.css","modified":1,"renderable":1},{"_id":"themes/async/source/js/plugins/local_search.js","path":"js/plugins/local_search.js","modified":1,"renderable":1},{"_id":"themes/async/source/js/plugins/typing.js","path":"js/plugins/typing.js","modified":1,"renderable":1},{"_id":"themes/async/source/css/plugins/font-awesome.min.css","path":"css/plugins/font-awesome.min.css","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"cd08c9f58805c0a27328d006b8f980e8a82befdb","modified":1681910044748},{"_id":"source/_data/languages.yml","hash":"2713049d52e005cd40cd706f7f54aeec883c298f","modified":1680582556005},{"_id":"source/about/index.md","hash":"5cb8e1b07055faf691223b01106e7d18a3b360ce","modified":1680618965228},{"_id":"source/about/.DS_Store","hash":"b84025d091de669775813c2a65db5a8da33724b4","modified":1680499487900},{"_id":"source/links/index.md","hash":"73022e1a3e40205453601450229395966e4a80db","modified":1680592511326},{"_id":"source/categories/.DS_Store","hash":"5c7a0f6093baf17a184d28530e504265d40a3b88","modified":1680504083396},{"_id":"source/categories/index.md","hash":"e8f1b2220c1eb2e60127d2b78c11687ef46425aa","modified":1680602520473},{"_id":"source/_posts/Hooks.md","hash":"4ef6c59a9b4f45e9f89cda62233b75cd1f2c6817","modified":1679465564044},{"_id":"source/_posts/Pinia与Vuex 的区别.md","hash":"ea5a92ffcfb3548b996c5b8195f7731bacbd9b09","modified":1681192116347},{"_id":"source/_posts/Vue-搜索引擎SEO优化.md","hash":"bd56dddd7916176add7d7f54f6f471c67cecac9e","modified":1681193479737},{"_id":"source/_posts/Vue-axios.md","hash":"a6c408b0c5870fb12472c3917d08db68cf7ee026","modified":1680496592973},{"_id":"source/_posts/Vue-Cli.md","hash":"06f84525da1f0a8bcef2cca79567a3934250e99a","modified":1681196305909},{"_id":"source/_posts/Vue3-Pinia使用.md","hash":"35d8f83857ef055e95f756b3f5b16626e462aa9b","modified":1680497090333},{"_id":"source/_posts/Vue3shallowRef和shallowReactive.md","hash":"2c7b130bf844d4fd37029369702ae5a522512897","modified":1679466485076},{"_id":"source/_posts/Vue3setup函数.md","hash":"5a99771eba4c1e8e86c923f97c4ea72d5b139cf4","modified":1679466458215},{"_id":"source/_posts/Vue3toRef和toRefs函数.md","hash":"344c099a678b07278510ccc2e8afd433f7e30ba4","modified":1679466553317},{"_id":"source/_posts/Vue3侦听器watch.md","hash":"9c4e356c6e6ccf34d141669d57b3f603a7a38593","modified":1679466329581},{"_id":"source/_posts/Vuex的namespaced属性.md","hash":"c71c24a92e3d854a6ee8f57b48e9267ed718a3a4","modified":1681192492729},{"_id":"source/_posts/Vue项目SEO优化-Nuxt.md","hash":"26a8a1d74f69b3f7a17a95c16a5f31fefac73a75","modified":1681188390069},{"_id":"source/_posts/component动态组件.md","hash":"860698439a9e3d66631d88ff8ea7cd7e251eea3a","modified":1681379760164},{"_id":"source/_posts/Vue3计算属性.md","hash":"331a76051784ffd319a0fa348d1da26643643d45","modified":1679466296958},{"_id":"source/_posts/serve的区别.md","hash":"0733fdb48e2b7f8aa524223b77824437e5509be6","modified":1679465694947},{"_id":"source/_posts/vue-cropper.md","hash":"917d2f8e9e3d8e5227181a2069b2d0d4055e40f0","modified":1681222462012},{"_id":"source/_posts/vue3-hooks使用.md","hash":"cd7845d26944f1aa8f4f0533f4cdc04a2cdb0eb1","modified":1679465934484},{"_id":"source/_posts/vue3API.md","hash":"b571759c2133ae5200274e366c2758f4386c897b","modified":1671439414765},{"_id":"source/_posts/vue3.md","hash":"e03f5d8c011902c3b3d718594f3b4f6819a8e73c","modified":1679466275681},{"_id":"source/_posts/vue3组件传值.md","hash":"df28158d6a9af93232b0a29fec830bf3a9c6c6d4","modified":1679466344254},{"_id":"source/_posts/Vue项目遇到问题.md","hash":"925f7454818d92618130a6b22c4e43a5ee597f88","modified":1681379048690},{"_id":"source/_posts/vue3ref和reactive函数.md","hash":"e97e58e1d04c70e4ce9cf2a1b4aafd124e2f36ea","modified":1679466395705},{"_id":"source/_posts/webpack迁移vite.md","hash":"b9420b3240ea69faef64be1f7b7087e019720425","modified":1681195757550},{"_id":"source/_posts/vue3新语法细节.md","hash":"875ee34a8dd2422edca574309aad53536522f2a2","modified":1673347396914},{"_id":"source/_posts/webpack.md","hash":"2ca00f15e99a34756a6005c2a18bbd6a4246c072","modified":1681094302245},{"_id":"source/_posts/Vuex.md","hash":"b71b64fc06cea9012eb5cec75a4b99442cb09f97","modified":1681192816068},{"_id":"source/_posts/微前端.md","hash":"8c1081f677b02a064b2bc69535a828d42b5c7125","modified":1680150165883},{"_id":"source/_posts/开发hexo主题记录.md","hash":"a895f9f31c2da689e7441840c002d567e6cb9213","modified":1681373967910},{"_id":"source/_posts/webpack升级.md","hash":"1e71baada8ecce4cd356604d5d415ebaae9b00d9","modified":1681194208349},{"_id":"source/_posts/微前端-qiankun.md","hash":"3d970d2c75c4cdf6f5d7fe36b24763cd145ae72e","modified":1681196080195},{"_id":"source/_posts/数组，对象遍历的用法总结.md","hash":"ea93f64ada81c57ba25030562829378f78d03890","modified":1680496948282},{"_id":"source/_posts/性能优化.md","hash":"3347f9c22297cdfe3d7c0d13c0451e19e3afc12c","modified":1681195479860},{"_id":"source/_posts/模块化.md","hash":"f195fde38a1c33e5ab99dd579e2befd132b468d2","modified":1681800000995},{"_id":"source/_posts/博客搭建.md","hash":"ba283baafaf06ac1dfd409ad497f708b6e08f3f2","modified":1679465303023},{"_id":"source/_posts/跨域.md","hash":"72fd84a0b769c7402b512d02b98c7058a7630e68","modified":1679465351591},{"_id":"source/_posts/深浅拷贝.md","hash":"bca2512692b0df7d99d5e73578ed258c1626f055","modified":1680496726130},{"_id":"source/images/.DS_Store","hash":"e5fa0c0736fed42fe5011a4f4561ffe19c020618","modified":1681997917275},{"_id":"source/images/defaultimg7.png","hash":"7ad0d95b5ca4faae504863caa48a7e06675ec8b5","modified":1680694796813},{"_id":"source/images/logo.gif","hash":"e6dfe357f9f842e8bbfb2e3cda164b1f3f6cdea3","modified":1680586743994},{"_id":"source/images/icon.png","hash":"cb821203c6eea9e37b33f1069d0326e3d329617c","modified":1680682419914},{"_id":"source/tags/index.md","hash":"af8a66cef6331d3ec378aeafe90daa15d67d6152","modified":1680602512370},{"_id":"source/tags/.DS_Store","hash":"5c7a0f6093baf17a184d28530e504265d40a3b88","modified":1680499338117},{"_id":"source/read/index.md","hash":"8ec15ee4d938dca2fca4106a25748bcc5ce5784a","modified":1680499473695},{"_id":"source/read/.DS_Store","hash":"f5a0bf683bd7f19fd55d38018a35f21fe480093e","modified":1680499497020},{"_id":"source/_posts/Vue3setup函数/被点击.png","hash":"08aa117a094790f49408b0072342fa89b4202050","modified":1665643256308},{"_id":"source/_posts/Vue3-Pinia使用/安装.png","hash":"b35c38aa5fd70dfbf973a8ecdde913b9fb0f26f8","modified":1666691495687},{"_id":"source/_posts/Vue3-Pinia使用/截图13代码1.png","hash":"7a1368e06c525c2e034dc39142bf844215e99a72","modified":1666708344764},{"_id":"source/_posts/Vue3-Pinia使用/截图14代码.png","hash":"6b88eac576b98e1a0c97c37be505a2357c37a8d2","modified":1666709359717},{"_id":"source/_posts/Vue3-Pinia使用/截图1结果.png","hash":"602355bda5c4ba049b2b60ba7127b34643e7f15a","modified":1666702914491},{"_id":"source/_posts/Vue3计算属性/案例二.png","hash":"bca10286752f9a3b70042c26480727bca5366cbc","modified":1666011378423},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef代码结果.png","hash":"fd9d5456f4fa5912e8e256c65cfb582e77cd8467","modified":1666179674421},{"_id":"source/_posts/Vue3计算属性/引入.png","hash":"fc352bb0212ecb4617ba425d65c88c0f0e81bb7e","modified":1666008886802},{"_id":"source/_posts/Vue3计算属性/计算属性求和.png","hash":"3403abc4b3d832e185d1b6602bdfa745a6cf3e70","modified":1666011494713},{"_id":"source/_posts/Vue3侦听器watch/侦听器一结果.png","hash":"2c6bd0186ff6e9afe79cc3be6285ebce50004974","modified":1666098668685},{"_id":"source/_posts/Vue3侦听器watch/多个侦听器代码.png","hash":"b6b5ce0a312074c007ca6c87951768a90b2914cd","modified":1666101970941},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref源数据.png","hash":"b0b445fedbc9be175e7039adbc9e601b941e5792","modified":1665756619169},{"_id":"source/_posts/Vue3toRef和toRefs函数/截屏2022-10-17 上午11.27.38.png","hash":"9b77eec67a3fb63a4cabdc29e11105b44eb39b6b","modified":1665977289220},{"_id":"source/_posts/深浅拷贝/深浅拷贝结果.png","hash":"624d55ea479daf8bcadae7ccbfda13bf0ad17fb0","modified":1661481320994},{"_id":"source/images/cover.png","hash":"7583ffb21f077fe577d7f5370b8c0647bbc4121c","modified":1681140974946},{"_id":"source/images/defaultimg1.png","hash":"c4375e1feb053b6d910ebfca9904110c89cf8fef","modified":1680694266608},{"_id":"source/images/defaultcover.png","hash":"2380411ace59c88218585a66898afff8c408a91d","modified":1680589088965},{"_id":"source/images/logo.png","hash":"6ef7a5685ca2673674b8a05f56e4dc9b035d1172","modified":1680586738023},{"_id":"source/images/piniacover.png","hash":"aaea7fed1e454cbd650a85c181eb5ea09d55c71b","modified":1681192087306},{"_id":"source/images/defaultimg3.png","hash":"a247996c42bb0feb567a9ed76d664de64a6636b6","modified":1680694406898},{"_id":"source/images/vueclicover.png","hash":"3372e0ea2f01ca4bd60e2ff907c9d05c65a35706","modified":1681196314955},{"_id":"source/images/vuexcover.png","hash":"291dffb1c147a6caa33e48772eef469aa8be0446","modified":1681192793330},{"_id":"source/_posts/Vue3setup函数/基本变量.png","hash":"b63521e989cac21dec73a6a0da721d3ab03ec044","modified":1665646062104},{"_id":"source/_posts/Vue3setup函数/name.png","hash":"b707a7fca8686ac90273234bbc914025085ab45c","modified":1665646155747},{"_id":"source/_posts/Vue3setup函数/名称渲染失败.png","hash":"8ac8f3f2485d1000771164a86e07cdebcfdcd57a","modified":1665642113569},{"_id":"source/_posts/Vue3setup函数/渲染成功.png","hash":"fb63b176ea1fffce2891c61087b95465af4868cd","modified":1665642648976},{"_id":"source/_posts/Vue3setup函数/点击代码.png","hash":"5e515ea203ff32f9079b05c4896d421f341fbff5","modified":1665646440428},{"_id":"source/_posts/Vue3-Pinia使用/indexts.png","hash":"8fd0b5d11e9d40dc24ede704ea6da047febbc9ad","modified":1666701836690},{"_id":"source/_posts/Vue3-Pinia使用/截图12结果.png","hash":"906013a2fc77c1765c242f82aa8381f783325c37","modified":1666708101268},{"_id":"source/_posts/Vue3-Pinia使用/截图11结果2.png","hash":"661a128e4433b159d68b13fe236e034ac9d06550","modified":1666707777714},{"_id":"source/_posts/Vue3-Pinia使用/截图11结果1.png","hash":"29749e46e1cdc7c73c671cbb22f006087a91abd0","modified":1666707782602},{"_id":"source/_posts/Vue3-Pinia使用/截图16结果2.png","hash":"2c70beda971e4bb00b1e3113b0a06dfab5eb3943","modified":1666710193214},{"_id":"source/_posts/Vue3-Pinia使用/截图1代码.png","hash":"75e9d7b5009d2fc31abb56fb8b32b4aa02509119","modified":1666702912111},{"_id":"source/_posts/Vue3-Pinia使用/截图3结果1.png","hash":"3cdc82239094f7501a406b74e88a96eae09c42e7","modified":1666703495990},{"_id":"source/_posts/Vue3-Pinia使用/截图3结果2.png","hash":"06e73c74a04b9800a008496966a3ba7ed566dec9","modified":1666703499276},{"_id":"source/_posts/Vue3-Pinia使用/截图2结果.png","hash":"4c6d26bc1876bbc2104a572d580bffecc38d81a0","modified":1666703174570},{"_id":"source/_posts/Vue3-Pinia使用/截图6代码1.png","hash":"748bc17657ce5095cb54750266367126d289982d","modified":1666704438421},{"_id":"source/_posts/Vue3-Pinia使用/截图6结果1.png","hash":"5c41e4182f85564c4423eb1e9e3ea7d54eddc5ef","modified":1666704446098},{"_id":"source/_posts/Vue3-Pinia使用/截图6结果2.png","hash":"52ac61cbd93d036519c8fc4db19c370b57951f9d","modified":1666704516186},{"_id":"source/_posts/Vue3-Pinia使用/截图7结果1.png","hash":"08076158cf4abb9ebf08df4b708005d1a91facaa","modified":1666704830109},{"_id":"source/_posts/Vue3-Pinia使用/截图7结果2.png","hash":"4e3c93ba6f79b3a1d6a3661f055e752890af7ba4","modified":1666704832463},{"_id":"source/_posts/Vue3-Pinia使用/截图7代码1.png","hash":"d06e170e0c788538fedc9db212c71010173ddf21","modified":1666704822183},{"_id":"source/_posts/Vuex/vuex.png","hash":"0577c82e34c8edc82bcdcadb98d4e832b1cb5fab","modified":1680856304899},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef代码.png","hash":"5d8dc074bb0e0ded665af5d195dfc2c50f8bb31c","modified":1666179567509},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用正常.png","hash":"8db8aa94bb3b5a8200e96359df504f46b23015a3","modified":1665975136686},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs解决代码.png","hash":"1f605f0d5a6d9ddfab7934b0f399dc46f3f81527","modified":1665976047722},{"_id":"source/_posts/Vue3toRef和toRefs函数/reactive代码.png","hash":"733615b731fc230b906fe3f86ee50ff92248fe03","modified":1665975575002},{"_id":"source/_posts/Vue项目SEO优化-Nuxt/客户端渲染.png","hash":"1fc822d916c2fa882bb4a7a3a2fba1c189f1e183","modified":1681179859533},{"_id":"source/_posts/Vue项目SEO优化-Nuxt/服务端渲染.png","hash":"7366a775890a80e2e82e0f3d6dddf4be7ab10227","modified":1681180116216},{"_id":"source/_posts/vue3API/案例6.png","hash":"55b29aea1b417c1f15ae0bf897fd764188256158","modified":1671438054538},{"_id":"source/_posts/vue3-Hooks使用/案例2.png","hash":"c947267b51513a52ee79dda20bb8b7baa65c1e1b","modified":1670576592186},{"_id":"source/_posts/vue3-Hooks使用/案例1.png","hash":"41a9ed7307a5ce4974ce055eb2e1aec4ab38eeed","modified":1670575796841},{"_id":"source/_posts/vue3-Hooks使用/案例3.png","hash":"e09d51e285963ee2d4ae41a68ddb4c76ceef621d","modified":1670576655816},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象代码.png","hash":"aaf3b834c26a34ea0f2de6d0998f502d337953db","modified":1665751960346},{"_id":"source/_posts/vue3ref和reactive函数/reactive数组处理结果.png","hash":"ab8274bde10d8e21feb91c9802d6179e5bccf62a","modified":1665752533490},{"_id":"source/_posts/vue3ref和reactive函数/ref基本出错.png","hash":"89635c08525515948e4b701e8e168f606fff583d","modified":1665747137732},{"_id":"source/_posts/vue3ref和reactive函数/ref基本修改成功.png","hash":"ceb47ae8580ab75ea06fd3a49c66af2072a4e868","modified":1665748816398},{"_id":"source/_posts/vue3ref和reactive函数/ref成功.png","hash":"7a233c69bc9cfa196d7d263578ef9197e4598a76","modified":1665751146623},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂数据代码.png","hash":"0024dcd4878f05c8b732c156890bdae8839731b6","modified":1665749107567},{"_id":"source/images/default.png","hash":"b655c32f8e557434f7faf0862521909a481d3fb8","modified":1680593572881},{"_id":"source/images/defaultimg.png","hash":"72cdebd7da697f56f672e8e172f3c70ea0c4693b","modified":1680586741736},{"_id":"source/images/defaultimg4.png","hash":"21068c09489df9ab4235063458721a25c2b6cd45","modified":1680694460520},{"_id":"source/images/defaultimg6.png","hash":"45fc80e0596db5a2bacdf5e13c72b3be0e898b23","modified":1680694584400},{"_id":"source/images/defaultimg2.png","hash":"c9039014de71f5ce489c6644c95ad6a5eae5b893","modified":1680694343197},{"_id":"source/images/defaultimg5.png","hash":"9d584d702b84209f2b6983565e545685da7d4916","modified":1680694540985},{"_id":"source/images/vueseocover.png","hash":"56645dee8c31cd790e404554f7d77cdf395a746d","modified":1681193456965},{"_id":"source/_posts/Hooks/案例1.png","hash":"868897c58cb1fd3493ab0a2e876ee893983fdf3c","modified":1670569657435},{"_id":"source/images/性能优化cover.png","hash":"ad9b1986dabe5cf82f420de00e43a41db75e1203","modified":1681195466729},{"_id":"source/_posts/Vue3setup函数/基本数据类型.png","hash":"14aa8ce4abcacbe2eab03b648c8eaf7d4d0e5ccc","modified":1665642782802},{"_id":"source/_posts/Vue3-Pinia使用/截图10结果.png","hash":"87d3a51ace6ec0a9eebbfd938e00cce00965092d","modified":1666705469703},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码.png","hash":"2ff59f992a8f17c65dad9a369925e7df7b80409d","modified":1666706957589},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码1.png","hash":"3ec7af117e340f99ddac1d8586a3cee26f9bb8a4","modified":1666707764556},{"_id":"source/_posts/Vue3-Pinia使用/截图10代码.png","hash":"1395fd458a42a930c62ff3ed9ca8667db3cf120e","modified":1666705466792},{"_id":"source/_posts/Vue3-Pinia使用/截图13结果2.png","hash":"78bb5044555f9d23733854c1c97ded2d2e5ee1a2","modified":1666708944697},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码2.png","hash":"7198042e761f1e68a47ad1f9fbf5a683736ae8d8","modified":1666707770432},{"_id":"source/_posts/Vue3-Pinia使用/截图13代码2.png","hash":"f98f2379f7c4f556be5f5e9b56f0e19a63102b93","modified":1666708400826},{"_id":"source/_posts/Vue3-Pinia使用/截图13结果1.png","hash":"40a3ffe728c745eea28d33e28a6f48051422c103","modified":1666708946816},{"_id":"source/_posts/Vue3-Pinia使用/截图15代码.png","hash":"84dfe56a7e0020a1412adbb9a78ae77f272cc166","modified":1666709494783},{"_id":"source/_posts/Vue3-Pinia使用/截图16结果1.png","hash":"73cb06309c246eca61f38a77a5d336e7fc244804","modified":1666710190350},{"_id":"source/_posts/Vue3-Pinia使用/截图14结果1.png","hash":"2a6e36d09632bd34d61ebc6736c57b8c18bc8100","modified":1666709362892},{"_id":"source/_posts/Vue3-Pinia使用/截图14结果2.png","hash":"60426c2088b76e54196495c373a04d7035192ce3","modified":1666709365689},{"_id":"source/_posts/Vue3-Pinia使用/截图2代码.png","hash":"21d9715a07655174901ed7fa05e92153f21a0318","modified":1666703172252},{"_id":"source/_posts/Vue3-Pinia使用/截图3代码.png","hash":"1bb7dfdcc7fb102c1624f03173784c89c7e470e4","modified":1666703493607},{"_id":"source/_posts/Vue3-Pinia使用/截图5代码.png","hash":"fa51f7613db86bdc4e9ee6d3e3e6353e6ec12f6e","modified":1666703997268},{"_id":"source/_posts/Vue3-Pinia使用/截图4代码.png","hash":"de9e43926f49e658ac346c7b5f591c69283642bf","modified":1666703993388},{"_id":"source/_posts/Vue3-Pinia使用/截图6代码2.png","hash":"b089d26856bee996ce18a2708b66fa7fb84099f1","modified":1666704441294},{"_id":"source/_posts/Vue3-Pinia使用/截图7代码2.png","hash":"919b9d4b0b77d4f9391b459e9659d1473a5e8165","modified":1666704825144},{"_id":"source/_posts/Vue3-Pinia使用/截图8代码.png","hash":"fe050cc1abc7053ad0e5c6d199f33cc18d9b642c","modified":1666705014422},{"_id":"source/_posts/Vue3-Pinia使用/截图9结果.png","hash":"1696b4942ef8cbc881e72638877c882f2c0d404d","modified":1666705250906},{"_id":"source/_posts/Vue3-Pinia使用/截图8结果.png","hash":"e7aee55a51c443f0c2ae02a6d9da924a45231c74","modified":1666705016549},{"_id":"source/_posts/Vue3-Pinia使用/截图9代码.png","hash":"2b5df9557f9f5c9272757b1974d8515693b97251","modified":1666705246405},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowReactive一代码.png","hash":"2384d4018de330b2c14cabebd069bc7c806ab037","modified":1666179127063},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef二代码结果.png","hash":"162d280234dad815826b1f9f2225f3f55802f91d","modified":1666180003907},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef二代码.png","hash":"1a00d0d541d828513b6603ba56ec15b3a7c46448","modified":1666179833684},{"_id":"source/_posts/Vue3侦听器watch/侦听器一代码.png","hash":"aee51e5ce07b91827da3c4ceb02e06f22e104094","modified":1666097002229},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowReactive一代码结果.png","hash":"460433078d58c9de4ad54624975cc1e6d562b66d","modified":1666179561899},{"_id":"source/_posts/Vue3计算属性/案例一.png","hash":"7a6a042bf4e2e9698ef031a0bf754805abf5d66b","modified":1666011200225},{"_id":"source/_posts/Vue3侦听器watch/侦听器一控制台.png","hash":"f4513cd9a342bf2705efaeb6f185a701da422d8d","modified":1666098664984},{"_id":"source/_posts/Vue3侦听器watch/侦听器三修改代码.png","hash":"7f386d5c6812c789ff065e17d6f23acea95bbd3e","modified":1666101651151},{"_id":"source/_posts/Vue3侦听器watch/侦听器三代码.png","hash":"5428081fe08ea11be13415e87e0c919a4064a46f","modified":1666101330673},{"_id":"source/_posts/Vue3侦听器watch/侦听器一数据更新代码.png","hash":"8c8cab41984a0ba050a74ad3d08bdafadb78217d","modified":1666099270743},{"_id":"source/_posts/Vue3侦听器watch/侦听器二修改代码.png","hash":"743dbbf2ec1250918c07b89a2a6f96157a4be45b","modified":1666100967568},{"_id":"source/_posts/Vue3侦听器watch/侦听器监听reactive代码.png","hash":"fdee0cf863b6c1e83d4992b4ed83750484ebccd8","modified":1666099364700},{"_id":"source/_posts/Vue3侦听器watch/侦听多个参数.png","hash":"e67f0b79227b4eb618c86f42c590cd0bb66686f6","modified":1666102062939},{"_id":"source/_posts/Vue3侦听器watch/侦听器二代码.png","hash":"b0ad55721871383c18be9eca918260c5e0c84649","modified":1666100722095},{"_id":"source/_posts/Vue3toRef和toRefs函数/ref函数验证代码.png","hash":"06b57eec559530274780610467c6185af5189486","modified":1665757535623},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用结果.png","hash":"afad00887f811bbbeda91e16efe49c6c225bca5b","modified":1665973729015},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref修改代码.png","hash":"d2d1bb4ab19341a958738d24f2ab79be6a2938f3","modified":1665756104669},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref代码.png","hash":"243d4d9ca586000df96c11df26d4ccb3a4dd133e","modified":1665755545321},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用代码.png","hash":"4546360c27c51682347024e74fb608348ed026de","modified":1665973466829},{"_id":"source/_posts/Vue项目SEO优化-Nuxt/nuxt渲染.png","hash":"57cb4c2a26642ed3c055bf2dd4810a0aea1beed0","modified":1681179864008},{"_id":"source/_posts/Vue3toRef和toRefs函数/原始数据代码.png","hash":"77aedb1e69bc73ff51201eb308ac8214711cf53c","modified":1665976237422},{"_id":"source/_posts/vue3API/案例11.png","hash":"00fb54237ad8674adf0fe9a9886ad0ab12cd7140","modified":1671438404371},{"_id":"source/_posts/vue3API/案例12.png","hash":"92c620cd017cc7962917b0990a84d396e2edf77c","modified":1671438471064},{"_id":"source/_posts/vue3API/案例23.png","hash":"376426f6680c28e8a963cd0aa50d729e86cbd41e","modified":1671439383144},{"_id":"source/_posts/vue3API/案例5.png","hash":"792504cf4e2e6b87009b591a8a190f327c7af420","modified":1671025965401},{"_id":"source/_posts/vue3API/案例3.png","hash":"84df433ef9450983bc6c71613f3ac01ffac88285","modified":1671025794148},{"_id":"source/_posts/vue3组件传值/子组件三代码.png","hash":"aad7ee1be4d85c10ac39a76070b3089fe2f4ec76","modified":1666321911441},{"_id":"source/_posts/vue3组件传值/子组件二代码.png","hash":"e64bef83b37d6bc0a3551955edb4ca6bf222f430","modified":1666321531738},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象修改结果.png","hash":"304b185a453096c60f6bc15b70a03c1e17499ab9","modified":1665752356156},{"_id":"source/_posts/vue3ref和reactive函数/reactive数组代码.png","hash":"a93b6d0fabf13f74f0a8cacaec4f717635b4165d","modified":1665752453894},{"_id":"source/_posts/vue3ref和reactive函数/refdom代码.png","hash":"d554724f5dfe1f8552762b6b05bfc94d5b1ac1a9","modified":1665750828539},{"_id":"source/_posts/vue3ref和reactive函数/ref修改代码.png","hash":"94d645e54beecb5a81bcf0c220155d82c0cfda3f","modified":1665748503639},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂修改代码成功.png","hash":"08ebd64d3de3343d66c318aa43352d08ff71345f","modified":1665750248482},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂修改代码.png","hash":"054e88cf5c25e8bac9cf48acd7ed2b39a05981af","modified":1665750143955},{"_id":"source/_posts/vue3ref和reactive函数/reactive修改代码.png","hash":"050308b60afb877775da196bb9856864dcb95e9a","modified":1665752277960},{"_id":"source/_posts/vue3ref和reactive函数/ref基本数据类型代码.png","hash":"fb11e49f6916cafa290d6a38bf280c9ff82ed1bc","modified":1665746888129},{"_id":"source/_posts/微前端-qiankun/defaultPic.png","hash":"72cdebd7da697f56f672e8e172f3c70ea0c4693b","modified":1680514755588},{"_id":"source/images/namespacedcover.png","hash":"979a6da75d683defc9f47bfe4740d2d4ba1aaea0","modified":1681191595119},{"_id":"source/images/webpackcover.png","hash":"e5514b2cbf696f470ff07e5629d26e01ac591811","modified":1681194187725},{"_id":"source/images/迁移vitecover.png","hash":"cf0a1a06376ceb0e506be001353009979715d13b","modified":1681195746297},{"_id":"source/_posts/Hooks/案例2.png","hash":"74b00eebdf721ace661d5a699d5b636935c3e654","modified":1670569677930},{"_id":"source/_posts/Vue3setup函数/提示找不到.png","hash":"77541a000deff4521d4819fdbab7d2cb8f0b44bc","modified":1665642385082},{"_id":"source/_posts/Vue3setup函数/复杂数据类型.png","hash":"043c0d8faed707cd2a24922078d1ce7bc41f5d11","modified":1665642894853},{"_id":"source/_posts/Vue3-Pinia使用/截图12代码.png","hash":"60c8cd99311bd5350a1281fbcf9b21a2a376ee4c","modified":1666708026094},{"_id":"source/_posts/Vue3-Pinia使用/截图15结果1.png","hash":"0f02b5e18b02dfa18bd2ed30c11c32b12583213f","modified":1666709895278},{"_id":"source/_posts/Vue3-Pinia使用/截图15结果2.png","hash":"03cea55f66253ed27722a0557392ee5971ae633b","modified":1666709897986},{"_id":"source/_posts/Vue3-Pinia使用/截图16代码.png","hash":"099fe0b855e49d6b6edf4314bf92b3fb13c6e6f1","modified":1666710065911},{"_id":"source/_posts/Vue3-Pinia使用/截图17代码.png","hash":"bc6478049274440c36ce42656644c6992d7f8077","modified":1666710561300},{"_id":"source/_posts/Vue3侦听器watch/侦听器二修改结果.png","hash":"9d1db9108cd46fc48764fc971d22158633de580a","modified":1666101212068},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref打印body代码.png","hash":"951b46e871a6a1106eb942d67c02cef438b7afdc","modified":1665756758872},{"_id":"source/_posts/vue3API/案例10.png","hash":"b9e08f7edc34dd6002b5289140b170f2ea2a4ff6","modified":1671438339741},{"_id":"source/_posts/serve的区别/npm区别.png","hash":"0df40dee128dd7245a783544b56e69930450f567","modified":1678677491357},{"_id":"source/_posts/vue3API/案例13.png","hash":"b72f3b1639e3e6e240397459b138f234e7731f10","modified":1671438559453},{"_id":"source/_posts/vue3API/案例15.png","hash":"30db8e13899164e1e246da2d0214852772bcc2f3","modified":1671438767849},{"_id":"source/_posts/vue3API/案例1.png","hash":"3749c2bc0a424c59dc316ffb8e0510dc1b3847cf","modified":1671025643931},{"_id":"source/_posts/vue3API/案例14.png","hash":"a447452e694c2df7c9654e6152100b8d3ae777fb","modified":1671438689752},{"_id":"source/_posts/vue3API/案例2.png","hash":"ac45a3b4102467c1661c004290592b5d3079d35e","modified":1671025716824},{"_id":"source/_posts/vue3API/案例7.png","hash":"0f4d27fb25d283beee04662a5b35b20545770fd7","modified":1671438137612},{"_id":"source/_posts/vue3组件传值/传值前结果.png","hash":"a38dabf08a04fc0bcc222c9556cd03206b83a7cd","modified":1666322088828},{"_id":"source/_posts/vue3组件传值/子组件代码.png","hash":"ef8853dad1c2a331a27401ce273378d8f1210783","modified":1666319520515},{"_id":"source/_posts/vue3组件传值/传值后结果.png","hash":"833aa748bd0e3d8a8e51e1ec2f6d726cd269ee8c","modified":1666322038784},{"_id":"source/_posts/vue3组件传值/父组件代码.png","hash":"34be2541e55ce25a0fb2ad42f2e895d9d8d1f9ae","modified":1666319375708},{"_id":"source/_posts/vue3组件传值/祖孙结果.png","hash":"c1cff8de7aad8dadab9a032812f1a856d33b700a","modified":1666321613087},{"_id":"source/_posts/vue3组件传值/父组件三代码.png","hash":"1f8caea6ab3214aaa2f25a584449d39a573cd2c9","modified":1666321728224},{"_id":"source/_posts/vue3组件传值/父组件二代码.png","hash":"a4b00c42a7da2d0469d17cfe925da35186210aee","modified":1666321442231},{"_id":"source/_posts/vue3ref和reactive函数/ref基本控制台.png","hash":"791cc971a4d69f5fc87568f6834312180abcb4ea","modified":1665747285406},{"_id":"source/_posts/vue3ref和reactive函数/ref打印.png","hash":"37e9af7e01bb74f3a6dc89ff6d3cf85303670556","modified":1665751183658},{"_id":"source/_posts/Vue3setup函数/基本数据代码.png","hash":"afb3efec654604c5b0c323213c66b735aca08028","modified":1665646352224},{"_id":"source/_posts/webpack升级/webpack5-1.png","hash":"31aabcba2010bceaec485ff41a60a2016e97cdf7","modified":1681111904788},{"_id":"source/_posts/Vue3侦听器watch/侦听器一数据更新.png","hash":"ecc5fde8517d62bc391f4ca2c5cbdd34ad8b805a","modified":1666099058421},{"_id":"source/_posts/Vue3侦听器watch/侦听器三报错.png","hash":"e3cf54e20af42c647cf70bb10b8af17f78fb416f","modified":1666101556075},{"_id":"source/_posts/Vue3侦听器watch/侦听器三修改结果.png","hash":"cfc6fbc9153515388e84b5450cd41dfa1d0c275c","modified":1666101802283},{"_id":"source/_posts/Vue3toRef和toRefs函数/数据源结果.png","hash":"0d52c3a41f898ae79c961c1c8bb2ca23a8535073","modified":1665976762854},{"_id":"source/_posts/vue3API/案例4.png","hash":"d119b34723578142c2cdd06fccc13b1fb53457b0","modified":1671025903773},{"_id":"source/_posts/vue3API/案例22.png","hash":"02f636d85da47984a2ec2860a6c664289d57040a","modified":1671439309265},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂结构.png","hash":"685333b144015b074af204a7d3bdec8689466702","modified":1665749856366},{"_id":"source/images/defaultbgurl.png","hash":"afd02b8d6283b137687944cd7dcad3dd5b177425","modified":1680594065644},{"_id":"source/images/qiankuncover.png","hash":"ab3ae22a566749ab7a26b0a4bca847dc4ff41aab","modified":1681217557739},{"_id":"source/_posts/Hooks/案例3.png","hash":"c901570618e6953c64d13a679ea0de943644eb31","modified":1670569692526},{"_id":"source/_posts/vue3ref和reactive函数/ref结构.png","hash":"c6720f7d16db079b3294d891f3c6fb4ccb1a28ed","modified":1665748368775},{"_id":"source/_posts/Vue3setup函数/复杂数据代码.png","hash":"d8108e61fcede23fe8b9448ec9e9b84ca3da2c7c","modified":1665646344619},{"_id":"source/_posts/Vue3侦听器watch/侦听器二警告.png","hash":"b9338963991e5acee941245f5ec14f713282b086","modified":1666100101586},{"_id":"source/_posts/Vue3toRef和toRefs函数/torefbody打印结果.png","hash":"500ade02277e28c474db944ec81f7d431e74a610","modified":1665757063642},{"_id":"source/_posts/vue3API/案例17.png","hash":"4946ce1dbfde314a97281cd87b255dc885018083","modified":1671438913991},{"_id":"source/_posts/vue3API/案例18.png","hash":"0b7a7ab71f0abc719726b990eba397ca86adde87","modified":1671439015007},{"_id":"source/_posts/vue3API/案例16.png","hash":"a47301b5384927cc8ea0732aec08691824e70beb","modified":1671438841004},{"_id":"source/_posts/vue3API/案例19.png","hash":"d7ae2edaea2d3fc2e444e20cbbeef9373083791d","modified":1671439097580},{"_id":"source/_posts/Vue3侦听器watch/侦听器监听reactive结果.png","hash":"880ed1c8fdb504f757f75c7b4e8198fdefce6b37","modified":1666099706287},{"_id":"source/_posts/Vue3侦听器watch/侦听多个参数结果.png","hash":"913b47f951bf57d60c5fbecb648bd5ad1c5f6a2b","modified":1666102380156},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref修改结果.png","hash":"77574d2b1b504b0258b096b9c706cc4ec0b86fbe","modified":1665756462928},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用控制台信息.png","hash":"8d85ef57adbf571c12d510dcebb9d57b4780f962","modified":1665974936031},{"_id":"source/_posts/vue3API/案例21.png","hash":"654ec1438a18111df14f4e7a1973d46e733adc72","modified":1671439233903},{"_id":"source/_posts/vue3API/案例20.png","hash":"386c78383d07d79f62f4fe1862f7dbc64b3bbdc9","modified":1671439165883},{"_id":"source/_posts/vue3API/案例9.png","hash":"3c4b30a0d297cb7f773f1ce7705fe4e0e7adf524","modified":1671438264990},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象结果.png","hash":"1e3d9f9787839ffc062cd7622661ef1a2332f9f4","modified":1665752167565},{"_id":"source/_posts/webpack升级/webpack4-2.png","hash":"a7376309820143ae28155c4a54db282b5a8596de","modified":1681098873033},{"_id":"source/_posts/webpack升级/webpack4.png","hash":"55503ae940964fa0a834f8d4eb35ca0291e00c6a","modified":1681096026197},{"_id":"source/_posts/Vue3toRef和toRefs函数/ref函数验证结果.png","hash":"80ec19fd6debdd3a6fb186dddda2d5bbece3605d","modified":1665757991938},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref页面成功.png","hash":"a8256b128a9d7f9ffb1c85a1ef755c13e0204bef","modified":1665755788777},{"_id":"source/_posts/Vue3-Pinia使用/截图17结果.png","hash":"6b79e742db256737f7c9b18e9040ee445f9ec13a","modified":1666710564188},{"_id":"source/_posts/vue3组件传值/子传父结果.png","hash":"5eb0fea3922366bba2cc46da6c840413a59e252d","modified":1666320801573},{"_id":"themes/async/README_zh-CN.md","hash":"f9dfc82d4b0e70f7afdbca600553157d5d7ebb47","modified":1681303588000},{"_id":"themes/async/README.md","hash":"42ce794d377d34a33e4d61384cb732d8306d8108","modified":1681303588000},{"_id":"themes/async/.gitignore","hash":"9cfb2ddd14ff8ee274e4a7a3180356587f6a757a","modified":1681303558000},{"_id":"themes/async/package.json","hash":"1ae3fc89425f4f2b8d263b393d46ca83a6d4e469","modified":1681303588000},{"_id":"themes/async/_config.yml","hash":"85a8ebcc50ddc61405a0cad6876b9b533d9e4fba","modified":1682047847291},{"_id":"themes/async/languages/en.yml","hash":"41dc13c0f09839409a86e82137d93e5a50f65142","modified":1681998391783},{"_id":"themes/async/.DS_Store","hash":"6de8c268af2f97f097500238019647295cab63bf","modified":1681909659772},{"_id":"themes/async/plugins.yml","hash":"f8eb3c9743d93c92816f05bc24e8140c04e52ee3","modified":1681303558000},{"_id":"themes/async/languages/zh-CN.yml","hash":"ebb6206f101438de572c2088a0fa557666c78772","modified":1681998393822},{"_id":"themes/async/scripts/utils.js","hash":"fcde4a1eb77de269bcfee9135e77f171077d53ec","modified":1681303558000},{"_id":"themes/async/source/.DS_Store","hash":"2a3334b08742dd6ba62c0e88b4965e8ea29b7474","modified":1681910172475},{"_id":"themes/async/layout/archive.ejs","hash":"699b18d557708ddbce89ec9fb3c2ffd8896f330b","modified":1681303558000},{"_id":"themes/async/layout/404.ejs","hash":"711cf5844e92ce42c22f93b50c6b794f1104a39e","modified":1681303558000},{"_id":"themes/async/source/sw.js","hash":"01b07120762ab155c99478afb36075d4d7e2bc9c","modified":1681303558000},{"_id":"themes/async/layout/custom.ejs","hash":"3e1cea3e7904992bdc8df2d630d75479bb2f6c16","modified":1681303558000},{"_id":"themes/async/layout/comment.ejs","hash":"55d3a6b69c5fdbeb6e946541401528243b4455cb","modified":1681303558000},{"_id":"themes/async/layout/index.ejs","hash":"02a02f3a2f5a9da329cd4c2ec0bd1af6c8d58f95","modified":1681870015916},{"_id":"themes/async/layout/page.ejs","hash":"1a81e2a16d463f5f944ae3b79f444c2ac4de1ce0","modified":1681303558000},{"_id":"themes/async/layout/about.ejs","hash":"52c1091fb0a3bd123ca72ad341ba5d1531e794c0","modified":1681303558000},{"_id":"themes/async/layout/category.ejs","hash":"1d4259078d3bc75c127da2176a13170f01687b5b","modified":1681552191118},{"_id":"themes/async/layout/layout.ejs","hash":"efaa02767b0b400376a2feba1ec910b972a327a3","modified":1681469241902},{"_id":"themes/async/layout/post.ejs","hash":"73264aa0e34b3cda21ec6ca33e932144c6b33811","modified":1681303558000},{"_id":"themes/async/layout/project.ejs","hash":"379a9822df4eba98d3be636e76dc2c578cb47d47","modified":1681303558000},{"_id":"themes/async/layout/tag.ejs","hash":"f9fb30ab43e5aba8427b7cb589c75da6aab88ba4","modified":1681552007949},{"_id":"themes/async/source/img/.DS_Store","hash":"28c574b79c2fb8ce51119cad493bc749784d12b9","modified":1682002058749},{"_id":"themes/async/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1681303558000},{"_id":"themes/async/source/img/block.jpg","hash":"1dd350354bd3fe2e7287dfe063d7783e4ab91090","modified":1681303558000},{"_id":"themes/async/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1681303558000},{"_id":"themes/async/source/css/index.less","hash":"dfb6f56f06f8980a7c11962a92ba389f4d017dd3","modified":1681303558000},{"_id":"themes/async/scripts/console/plugin.js","hash":"d31a3bc8ee816dbccbf4da914116a9991dd0b395","modified":1681303558000},{"_id":"themes/async/scripts/events/config.js","hash":"f63944b63456dd44d48eea29e0db6b8d7461ab98","modified":1681998534749},{"_id":"themes/async/scripts/events/index.js","hash":"872489c688bdad9d3c70c3b8b73fcad55a5e38b8","modified":1681303558000},{"_id":"themes/async/scripts/events/layout.js","hash":"ca81e8ed0aff086eca498c0bdc84ee05585ae245","modified":1681303558000},{"_id":"themes/async/scripts/filters/index.js","hash":"b1ea8e2b4b6ad798a5774a8633e55ca352ece5ae","modified":1681303558000},{"_id":"themes/async/layout/links.ejs","hash":"5db12fd2559da0fdebf6c80566adbbf459361e61","modified":1681303558000},{"_id":"themes/async/scripts/filters/cdn.js","hash":"ebc35d0ca20d65e7f113371ae3ddb0fd4988dee4","modified":1681303558000},{"_id":"themes/async/scripts/helper/async_config.js","hash":"2a0b80d58c5c0de061c4c79e4a5b6d86e57d9157","modified":1681708722993},{"_id":"themes/async/scripts/helper/index.js","hash":"bde383f098d69571eec6feca1539040ce132b820","modified":1681303558000},{"_id":"themes/async/scripts/helper/list_categories.js","hash":"57bcd21f608fd985a4c755a30e6b40ad91494f3e","modified":1681303558000},{"_id":"themes/async/scripts/helper/tag.js","hash":"0d9d369f95bdf916628132c7ca2452da63825741","modified":1681303558000},{"_id":"themes/async/scripts/tags/caniuse.js","hash":"ce50e901dfe8b556786c1ebde4639d632e88c9ea","modified":1681303558000},{"_id":"themes/async/scripts/tags/flink.js","hash":"b48daa4a9b70f616e7867b41badde830176f7e31","modified":1681303558000},{"_id":"themes/async/scripts/helper/toc.js","hash":"b2bb8f1c854a5bb9cb6a0cb82de1cab7e5ba681b","modified":1681303558000},{"_id":"themes/async/scripts/tags/imgs.js","hash":"611ea3c68d2ea8dfc5711b77b42183f65c0e0296","modified":1681303558000},{"_id":"themes/async/scripts/tags/gallery.js","hash":"81a6604d847199f12af569ebd512f1989c9660cb","modified":1681303558000},{"_id":"themes/async/source/img/logo.gif","hash":"e6dfe357f9f842e8bbfb2e3cda164b1f3f6cdea3","modified":1680586743994},{"_id":"themes/async/scripts/helper/list_archives.js","hash":"bfe4d871ca685d67cba73d824a3bbb8f610929b1","modified":1681303558000},{"_id":"themes/async/scripts/helper/variable.js","hash":"3a39eb9b05b4624d444fbf036597932e3f8d7728","modified":1681303558000},{"_id":"themes/async/layout/_third-party/cdn.ejs","hash":"964693a454808aa8277027ec3c5dda7f7af01255","modified":1681303558000},{"_id":"themes/async/layout/_third-party/sw.ejs","hash":"277f75522dffa7d985f3400f18b4f60861d2430d","modified":1681303558000},{"_id":"themes/async/layout/_third-party/plugin.ejs","hash":"1af7dac0d91366cc334be40aa78dec0c9a59158c","modified":1681303558000},{"_id":"themes/async/layout/_third-party/web-analytics.ejs","hash":"9ed8b2717075bb8f37d65580f1de586ebbb89bc1","modified":1681303558000},{"_id":"themes/async/source/js/main.js","hash":"4a1d985bda4b498c2324d88418de10fd3e7c1e84","modified":1681999881525},{"_id":"themes/async/layout/_partial/header.ejs","hash":"891be309ffcc21616f3c00690407fda625bb18ff","modified":1681303558000},{"_id":"themes/async/scripts/tags/tabs.js","hash":"2ff28bdaf5bf184208290be766e98ed18ca84780","modified":1681303558000},{"_id":"themes/async/source/img/logo.png","hash":"7ee8abc622b301f03a626012aacfe5bb44abdbdc","modified":1681466529561},{"_id":"themes/async/layout/_partial/script.ejs","hash":"6d9d5202a0eb36783505e77498ff54f85896f07e","modified":1681303558000},{"_id":"themes/async/layout/_partial/banner.ejs","hash":"86e4e68197bb1c63eb3800411867a71605e5437c","modified":1681871048516},{"_id":"themes/async/layout/_partial/footer.ejs","hash":"1f83454c48ac6cbcd076eab88d8d349c36e7dc98","modified":1681874611693},{"_id":"themes/async/layout/_widget/header_menu.ejs","hash":"c2efd3f4417b8f6f27caf86a8467903d73fcdc6d","modified":1681303558000},{"_id":"themes/async/layout/_partial/main.ejs","hash":"b96fbd7b839cb4f774cf332a7dd3ec4f3bd7bbb0","modified":1681469706965},{"_id":"themes/async/layout/_widget/categorie.ejs","hash":"634d10e2965f9b2cdd662eaaf8ee027814eb7ad1","modified":1681303558000},{"_id":"themes/async/layout/_widget/header_search.ejs","hash":"62a5a69f6206c224f037229968b2961f241eef2e","modified":1681303558000},{"_id":"themes/async/layout/_partial/head.ejs","hash":"78fc6ad5d53cf1f705fee9e3176c6dd3f93b4a20","modified":1681466808081},{"_id":"themes/async/layout/_widget/header_logo.ejs","hash":"2719b4f875d147893cad965204bc5cfe790c5727","modified":1681464768212},{"_id":"themes/async/layout/_widget/paginator.ejs","hash":"c7b76e443375b7d2bb15452b34ffcc654105db1f","modified":1681303558000},{"_id":"themes/async/layout/_widget/header_theme.ejs","hash":"330df0060a67e16d18cbd5b19e3d6857b87d3bf1","modified":1681709061771},{"_id":"themes/async/layout/_widget/search.ejs","hash":"573c500a4ecb65b822b3a34168dbcf446c92bc0f","modified":1681303558000},{"_id":"themes/async/source/fonts/webfonts/fa-regular-400.woff2","hash":"fbb0d9d51850d824d7eba66e0e210c778d6d42f5","modified":1681303558000},{"_id":"themes/async/source/css/_components/app-frame.less","hash":"8fc482822be50c6dd5fccd85a2f9b8f6ef9d3423","modified":1681303558000},{"_id":"themes/async/source/css/_components/blockquote.less","hash":"969d13d3e270b98287cfb1fc6ff0ca70dde480cc","modified":1681303558000},{"_id":"themes/async/source/css/_components/btn.less","hash":"4c1983d0899d133cff50c14f84cf5f834bb2c33c","modified":1681303558000},{"_id":"themes/async/layout/_widget/fixed-btn.ejs","hash":"76b2e9fb70272e7fb2759ca58c0f76715fa5acce","modified":1682001551364},{"_id":"themes/async/source/css/_components/card.less","hash":"7646cc3e11debfbf3d5186fa8470c88c0a6672dc","modified":1681303558000},{"_id":"themes/async/source/css/_components/banner.less","hash":"49be916c438e02e1a0430843e0cba704abb920e9","modified":1681303558000},{"_id":"themes/async/source/css/_components/base.less","hash":"4a5e380607970db240dbb8e3c404eef2cb80905e","modified":1681303558000},{"_id":"themes/async/source/css/_components/list.less","hash":"a28990af7f211d3c919fad8e4dbe45af77d3c97f","modified":1681303558000},{"_id":"themes/async/source/css/_components/form.less","hash":"8bcd9e7d094a7ddfcd617bed07da8f2ca1db93e9","modified":1681303558000},{"_id":"themes/async/source/css/_components/menu.less","hash":"9aee9cd92fb77e90a47c522e5a3504eb49b62a4e","modified":1681303558000},{"_id":"themes/async/source/css/_components/fixed-btn.less","hash":"3d99acd2624dee5b7debf0cef4b6a93f6c4f87ed","modified":1682000365525},{"_id":"themes/async/source/css/_components/index.less","hash":"9b29da29f4a5a737b61d1ef3b10ad56257f7806d","modified":1681303558000},{"_id":"themes/async/source/css/_components/footer.less","hash":"148b39349030a2c400887adc972594cf788b69eb","modified":1681303558000},{"_id":"themes/async/source/css/_components/preloader.less","hash":"01799e25f1f46adf890415b9ffa54d6faa8d6cf0","modified":1681303558000},{"_id":"themes/async/source/css/_components/pagination.less","hash":"c9fd513fe0b88bde7bed61d3125da0c89b2da70b","modified":1681303558000},{"_id":"themes/async/source/css/_components/message.less","hash":"e70983c10167cc08e7ea168d836b0788ac0edc5e","modified":1681303558000},{"_id":"themes/async/source/css/_components/publication.less","hash":"c78e60be25b4c4253a53e6f7b395089e4419d141","modified":1681303558000},{"_id":"themes/async/source/css/_components/timeline.less","hash":"6f97e97a214172402ea5a4547d6f71825424a5af","modified":1681303558000},{"_id":"themes/async/source/css/_components/title-divider.less","hash":"762448f365a4ff121f0cc0ede58b773916d4e9ee","modified":1681303558000},{"_id":"themes/async/source/css/_components/toc.less","hash":"c0dc5ad1b20054bf9243a2befc13c9f53734a02a","modified":1681303558000},{"_id":"themes/async/source/css/_components/mode-switcher.less","hash":"c232eee8a2b4f3b9f74e8664a8074c06d542e7c9","modified":1681697974104},{"_id":"themes/async/source/css/_components/video.less","hash":"862f3404abca726d1de29fbfc0034081ed417b4f","modified":1681303558000},{"_id":"themes/async/source/css/_components/tag-plugins.less","hash":"18f2265b80a57b722cf55180e93487d47af3e1ba","modified":1681303558000},{"_id":"themes/async/source/css/_variables/index.less","hash":"831bf5eb6f46eaff12ddd7542f52783dff511896","modified":1681303558000},{"_id":"themes/async/source/css/_components/top-bar.less","hash":"3b9ecd717d76fd334aa2e14bbbd0adfb753cf22b","modified":1681473460505},{"_id":"themes/async/source/css/plugins/locomotive-scroll.css","hash":"221f0205ccfc91a68b095f0d02c00e664e9ddf61","modified":1681303558000},{"_id":"themes/async/source/css/plugins/bootstrap.row.css","hash":"95c954c577f21e537229c4806419206e822eba04","modified":1681303558000},{"_id":"themes/async/layout/_third-party/comment/giscus.ejs","hash":"7ce3479ece958b829a8b9a2256f0db53ce1eeac8","modified":1681303558000},{"_id":"themes/async/source/css/plugins/font-awesome.min.css","hash":"6137a9883adce70d78c7f7bbe8af27d91b627d32","modified":1681303558000},{"_id":"themes/async/layout/_third-party/comment/b-comments.ejs","hash":"202aace17a9bd66cf82b15cdd52db4d8a5b04d28","modified":1681303558000},{"_id":"themes/async/source/js/plugins/typing.js","hash":"49e5af4f80da9bfd46a81495711822de87719656","modified":1681303589000},{"_id":"themes/async/layout/_third-party/comment/index.ejs","hash":"bac629e4c8d28cc16720c17d526e0b9fc7059be3","modified":1681303558000},{"_id":"themes/async/layout/_third-party/comment/twikoo.ejs","hash":"d8c022399cc7e4a48ea01276641388dde925aa5d","modified":1681303558000},{"_id":"themes/async/layout/_third-party/seo/baidu-push.ejs","hash":"2e3d405b5973c5ceed9cc24a5591240c0345cb94","modified":1681303558000},{"_id":"themes/async/layout/_partial/page/archive.ejs","hash":"cf3ebc04bf199bcf4b396f55c7270c81363f2698","modified":1681303558000},{"_id":"themes/async/layout/_partial/page/category.ejs","hash":"041a18d4d563349c0e3110f822d5e82ef6dc2c1a","modified":1681303558000},{"_id":"themes/async/source/js/plugins/local_search.js","hash":"18823ee20d0f09d2a925e3189a6458620636ee67","modified":1681303589000},{"_id":"themes/async/layout/_partial/page/project.ejs","hash":"5e143fa68e889c6e829d12f5a89b2d8979a32e46","modified":1681303558000},{"_id":"themes/async/layout/_partial/post/post-card.ejs","hash":"09e3037a9f67e47ddcd4c26d3f3b0dbdd0ef489b","modified":1681303558000},{"_id":"themes/async/layout/_partial/page/post.ejs","hash":"e715889490422b906bde47aeab080b6d08d66fee","modified":1681998671467},{"_id":"themes/async/layout/_partial/page/links.ejs","hash":"8548c51cc30dfa477b3ba144aae59ea5fee82602","modified":1681467804237},{"_id":"themes/async/layout/_partial/post/post-card-mini.ejs","hash":"170f8d60eb92e857520ad31ef8fa6f317c3b5170","modified":1681303558000},{"_id":"themes/async/layout/_partial/page/tag.ejs","hash":"7f278f929ff15d2ae843c8931dcd00cbf273cf59","modified":1681551976691},{"_id":"themes/async/layout/_partial/post/post-content.ejs","hash":"2cb43a1657dfcff799f67d8e06c31d4c9b571bca","modified":1681303558000},{"_id":"themes/async/layout/_partial/post/post-copyright.ejs","hash":"b7e4518edcdc719795c30ad325c410a49255471a","modified":1681303558000},{"_id":"themes/async/layout/_partial/post/post-next-prev.ejs","hash":"cbd221f3b36f652c80b3c0b0a14125243a13dd7c","modified":1681303558000},{"_id":"themes/async/layout/_partial/page/about.ejs","hash":"bb37db80049d49213cec87510b77870ab04f1d55","modified":1681551205898},{"_id":"themes/async/layout/_partial/preloader/page-preloader.ejs","hash":"a1ce51be9b477e146dcc3bb4fbe9628c1471969e","modified":1681303558000},{"_id":"themes/async/layout/_partial/post/post-info.ejs","hash":"980872eb767d5015f5bec52617cb74bdbcfbd976","modified":1681303558000},{"_id":"themes/async/layout/_partial/page/index.ejs","hash":"19d539a157993bd92ec61db15cf4f6c8fefbbe11","modified":1681469305502},{"_id":"themes/async/layout/_partial/sidebar/index.ejs","hash":"d94eefe8acb426c455bafea6be27a7fce6f4e127","modified":1681303558000},{"_id":"themes/async/layout/_partial/preloader/change-mode-preloader.ejs","hash":"8a6019defee71021eb9bd46549c8a4479546ec9d","modified":1681303558000},{"_id":"themes/async/layout/_partial/sidebar/card/email.ejs","hash":"d8ceed83ba3b0af7d361ca9254a62afd6e8f741e","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/index.less","hash":"9a465599006f7a3b0690f5c6f7032f1609fb7b9b","modified":1681998677220},{"_id":"themes/async/layout/_partial/sidebar/card/info.ejs","hash":"dfa5d015d7174ad02df0099dadfab3e35e85dd59","modified":1681303558000},{"_id":"themes/async/layout/_partial/sidebar/card/social.ejs","hash":"4543c52a486a87f718fcfe03b6ef59bd771759d5","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/comment/twikoo.less","hash":"f365099c5fcae37b4c0163c09d9a498aae61af44","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/comment/index.less","hash":"157debbb5fbf62389dc49a8998c8ee13da526335","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/fancybox/index.less","hash":"f2286a1158475425b8715979c4ae7d90d206c438","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/search/index.less","hash":"7f57003ebd89d50a4e6a8a4c6636bcd129e22eed","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/search/search.less","hash":"306d1dd8a24b36c3ed602a6e03e6ba0370722d70","modified":1681303558000},{"_id":"themes/async/layout/_partial/sidebar/card/toc.ejs","hash":"1a82facc6d08f12811783c6d6cc7ad565d859cb6","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/highlight/minix.less","hash":"5b7def3a700ef357a53c2660a22b22ee30727596","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/highlight/index.less","hash":"77897529e46022ea46a5c352622fac891ba0c406","modified":1681303558000},{"_id":"themes/async/layout/_partial/sidebar/card/user.ejs","hash":"b3545aabecc0128d67c34e8238158a796fd2b7dd","modified":1681709901972},{"_id":"themes/async/source/css/_components/plugins/comment/bcomments.less","hash":"d387268ed3486bf66db9243114d55ac974b73fb1","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/read-mode/index.less","hash":"ba5c0ec35a657fd1d37ef11637e9d11c1ef37fc6","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/read-mode/single-column.less","hash":"5589661bf35cd6c5bc08a9005edbf95906bcf178","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/highlight/highlight/index.less","hash":"552296ca563930093a85290f84316bbb76821175","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/read-mode/read-mode.less","hash":"687dd581162d5e35e0d871fbc6392a7cadc4ecb9","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/highlight/highlight/diff.less","hash":"3879fa32f66d23b74c6e6dd016f58ea1eff4d39c","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/highlight/prismjs/line-number.less","hash":"b5e9230948a1cdf0dc198498ee6694c26f26b88e","modified":1681303558000},{"_id":"source/_posts/webpack升级/webpack4-1.png","hash":"cc0440d9a8144d3e53f968b4e6d47f3d379feb5b","modified":1681098650749},{"_id":"themes/async/source/css/_components/plugins/highlight/prismjs/diff.less","hash":"3b6f63fa0c8f033219aa2cc6e6bd9e33a0a8ab81","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/highlight/prismjs/index.less","hash":"d2411c499a7b83284c71655574063c14bbbe5fce","modified":1681303558000},{"_id":"themes/async/source/css/_components/plugins/highlight/theme.less","hash":"a967c2857811320bdf85e701a8efc06bac048c60","modified":1681303558000},{"_id":"themes/async/source/img/avatar.png","hash":"6ef7a5685ca2673674b8a05f56e4dc9b035d1172","modified":1680586738023},{"_id":"themes/async/source/fonts/webfonts/fa-solid-900.woff2","hash":"80644191098f863f25be27841c0d92c452cf2327","modified":1681303558000},{"_id":"themes/async/source/failure.png","hash":"7d7831b6543b74d02495eac225c5d8676aadf8c8","modified":1681461048763},{"_id":"themes/async/source/fonts/webfonts/fa-brands-400.woff2","hash":"f988b2efe9434b0af28943708d33dd3afad9a5ba","modified":1681303558000},{"_id":"themes/async/source/css/plugins/bootstrap.min.css","hash":"b6f019002b87e86a07275eacd3c35a13c378b5c3","modified":1681303558000},{"_id":"themes/async/source/img/favicon.png","hash":"8158fd674040de3e86c067129aa20ab9093db1bb","modified":1681461184804},{"_id":"source/_posts/webpack升级/webpack4-3.png","hash":"cc5bdc0bdee450f2ec3f06bf9a0db4891b059f06","modified":1681111902207},{"_id":"themes/async/source/img/banner.png","hash":"afd02b8d6283b137687944cd7dcad3dd5b177425","modified":1680594065644},{"_id":"public/search.xml","hash":"eccdd06363ef0ef92a4cbd2d278529c69bab297d","modified":1682049932580},{"_id":"public/categories/index.html","hash":"48f2352a8009fbf7bb6028d05bed0969a12ea0e7","modified":1682049932580},{"_id":"public/about/index.html","hash":"9a2ec4af04267bd9aeb6c2321899fd552a44e637","modified":1682049932580},{"_id":"public/2023/04/13/开发hexo主题记录/index.html","hash":"02516b49d29dfdb297b0a08445e637fe73ae1912","modified":1682049932580},{"_id":"public/tags/index.html","hash":"8a8fae1738fb27ba70c90af90677366fca57b015","modified":1682049932580},{"_id":"public/read/index.html","hash":"738ed43cefba26b3069a503689f8cd5b5e8917d9","modified":1682049932580},{"_id":"public/2023/04/12/Vue项目遇到问题/index.html","hash":"78bb2a2c0287acb4cdbbca0a7e6838ad2e8ff0f9","modified":1682049932580},{"_id":"public/2023/04/11/模块化/index.html","hash":"70ebb0555f9a60b1c5a704f987a771282ee7513f","modified":1682049932580},{"_id":"public/2023/04/11/vue-cropper/index.html","hash":"f5fa5f5fd531d6aa3cc03ba22188adc1443fad15","modified":1682049932580},{"_id":"public/2023/04/10/Vue项目SEO优化-Nuxt/index.html","hash":"071eb09d18d55c37c1306d51f0ac71e6156778cb","modified":1682049932580},{"_id":"public/2023/04/05/Vuex的namespaced属性/index.html","hash":"36099b953727e1dd7f08318f875c1f8a2432fcb9","modified":1682049932580},{"_id":"public/2023/04/05/Pinia与Vuex 的区别/index.html","hash":"ead2cfd6eb80b7e7e29b0a081c256033f09f023a","modified":1682049932580},{"_id":"public/2023/04/05/Vuex/index.html","hash":"65bdb0aa8b6fc48b8945bb99b933527bdd6ca3b8","modified":1682049932580},{"_id":"public/2023/04/05/Vue-搜索引擎SEO优化/index.html","hash":"ca30be76406b0c5519cc11086e623dc4585bee15","modified":1682049932580},{"_id":"public/2023/04/05/webpack升级/index.html","hash":"415c374638cbd56a47eb87a5eb5c719e165fdf30","modified":1682049932580},{"_id":"public/2023/04/03/性能优化/index.html","hash":"0da7620267d52550b78b55a8f8f70588360171e6","modified":1682049932580},{"_id":"public/links/index.html","hash":"840b171c325054e4c8d29c3bab897473c0c31024","modified":1682049932580},{"_id":"public/2023/03/29/webpack迁移vite/index.html","hash":"9e2d7203098dfac23c2a3fdcfa9b29d188b5ef66","modified":1682049932580},{"_id":"public/2023/03/27/Vue-Cli/index.html","hash":"27b5839d471aa9638afff2be964adee43daee35e","modified":1682049932580},{"_id":"public/2023/03/27/微前端/index.html","hash":"a0a0bdfa2115db6e734c62c2341af3411b61f4b9","modified":1682049932580},{"_id":"public/2023/03/29/微前端-qiankun/index.html","hash":"d4aaf169fbaa97bd1216bdd87c978e03e12ab610","modified":1682049932580},{"_id":"public/2023/03/21/数组，对象遍历的用法总结/index.html","hash":"2aa59676ba7a5507ce7675aa0ce1391483d1d815","modified":1682049932580},{"_id":"public/2023/03/13/serve的区别/index.html","hash":"ed6ce9683791741859f4bf0cf2449bd9a562ad2e","modified":1682049932580},{"_id":"public/2023/01/10/vue3新语法细节/index.html","hash":"2c2cce46af0ee9c5f1a574d03264fb6d96e0650a","modified":1682049932580},{"_id":"public/2023/03/23/component动态组件/index.html","hash":"05c2490104c3f531720326c5bb1afd7678bff7ae","modified":1682049932580},{"_id":"public/2022/12/19/Vue-axios/index.html","hash":"19c19a44b6474d1383350059e485d3d679d72862","modified":1682049932580},{"_id":"public/2022/12/08/Hooks/index.html","hash":"95c2d2f7a5b90728971e14c16803e686a1ce4c8e","modified":1682049932580},{"_id":"public/2022/10/25/vue3-hooks使用/index.html","hash":"915e77d2a96eeead62eef4c8a8fb3976d7c03551","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/index.html","hash":"79df1373cbf0b80d19ab49ddbd8b43f593148d96","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/index.html","hash":"c9f5602c3cae14ff4b3ae0a8d457970ac313fa1e","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/index.html","hash":"093bee1aef7d26df00a1394fef698d6e429d2aa7","modified":1682049932580},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/index.html","hash":"cea7b9271d4a3c24b4d7266febbbb6b8674a9a15","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/index.html","hash":"bc7891e2774519978fd287d26cfb1154bb0918c1","modified":1682049932580},{"_id":"public/2022/10/17/Vue3计算属性/index.html","hash":"2c10641ea42acefa0f3facd245eaa49940f689ae","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/index.html","hash":"e348358674e0c46e799395e2f5bf56492ae41fc9","modified":1682049932580},{"_id":"public/2022/10/10/vue3/index.html","hash":"89915aa8ce2b1569f6282b8b8563f948d2a58951","modified":1682049932580},{"_id":"public/2022/09/30/跨域/index.html","hash":"9f6281143a913919cd7f07c65c76c6200c873a4e","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/index.html","hash":"6bd81bbde115b03ba1922a65544d7712668a964e","modified":1682049932580},{"_id":"public/2022/08/30/webpack/index.html","hash":"ecdad5842d8c4116ba9725c32dfc40286d33ae11","modified":1682049932580},{"_id":"public/2022/08/16/博客搭建/index.html","hash":"f575282fdcb291935ddb86d694fdf61951259fef","modified":1682049932580},{"_id":"public/2022/08/25/深浅拷贝/index.html","hash":"c64d80a6f6af4bb9f983004a26beb47a11fba2eb","modified":1682049932580},{"_id":"public/categories/vue3/index.html","hash":"4d03ce8fd5329f2bd1900d8987e4802559c48675","modified":1682049932580},{"_id":"public/categories/vue3/page/2/index.html","hash":"fed000aa522a439a9f544d51dda7356a32a92403","modified":1682049932580},{"_id":"public/categories/Vue/index.html","hash":"f5399d48ad88bb8f0cc11404e5e8bd86baea072e","modified":1682049932580},{"_id":"public/categories/知识点/index.html","hash":"33a349100f3a224209410f5119bafbe7248592b2","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/index.html","hash":"da8291cff9f50019d90b456c9d4860eb62cf2acf","modified":1682049932580},{"_id":"public/categories/知识点/page/2/index.html","hash":"a354326db84feca550fe75012cc3fa1a692f9aa0","modified":1682049932580},{"_id":"public/categories/性能优化/index.html","hash":"0b18d6bcb540e2ee15672b23c743444405f00e3e","modified":1682049932580},{"_id":"public/categories/webpack/index.html","hash":"c1a6df7813a4a12bcc8c2d92e2d69ea998d1ab74","modified":1682049932580},{"_id":"public/categories/工具/index.html","hash":"bac371e94467b4713fa1622056c1fa39269ab961","modified":1682049932580},{"_id":"public/index.html","hash":"a03c19b427cef70d2803c7feb25a18f493ddb452","modified":1682049932580},{"_id":"public/page/2/index.html","hash":"a88a3799bb3e8828ccd8b8eb3a31911d88cfad60","modified":1682049932580},{"_id":"public/categories/模块化/index.html","hash":"00fde3d74f1ead7e157fa7bae967395c3a2b9f6b","modified":1682049932580},{"_id":"public/categories/JavaScript/index.html","hash":"8a5976fd6188fddf1d57d09f982f49b92c904202","modified":1682049932580},{"_id":"public/page/3/index.html","hash":"4f708ad9d7218b91225113ad8bcab777aa3e7c48","modified":1682049932580},{"_id":"public/page/4/index.html","hash":"2dd1ab22c87cf4cac2540c41174e695df219884c","modified":1682049932580},{"_id":"public/archives/index.html","hash":"ddbf37c0595c361d72b8c9f644dc126323de49c2","modified":1682049932580},{"_id":"public/archives/page/2/index.html","hash":"8a68eea4dc6a65be22edc293061292e6b6c5e5b4","modified":1682049932580},{"_id":"public/archives/page/3/index.html","hash":"6c3545b0bf090b09ebd40f6e2fd10a3665f873de","modified":1682049932580},{"_id":"public/archives/page/4/index.html","hash":"8807c396fd0c98b58e7b0ffbc5fe2ab7a36c578b","modified":1682049932580},{"_id":"public/archives/2022/index.html","hash":"0dc00585f8659c3df2f9238150ebc9b556c8cd0b","modified":1682049932580},{"_id":"public/archives/2022/08/index.html","hash":"936a6adc5dff66848c07a027e950fc80b8f1e988","modified":1682049932580},{"_id":"public/archives/2022/09/index.html","hash":"6da6534c504de2aa512ba9c6495136a3c0b6b444","modified":1682049932580},{"_id":"public/archives/2022/page/2/index.html","hash":"964ef46980044efa99ac7660ed79ab4f5d4fea1a","modified":1682049932580},{"_id":"public/archives/2022/10/index.html","hash":"1e8b7f48f99aac9dacd9f44116cba6e0fa5f0dc1","modified":1682049932580},{"_id":"public/archives/2022/12/index.html","hash":"9f2de17d9a58c9dd074268c195d095af9f611b59","modified":1682049932580},{"_id":"public/archives/2022/10/page/2/index.html","hash":"9391e1165115729a91700eaffdf4541c342e71fe","modified":1682049932580},{"_id":"public/archives/2023/page/2/index.html","hash":"f77b7f54680f7cce74414eaf7cddb971e8c97f6f","modified":1682049932580},{"_id":"public/archives/2023/page/3/index.html","hash":"13dc18f351097aabba568667a2fb65d7748d4ecf","modified":1682049932580},{"_id":"public/archives/2023/index.html","hash":"7fb715c6a38da32fee548eb5e6604427cef36643","modified":1682049932580},{"_id":"public/archives/2023/03/index.html","hash":"454fd0c4b7244ea0061908b71c0a661855534f2f","modified":1682049932580},{"_id":"public/archives/2023/04/index.html","hash":"43996931ddbe4f7107d26ed8e969140399154cdb","modified":1682049932580},{"_id":"public/archives/2023/01/index.html","hash":"d759df494518d79fba41336730f70579c222eee8","modified":1682049932580},{"_id":"public/archives/2023/04/page/2/index.html","hash":"94353dbde66ea922b5dd1bd6f3dac0de50f2e997","modified":1682049932580},{"_id":"public/tags/vue3/index.html","hash":"060ed0199c56b27acdc85b562abdb0d261028db0","modified":1682049932580},{"_id":"public/tags/vue3/page/2/index.html","hash":"b24c54048e2b3530b2c5679b0e4c921f58820706","modified":1682049932580},{"_id":"public/tags/Vuex/index.html","hash":"8e83c427bcd2b816d954a992c157c7e7a896b7f3","modified":1682049932580},{"_id":"public/tags/Webpack/index.html","hash":"2483123af82f1881283571a8c583f3499b716cb4","modified":1682049932580},{"_id":"public/tags/vue/index.html","hash":"5dc59bf0284fa17ff47b1d499c3ca4450e7896a6","modified":1682049932580},{"_id":"public/tags/Vue/index.html","hash":"56c9cd2d756bd4764d2226676b10c65ebb8b1025","modified":1682049932580},{"_id":"public/tags/vue-cropper/index.html","hash":"5cb0d36bd59429fddf9a37d2d350f4ab67004de9","modified":1682049932580},{"_id":"public/tags/webpack/index.html","hash":"53f42e4255ce8b6e0397cf2a6ffe7b841dc92168","modified":1682049932580},{"_id":"public/tags/搭建博客/index.html","hash":"86693320ce6e884440da076edee89c06c27f16dc","modified":1682049932580},{"_id":"public/tags/hexo/index.html","hash":"ff6988aeacdbc0e347ce65e88b7f8466c56e9776","modified":1682049932580},{"_id":"public/tags/微前端/index.html","hash":"bb33fea03398cba0f7b78e97bcd5729264707729","modified":1682049932580},{"_id":"public/tags/JavaScript/index.html","hash":"66930784756bacf6d0b59df0d61218fc23fd7057","modified":1682049932580},{"_id":"public/tags/模块化/index.html","hash":"9797b35040203d9de13105bbd72a6e54ed8c159b","modified":1682049932580},{"_id":"public/tags/深浅拷贝/index.html","hash":"eed69fc76471160e8d9bdea83c61cb6f2b222cfc","modified":1682049932580},{"_id":"public/tags/跨域/index.html","hash":"c94663fa9d02cd71d948448264fb5637d85b535b","modified":1682049932580},{"_id":"public/images/defaultimg7.png","hash":"7ad0d95b5ca4faae504863caa48a7e06675ec8b5","modified":1682049932580},{"_id":"public/images/logo.gif","hash":"e6dfe357f9f842e8bbfb2e3cda164b1f3f6cdea3","modified":1682049932580},{"_id":"public/images/icon.png","hash":"cb821203c6eea9e37b33f1069d0326e3d329617c","modified":1682049932580},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1682049932580},{"_id":"public/img/logo.gif","hash":"e6dfe357f9f842e8bbfb2e3cda164b1f3f6cdea3","modified":1682049932580},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1682049932580},{"_id":"public/fonts/webfonts/fa-regular-400.woff2","hash":"fbb0d9d51850d824d7eba66e0e210c778d6d42f5","modified":1682049932580},{"_id":"public/img/block.jpg","hash":"1dd350354bd3fe2e7287dfe063d7783e4ab91090","modified":1682049932580},{"_id":"public/img/logo.png","hash":"7ee8abc622b301f03a626012aacfe5bb44abdbdc","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/被点击.png","hash":"08aa117a094790f49408b0072342fa89b4202050","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/安装.png","hash":"b35c38aa5fd70dfbf973a8ecdde913b9fb0f26f8","modified":1682049932580},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowRef代码结果.png","hash":"fd9d5456f4fa5912e8e256c65cfb582e77cd8467","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图13代码1.png","hash":"7a1368e06c525c2e034dc39142bf844215e99a72","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图14代码.png","hash":"6b88eac576b98e1a0c97c37be505a2357c37a8d2","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图1结果.png","hash":"602355bda5c4ba049b2b60ba7127b34643e7f15a","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一结果.png","hash":"2c6bd0186ff6e9afe79cc3be6285ebce50004974","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/多个侦听器代码.png","hash":"b6b5ce0a312074c007ca6c87951768a90b2914cd","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref源数据.png","hash":"b0b445fedbc9be175e7039adbc9e601b941e5792","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/截屏2022-10-17 上午11.27.38.png","hash":"9b77eec67a3fb63a4cabdc29e11105b44eb39b6b","modified":1682049932580},{"_id":"public/2022/10/17/Vue3计算属性/案例二.png","hash":"bca10286752f9a3b70042c26480727bca5366cbc","modified":1682049932580},{"_id":"public/2022/10/17/Vue3计算属性/引入.png","hash":"fc352bb0212ecb4617ba425d65c88c0f0e81bb7e","modified":1682049932580},{"_id":"public/2022/10/17/Vue3计算属性/计算属性求和.png","hash":"3403abc4b3d832e185d1b6602bdfa745a6cf3e70","modified":1682049932580},{"_id":"public/2022/08/25/深浅拷贝/深浅拷贝结果.png","hash":"624d55ea479daf8bcadae7ccbfda13bf0ad17fb0","modified":1682049932580},{"_id":"public/images/defaultimg1.png","hash":"c4375e1feb053b6d910ebfca9904110c89cf8fef","modified":1682049932580},{"_id":"public/images/defaultimg3.png","hash":"a247996c42bb0feb567a9ed76d664de64a6636b6","modified":1682049932580},{"_id":"public/images/defaultcover.png","hash":"2380411ace59c88218585a66898afff8c408a91d","modified":1682049932580},{"_id":"public/images/cover.png","hash":"7583ffb21f077fe577d7f5370b8c0647bbc4121c","modified":1682049932580},{"_id":"public/images/logo.png","hash":"6ef7a5685ca2673674b8a05f56e4dc9b035d1172","modified":1682049932580},{"_id":"public/images/piniacover.png","hash":"aaea7fed1e454cbd650a85c181eb5ea09d55c71b","modified":1682049932580},{"_id":"public/images/vueclicover.png","hash":"3372e0ea2f01ca4bd60e2ff907c9d05c65a35706","modified":1682049932580},{"_id":"public/images/vuexcover.png","hash":"291dffb1c147a6caa33e48772eef469aa8be0446","modified":1682049932580},{"_id":"public/failure.png","hash":"7d7831b6543b74d02495eac225c5d8676aadf8c8","modified":1682049932580},{"_id":"public/img/avatar.png","hash":"6ef7a5685ca2673674b8a05f56e4dc9b035d1172","modified":1682049932580},{"_id":"public/fonts/webfonts/fa-solid-900.woff2","hash":"80644191098f863f25be27841c0d92c452cf2327","modified":1682049932580},{"_id":"public/fonts/webfonts/fa-brands-400.woff2","hash":"f988b2efe9434b0af28943708d33dd3afad9a5ba","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/基本变量.png","hash":"b63521e989cac21dec73a6a0da721d3ab03ec044","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/名称渲染失败.png","hash":"8ac8f3f2485d1000771164a86e07cdebcfdcd57a","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/name.png","hash":"b707a7fca8686ac90273234bbc914025085ab45c","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/点击代码.png","hash":"5e515ea203ff32f9079b05c4896d421f341fbff5","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/渲染成功.png","hash":"fb63b176ea1fffce2891c61087b95465af4868cd","modified":1682049932580},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowRef代码.png","hash":"5d8dc074bb0e0ded665af5d195dfc2c50f8bb31c","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/indexts.png","hash":"8fd0b5d11e9d40dc24ede704ea6da047febbc9ad","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图12结果.png","hash":"906013a2fc77c1765c242f82aa8381f783325c37","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11结果1.png","hash":"29749e46e1cdc7c73c671cbb22f006087a91abd0","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11结果2.png","hash":"661a128e4433b159d68b13fe236e034ac9d06550","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图1代码.png","hash":"75e9d7b5009d2fc31abb56fb8b32b4aa02509119","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图2结果.png","hash":"4c6d26bc1876bbc2104a572d580bffecc38d81a0","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图16结果2.png","hash":"2c70beda971e4bb00b1e3113b0a06dfab5eb3943","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图3结果2.png","hash":"06e73c74a04b9800a008496966a3ba7ed566dec9","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图6代码1.png","hash":"748bc17657ce5095cb54750266367126d289982d","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图3结果1.png","hash":"3cdc82239094f7501a406b74e88a96eae09c42e7","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图6结果1.png","hash":"5c41e4182f85564c4423eb1e9e3ea7d54eddc5ef","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图7代码1.png","hash":"d06e170e0c788538fedc9db212c71010173ddf21","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图6结果2.png","hash":"52ac61cbd93d036519c8fc4db19c370b57951f9d","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图7结果1.png","hash":"08076158cf4abb9ebf08df4b708005d1a91facaa","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图7结果2.png","hash":"4e3c93ba6f79b3a1d6a3661f055e752890af7ba4","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/reactive代码.png","hash":"733615b731fc230b906fe3f86ee50ff92248fe03","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs解决代码.png","hash":"1f605f0d5a6d9ddfab7934b0f399dc46f3f81527","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs使用正常.png","hash":"8db8aa94bb3b5a8200e96359df504f46b23015a3","modified":1682049932580},{"_id":"public/sw.js","hash":"01b07120762ab155c99478afb36075d4d7e2bc9c","modified":1682049932580},{"_id":"public/css/plugins/bootstrap.row.css","hash":"95c954c577f21e537229c4806419206e822eba04","modified":1682049932580},{"_id":"public/js/plugins/typing.js","hash":"49e5af4f80da9bfd46a81495711822de87719656","modified":1682049932580},{"_id":"public/js/plugins/local_search.js","hash":"18823ee20d0f09d2a925e3189a6458620636ee67","modified":1682049932580},{"_id":"public/css/plugins/locomotive-scroll.css","hash":"221f0205ccfc91a68b095f0d02c00e664e9ddf61","modified":1682049932580},{"_id":"public/css/plugins/bootstrap.min.css","hash":"b6f019002b87e86a07275eacd3c35a13c378b5c3","modified":1682049932580},{"_id":"public/css/plugins/font-awesome.min.css","hash":"6137a9883adce70d78c7f7bbe8af27d91b627d32","modified":1682049932580},{"_id":"public/js/main.js","hash":"4a1d985bda4b498c2324d88418de10fd3e7c1e84","modified":1682049932580},{"_id":"public/2023/04/10/Vue项目SEO优化-Nuxt/服务端渲染.png","hash":"7366a775890a80e2e82e0f3d6dddf4be7ab10227","modified":1682049932580},{"_id":"public/2023/04/10/Vue项目SEO优化-Nuxt/客户端渲染.png","hash":"1fc822d916c2fa882bb4a7a3a2fba1c189f1e183","modified":1682049932580},{"_id":"public/2022/10/25/vue3-hooks使用/案例3.png","hash":"e09d51e285963ee2d4ae41a68ddb4c76ceef621d","modified":1682049932580},{"_id":"public/2022/10/25/vue3-hooks使用/案例1.png","hash":"41a9ed7307a5ce4974ce055eb2e1aec4ab38eeed","modified":1682049932580},{"_id":"public/2022/10/25/vue3-hooks使用/案例2.png","hash":"c947267b51513a52ee79dda20bb8b7baa65c1e1b","modified":1682049932580},{"_id":"public/2023/04/05/Vuex/vuex.png","hash":"0577c82e34c8edc82bcdcadb98d4e832b1cb5fab","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive数组处理结果.png","hash":"ab8274bde10d8e21feb91c9802d6179e5bccf62a","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例6.png","hash":"55b29aea1b417c1f15ae0bf897fd764188256158","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive对象代码.png","hash":"aaf3b834c26a34ea0f2de6d0998f502d337953db","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref基本修改成功.png","hash":"ceb47ae8580ab75ea06fd3a49c66af2072a4e868","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref基本出错.png","hash":"89635c08525515948e4b701e8e168f606fff583d","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref复杂数据代码.png","hash":"0024dcd4878f05c8b732c156890bdae8839731b6","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref成功.png","hash":"7a233c69bc9cfa196d7d263578ef9197e4598a76","modified":1682049932580},{"_id":"public/images/defaultimg4.png","hash":"21068c09489df9ab4235063458721a25c2b6cd45","modified":1682049932580},{"_id":"public/images/defaultimg2.png","hash":"c9039014de71f5ce489c6644c95ad6a5eae5b893","modified":1682049932580},{"_id":"public/images/default.png","hash":"b655c32f8e557434f7faf0862521909a481d3fb8","modified":1682049932580},{"_id":"public/images/defaultimg.png","hash":"72cdebd7da697f56f672e8e172f3c70ea0c4693b","modified":1682049932580},{"_id":"public/images/defaultimg5.png","hash":"9d584d702b84209f2b6983565e545685da7d4916","modified":1682049932580},{"_id":"public/images/defaultimg6.png","hash":"45fc80e0596db5a2bacdf5e13c72b3be0e898b23","modified":1682049932580},{"_id":"public/images/性能优化cover.png","hash":"ad9b1986dabe5cf82f420de00e43a41db75e1203","modified":1682049932580},{"_id":"public/images/vueseocover.png","hash":"56645dee8c31cd790e404554f7d77cdf395a746d","modified":1682049932580},{"_id":"public/2022/12/08/Hooks/案例1.png","hash":"868897c58cb1fd3493ab0a2e876ee893983fdf3c","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/基本数据类型.png","hash":"14aa8ce4abcacbe2eab03b648c8eaf7d4d0e5ccc","modified":1682049932580},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowReactive一代码结果.png","hash":"460433078d58c9de4ad54624975cc1e6d562b66d","modified":1682049932580},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowRef二代码结果.png","hash":"162d280234dad815826b1f9f2225f3f55802f91d","modified":1682049932580},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowRef二代码.png","hash":"1a00d0d541d828513b6603ba56ec15b3a7c46448","modified":1682049932580},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowReactive一代码.png","hash":"2384d4018de330b2c14cabebd069bc7c806ab037","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11代码2.png","hash":"7198042e761f1e68a47ad1f9fbf5a683736ae8d8","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图10代码.png","hash":"1395fd458a42a930c62ff3ed9ca8667db3cf120e","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图10结果.png","hash":"87d3a51ace6ec0a9eebbfd938e00cce00965092d","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11代码.png","hash":"2ff59f992a8f17c65dad9a369925e7df7b80409d","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11代码1.png","hash":"3ec7af117e340f99ddac1d8586a3cee26f9bb8a4","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图13代码2.png","hash":"f98f2379f7c4f556be5f5e9b56f0e19a63102b93","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图13结果2.png","hash":"78bb5044555f9d23733854c1c97ded2d2e5ee1a2","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图13结果1.png","hash":"40a3ffe728c745eea28d33e28a6f48051422c103","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图14结果1.png","hash":"2a6e36d09632bd34d61ebc6736c57b8c18bc8100","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图15代码.png","hash":"84dfe56a7e0020a1412adbb9a78ae77f272cc166","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图14结果2.png","hash":"60426c2088b76e54196495c373a04d7035192ce3","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图16结果1.png","hash":"73cb06309c246eca61f38a77a5d336e7fc244804","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图2代码.png","hash":"21d9715a07655174901ed7fa05e92153f21a0318","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图3代码.png","hash":"1bb7dfdcc7fb102c1624f03173784c89c7e470e4","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图5代码.png","hash":"fa51f7613db86bdc4e9ee6d3e3e6353e6ec12f6e","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图4代码.png","hash":"de9e43926f49e658ac346c7b5f591c69283642bf","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图7代码2.png","hash":"919b9d4b0b77d4f9391b459e9659d1473a5e8165","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图6代码2.png","hash":"b089d26856bee996ce18a2708b66fa7fb84099f1","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图9代码.png","hash":"2b5df9557f9f5c9272757b1974d8515693b97251","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图8代码.png","hash":"fe050cc1abc7053ad0e5c6d199f33cc18d9b642c","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一代码.png","hash":"aee51e5ce07b91827da3c4ceb02e06f22e104094","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图9结果.png","hash":"1696b4942ef8cbc881e72638877c882f2c0d404d","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一数据更新代码.png","hash":"8c8cab41984a0ba050a74ad3d08bdafadb78217d","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一控制台.png","hash":"f4513cd9a342bf2705efaeb6f185a701da422d8d","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图8结果.png","hash":"e7aee55a51c443f0c2ae02a6d9da924a45231c74","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器三代码.png","hash":"5428081fe08ea11be13415e87e0c919a4064a46f","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器二代码.png","hash":"b0ad55721871383c18be9eca918260c5e0c84649","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器二修改代码.png","hash":"743dbbf2ec1250918c07b89a2a6f96157a4be45b","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器监听reactive代码.png","hash":"fdee0cf863b6c1e83d4992b4ed83750484ebccd8","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器三修改代码.png","hash":"7f386d5c6812c789ff065e17d6f23acea95bbd3e","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听多个参数.png","hash":"e67f0b79227b4eb618c86f42c590cd0bb66686f6","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs使用代码.png","hash":"4546360c27c51682347024e74fb608348ed026de","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs使用结果.png","hash":"afad00887f811bbbeda91e16efe49c6c225bca5b","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref代码.png","hash":"243d4d9ca586000df96c11df26d4ccb3a4dd133e","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/ref函数验证代码.png","hash":"06b57eec559530274780610467c6185af5189486","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/原始数据代码.png","hash":"77aedb1e69bc73ff51201eb308ac8214711cf53c","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref修改代码.png","hash":"d2d1bb4ab19341a958738d24f2ab79be6a2938f3","modified":1682049932580},{"_id":"public/2023/04/10/Vue项目SEO优化-Nuxt/nuxt渲染.png","hash":"57cb4c2a26642ed3c055bf2dd4810a0aea1beed0","modified":1682049932580},{"_id":"public/2022/10/17/Vue3计算属性/案例一.png","hash":"7a6a042bf4e2e9698ef031a0bf754805abf5d66b","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例11.png","hash":"00fb54237ad8674adf0fe9a9886ad0ab12cd7140","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例12.png","hash":"92c620cd017cc7962917b0990a84d396e2edf77c","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例23.png","hash":"376426f6680c28e8a963cd0aa50d729e86cbd41e","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例3.png","hash":"84df433ef9450983bc6c71613f3ac01ffac88285","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive修改代码.png","hash":"050308b60afb877775da196bb9856864dcb95e9a","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例5.png","hash":"792504cf4e2e6b87009b591a8a190f327c7af420","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive对象修改结果.png","hash":"304b185a453096c60f6bc15b70a03c1e17499ab9","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive数组代码.png","hash":"a93b6d0fabf13f74f0a8cacaec4f717635b4165d","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/refdom代码.png","hash":"d554724f5dfe1f8552762b6b05bfc94d5b1ac1a9","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref修改代码.png","hash":"94d645e54beecb5a81bcf0c220155d82c0cfda3f","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref基本数据类型代码.png","hash":"fb11e49f6916cafa290d6a38bf280c9ff82ed1bc","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref复杂修改代码.png","hash":"054e88cf5c25e8bac9cf48acd7ed2b39a05981af","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref复杂修改代码成功.png","hash":"08ebd64d3de3343d66c318aa43352d08ff71345f","modified":1682049932580},{"_id":"public/2023/03/29/微前端-qiankun/defaultPic.png","hash":"72cdebd7da697f56f672e8e172f3c70ea0c4693b","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/子组件三代码.png","hash":"aad7ee1be4d85c10ac39a76070b3089fe2f4ec76","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/子组件二代码.png","hash":"e64bef83b37d6bc0a3551955edb4ca6bf222f430","modified":1682049932580},{"_id":"public/images/namespacedcover.png","hash":"979a6da75d683defc9f47bfe4740d2d4ba1aaea0","modified":1682049932580},{"_id":"public/images/webpackcover.png","hash":"e5514b2cbf696f470ff07e5629d26e01ac591811","modified":1682049932580},{"_id":"public/images/迁移vitecover.png","hash":"cf0a1a06376ceb0e506be001353009979715d13b","modified":1682049932580},{"_id":"public/img/favicon.png","hash":"8158fd674040de3e86c067129aa20ab9093db1bb","modified":1682049932580},{"_id":"public/2022/12/08/Hooks/案例2.png","hash":"74b00eebdf721ace661d5a699d5b636935c3e654","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/复杂数据类型.png","hash":"043c0d8faed707cd2a24922078d1ce7bc41f5d11","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/提示找不到.png","hash":"77541a000deff4521d4819fdbab7d2cb8f0b44bc","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图12代码.png","hash":"60c8cd99311bd5350a1281fbcf9b21a2a376ee4c","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图15结果2.png","hash":"03cea55f66253ed27722a0557392ee5971ae633b","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图16代码.png","hash":"099fe0b855e49d6b6edf4314bf92b3fb13c6e6f1","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图17代码.png","hash":"bc6478049274440c36ce42656644c6992d7f8077","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图15结果1.png","hash":"0f02b5e18b02dfa18bd2ed30c11c32b12583213f","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器二修改结果.png","hash":"9d1db9108cd46fc48764fc971d22158633de580a","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref打印body代码.png","hash":"951b46e871a6a1106eb942d67c02cef438b7afdc","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例1.png","hash":"3749c2bc0a424c59dc316ffb8e0510dc1b3847cf","modified":1682049932580},{"_id":"public/2023/03/13/serve的区别/npm区别.png","hash":"0df40dee128dd7245a783544b56e69930450f567","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例10.png","hash":"b9e08f7edc34dd6002b5289140b170f2ea2a4ff6","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例13.png","hash":"b72f3b1639e3e6e240397459b138f234e7731f10","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例14.png","hash":"a447452e694c2df7c9654e6152100b8d3ae777fb","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例2.png","hash":"ac45a3b4102467c1661c004290592b5d3079d35e","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例15.png","hash":"30db8e13899164e1e246da2d0214852772bcc2f3","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例7.png","hash":"0f4d27fb25d283beee04662a5b35b20545770fd7","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref基本控制台.png","hash":"791cc971a4d69f5fc87568f6834312180abcb4ea","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref打印.png","hash":"37e9af7e01bb74f3a6dc89ff6d3cf85303670556","modified":1682049932580},{"_id":"public/2023/04/05/webpack升级/webpack5-1.png","hash":"31aabcba2010bceaec485ff41a60a2016e97cdf7","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/传值前结果.png","hash":"a38dabf08a04fc0bcc222c9556cd03206b83a7cd","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/传值后结果.png","hash":"833aa748bd0e3d8a8e51e1ec2f6d726cd269ee8c","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/父组件二代码.png","hash":"a4b00c42a7da2d0469d17cfe925da35186210aee","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/父组件三代码.png","hash":"1f8caea6ab3214aaa2f25a584449d39a573cd2c9","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/父组件代码.png","hash":"34be2541e55ce25a0fb2ad42f2e895d9d8d1f9ae","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/子组件代码.png","hash":"ef8853dad1c2a331a27401ce273378d8f1210783","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/祖孙结果.png","hash":"c1cff8de7aad8dadab9a032812f1a856d33b700a","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/基本数据代码.png","hash":"afb3efec654604c5b0c323213c66b735aca08028","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一数据更新.png","hash":"ecc5fde8517d62bc391f4ca2c5cbdd34ad8b805a","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器三修改结果.png","hash":"cfc6fbc9153515388e84b5450cd41dfa1d0c275c","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器三报错.png","hash":"e3cf54e20af42c647cf70bb10b8af17f78fb416f","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/数据源结果.png","hash":"0d52c3a41f898ae79c961c1c8bb2ca23a8535073","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例22.png","hash":"02f636d85da47984a2ec2860a6c664289d57040a","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例4.png","hash":"d119b34723578142c2cdd06fccc13b1fb53457b0","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref复杂结构.png","hash":"685333b144015b074af204a7d3bdec8689466702","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref结构.png","hash":"c6720f7d16db079b3294d891f3c6fb4ccb1a28ed","modified":1682049932580},{"_id":"public/images/defaultbgurl.png","hash":"afd02b8d6283b137687944cd7dcad3dd5b177425","modified":1682049932580},{"_id":"public/2022/12/08/Hooks/案例3.png","hash":"c901570618e6953c64d13a679ea0de943644eb31","modified":1682049932580},{"_id":"public/img/banner.png","hash":"afd02b8d6283b137687944cd7dcad3dd5b177425","modified":1682049932580},{"_id":"public/2022/10/13/Vue3setup函数/复杂数据代码.png","hash":"d8108e61fcede23fe8b9448ec9e9b84ca3da2c7c","modified":1682049932580},{"_id":"public/images/qiankuncover.png","hash":"ab3ae22a566749ab7a26b0a4bca847dc4ff41aab","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器二警告.png","hash":"b9338963991e5acee941245f5ec14f713282b086","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/torefbody打印结果.png","hash":"500ade02277e28c474db944ec81f7d431e74a610","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例16.png","hash":"a47301b5384927cc8ea0732aec08691824e70beb","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例17.png","hash":"4946ce1dbfde314a97281cd87b255dc885018083","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例19.png","hash":"d7ae2edaea2d3fc2e444e20cbbeef9373083791d","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例18.png","hash":"0b7a7ab71f0abc719726b990eba397ca86adde87","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听多个参数结果.png","hash":"913b47f951bf57d60c5fbecb648bd5ad1c5f6a2b","modified":1682049932580},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器监听reactive结果.png","hash":"880ed1c8fdb504f757f75c7b4e8198fdefce6b37","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs使用控制台信息.png","hash":"8d85ef57adbf571c12d510dcebb9d57b4780f962","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref修改结果.png","hash":"77574d2b1b504b0258b096b9c706cc4ec0b86fbe","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例20.png","hash":"386c78383d07d79f62f4fe1862f7dbc64b3bbdc9","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例21.png","hash":"654ec1438a18111df14f4e7a1973d46e733adc72","modified":1682049932580},{"_id":"public/2023/04/05/webpack升级/webpack4.png","hash":"55503ae940964fa0a834f8d4eb35ca0291e00c6a","modified":1682049932580},{"_id":"public/2023/04/05/webpack升级/webpack4-2.png","hash":"a7376309820143ae28155c4a54db282b5a8596de","modified":1682049932580},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive对象结果.png","hash":"1e3d9f9787839ffc062cd7622661ef1a2332f9f4","modified":1682049932580},{"_id":"public/2022/12/13/vue3API/案例9.png","hash":"3c4b30a0d297cb7f773f1ce7705fe4e0e7adf524","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref页面成功.png","hash":"a8256b128a9d7f9ffb1c85a1ef755c13e0204bef","modified":1682049932580},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/ref函数验证结果.png","hash":"80ec19fd6debdd3a6fb186dddda2d5bbece3605d","modified":1682049932580},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图17结果.png","hash":"6b79e742db256737f7c9b18e9040ee445f9ec13a","modified":1682049932580},{"_id":"public/2022/10/20/vue3组件传值/子传父结果.png","hash":"5eb0fea3922366bba2cc46da6c840413a59e252d","modified":1682049932580},{"_id":"public/2023/04/05/webpack升级/webpack4-1.png","hash":"cc0440d9a8144d3e53f968b4e6d47f3d379feb5b","modified":1682049932580},{"_id":"public/2023/04/05/webpack升级/webpack4-3.png","hash":"cc5bdc0bdee450f2ec3f06bf9a0db4891b059f06","modified":1682049932580},{"_id":"public/css/index.css","hash":"d680512f5a06275d4c36c5e913c6a82d869d995c","modified":1682049932580}],"Category":[{"name":"vue3","_id":"clgq13ml00004tit8fta0gst9"},{"name":"Vue","_id":"clgq13ml2000ctit8317ehxlo"},{"name":"知识点","_id":"clgq13ml3000itit893rna69j"},{"name":"性能优化","_id":"clgq13ml5000xtit85prq7gjg"},{"name":"webpack","_id":"clgq13ml9002dtit8f43p3tvl"},{"name":"工具","_id":"clgq13mla002ntit889hrhl59"},{"name":"JavaScript","_id":"clgq13mlb0033tit8cwbxdirh"},{"name":"模块化","_id":"clgq13mlc003btit8gayb9emy"}],"Data":[{"_id":"languages","data":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}],"Page":[{"title":"关于","date":"2022-08-15T16:00:00.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2022-08-16\nlayout: about\n---\n","updated":"2023-04-04T14:36:05.228Z","path":"about/index.html","comments":1,"_id":"clgq13mkw0000tit8gaa12fmd","content":"","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":""},{"title":"文章分类","date":"2022-08-15T16:00:00.000Z","layout":"category","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2022-08-16\nlayout: category\n---\n","updated":"2023-04-04T10:02:00.473Z","path":"categories/index.html","comments":1,"_id":"clgq13mkz0002tit8d8oh84s0","content":"","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":""},{"title":"友情链接","date":"2022-08-15T16:00:00.000Z","type":"links","layout":"links","comments":0,"_content":"","source":"links/index.md","raw":"---\ntitle: 友情链接\ndate: 2022-08-16\ntype: links\nlayout: links\ncomments: false\n---","updated":"2023-04-04T07:15:11.326Z","path":"links/index.html","_id":"clgq13ml00006tit88p39hvbz","content":"","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":""},{"title":"标签","date":"2022-08-16T13:47:07.000Z","layout":"tag","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-08-16 21:47:07\nlayout: tag\n---\n","updated":"2023-04-04T10:01:52.370Z","path":"tags/index.html","comments":1,"_id":"clgq13ml10008tit8ake504ve","content":"","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":""},{"title":"read","date":"2022-08-16T13:47:07.000Z","_content":"","source":"read/index.md","raw":"---\ntitle: read\ndate: 2022-08-16 21:47:07\n---\n","updated":"2023-04-03T05:24:33.695Z","path":"read/index.html","comments":1,"layout":"page","_id":"clgq13ml2000atit8acc1fxj1","content":"","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":""}],"Post":[{"title":"Hooks","date":"2022-12-08T13:22:28.000Z","_content":"# 1、为什么要封装 Hooks ？\n众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。\n我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。\n## 你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\n这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。\n但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。\n## 哪什么是Hooks封装呢？\nHooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。\n# 2、如何封装 Hooks 呢？\n首先我们要在setup 组合的开发模式下，\n然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，\n提取到一个以 use* 开头的自定义函数中去。\n## 把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？\n其一享受到封装带来的便利性，还有利于代码逻辑的复用。\n其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。\n# 3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：\n一种是功能类Hooks，即为了逻辑复用的封装；\n另一种是业务类Hooks，即为了逻辑解耦的封装。\n下面我给两组代码，说明这两种使用场景。\n# 4、示例：功能类 Hooks封装\n![](案例1.png)\n# 5、示例：业务类 Hooks封装\n![](案例2.png)\n## 封装Hooks不能为了封装而封装。要考虑以下几点：\n1. 是否有复用的价值？\n2. 是否有利于逻辑的分离？\n3. 是否有助提升代码的可阅读性和可维护性？\n\n\n\n\n","source":"_posts/Hooks.md","raw":"---\ntitle: Hooks\ndate: 2022-12-08 21:22:28\ntags: vue3\ncategories: vue3\n---\n# 1、为什么要封装 Hooks ？\n众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。\n我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。\n## 你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\n这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。\n但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。\n## 哪什么是Hooks封装呢？\nHooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。\n# 2、如何封装 Hooks 呢？\n首先我们要在setup 组合的开发模式下，\n然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，\n提取到一个以 use* 开头的自定义函数中去。\n## 把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？\n其一享受到封装带来的便利性，还有利于代码逻辑的复用。\n其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。\n# 3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：\n一种是功能类Hooks，即为了逻辑复用的封装；\n另一种是业务类Hooks，即为了逻辑解耦的封装。\n下面我给两组代码，说明这两种使用场景。\n# 4、示例：功能类 Hooks封装\n![](案例1.png)\n# 5、示例：业务类 Hooks封装\n![](案例2.png)\n## 封装Hooks不能为了封装而封装。要考虑以下几点：\n1. 是否有复用的价值？\n2. 是否有利于逻辑的分离？\n3. 是否有助提升代码的可阅读性和可维护性？\n\n\n\n\n","slug":"Hooks","published":1,"updated":"2023-03-22T06:12:44.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13mkx0001tit86mx57cfq","content":"<h1 id=\"1、为什么要封装-Hooks-？\"><a href=\"#1、为什么要封装-Hooks-？\" class=\"headerlink\" title=\"1、为什么要封装 Hooks ？\"></a>1、为什么要封装 Hooks ？</h1><p>众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。<br>我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。</p>\n<h2 id=\"你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\"><a href=\"#你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\" class=\"headerlink\" title=\"你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\"></a>你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？</h2><p>这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。<br>但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。</p>\n<h2 id=\"哪什么是Hooks封装呢？\"><a href=\"#哪什么是Hooks封装呢？\" class=\"headerlink\" title=\"哪什么是Hooks封装呢？\"></a>哪什么是Hooks封装呢？</h2><p>Hooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。</p>\n<h1 id=\"2、如何封装-Hooks-呢？\"><a href=\"#2、如何封装-Hooks-呢？\" class=\"headerlink\" title=\"2、如何封装 Hooks 呢？\"></a>2、如何封装 Hooks 呢？</h1><p>首先我们要在setup 组合的开发模式下，<br>然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，<br>提取到一个以 use* 开头的自定义函数中去。</p>\n<h2 id=\"把它封装在以use-开头的Hooks函数中，有什么样的好处呢？\"><a href=\"#把它封装在以use-开头的Hooks函数中，有什么样的好处呢？\" class=\"headerlink\" title=\"把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？\"></a>把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？</h2><p>其一享受到封装带来的便利性，还有利于代码逻辑的复用。<br>其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。</p>\n<h1 id=\"3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：\"><a href=\"#3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：\" class=\"headerlink\" title=\"3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：\"></a>3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：</h1><p>一种是功能类Hooks，即为了逻辑复用的封装；<br>另一种是业务类Hooks，即为了逻辑解耦的封装。<br>下面我给两组代码，说明这两种使用场景。</p>\n<h1 id=\"4、示例：功能类-Hooks封装\"><a href=\"#4、示例：功能类-Hooks封装\" class=\"headerlink\" title=\"4、示例：功能类 Hooks封装\"></a>4、示例：功能类 Hooks封装</h1><p><img src=\"/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"5、示例：业务类-Hooks封装\"><a href=\"#5、示例：业务类-Hooks封装\" class=\"headerlink\" title=\"5、示例：业务类 Hooks封装\"></a>5、示例：业务类 Hooks封装</h1><p><img src=\"/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h2 id=\"封装Hooks不能为了封装而封装。要考虑以下几点：\"><a href=\"#封装Hooks不能为了封装而封装。要考虑以下几点：\" class=\"headerlink\" title=\"封装Hooks不能为了封装而封装。要考虑以下几点：\"></a>封装Hooks不能为了封装而封装。要考虑以下几点：</h2><ol>\n<li>是否有复用的价值？</li>\n<li>是否有利于逻辑的分离？</li>\n<li>是否有助提升代码的可阅读性和可维护性？</li>\n</ol>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"1、为什么要封装-Hooks-？\"><a href=\"#1、为什么要封装-Hooks-？\" class=\"headerlink\" title=\"1、为什么要封装 Hooks ？\"></a>1、为什么要封装 Hooks ？</h1><p>众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。<br>我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。</p>\n<h2 id=\"你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\"><a href=\"#你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\" class=\"headerlink\" title=\"你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\"></a>你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？</h2><p>这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。<br>但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。</p>\n<h2 id=\"哪什么是Hooks封装呢？\"><a href=\"#哪什么是Hooks封装呢？\" class=\"headerlink\" title=\"哪什么是Hooks封装呢？\"></a>哪什么是Hooks封装呢？</h2><p>Hooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。</p>\n<h1 id=\"2、如何封装-Hooks-呢？\"><a href=\"#2、如何封装-Hooks-呢？\" class=\"headerlink\" title=\"2、如何封装 Hooks 呢？\"></a>2、如何封装 Hooks 呢？</h1><p>首先我们要在setup 组合的开发模式下，<br>然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，<br>提取到一个以 use* 开头的自定义函数中去。</p>\n<h2 id=\"把它封装在以use-开头的Hooks函数中，有什么样的好处呢？\"><a href=\"#把它封装在以use-开头的Hooks函数中，有什么样的好处呢？\" class=\"headerlink\" title=\"把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？\"></a>把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？</h2><p>其一享受到封装带来的便利性，还有利于代码逻辑的复用。<br>其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。</p>\n<h1 id=\"3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：\"><a href=\"#3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：\" class=\"headerlink\" title=\"3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：\"></a>3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：</h1><p>一种是功能类Hooks，即为了逻辑复用的封装；<br>另一种是业务类Hooks，即为了逻辑解耦的封装。<br>下面我给两组代码，说明这两种使用场景。</p>\n<h1 id=\"4、示例：功能类-Hooks封装\"><a href=\"#4、示例：功能类-Hooks封装\" class=\"headerlink\" title=\"4、示例：功能类 Hooks封装\"></a>4、示例：功能类 Hooks封装</h1><p><img src=\"/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B1.png\"></p>\n<h1 id=\"5、示例：业务类-Hooks封装\"><a href=\"#5、示例：业务类-Hooks封装\" class=\"headerlink\" title=\"5、示例：业务类 Hooks封装\"></a>5、示例：业务类 Hooks封装</h1><p><img src=\"/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B2.png\"></p>\n<h2 id=\"封装Hooks不能为了封装而封装。要考虑以下几点：\"><a href=\"#封装Hooks不能为了封装而封装。要考虑以下几点：\" class=\"headerlink\" title=\"封装Hooks不能为了封装而封装。要考虑以下几点：\"></a>封装Hooks不能为了封装而封装。要考虑以下几点：</h2><ol>\n<li>是否有复用的价值？</li>\n<li>是否有利于逻辑的分离？</li>\n<li>是否有助提升代码的可阅读性和可维护性？</li>\n</ol>\n"},{"title":"Pinia 与 Vuex 的区别","date":"2023-04-05T11:58:26.000Z","cover":["/images/piniacover.png"],"banner":{"type":"img","bgurl":["/images/piniacover.png"]},"_content":"# 两者区别\n1. Vuex的核心概念有state,getters,mutations,actions,moudles五个部分\nPinia的核心概念有state,getter,action三个部分\n1.2 mutation 已被弃用。它们经常被认为是极其冗余的\n1.3不再有嵌套结构的moudles，store的命名取决于它的定义方式，实现一种扁平架构\n2. Vuex对state的修改推荐使用mutations中的方法进行修改,\nPinia直接对state进行修改\n3. Pinia中 getter，action 也可通过 this 访问整个 store 实例\n# main.js中\n在main.js中，vuecli会自动将vuex挂载到app上，使用vite需要自己手动挂载pinia\n```js\nimport { createPinia } from 'pinia'  \nconst pinia = createPinia();  \napp.use(pinia);\n```\n# store/index.js中\nvuex有state,getter,mutation,action,moudle五个部分\n```js\nimport { createStore } from 'vuex'\nimport { receiveMessagePerson } from './modules/receiveMessagePerson'\nexport default createStore({\n  state: {\n    memberOrAdmin: \"member\",\n    searchPerson: []\n  },\n  getters: {\n  },\n  mutations: {\n    setMemberOrAdmin(context, data){\n      context.memberOrAdmin = data\n    },\n  },\n  actions: {\n    getPerson(context){\n      let userId = context.state.PersonId\n      API.getAllInformation({userId}).then(res => {\n        context.commit('setPerson',res.data)\n      }).catch(err => {\n        console.log(err);\n      })\n    }\n  },\n  modules: {\n    receiveMessagePerson\n  }\n})\n```\nPinia有state,getter,action三个部分\n```js\nimport { defineStore } from \"pinia\";\nexport const useTestStore = defineStore('Test', {\n  state(){\n    return{\n      cuont: 0\n    }\n  },\n  getters: {\n    double(state){\n      return state.cuont*2\n    }\n  },\n  actions: {\n    increase(){\n      this.cuont++\n    }\n  }\n})\n```\n# 在vue组件中\n## vuex\nvue2中：\n```js\nthis.$store.***\n```\nvue3中：\n```js\nimport { useStore } from 'vuex'\nlet store = useStore()\nlet *** = computed(() => store.state.***)\nstore.commit('**', **)\nstore.dispatch('**', **)\n```\n## vuex拆解\nvue2中：\n使用到mapState,mapGetter,mapMutations,mapActions方法,[_post/Vuex的namespaced属性.md]\nvue3中：\n## Pinia\n```js\nimport { useTestStore } from '../store/index';\nlet store = useTestStore()\nstore.**(state变量名)\nstore.**(getters变量名)\nstore.**(actions方法名)\n```\n省去了state,getters,commit,dispatch这些字段，更方便\n## Pinia拆解\n用到storeToRefs\n```js\nimport { storeToRefs } from 'pinia';\n   // state和getters的变量都可以拆解出来\nlet { **, ** } = storeToRefs(store) \n// actions的方法拆解出来\nlet { ** } = store                   \n```","source":"_posts/Pinia与Vuex 的区别.md","raw":"---\ntitle: Pinia 与 Vuex 的区别\ndate: 2023-04-05 19:58:26\ntags: Vuex\ncategories: Vue\ncover: [/images/piniacover.png]\nbanner: \n  type: img\n  bgurl: [/images/piniacover.png]\n---\n# 两者区别\n1. Vuex的核心概念有state,getters,mutations,actions,moudles五个部分\nPinia的核心概念有state,getter,action三个部分\n1.2 mutation 已被弃用。它们经常被认为是极其冗余的\n1.3不再有嵌套结构的moudles，store的命名取决于它的定义方式，实现一种扁平架构\n2. Vuex对state的修改推荐使用mutations中的方法进行修改,\nPinia直接对state进行修改\n3. Pinia中 getter，action 也可通过 this 访问整个 store 实例\n# main.js中\n在main.js中，vuecli会自动将vuex挂载到app上，使用vite需要自己手动挂载pinia\n```js\nimport { createPinia } from 'pinia'  \nconst pinia = createPinia();  \napp.use(pinia);\n```\n# store/index.js中\nvuex有state,getter,mutation,action,moudle五个部分\n```js\nimport { createStore } from 'vuex'\nimport { receiveMessagePerson } from './modules/receiveMessagePerson'\nexport default createStore({\n  state: {\n    memberOrAdmin: \"member\",\n    searchPerson: []\n  },\n  getters: {\n  },\n  mutations: {\n    setMemberOrAdmin(context, data){\n      context.memberOrAdmin = data\n    },\n  },\n  actions: {\n    getPerson(context){\n      let userId = context.state.PersonId\n      API.getAllInformation({userId}).then(res => {\n        context.commit('setPerson',res.data)\n      }).catch(err => {\n        console.log(err);\n      })\n    }\n  },\n  modules: {\n    receiveMessagePerson\n  }\n})\n```\nPinia有state,getter,action三个部分\n```js\nimport { defineStore } from \"pinia\";\nexport const useTestStore = defineStore('Test', {\n  state(){\n    return{\n      cuont: 0\n    }\n  },\n  getters: {\n    double(state){\n      return state.cuont*2\n    }\n  },\n  actions: {\n    increase(){\n      this.cuont++\n    }\n  }\n})\n```\n# 在vue组件中\n## vuex\nvue2中：\n```js\nthis.$store.***\n```\nvue3中：\n```js\nimport { useStore } from 'vuex'\nlet store = useStore()\nlet *** = computed(() => store.state.***)\nstore.commit('**', **)\nstore.dispatch('**', **)\n```\n## vuex拆解\nvue2中：\n使用到mapState,mapGetter,mapMutations,mapActions方法,[_post/Vuex的namespaced属性.md]\nvue3中：\n## Pinia\n```js\nimport { useTestStore } from '../store/index';\nlet store = useTestStore()\nstore.**(state变量名)\nstore.**(getters变量名)\nstore.**(actions方法名)\n```\n省去了state,getters,commit,dispatch这些字段，更方便\n## Pinia拆解\n用到storeToRefs\n```js\nimport { storeToRefs } from 'pinia';\n   // state和getters的变量都可以拆解出来\nlet { **, ** } = storeToRefs(store) \n// actions的方法拆解出来\nlet { ** } = store                   \n```","slug":"Pinia与Vuex 的区别","published":1,"updated":"2023-04-11T05:48:36.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13mkz0003tit86x0t1cvp","content":"<h1 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h1><ol>\n<li>Vuex的核心概念有state,getters,mutations,actions,moudles五个部分<br>Pinia的核心概念有state,getter,action三个部分</li>\n<li>2 mutation 已被弃用。它们经常被认为是极其冗余的</li>\n<li>3不再有嵌套结构的moudles，store的命名取决于它的定义方式，实现一种扁平架构</li>\n<li>Vuex对state的修改推荐使用mutations中的方法进行修改,<br>Pinia直接对state进行修改</li>\n<li>Pinia中 getter，action 也可通过 this 访问整个 store 实例<h1 id=\"main-js中\"><a href=\"#main-js中\" class=\"headerlink\" title=\"main.js中\"></a>main.js中</h1>在main.js中，vuecli会自动将vuex挂载到app上，使用vite需要自己手动挂载pinia<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createPinia &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pinia&#x27;</span>  </span><br><span class=\"line\"><span class=\"keyword\">const</span> pinia = <span class=\"title function_\">createPinia</span>();  </span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(pinia);</span><br></pre></td></tr></table></figure>\n<h1 id=\"store-index-js中\"><a href=\"#store-index-js中\" class=\"headerlink\" title=\"store/index.js中\"></a>store/index.js中</h1>vuex有state,getter,mutation,action,moudle五个部分<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; receiveMessagePerson &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./modules/receiveMessagePerson&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">createStore</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">memberOrAdmin</span>: <span class=\"string\">&quot;member&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">searchPerson</span>: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setMemberOrAdmin</span>(<span class=\"params\">context, data</span>)&#123;</span><br><span class=\"line\">      context.<span class=\"property\">memberOrAdmin</span> = data</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getPerson</span>(<span class=\"params\">context</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> userId = context.<span class=\"property\">state</span>.<span class=\"property\">PersonId</span></span><br><span class=\"line\">      <span class=\"variable constant_\">API</span>.<span class=\"title function_\">getAllInformation</span>(&#123;userId&#125;).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        context.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setPerson&#x27;</span>,res.<span class=\"property\">data</span>)</span><br><span class=\"line\">      &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">modules</span>: &#123;</span><br><span class=\"line\">    receiveMessagePerson</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\nPinia有state,getter,action三个部分<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defineStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;pinia&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> useTestStore = <span class=\"title function_\">defineStore</span>(<span class=\"string\">&#x27;Test&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"title function_\">state</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">      <span class=\"attr\">cuont</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">double</span>(<span class=\"params\">state</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">cuont</span>*<span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">increase</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">cuont</span>++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"在vue组件中\"><a href=\"#在vue组件中\" class=\"headerlink\" title=\"在vue组件中\"></a>在vue组件中</h1><h2 id=\"vuex\"><a href=\"#vuex\" class=\"headerlink\" title=\"vuex\"></a>vuex</h2>vue2中：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.***</span><br></pre></td></tr></table></figure>\nvue3中：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = <span class=\"title function_\">useStore</span>()</span><br><span class=\"line\"><span class=\"keyword\">let</span> *** = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> store.<span class=\"property\">state</span>.***)</span><br><span class=\"line\">store.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;**&#x27;</span>, **)</span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(<span class=\"string\">&#x27;**&#x27;</span>, **)</span><br></pre></td></tr></table></figure>\n<h2 id=\"vuex拆解\"><a href=\"#vuex拆解\" class=\"headerlink\" title=\"vuex拆解\"></a>vuex拆解</h2>vue2中：<br>使用到mapState,mapGetter,mapMutations,mapActions方法,[_post/Vuex的namespaced属性.md]<br>vue3中：<h2 id=\"Pinia\"><a href=\"#Pinia\" class=\"headerlink\" title=\"Pinia\"></a>Pinia</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useTestStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../store/index&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = <span class=\"title function_\">useTestStore</span>()</span><br><span class=\"line\">store.**(state变量名)</span><br><span class=\"line\">store.**(getters变量名)</span><br><span class=\"line\">store.**(actions方法名)</span><br></pre></td></tr></table></figure>\n省去了state,getters,commit,dispatch这些字段，更方便<h2 id=\"Pinia拆解\"><a href=\"#Pinia拆解\" class=\"headerlink\" title=\"Pinia拆解\"></a>Pinia拆解</h2>用到storeToRefs<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; storeToRefs &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pinia&#x27;</span>;</span><br><span class=\"line\">   <span class=\"comment\">// state和getters的变量都可以拆解出来</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; **, ** &#125; = <span class=\"title function_\">storeToRefs</span>(store) </span><br><span class=\"line\"><span class=\"comment\">// actions的方法拆解出来</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; ** &#125; = store                   </span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h1><ol>\n<li>Vuex的核心概念有state,getters,mutations,actions,moudles五个部分<br>Pinia的核心概念有state,getter,action三个部分</li>\n<li>2 mutation 已被弃用。它们经常被认为是极其冗余的</li>\n<li>3不再有嵌套结构的moudles，store的命名取决于它的定义方式，实现一种扁平架构</li>\n<li>Vuex对state的修改推荐使用mutations中的方法进行修改,<br>Pinia直接对state进行修改</li>\n<li>Pinia中 getter，action 也可通过 this 访问整个 store 实例<h1 id=\"main-js中\"><a href=\"#main-js中\" class=\"headerlink\" title=\"main.js中\"></a>main.js中</h1>在main.js中，vuecli会自动将vuex挂载到app上，使用vite需要自己手动挂载pinia<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createPinia &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pinia&#x27;</span>  </span><br><span class=\"line\"><span class=\"keyword\">const</span> pinia = <span class=\"title function_\">createPinia</span>();  </span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(pinia);</span><br></pre></td></tr></table></figure>\n<h1 id=\"store-index-js中\"><a href=\"#store-index-js中\" class=\"headerlink\" title=\"store/index.js中\"></a>store/index.js中</h1>vuex有state,getter,mutation,action,moudle五个部分<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; receiveMessagePerson &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./modules/receiveMessagePerson&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">createStore</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">memberOrAdmin</span>: <span class=\"string\">&quot;member&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">searchPerson</span>: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setMemberOrAdmin</span>(<span class=\"params\">context, data</span>)&#123;</span><br><span class=\"line\">      context.<span class=\"property\">memberOrAdmin</span> = data</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getPerson</span>(<span class=\"params\">context</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> userId = context.<span class=\"property\">state</span>.<span class=\"property\">PersonId</span></span><br><span class=\"line\">      <span class=\"variable constant_\">API</span>.<span class=\"title function_\">getAllInformation</span>(&#123;userId&#125;).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        context.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setPerson&#x27;</span>,res.<span class=\"property\">data</span>)</span><br><span class=\"line\">      &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">modules</span>: &#123;</span><br><span class=\"line\">    receiveMessagePerson</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\nPinia有state,getter,action三个部分<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defineStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;pinia&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> useTestStore = <span class=\"title function_\">defineStore</span>(<span class=\"string\">&#x27;Test&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"title function_\">state</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">      <span class=\"attr\">cuont</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">double</span>(<span class=\"params\">state</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">cuont</span>*<span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">increase</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">cuont</span>++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"在vue组件中\"><a href=\"#在vue组件中\" class=\"headerlink\" title=\"在vue组件中\"></a>在vue组件中</h1><h2 id=\"vuex\"><a href=\"#vuex\" class=\"headerlink\" title=\"vuex\"></a>vuex</h2>vue2中：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.***</span><br></pre></td></tr></table></figure>\nvue3中：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = <span class=\"title function_\">useStore</span>()</span><br><span class=\"line\"><span class=\"keyword\">let</span> *** = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> store.<span class=\"property\">state</span>.***)</span><br><span class=\"line\">store.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;**&#x27;</span>, **)</span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(<span class=\"string\">&#x27;**&#x27;</span>, **)</span><br></pre></td></tr></table></figure>\n<h2 id=\"vuex拆解\"><a href=\"#vuex拆解\" class=\"headerlink\" title=\"vuex拆解\"></a>vuex拆解</h2>vue2中：<br>使用到mapState,mapGetter,mapMutations,mapActions方法,[_post/Vuex的namespaced属性.md]<br>vue3中：<h2 id=\"Pinia\"><a href=\"#Pinia\" class=\"headerlink\" title=\"Pinia\"></a>Pinia</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useTestStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../store/index&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = <span class=\"title function_\">useTestStore</span>()</span><br><span class=\"line\">store.**(state变量名)</span><br><span class=\"line\">store.**(getters变量名)</span><br><span class=\"line\">store.**(actions方法名)</span><br></pre></td></tr></table></figure>\n省去了state,getters,commit,dispatch这些字段，更方便<h2 id=\"Pinia拆解\"><a href=\"#Pinia拆解\" class=\"headerlink\" title=\"Pinia拆解\"></a>Pinia拆解</h2>用到storeToRefs<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; storeToRefs &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;pinia&#x27;</span>;</span><br><span class=\"line\">   <span class=\"comment\">// state和getters的变量都可以拆解出来</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; **, ** &#125; = <span class=\"title function_\">storeToRefs</span>(store) </span><br><span class=\"line\"><span class=\"comment\">// actions的方法拆解出来</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; ** &#125; = store                   </span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"基于Webpack5搭建一个Vue-Cli","date":"2023-03-27T13:30:26.000Z","cover":["/images/vueclicover.png"],"banner":{"type":"img","bgurl":["/images/vueclicover.png"]},"_content":"大家平时在进行Vue开发的时候，大部分人都是使用 Vue-cli 这个现成的Vue脚手架来进行开发的，但是用它用了这么久，你难道不想自己搭一个属于自己的 Vue-cli 吗？\n\n# 1、建一个文件夹\n新建一个文件夹my-vue-cli用来存放项目\n# 2、初始化npm\n在终端中输入 npm init\n然后一直回车就行，这样能使项目拥有一个npm管理环境，之后可以在此环境上安装我们所需要的包\n# 3、webpack、webpack-cli\n安装 webpack、webpack-cli\nwebpack ：打包的工具\nwebpack-cli ：为webpack提供命令行的工具\nnpm i webpack webpack-cli -D\n# 4、src、public\n在根目录下新建 src、public 这两个文件夹，前者用来放置项目主要代码，后者用来放项目公用静态资源\n```\npublic/index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>my-vue-cli</title>\n</head>\n<body>\n<div id=\"app\"></div>\n</body>\n</html>\n```\n```\nsrc/main.js\nimport { add } from './tools/add.js'\nconsole.log(add(1, 2))\nconsole.log('我是main.js')\n```\n```\nsrc/tools/add.js\nexport const add = (a, b) => {\nreturn a + b\n}\n```\n# 5、入口文件\n刚刚的 main.js 就是我们的入口文件，也就相当于整个引用树的根节点，webpack打包需要从入口文件开始查找，一直到打包所有引用文件。\n进行入口文件的配置，在根目录下新建 webpack.config.js ：\n```\nconst path = require('path')\nmodule.exports = {\n  // 模式 开发模式\n  mode: 'development',\n  // 入口文件 main.js\n  entry: {\n    main: './src/main.js'\n  },\n  // 输出\n  output: {\n    // 输出到 dist文件夹\n    path: path.resolve(__dirname, './dist'),\n    // js文件下\n    filename: 'js/chunk-[contenthash].js',\n    // 每次打包前自动清除旧的dist\n    clean: true,\n  }\n}\n```\n# 6、配置打包命令\n到 package.json 里配置打包命令：\n```\n\"scripts\": {\n    \"build\": \"webpack\"\n},\n```\n现在我们到终端输入 npm run build ，就能发现打包成功：\n但是这其实不是我们要的目的，我们的目的是将这个打包后的最终js文件，插入到刚刚的 index.html 中，因为js文件得让html文件引用，才有意义嘛！所以我们不仅要打包js，还要打包html\n小知识：loader和plugin\nloader ：使webpack拥有解析非js文件的能力，如css、png、ts等等\nplugin ：拓展webpack的打包功能，如优化体积、显示进度条等等\n\n# 7、打包html\n打包html需要用到 html-webpack-plugin 这个插件，也就是plugin，所以需要安装一下：\nnpm i html-webpack-plugin -D\n并且需要在 webpack.config.js 中配置一下\n```\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  // 刚刚的代码...\n  // 插件都放 plugins 中\n  plugins: [\n    new HtmlWebpackPlugin({\n      // 选择模板 public/index.html\n      template: './public/index.html',\n      // 打包后的名字\n      filename: 'index.html',\n      // js文件插入 body里\n      inject: 'body',\n    }),\n  ]\n}\n```\n现在我们可以在终端中执行打包命令 npm run build 可以看到html被打包了，且打包后的html自动引入打包后的js文件\n现在我们可以打开打包后的 index.html ，发现控制台可以输出，说明成功了！\n## 打包CSS\n在 src 下新建 styles 文件夹，用来存放样式文件文件src/styles/index.scss\n```\nbody {\nbackground-color: blue;\n}\n```\n然后我们在入口文件 main.js 中引入\nimport './styles/index.scss'\n// 刚刚的代码...\n我们的目的是，打包 index.scss 这个文件，并且让 index.html 自动引入打包后的css文件，所以我们需要安装以下几个东 \nsass、sass-loader ：可以将scss代码转成css\ncss-loader ：使webpack具有打包css的能力\nsass-resources-loader ：可选，支持打包全局公共scss文件\nmini-css-extract-plugin ：可将css代码打包成一个单独的css文件\n我们安装一下这些插件\nnpm i sass sass-loader sass-resources-loader mini-css-extract-plugin -D\n然后配置一下 webpack.config.js\n```\n// 刚才的代码...\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nmodule.exports = {\n  // 刚才的代码...\n  plugins: [\n    // 刚才的代码...\n    new MiniCssExtractPlugin({\n      // 将css代码输出到dist/styles文件夹下\n      filename: 'styles/chunk-[contenthash].css',\n      ignoreOrder: true,\n    }),\n  ],\n  module: {\n    rules: [\n      {\n        // 匹配文件后缀的规则\n        test: /\\.(css|s[cs]ss)$/,\n        use: [\n          // loader执行顺序是从右到左\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          'sass-loader',\n          // {\n          //   loader: 'sass-resources-loader',\n          //   options: {\n          //     resources: [\n          //       // 放置全局引入的公共scss文件\n          //     ],\n          //   },\n          // },\n        ],\n      },\n    ]\n  }\n}\n```\n此时我们重新执行打包命令 npm run build ，可以发现出现了打包后的css文件，且 index.html 中自动引入了css文件：\n我们可以看看页面，可以看到，body的背景已经变成蓝色，说明有效果了.\n## 打包图片\nwebpack5中已经废弃了 url-loader ，打包图片可以使用 asset-module ，我们先放置一张图片在 src/assets/images 中：并且改写一下 index.css\n```\nbody {\n  width: 100vw;\n  height: 100vh;\n  // 引入背景图片\n  background-image: url('../assets/images/guang.png');\n  background-size: 100% 100%;\n}\n```\n然后我们在 webpack.config.js 中添加打包图片的配置\n```\n  module: {\n    rules: [\n      // 刚刚的代码...\n      {\n        // 匹配文件后缀的规则\n        test: /\\.(png|jpe?g|gif|svg|webp)$/,\n        type: 'asset',\n        parser: {\n          // 转base64的条件\n          dataUrlCondition: {\n             maxSize: 25 * 1024, // 25kb\n          }\n        },\n        generator: {\n          // 打包到 dist/image 文件下\n         filename: 'images/[contenthash][ext][query]',\n        },\n     }\n    ]\n  }\n```\n  我们现在重新运行一下 npm run build ，发现dist下已经有了 images 这个文件夹\n  我们看一下页面背景图片已经生效，说明打包成功了！\n## 配置babel\nbabel 可以将我们项目中的高级语法转化成比较低级的语法，比如可以将 ES6 转为 ES5 ，这样可以兼容一些低版本浏览器，所以是很有必要的\n\n首先安装所需的包：\n@babel/core、babel-loader ：转换语法的工具\n@babel/preset-env ：转换的一套现成规则\n@babel/plugin-transform-runtime ：转换async/await所需插件\n\nnpm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime -D\n由于 babel 是针对js文件的语法转换，所以我们需要在 webpack.config.js 中去针对js进行操作\n```\nmodule: {\n  rules: [\n    // 刚刚的代码...\n    {\n      // 匹配js后缀文件\n      test: /\\.js$/,\n      // 排除node_modules中的js\n      exclude: /node_modules/,\n      use: [\n        'babel-loader'\n      ],\n    }\n  ]\n}\n```\n单单配置了 babel-loader 还是不够的，我们还需要配置 babel 转换的规则，所以需要在根目录下创建 babel.config.js\n```\n// babel.config.js\nmodule.exports = {\npresets: [\n  // 配置规则\n  \"@babel/preset-env\"\n],\n// 配置插件\nplugins: [\"@babel/plugin-transform-runtime\"]\n}\n```\n此时我们重新运行打包 npm run build ，我们可以发现打包后的js代码中，已经把刚刚代码中的 ES6 语法转成 ES5 语法了！可以看到刚刚代码中的 const 已经转成 ES5 语法了\n## 打包Vue\n打包Vue需要用到以下几个包：\nvue ：Vue开发所需的依赖\nvue-loader ：解析 .vue 文件的loader\nvue-template-compiler ：解析vue中模板的工具\n@vue/babel-preset-jsx ：支持解析vue中的jsx语法\n注意： vue 和 vue-template-compiler 版本需要一致，这里我使用 2.6.14 这个版本， vue-loader 这里我使用了 15.9.8 这个版本\n所以我们先安装一下：\nnpm i \nvue@2.6.14 vue-template-compiler@2.6.14 vue-loader@15.9.8 @vue/babel-preset-jsx -D\n然后我们需要去 webpack.config.js 中配置对 .vue 文件的解析\n```\n// 刚才的代码...\nconst { VueLoaderPlugin } = require('vue-loader')\nmodule.exports = {\n  // 刚才的代码...\n  plugins: [\n    // 刚才的代码...\n    new VueLoaderPlugin()\n  ],\n  module: {\n    rules: [\n      // 刚才的代码...\n      {\n        test: /\\.vue$/,\n        use: 'vue-loader',\n      }\n    ]\n  }\n}\n```\n并且到 babel.config.js 中配置一下，让webpack支持 .vue 文件中的 jsx 语法\n```\nmodule.exports = {\n  presets: [\n    \"@babel/preset-env\",\n    // 支持vue中的jsx语法\n    \"@vue/babel-preset-jsx\"\n  ],\n  plugins: [\"@babel/plugin-transform-runtime\"]\n}\n```\n现在我们可以在 src 下新建一个 App.vue\n```\n<template>\n  <div class=\"box\">我是App哈哈哈哈</div>\n</template>\n<script>\nexport default {}\n</script>\n<style lang=\"scss\">\n.box {\n  width: 500px;\n  height: 200px;\n  color: #fff;\n  background-color: #000;\n}\n</style>\n```\n然后改写一下 src/main.js\n```\nimport Vue from 'vue'\nimport App from './App.vue'\nnew Vue({\n  render: (h) => h(App),\n}).$mount('#app')\n```\n此时我们重新运行 npm run build ，我们可以看看页面的效果，说明打包成功啦！\n## 配置路径别名\n有时候文件引用搁着太多层，引用起来会看起来很不明确，比如\n../../../../../App.vue ，所以我们可以配置一下别名 alia\n```\nmodule.exports = {\n  // 刚才的代码...\n  resolve: {\n    // 路径别名\n    alias: {\n      '@': path.resolve('./src'),\n      assets: '~/assets',\n      tools: '~/tools'\n    },\n    // 引入文件时省略后缀\n    extensions: ['.js', '.ts', '.less', '.vue'],\n  },\n}\n```\n现在别名配置完成啦：\n配置前： ../../../../../App.vue\n配置后： @/App.vue\n## webpack-dev-server\n刚刚我们发现，每改一次代码就得重新打包一次，非常繁琐，有没有可以改代码自动重新打包的呢？这就要用到 webpack-dev-server\n\nnpm i webpack-dev-server -D\n到 webpack.config.js 中配置 devServer\n```\n  devServer: {\n    // 自定义端口号\n    // port:7000,\n    // 自动打开浏览器\n    open: true\n  },\n```\n然后到 package.json 中配置一下启动命令\n```\n  \"scripts\": {\n    \"build\": \"webpack\",\n    \"serve\": \"webpack serve\"\n  },\n```\n此时我们运行 npm run serve 就可以启动项目啦！\n## 区分环境\n我们不能把所有配置都配置在一个 webpack.config.js 中，因为我们有两个环境 development(开发环境)、production(生产环境) ，所以我们在根目录下创建 build文件夹 ，并创建三个文件\nwebpack.base.js ：两个环境共用配置\n入口，输出配置\n各种文件的处理\n进度条展示\n路径别名\nwebpack.dev.js ：开发环境独有配置\nwebpack-dev-server\n不同的source-map模式\n不同的环境变量\nwebpack.prod.js ：生产环境独有配置\n不同的source-map模式\n不同的环境变量\n我们需要先安装一个合并插件 webpack-merge ，用于两个环境的配置可以合并公共的配置\nnpm i webpack-merge -D\n然后我们在根目录下新建一个 build文件夹 ，并在此文件夹下新建 webpack.base.js、webpack.dev.js、webpack.config.js\n```\n// 公共配置\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst { VueLoaderPlugin } = require('vue-loader')\nmodule.exports = {\n// 入口文件 main.js\nentry: {\n  main: './src/main.js'\n},\n// 输出\noutput: {\n  // 输出到 dist文件夹\n  // 记得改路径\n  path: path.resolve(__dirname, '../dist'),\n  // js文件下\n  filename: 'js/chunk-[contenthash].js',\n  // 每次打包前自动清除旧的dist\n  clean: true,\n},\nplugins: [\n  new HtmlWebpackPlugin({\n    // 选择模板 public/index.html\n    template: './public/index.html',\n    // 打包后的名字\n    filename: 'index.html',\n    // js文件插入 body里\n    inject: 'body',\n  }),\n  new MiniCssExtractPlugin({\n    // 将css代码输出到dist/styles文件夹下\n    filename: 'styles/chunk-[contenthash].css',\n    ignoreOrder: true,\n  }),\n  new VueLoaderPlugin()\n],\nmodule: {\n  rules: [\n    {\n      // 匹配文件后缀的规则\n      test: /\\.(css|s[cs]ss)$/,\n      use: [\n        // loader执行顺序是从右到左\n        MiniCssExtractPlugin.loader,\n        'css-loader',\n        'sass-loader',\n        // {\n        //   loader: 'sass-resources-loader',\n        //   options: {\n        //     resources: [\n        //       // 放置全局引入的公共scss文件\n        //     ],\n        //   },\n        // },\n      ],\n    },\n    {\n      // 匹配文件后缀的规则\n      test: /\\.(png|jpe?g|gif|svg|webp)$/,\n      type: 'asset',\n      parser: {\n        // 转base64的条件\n        dataUrlCondition: {\n          maxSize: 25 * 1024, // 25kb\n        }\n      },\n      generator: {\n        // 打包到 dist/image 文件下\n        filename: 'images/[contenthash][ext][query]',\n      },\n    },\n    {\n      test: /\\.js$/,\n      // 排除node_modules中的js\n      exclude: /node_modules/,\n      use: [\n        'babel-loader'\n      ],\n    },\n    {\n      test: /\\.vue$/,\n      use: 'vue-loader',\n    }\n  ]\n},\nresolve: {\n  // 路径别名\n  alias: {\n    '@': path.resolve('./src'),\n    assets: '~/assets'\n  },\n  // 引入文件时省略后缀\n  extensions: ['.js', '.ts', '.less', '.vue']\n},\n}\n```\n```\nwebpack.dev.js\n// 开发环境\nconst { merge } = require('webpack-merge')\nconst base = require('./webpack.base')\nmodule.exports = merge(base, {\nmode: 'development',\ndevServer: {\n  open: true,\n  // hot: true,\n}\n})\n```\n```\nwebpack.prod.js\n// 生产环境\nconst { merge } = require('webpack-merge')\nconst base = require('./webpack.base')\nmodule.exports = merge(base, {\nmode: 'production'\n})\n```\n然后我们到 package.json 修改一下指令\n```\n  \"scripts\": {\n    \"serve\": \"webpack serve --config ./build/webpack.dev\",\n    \"build\": \"webpack --config ./build/webpack.prod\"\n  },\n```\n接下来我们运行这两个命令，发现都成功了：\nnpm run build\nnpm run serve\n\n## 构建进度条\n无论是启动项目时还是打包时，都需要进度条的展示，所以需要把进度条配置在 webpack.base 中，我们需要先安装进度条的插件 progress-bar-webpack-plugin\n\nnpm i progress-bar-webpack-plugin -D\n```\n// webpack.base.js\n// 刚刚的代码...\nconst ProgressBarPlugin = require('progress-bar-webpack-plugin')\nconst chalk = require('chalk')\nmodule.exports = {\n  // 刚刚的代码...\n  plugins: [\n    // 刚刚的代码...\n    new ProgressBarPlugin({\n      format: ` build [:bar] ${chalk.green.bold(':percent')} (:elapsed seconds)`,\n    })\n  ],\n  // 刚刚的代码...\n}\n```\n现在我们可以看到无论启动项目或者打包，都会有进度条了\n\n\n## source-map\nsource-map 的作用：代码报错时，能快速定位到出错位置， webpack5 的所有 source-map模式 可以看webpack官网：https://webpack.docschina.org...\n\n这里我使用两种模式：\ndevelopment ：使用 eval-cheap-module-source-map 模式，能具体定位到源码位置和源码展示，适合开发模式，体积较小\nproduction ：使用 nosources-source-map ，只能定位源码位置，不能源码展示，体积较小，适合生产模式\n所以我们开始配置 source-map\n```\nwebpack.dev.js\n// 刚才的代码...\nmodule.exports = merge(base, {\n// 刚才的代码...\ndevtool: 'eval-cheap-module-source-map'\n})\nwebpack.prod.js\n// 刚才的代码...\nmodule.exports = merge(base, {\n// 刚才的代码...\ndevtool: 'nosources-source-map'\n})\n```\n## 环境变量\n配置 devlopment、production 这两个环境的环境变量\n```\nwebpack.dev.js\n// 刚才的代码...\nconst webpack = require('webpack')\nmodule.exports = merge(base, {\n// 刚才的代码...\nplugins: [\n  // 定义全局变量\n  new webpack.DefinePlugin({\n    process: {\n      env: {\n        NODE_DEV: JSON.stringify('development'),\n        // 这里可以定义你的环境变量\n        // VUE_APP_URL: JSON.stringify('https://xxx.com')\n      },\n    },\n  }),\n]\n})\n```\n```\nwebpack.prod.js\n// 刚才的代码...\nconst webpack = require('webpack')\nmodule.exports = merge(base, {\n// 刚才的代码...\nplugins: [\n  // 定义全局变量\n  new webpack.DefinePlugin({\n    process: {\n      env: {\n        NODE_DEV: JSON.stringify('prodction'),\n        // 这里可以定义你的环境变量\n        // VUE_APP_URL: JSON.stringify('https://xxx.com')\n      },\n    },\n  }),\n]\n})\n```\n\n","source":"_posts/Vue-Cli.md","raw":"---\ntitle: 基于Webpack5搭建一个Vue-Cli\ndate: 2023-03-27 21:30:26\ntags: Webpack\ncategories: 知识点\ncover: [/images/vueclicover.png]\nbanner: \n  type: img\n  bgurl: [/images/vueclicover.png]\n---\n大家平时在进行Vue开发的时候，大部分人都是使用 Vue-cli 这个现成的Vue脚手架来进行开发的，但是用它用了这么久，你难道不想自己搭一个属于自己的 Vue-cli 吗？\n\n# 1、建一个文件夹\n新建一个文件夹my-vue-cli用来存放项目\n# 2、初始化npm\n在终端中输入 npm init\n然后一直回车就行，这样能使项目拥有一个npm管理环境，之后可以在此环境上安装我们所需要的包\n# 3、webpack、webpack-cli\n安装 webpack、webpack-cli\nwebpack ：打包的工具\nwebpack-cli ：为webpack提供命令行的工具\nnpm i webpack webpack-cli -D\n# 4、src、public\n在根目录下新建 src、public 这两个文件夹，前者用来放置项目主要代码，后者用来放项目公用静态资源\n```\npublic/index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>my-vue-cli</title>\n</head>\n<body>\n<div id=\"app\"></div>\n</body>\n</html>\n```\n```\nsrc/main.js\nimport { add } from './tools/add.js'\nconsole.log(add(1, 2))\nconsole.log('我是main.js')\n```\n```\nsrc/tools/add.js\nexport const add = (a, b) => {\nreturn a + b\n}\n```\n# 5、入口文件\n刚刚的 main.js 就是我们的入口文件，也就相当于整个引用树的根节点，webpack打包需要从入口文件开始查找，一直到打包所有引用文件。\n进行入口文件的配置，在根目录下新建 webpack.config.js ：\n```\nconst path = require('path')\nmodule.exports = {\n  // 模式 开发模式\n  mode: 'development',\n  // 入口文件 main.js\n  entry: {\n    main: './src/main.js'\n  },\n  // 输出\n  output: {\n    // 输出到 dist文件夹\n    path: path.resolve(__dirname, './dist'),\n    // js文件下\n    filename: 'js/chunk-[contenthash].js',\n    // 每次打包前自动清除旧的dist\n    clean: true,\n  }\n}\n```\n# 6、配置打包命令\n到 package.json 里配置打包命令：\n```\n\"scripts\": {\n    \"build\": \"webpack\"\n},\n```\n现在我们到终端输入 npm run build ，就能发现打包成功：\n但是这其实不是我们要的目的，我们的目的是将这个打包后的最终js文件，插入到刚刚的 index.html 中，因为js文件得让html文件引用，才有意义嘛！所以我们不仅要打包js，还要打包html\n小知识：loader和plugin\nloader ：使webpack拥有解析非js文件的能力，如css、png、ts等等\nplugin ：拓展webpack的打包功能，如优化体积、显示进度条等等\n\n# 7、打包html\n打包html需要用到 html-webpack-plugin 这个插件，也就是plugin，所以需要安装一下：\nnpm i html-webpack-plugin -D\n并且需要在 webpack.config.js 中配置一下\n```\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  // 刚刚的代码...\n  // 插件都放 plugins 中\n  plugins: [\n    new HtmlWebpackPlugin({\n      // 选择模板 public/index.html\n      template: './public/index.html',\n      // 打包后的名字\n      filename: 'index.html',\n      // js文件插入 body里\n      inject: 'body',\n    }),\n  ]\n}\n```\n现在我们可以在终端中执行打包命令 npm run build 可以看到html被打包了，且打包后的html自动引入打包后的js文件\n现在我们可以打开打包后的 index.html ，发现控制台可以输出，说明成功了！\n## 打包CSS\n在 src 下新建 styles 文件夹，用来存放样式文件文件src/styles/index.scss\n```\nbody {\nbackground-color: blue;\n}\n```\n然后我们在入口文件 main.js 中引入\nimport './styles/index.scss'\n// 刚刚的代码...\n我们的目的是，打包 index.scss 这个文件，并且让 index.html 自动引入打包后的css文件，所以我们需要安装以下几个东 \nsass、sass-loader ：可以将scss代码转成css\ncss-loader ：使webpack具有打包css的能力\nsass-resources-loader ：可选，支持打包全局公共scss文件\nmini-css-extract-plugin ：可将css代码打包成一个单独的css文件\n我们安装一下这些插件\nnpm i sass sass-loader sass-resources-loader mini-css-extract-plugin -D\n然后配置一下 webpack.config.js\n```\n// 刚才的代码...\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nmodule.exports = {\n  // 刚才的代码...\n  plugins: [\n    // 刚才的代码...\n    new MiniCssExtractPlugin({\n      // 将css代码输出到dist/styles文件夹下\n      filename: 'styles/chunk-[contenthash].css',\n      ignoreOrder: true,\n    }),\n  ],\n  module: {\n    rules: [\n      {\n        // 匹配文件后缀的规则\n        test: /\\.(css|s[cs]ss)$/,\n        use: [\n          // loader执行顺序是从右到左\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          'sass-loader',\n          // {\n          //   loader: 'sass-resources-loader',\n          //   options: {\n          //     resources: [\n          //       // 放置全局引入的公共scss文件\n          //     ],\n          //   },\n          // },\n        ],\n      },\n    ]\n  }\n}\n```\n此时我们重新执行打包命令 npm run build ，可以发现出现了打包后的css文件，且 index.html 中自动引入了css文件：\n我们可以看看页面，可以看到，body的背景已经变成蓝色，说明有效果了.\n## 打包图片\nwebpack5中已经废弃了 url-loader ，打包图片可以使用 asset-module ，我们先放置一张图片在 src/assets/images 中：并且改写一下 index.css\n```\nbody {\n  width: 100vw;\n  height: 100vh;\n  // 引入背景图片\n  background-image: url('../assets/images/guang.png');\n  background-size: 100% 100%;\n}\n```\n然后我们在 webpack.config.js 中添加打包图片的配置\n```\n  module: {\n    rules: [\n      // 刚刚的代码...\n      {\n        // 匹配文件后缀的规则\n        test: /\\.(png|jpe?g|gif|svg|webp)$/,\n        type: 'asset',\n        parser: {\n          // 转base64的条件\n          dataUrlCondition: {\n             maxSize: 25 * 1024, // 25kb\n          }\n        },\n        generator: {\n          // 打包到 dist/image 文件下\n         filename: 'images/[contenthash][ext][query]',\n        },\n     }\n    ]\n  }\n```\n  我们现在重新运行一下 npm run build ，发现dist下已经有了 images 这个文件夹\n  我们看一下页面背景图片已经生效，说明打包成功了！\n## 配置babel\nbabel 可以将我们项目中的高级语法转化成比较低级的语法，比如可以将 ES6 转为 ES5 ，这样可以兼容一些低版本浏览器，所以是很有必要的\n\n首先安装所需的包：\n@babel/core、babel-loader ：转换语法的工具\n@babel/preset-env ：转换的一套现成规则\n@babel/plugin-transform-runtime ：转换async/await所需插件\n\nnpm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime -D\n由于 babel 是针对js文件的语法转换，所以我们需要在 webpack.config.js 中去针对js进行操作\n```\nmodule: {\n  rules: [\n    // 刚刚的代码...\n    {\n      // 匹配js后缀文件\n      test: /\\.js$/,\n      // 排除node_modules中的js\n      exclude: /node_modules/,\n      use: [\n        'babel-loader'\n      ],\n    }\n  ]\n}\n```\n单单配置了 babel-loader 还是不够的，我们还需要配置 babel 转换的规则，所以需要在根目录下创建 babel.config.js\n```\n// babel.config.js\nmodule.exports = {\npresets: [\n  // 配置规则\n  \"@babel/preset-env\"\n],\n// 配置插件\nplugins: [\"@babel/plugin-transform-runtime\"]\n}\n```\n此时我们重新运行打包 npm run build ，我们可以发现打包后的js代码中，已经把刚刚代码中的 ES6 语法转成 ES5 语法了！可以看到刚刚代码中的 const 已经转成 ES5 语法了\n## 打包Vue\n打包Vue需要用到以下几个包：\nvue ：Vue开发所需的依赖\nvue-loader ：解析 .vue 文件的loader\nvue-template-compiler ：解析vue中模板的工具\n@vue/babel-preset-jsx ：支持解析vue中的jsx语法\n注意： vue 和 vue-template-compiler 版本需要一致，这里我使用 2.6.14 这个版本， vue-loader 这里我使用了 15.9.8 这个版本\n所以我们先安装一下：\nnpm i \nvue@2.6.14 vue-template-compiler@2.6.14 vue-loader@15.9.8 @vue/babel-preset-jsx -D\n然后我们需要去 webpack.config.js 中配置对 .vue 文件的解析\n```\n// 刚才的代码...\nconst { VueLoaderPlugin } = require('vue-loader')\nmodule.exports = {\n  // 刚才的代码...\n  plugins: [\n    // 刚才的代码...\n    new VueLoaderPlugin()\n  ],\n  module: {\n    rules: [\n      // 刚才的代码...\n      {\n        test: /\\.vue$/,\n        use: 'vue-loader',\n      }\n    ]\n  }\n}\n```\n并且到 babel.config.js 中配置一下，让webpack支持 .vue 文件中的 jsx 语法\n```\nmodule.exports = {\n  presets: [\n    \"@babel/preset-env\",\n    // 支持vue中的jsx语法\n    \"@vue/babel-preset-jsx\"\n  ],\n  plugins: [\"@babel/plugin-transform-runtime\"]\n}\n```\n现在我们可以在 src 下新建一个 App.vue\n```\n<template>\n  <div class=\"box\">我是App哈哈哈哈</div>\n</template>\n<script>\nexport default {}\n</script>\n<style lang=\"scss\">\n.box {\n  width: 500px;\n  height: 200px;\n  color: #fff;\n  background-color: #000;\n}\n</style>\n```\n然后改写一下 src/main.js\n```\nimport Vue from 'vue'\nimport App from './App.vue'\nnew Vue({\n  render: (h) => h(App),\n}).$mount('#app')\n```\n此时我们重新运行 npm run build ，我们可以看看页面的效果，说明打包成功啦！\n## 配置路径别名\n有时候文件引用搁着太多层，引用起来会看起来很不明确，比如\n../../../../../App.vue ，所以我们可以配置一下别名 alia\n```\nmodule.exports = {\n  // 刚才的代码...\n  resolve: {\n    // 路径别名\n    alias: {\n      '@': path.resolve('./src'),\n      assets: '~/assets',\n      tools: '~/tools'\n    },\n    // 引入文件时省略后缀\n    extensions: ['.js', '.ts', '.less', '.vue'],\n  },\n}\n```\n现在别名配置完成啦：\n配置前： ../../../../../App.vue\n配置后： @/App.vue\n## webpack-dev-server\n刚刚我们发现，每改一次代码就得重新打包一次，非常繁琐，有没有可以改代码自动重新打包的呢？这就要用到 webpack-dev-server\n\nnpm i webpack-dev-server -D\n到 webpack.config.js 中配置 devServer\n```\n  devServer: {\n    // 自定义端口号\n    // port:7000,\n    // 自动打开浏览器\n    open: true\n  },\n```\n然后到 package.json 中配置一下启动命令\n```\n  \"scripts\": {\n    \"build\": \"webpack\",\n    \"serve\": \"webpack serve\"\n  },\n```\n此时我们运行 npm run serve 就可以启动项目啦！\n## 区分环境\n我们不能把所有配置都配置在一个 webpack.config.js 中，因为我们有两个环境 development(开发环境)、production(生产环境) ，所以我们在根目录下创建 build文件夹 ，并创建三个文件\nwebpack.base.js ：两个环境共用配置\n入口，输出配置\n各种文件的处理\n进度条展示\n路径别名\nwebpack.dev.js ：开发环境独有配置\nwebpack-dev-server\n不同的source-map模式\n不同的环境变量\nwebpack.prod.js ：生产环境独有配置\n不同的source-map模式\n不同的环境变量\n我们需要先安装一个合并插件 webpack-merge ，用于两个环境的配置可以合并公共的配置\nnpm i webpack-merge -D\n然后我们在根目录下新建一个 build文件夹 ，并在此文件夹下新建 webpack.base.js、webpack.dev.js、webpack.config.js\n```\n// 公共配置\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst { VueLoaderPlugin } = require('vue-loader')\nmodule.exports = {\n// 入口文件 main.js\nentry: {\n  main: './src/main.js'\n},\n// 输出\noutput: {\n  // 输出到 dist文件夹\n  // 记得改路径\n  path: path.resolve(__dirname, '../dist'),\n  // js文件下\n  filename: 'js/chunk-[contenthash].js',\n  // 每次打包前自动清除旧的dist\n  clean: true,\n},\nplugins: [\n  new HtmlWebpackPlugin({\n    // 选择模板 public/index.html\n    template: './public/index.html',\n    // 打包后的名字\n    filename: 'index.html',\n    // js文件插入 body里\n    inject: 'body',\n  }),\n  new MiniCssExtractPlugin({\n    // 将css代码输出到dist/styles文件夹下\n    filename: 'styles/chunk-[contenthash].css',\n    ignoreOrder: true,\n  }),\n  new VueLoaderPlugin()\n],\nmodule: {\n  rules: [\n    {\n      // 匹配文件后缀的规则\n      test: /\\.(css|s[cs]ss)$/,\n      use: [\n        // loader执行顺序是从右到左\n        MiniCssExtractPlugin.loader,\n        'css-loader',\n        'sass-loader',\n        // {\n        //   loader: 'sass-resources-loader',\n        //   options: {\n        //     resources: [\n        //       // 放置全局引入的公共scss文件\n        //     ],\n        //   },\n        // },\n      ],\n    },\n    {\n      // 匹配文件后缀的规则\n      test: /\\.(png|jpe?g|gif|svg|webp)$/,\n      type: 'asset',\n      parser: {\n        // 转base64的条件\n        dataUrlCondition: {\n          maxSize: 25 * 1024, // 25kb\n        }\n      },\n      generator: {\n        // 打包到 dist/image 文件下\n        filename: 'images/[contenthash][ext][query]',\n      },\n    },\n    {\n      test: /\\.js$/,\n      // 排除node_modules中的js\n      exclude: /node_modules/,\n      use: [\n        'babel-loader'\n      ],\n    },\n    {\n      test: /\\.vue$/,\n      use: 'vue-loader',\n    }\n  ]\n},\nresolve: {\n  // 路径别名\n  alias: {\n    '@': path.resolve('./src'),\n    assets: '~/assets'\n  },\n  // 引入文件时省略后缀\n  extensions: ['.js', '.ts', '.less', '.vue']\n},\n}\n```\n```\nwebpack.dev.js\n// 开发环境\nconst { merge } = require('webpack-merge')\nconst base = require('./webpack.base')\nmodule.exports = merge(base, {\nmode: 'development',\ndevServer: {\n  open: true,\n  // hot: true,\n}\n})\n```\n```\nwebpack.prod.js\n// 生产环境\nconst { merge } = require('webpack-merge')\nconst base = require('./webpack.base')\nmodule.exports = merge(base, {\nmode: 'production'\n})\n```\n然后我们到 package.json 修改一下指令\n```\n  \"scripts\": {\n    \"serve\": \"webpack serve --config ./build/webpack.dev\",\n    \"build\": \"webpack --config ./build/webpack.prod\"\n  },\n```\n接下来我们运行这两个命令，发现都成功了：\nnpm run build\nnpm run serve\n\n## 构建进度条\n无论是启动项目时还是打包时，都需要进度条的展示，所以需要把进度条配置在 webpack.base 中，我们需要先安装进度条的插件 progress-bar-webpack-plugin\n\nnpm i progress-bar-webpack-plugin -D\n```\n// webpack.base.js\n// 刚刚的代码...\nconst ProgressBarPlugin = require('progress-bar-webpack-plugin')\nconst chalk = require('chalk')\nmodule.exports = {\n  // 刚刚的代码...\n  plugins: [\n    // 刚刚的代码...\n    new ProgressBarPlugin({\n      format: ` build [:bar] ${chalk.green.bold(':percent')} (:elapsed seconds)`,\n    })\n  ],\n  // 刚刚的代码...\n}\n```\n现在我们可以看到无论启动项目或者打包，都会有进度条了\n\n\n## source-map\nsource-map 的作用：代码报错时，能快速定位到出错位置， webpack5 的所有 source-map模式 可以看webpack官网：https://webpack.docschina.org...\n\n这里我使用两种模式：\ndevelopment ：使用 eval-cheap-module-source-map 模式，能具体定位到源码位置和源码展示，适合开发模式，体积较小\nproduction ：使用 nosources-source-map ，只能定位源码位置，不能源码展示，体积较小，适合生产模式\n所以我们开始配置 source-map\n```\nwebpack.dev.js\n// 刚才的代码...\nmodule.exports = merge(base, {\n// 刚才的代码...\ndevtool: 'eval-cheap-module-source-map'\n})\nwebpack.prod.js\n// 刚才的代码...\nmodule.exports = merge(base, {\n// 刚才的代码...\ndevtool: 'nosources-source-map'\n})\n```\n## 环境变量\n配置 devlopment、production 这两个环境的环境变量\n```\nwebpack.dev.js\n// 刚才的代码...\nconst webpack = require('webpack')\nmodule.exports = merge(base, {\n// 刚才的代码...\nplugins: [\n  // 定义全局变量\n  new webpack.DefinePlugin({\n    process: {\n      env: {\n        NODE_DEV: JSON.stringify('development'),\n        // 这里可以定义你的环境变量\n        // VUE_APP_URL: JSON.stringify('https://xxx.com')\n      },\n    },\n  }),\n]\n})\n```\n```\nwebpack.prod.js\n// 刚才的代码...\nconst webpack = require('webpack')\nmodule.exports = merge(base, {\n// 刚才的代码...\nplugins: [\n  // 定义全局变量\n  new webpack.DefinePlugin({\n    process: {\n      env: {\n        NODE_DEV: JSON.stringify('prodction'),\n        // 这里可以定义你的环境变量\n        // VUE_APP_URL: JSON.stringify('https://xxx.com')\n      },\n    },\n  }),\n]\n})\n```\n\n","slug":"Vue-Cli","published":1,"updated":"2023-04-11T06:58:25.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml10007tit87dmogfxu","content":"<p>大家平时在进行Vue开发的时候，大部分人都是使用 Vue-cli 这个现成的Vue脚手架来进行开发的，但是用它用了这么久，你难道不想自己搭一个属于自己的 Vue-cli 吗？</p>\n<h1 id=\"1、建一个文件夹\"><a href=\"#1、建一个文件夹\" class=\"headerlink\" title=\"1、建一个文件夹\"></a>1、建一个文件夹</h1><p>新建一个文件夹my-vue-cli用来存放项目</p>\n<h1 id=\"2、初始化npm\"><a href=\"#2、初始化npm\" class=\"headerlink\" title=\"2、初始化npm\"></a>2、初始化npm</h1><p>在终端中输入 npm init<br>然后一直回车就行，这样能使项目拥有一个npm管理环境，之后可以在此环境上安装我们所需要的包</p>\n<h1 id=\"3、webpack、webpack-cli\"><a href=\"#3、webpack、webpack-cli\" class=\"headerlink\" title=\"3、webpack、webpack-cli\"></a>3、webpack、webpack-cli</h1><p>安装 webpack、webpack-cli<br>webpack ：打包的工具<br>webpack-cli ：为webpack提供命令行的工具<br>npm i webpack webpack-cli -D</p>\n<h1 id=\"4、src、public\"><a href=\"#4、src、public\" class=\"headerlink\" title=\"4、src、public\"></a>4、src、public</h1><p>在根目录下新建 src、public 这两个文件夹，前者用来放置项目主要代码，后者用来放项目公用静态资源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public/index.html</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;my-vue-cli&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src/main.js</span><br><span class=\"line\">import &#123; add &#125; from &#x27;./tools/add.js&#x27;</span><br><span class=\"line\">console.log(add(1, 2))</span><br><span class=\"line\">console.log(&#x27;我是main.js&#x27;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src/tools/add.js</span><br><span class=\"line\">export const add = (a, b) =&gt; &#123;</span><br><span class=\"line\">return a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"5、入口文件\"><a href=\"#5、入口文件\" class=\"headerlink\" title=\"5、入口文件\"></a>5、入口文件</h1><p>刚刚的 main.js 就是我们的入口文件，也就相当于整个引用树的根节点，webpack打包需要从入口文件开始查找，一直到打包所有引用文件。<br>进行入口文件的配置，在根目录下新建 webpack.config.js ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const path = require(&#x27;path&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 模式 开发模式</span><br><span class=\"line\">  mode: &#x27;development&#x27;,</span><br><span class=\"line\">  // 入口文件 main.js</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: &#x27;./src/main.js&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 输出</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    // 输出到 dist文件夹</span><br><span class=\"line\">    path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class=\"line\">    // js文件下</span><br><span class=\"line\">    filename: &#x27;js/chunk-[contenthash].js&#x27;,</span><br><span class=\"line\">    // 每次打包前自动清除旧的dist</span><br><span class=\"line\">    clean: true,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6、配置打包命令\"><a href=\"#6、配置打包命令\" class=\"headerlink\" title=\"6、配置打包命令\"></a>6、配置打包命令</h1><p>到 package.json 里配置打包命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>现在我们到终端输入 npm run build ，就能发现打包成功：<br>但是这其实不是我们要的目的，我们的目的是将这个打包后的最终js文件，插入到刚刚的 index.html 中，因为js文件得让html文件引用，才有意义嘛！所以我们不仅要打包js，还要打包html<br>小知识：loader和plugin<br>loader ：使webpack拥有解析非js文件的能力，如css、png、ts等等<br>plugin ：拓展webpack的打包功能，如优化体积、显示进度条等等</p>\n<h1 id=\"7、打包html\"><a href=\"#7、打包html\" class=\"headerlink\" title=\"7、打包html\"></a>7、打包html</h1><p>打包html需要用到 html-webpack-plugin 这个插件，也就是plugin，所以需要安装一下：<br>npm i html-webpack-plugin -D<br>并且需要在 webpack.config.js 中配置一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚刚的代码...</span><br><span class=\"line\">  // 插件都放 plugins 中</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      // 选择模板 public/index.html</span><br><span class=\"line\">      template: &#x27;./public/index.html&#x27;,</span><br><span class=\"line\">      // 打包后的名字</span><br><span class=\"line\">      filename: &#x27;index.html&#x27;,</span><br><span class=\"line\">      // js文件插入 body里</span><br><span class=\"line\">      inject: &#x27;body&#x27;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以在终端中执行打包命令 npm run build 可以看到html被打包了，且打包后的html自动引入打包后的js文件<br>现在我们可以打开打包后的 index.html ，发现控制台可以输出，说明成功了！</p>\n<h2 id=\"打包CSS\"><a href=\"#打包CSS\" class=\"headerlink\" title=\"打包CSS\"></a>打包CSS</h2><p>在 src 下新建 styles 文件夹，用来存放样式文件文件src/styles/index.scss</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">body &#123;</span><br><span class=\"line\">background-color: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们在入口文件 main.js 中引入<br>import ‘./styles/index.scss’<br>// 刚刚的代码…<br>我们的目的是，打包 index.scss 这个文件，并且让 index.html 自动引入打包后的css文件，所以我们需要安装以下几个东<br>sass、sass-loader ：可以将scss代码转成css<br>css-loader ：使webpack具有打包css的能力<br>sass-resources-loader ：可选，支持打包全局公共scss文件<br>mini-css-extract-plugin ：可将css代码打包成一个单独的css文件<br>我们安装一下这些插件<br>npm i sass sass-loader sass-resources-loader mini-css-extract-plugin -D<br>然后配置一下 webpack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚才的代码...</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 刚才的代码...</span><br><span class=\"line\">    new MiniCssExtractPlugin(&#123;</span><br><span class=\"line\">      // 将css代码输出到dist/styles文件夹下</span><br><span class=\"line\">      filename: &#x27;styles/chunk-[contenthash].css&#x27;,</span><br><span class=\"line\">      ignoreOrder: true,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        // 匹配文件后缀的规则</span><br><span class=\"line\">        test: /\\.(css|s[cs]ss)$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          // loader执行顺序是从右到左</span><br><span class=\"line\">          MiniCssExtractPlugin.loader,</span><br><span class=\"line\">          &#x27;css-loader&#x27;,</span><br><span class=\"line\">          &#x27;sass-loader&#x27;,</span><br><span class=\"line\">          // &#123;</span><br><span class=\"line\">          //   loader: &#x27;sass-resources-loader&#x27;,</span><br><span class=\"line\">          //   options: &#123;</span><br><span class=\"line\">          //     resources: [</span><br><span class=\"line\">          //       // 放置全局引入的公共scss文件</span><br><span class=\"line\">          //     ],</span><br><span class=\"line\">          //   &#125;,</span><br><span class=\"line\">          // &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时我们重新执行打包命令 npm run build ，可以发现出现了打包后的css文件，且 index.html 中自动引入了css文件：<br>我们可以看看页面，可以看到，body的背景已经变成蓝色，说明有效果了.</p>\n<h2 id=\"打包图片\"><a href=\"#打包图片\" class=\"headerlink\" title=\"打包图片\"></a>打包图片</h2><p>webpack5中已经废弃了 url-loader ，打包图片可以使用 asset-module ，我们先放置一张图片在 src/assets/images 中：并且改写一下 index.css</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">body &#123;</span><br><span class=\"line\">  width: 100vw;</span><br><span class=\"line\">  height: 100vh;</span><br><span class=\"line\">  // 引入背景图片</span><br><span class=\"line\">  background-image: url(&#x27;../assets/images/guang.png&#x27;);</span><br><span class=\"line\">  background-size: 100% 100%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们在 webpack.config.js 中添加打包图片的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    // 刚刚的代码...</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 匹配文件后缀的规则</span><br><span class=\"line\">      test: /\\.(png|jpe?g|gif|svg|webp)$/,</span><br><span class=\"line\">      type: &#x27;asset&#x27;,</span><br><span class=\"line\">      parser: &#123;</span><br><span class=\"line\">        // 转base64的条件</span><br><span class=\"line\">        dataUrlCondition: &#123;</span><br><span class=\"line\">           maxSize: 25 * 1024, // 25kb</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      generator: &#123;</span><br><span class=\"line\">        // 打包到 dist/image 文件下</span><br><span class=\"line\">       filename: &#x27;images/[contenthash][ext][query]&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  我们现在重新运行一下 npm run build ，发现dist下已经有了 images 这个文件夹<br>  我们看一下页面背景图片已经生效，说明打包成功了！</p>\n<h2 id=\"配置babel\"><a href=\"#配置babel\" class=\"headerlink\" title=\"配置babel\"></a>配置babel</h2><p>babel 可以将我们项目中的高级语法转化成比较低级的语法，比如可以将 ES6 转为 ES5 ，这样可以兼容一些低版本浏览器，所以是很有必要的</p>\n<p>首先安装所需的包：<br>@babel/core、babel-loader ：转换语法的工具<br>@babel/preset-env ：转换的一套现成规则<br>@babel/plugin-transform-runtime ：转换async/await所需插件</p>\n<p>npm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime -D<br>由于 babel 是针对js文件的语法转换，所以我们需要在 webpack.config.js 中去针对js进行操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    // 刚刚的代码...</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 匹配js后缀文件</span><br><span class=\"line\">      test: /\\.js$/,</span><br><span class=\"line\">      // 排除node_modules中的js</span><br><span class=\"line\">      exclude: /node_modules/,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        &#x27;babel-loader&#x27;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>单单配置了 babel-loader 还是不够的，我们还需要配置 babel 转换的规则，所以需要在根目录下创建 babel.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// babel.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">presets: [</span><br><span class=\"line\">  // 配置规则</span><br><span class=\"line\">  &quot;@babel/preset-env&quot;</span><br><span class=\"line\">],</span><br><span class=\"line\">// 配置插件</span><br><span class=\"line\">plugins: [&quot;@babel/plugin-transform-runtime&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时我们重新运行打包 npm run build ，我们可以发现打包后的js代码中，已经把刚刚代码中的 ES6 语法转成 ES5 语法了！可以看到刚刚代码中的 const 已经转成 ES5 语法了</p>\n<h2 id=\"打包Vue\"><a href=\"#打包Vue\" class=\"headerlink\" title=\"打包Vue\"></a>打包Vue</h2><p>打包Vue需要用到以下几个包：<br>vue ：Vue开发所需的依赖<br>vue-loader ：解析 .vue 文件的loader<br>vue-template-compiler ：解析vue中模板的工具<br>@vue/babel-preset-jsx ：支持解析vue中的jsx语法<br>注意： vue 和 vue-template-compiler 版本需要一致，这里我使用 2.6.14 这个版本， vue-loader 这里我使用了 15.9.8 这个版本<br>所以我们先安装一下：<br>npm i<br><a href=\"mailto:&#118;&#117;&#101;&#x40;&#50;&#x2e;&#x36;&#x2e;&#x31;&#x34;\">&#118;&#117;&#101;&#x40;&#50;&#x2e;&#x36;&#x2e;&#x31;&#x34;</a> <a href=\"mailto:&#118;&#117;&#101;&#45;&#x74;&#x65;&#109;&#112;&#108;&#x61;&#x74;&#101;&#45;&#x63;&#x6f;&#x6d;&#x70;&#105;&#108;&#101;&#x72;&#64;&#x32;&#x2e;&#x36;&#x2e;&#x31;&#x34;\">&#118;&#117;&#101;&#45;&#x74;&#x65;&#109;&#112;&#108;&#x61;&#x74;&#101;&#45;&#x63;&#x6f;&#x6d;&#x70;&#105;&#108;&#101;&#x72;&#64;&#x32;&#x2e;&#x36;&#x2e;&#x31;&#x34;</a> <a href=\"mailto:&#118;&#x75;&#x65;&#45;&#108;&#x6f;&#x61;&#100;&#101;&#x72;&#64;&#x31;&#53;&#46;&#x39;&#46;&#56;\">&#118;&#x75;&#x65;&#45;&#108;&#x6f;&#x61;&#100;&#101;&#x72;&#64;&#x31;&#53;&#46;&#x39;&#46;&#56;</a> @vue/babel-preset-jsx -D<br>然后我们需要去 webpack.config.js 中配置对 .vue 文件的解析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚才的代码...</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 刚才的代码...</span><br><span class=\"line\">    new VueLoaderPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      // 刚才的代码...</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        use: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且到 babel.config.js 中配置一下，让webpack支持 .vue 文件中的 jsx 语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  presets: [</span><br><span class=\"line\">    &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">    // 支持vue中的jsx语法</span><br><span class=\"line\">    &quot;@vue/babel-preset-jsx&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  plugins: [&quot;@babel/plugin-transform-runtime&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以在 src 下新建一个 App.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;box&quot;&gt;我是App哈哈哈哈&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class=\"line\">.box &#123;</span><br><span class=\"line\">  width: 500px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  background-color: #000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>然后改写一下 src/main.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  render: (h) =&gt; h(App),</span><br><span class=\"line\">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>\n<p>此时我们重新运行 npm run build ，我们可以看看页面的效果，说明打包成功啦！</p>\n<h2 id=\"配置路径别名\"><a href=\"#配置路径别名\" class=\"headerlink\" title=\"配置路径别名\"></a>配置路径别名</h2><p>有时候文件引用搁着太多层，引用起来会看起来很不明确，比如<br>../../../../../App.vue ，所以我们可以配置一下别名 alia</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚才的代码...</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    // 路径别名</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      &#x27;@&#x27;: path.resolve(&#x27;./src&#x27;),</span><br><span class=\"line\">      assets: &#x27;~/assets&#x27;,</span><br><span class=\"line\">      tools: &#x27;~/tools&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 引入文件时省略后缀</span><br><span class=\"line\">    extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.less&#x27;, &#x27;.vue&#x27;],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在别名配置完成啦：<br>配置前： ../../../../../App.vue<br>配置后： @/App.vue</p>\n<h2 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack-dev-server\"></a>webpack-dev-server</h2><p>刚刚我们发现，每改一次代码就得重新打包一次，非常繁琐，有没有可以改代码自动重新打包的呢？这就要用到 webpack-dev-server</p>\n<p>npm i webpack-dev-server -D<br>到 webpack.config.js 中配置 devServer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">  // 自定义端口号</span><br><span class=\"line\">  // port:7000,</span><br><span class=\"line\">  // 自动打开浏览器</span><br><span class=\"line\">  open: true</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>然后到 package.json 中配置一下启动命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;build&quot;: &quot;webpack&quot;,</span><br><span class=\"line\">  &quot;serve&quot;: &quot;webpack serve&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>此时我们运行 npm run serve 就可以启动项目啦！</p>\n<h2 id=\"区分环境\"><a href=\"#区分环境\" class=\"headerlink\" title=\"区分环境\"></a>区分环境</h2><p>我们不能把所有配置都配置在一个 webpack.config.js 中，因为我们有两个环境 development(开发环境)、production(生产环境) ，所以我们在根目录下创建 build文件夹 ，并创建三个文件<br>webpack.base.js ：两个环境共用配置<br>入口，输出配置<br>各种文件的处理<br>进度条展示<br>路径别名<br>webpack.dev.js ：开发环境独有配置<br>webpack-dev-server<br>不同的source-map模式<br>不同的环境变量<br>webpack.prod.js ：生产环境独有配置<br>不同的source-map模式<br>不同的环境变量<br>我们需要先安装一个合并插件 webpack-merge ，用于两个环境的配置可以合并公共的配置<br>npm i webpack-merge -D<br>然后我们在根目录下新建一个 build文件夹 ，并在此文件夹下新建 webpack.base.js、webpack.dev.js、webpack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 公共配置</span><br><span class=\"line\">const path = require(&#x27;path&#x27;)</span><br><span class=\"line\">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class=\"line\">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class=\"line\">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">// 入口文件 main.js</span><br><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  main: &#x27;./src/main.js&#x27;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 输出</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">  // 输出到 dist文件夹</span><br><span class=\"line\">  // 记得改路径</span><br><span class=\"line\">  path: path.resolve(__dirname, &#x27;../dist&#x27;),</span><br><span class=\"line\">  // js文件下</span><br><span class=\"line\">  filename: &#x27;js/chunk-[contenthash].js&#x27;,</span><br><span class=\"line\">  // 每次打包前自动清除旧的dist</span><br><span class=\"line\">  clean: true,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">    // 选择模板 public/index.html</span><br><span class=\"line\">    template: &#x27;./public/index.html&#x27;,</span><br><span class=\"line\">    // 打包后的名字</span><br><span class=\"line\">    filename: &#x27;index.html&#x27;,</span><br><span class=\"line\">    // js文件插入 body里</span><br><span class=\"line\">    inject: &#x27;body&#x27;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  new MiniCssExtractPlugin(&#123;</span><br><span class=\"line\">    // 将css代码输出到dist/styles文件夹下</span><br><span class=\"line\">    filename: &#x27;styles/chunk-[contenthash].css&#x27;,</span><br><span class=\"line\">    ignoreOrder: true,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  new VueLoaderPlugin()</span><br><span class=\"line\">],</span><br><span class=\"line\">module: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 匹配文件后缀的规则</span><br><span class=\"line\">      test: /\\.(css|s[cs]ss)$/,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        // loader执行顺序是从右到左</span><br><span class=\"line\">        MiniCssExtractPlugin.loader,</span><br><span class=\"line\">        &#x27;css-loader&#x27;,</span><br><span class=\"line\">        &#x27;sass-loader&#x27;,</span><br><span class=\"line\">        // &#123;</span><br><span class=\"line\">        //   loader: &#x27;sass-resources-loader&#x27;,</span><br><span class=\"line\">        //   options: &#123;</span><br><span class=\"line\">        //     resources: [</span><br><span class=\"line\">        //       // 放置全局引入的公共scss文件</span><br><span class=\"line\">        //     ],</span><br><span class=\"line\">        //   &#125;,</span><br><span class=\"line\">        // &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 匹配文件后缀的规则</span><br><span class=\"line\">      test: /\\.(png|jpe?g|gif|svg|webp)$/,</span><br><span class=\"line\">      type: &#x27;asset&#x27;,</span><br><span class=\"line\">      parser: &#123;</span><br><span class=\"line\">        // 转base64的条件</span><br><span class=\"line\">        dataUrlCondition: &#123;</span><br><span class=\"line\">          maxSize: 25 * 1024, // 25kb</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      generator: &#123;</span><br><span class=\"line\">        // 打包到 dist/image 文件下</span><br><span class=\"line\">        filename: &#x27;images/[contenthash][ext][query]&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: /\\.js$/,</span><br><span class=\"line\">      // 排除node_modules中的js</span><br><span class=\"line\">      exclude: /node_modules/,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        &#x27;babel-loader&#x27;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: /\\.vue$/,</span><br><span class=\"line\">      use: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">  // 路径别名</span><br><span class=\"line\">  alias: &#123;</span><br><span class=\"line\">    &#x27;@&#x27;: path.resolve(&#x27;./src&#x27;),</span><br><span class=\"line\">    assets: &#x27;~/assets&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 引入文件时省略后缀</span><br><span class=\"line\">  extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.less&#x27;, &#x27;.vue&#x27;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.dev.js</span><br><span class=\"line\">// 开发环境</span><br><span class=\"line\">const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)</span><br><span class=\"line\">const base = require(&#x27;./webpack.base&#x27;)</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">mode: &#x27;development&#x27;,</span><br><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">  open: true,</span><br><span class=\"line\">  // hot: true,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.prod.js</span><br><span class=\"line\">// 生产环境</span><br><span class=\"line\">const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)</span><br><span class=\"line\">const base = require(&#x27;./webpack.base&#x27;)</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">mode: &#x27;production&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后我们到 package.json 修改一下指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;serve&quot;: &quot;webpack serve --config ./build/webpack.dev&quot;,</span><br><span class=\"line\">  &quot;build&quot;: &quot;webpack --config ./build/webpack.prod&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>接下来我们运行这两个命令，发现都成功了：<br>npm run build<br>npm run serve</p>\n<h2 id=\"构建进度条\"><a href=\"#构建进度条\" class=\"headerlink\" title=\"构建进度条\"></a>构建进度条</h2><p>无论是启动项目时还是打包时，都需要进度条的展示，所以需要把进度条配置在 webpack.base 中，我们需要先安装进度条的插件 progress-bar-webpack-plugin</p>\n<p>npm i progress-bar-webpack-plugin -D</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.base.js</span><br><span class=\"line\">// 刚刚的代码...</span><br><span class=\"line\">const ProgressBarPlugin = require(&#x27;progress-bar-webpack-plugin&#x27;)</span><br><span class=\"line\">const chalk = require(&#x27;chalk&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚刚的代码...</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 刚刚的代码...</span><br><span class=\"line\">    new ProgressBarPlugin(&#123;</span><br><span class=\"line\">      format: ` build [:bar] $&#123;chalk.green.bold(&#x27;:percent&#x27;)&#125; (:elapsed seconds)`,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  // 刚刚的代码...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以看到无论启动项目或者打包，都会有进度条了</p>\n<h2 id=\"source-map\"><a href=\"#source-map\" class=\"headerlink\" title=\"source-map\"></a>source-map</h2><p>source-map 的作用：代码报错时，能快速定位到出错位置， webpack5 的所有 source-map模式 可以看webpack官网：<a href=\"https://webpack.docschina.org/\">https://webpack.docschina.org</a>…</p>\n<p>这里我使用两种模式：<br>development ：使用 eval-cheap-module-source-map 模式，能具体定位到源码位置和源码展示，适合开发模式，体积较小<br>production ：使用 nosources-source-map ，只能定位源码位置，不能源码展示，体积较小，适合生产模式<br>所以我们开始配置 source-map</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.dev.js</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">devtool: &#x27;eval-cheap-module-source-map&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">webpack.prod.js</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">devtool: &#x27;nosources-source-map&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>配置 devlopment、production 这两个环境的环境变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.dev.js</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">const webpack = require(&#x27;webpack&#x27;)</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  // 定义全局变量</span><br><span class=\"line\">  new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    process: &#123;</span><br><span class=\"line\">      env: &#123;</span><br><span class=\"line\">        NODE_DEV: JSON.stringify(&#x27;development&#x27;),</span><br><span class=\"line\">        // 这里可以定义你的环境变量</span><br><span class=\"line\">        // VUE_APP_URL: JSON.stringify(&#x27;https://xxx.com&#x27;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.prod.js</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">const webpack = require(&#x27;webpack&#x27;)</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  // 定义全局变量</span><br><span class=\"line\">  new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    process: &#123;</span><br><span class=\"line\">      env: &#123;</span><br><span class=\"line\">        NODE_DEV: JSON.stringify(&#x27;prodction&#x27;),</span><br><span class=\"line\">        // 这里可以定义你的环境变量</span><br><span class=\"line\">        // VUE_APP_URL: JSON.stringify(&#x27;https://xxx.com&#x27;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>大家平时在进行Vue开发的时候，大部分人都是使用 Vue-cli 这个现成的Vue脚手架来进行开发的，但是用它用了这么久，你难道不想自己搭一个属于自己的 Vue-cli 吗？</p>\n<h1 id=\"1、建一个文件夹\"><a href=\"#1、建一个文件夹\" class=\"headerlink\" title=\"1、建一个文件夹\"></a>1、建一个文件夹</h1><p>新建一个文件夹my-vue-cli用来存放项目</p>\n<h1 id=\"2、初始化npm\"><a href=\"#2、初始化npm\" class=\"headerlink\" title=\"2、初始化npm\"></a>2、初始化npm</h1><p>在终端中输入 npm init<br>然后一直回车就行，这样能使项目拥有一个npm管理环境，之后可以在此环境上安装我们所需要的包</p>\n<h1 id=\"3、webpack、webpack-cli\"><a href=\"#3、webpack、webpack-cli\" class=\"headerlink\" title=\"3、webpack、webpack-cli\"></a>3、webpack、webpack-cli</h1><p>安装 webpack、webpack-cli<br>webpack ：打包的工具<br>webpack-cli ：为webpack提供命令行的工具<br>npm i webpack webpack-cli -D</p>\n<h1 id=\"4、src、public\"><a href=\"#4、src、public\" class=\"headerlink\" title=\"4、src、public\"></a>4、src、public</h1><p>在根目录下新建 src、public 这两个文件夹，前者用来放置项目主要代码，后者用来放项目公用静态资源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public/index.html</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;my-vue-cli&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src/main.js</span><br><span class=\"line\">import &#123; add &#125; from &#x27;./tools/add.js&#x27;</span><br><span class=\"line\">console.log(add(1, 2))</span><br><span class=\"line\">console.log(&#x27;我是main.js&#x27;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src/tools/add.js</span><br><span class=\"line\">export const add = (a, b) =&gt; &#123;</span><br><span class=\"line\">return a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"5、入口文件\"><a href=\"#5、入口文件\" class=\"headerlink\" title=\"5、入口文件\"></a>5、入口文件</h1><p>刚刚的 main.js 就是我们的入口文件，也就相当于整个引用树的根节点，webpack打包需要从入口文件开始查找，一直到打包所有引用文件。<br>进行入口文件的配置，在根目录下新建 webpack.config.js ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const path = require(&#x27;path&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 模式 开发模式</span><br><span class=\"line\">  mode: &#x27;development&#x27;,</span><br><span class=\"line\">  // 入口文件 main.js</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: &#x27;./src/main.js&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 输出</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    // 输出到 dist文件夹</span><br><span class=\"line\">    path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class=\"line\">    // js文件下</span><br><span class=\"line\">    filename: &#x27;js/chunk-[contenthash].js&#x27;,</span><br><span class=\"line\">    // 每次打包前自动清除旧的dist</span><br><span class=\"line\">    clean: true,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6、配置打包命令\"><a href=\"#6、配置打包命令\" class=\"headerlink\" title=\"6、配置打包命令\"></a>6、配置打包命令</h1><p>到 package.json 里配置打包命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>现在我们到终端输入 npm run build ，就能发现打包成功：<br>但是这其实不是我们要的目的，我们的目的是将这个打包后的最终js文件，插入到刚刚的 index.html 中，因为js文件得让html文件引用，才有意义嘛！所以我们不仅要打包js，还要打包html<br>小知识：loader和plugin<br>loader ：使webpack拥有解析非js文件的能力，如css、png、ts等等<br>plugin ：拓展webpack的打包功能，如优化体积、显示进度条等等</p>\n<h1 id=\"7、打包html\"><a href=\"#7、打包html\" class=\"headerlink\" title=\"7、打包html\"></a>7、打包html</h1><p>打包html需要用到 html-webpack-plugin 这个插件，也就是plugin，所以需要安装一下：<br>npm i html-webpack-plugin -D<br>并且需要在 webpack.config.js 中配置一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚刚的代码...</span><br><span class=\"line\">  // 插件都放 plugins 中</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      // 选择模板 public/index.html</span><br><span class=\"line\">      template: &#x27;./public/index.html&#x27;,</span><br><span class=\"line\">      // 打包后的名字</span><br><span class=\"line\">      filename: &#x27;index.html&#x27;,</span><br><span class=\"line\">      // js文件插入 body里</span><br><span class=\"line\">      inject: &#x27;body&#x27;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以在终端中执行打包命令 npm run build 可以看到html被打包了，且打包后的html自动引入打包后的js文件<br>现在我们可以打开打包后的 index.html ，发现控制台可以输出，说明成功了！</p>\n<h2 id=\"打包CSS\"><a href=\"#打包CSS\" class=\"headerlink\" title=\"打包CSS\"></a>打包CSS</h2><p>在 src 下新建 styles 文件夹，用来存放样式文件文件src/styles/index.scss</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">body &#123;</span><br><span class=\"line\">background-color: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们在入口文件 main.js 中引入<br>import ‘./styles/index.scss’<br>// 刚刚的代码…<br>我们的目的是，打包 index.scss 这个文件，并且让 index.html 自动引入打包后的css文件，所以我们需要安装以下几个东<br>sass、sass-loader ：可以将scss代码转成css<br>css-loader ：使webpack具有打包css的能力<br>sass-resources-loader ：可选，支持打包全局公共scss文件<br>mini-css-extract-plugin ：可将css代码打包成一个单独的css文件<br>我们安装一下这些插件<br>npm i sass sass-loader sass-resources-loader mini-css-extract-plugin -D<br>然后配置一下 webpack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚才的代码...</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 刚才的代码...</span><br><span class=\"line\">    new MiniCssExtractPlugin(&#123;</span><br><span class=\"line\">      // 将css代码输出到dist/styles文件夹下</span><br><span class=\"line\">      filename: &#x27;styles/chunk-[contenthash].css&#x27;,</span><br><span class=\"line\">      ignoreOrder: true,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        // 匹配文件后缀的规则</span><br><span class=\"line\">        test: /\\.(css|s[cs]ss)$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          // loader执行顺序是从右到左</span><br><span class=\"line\">          MiniCssExtractPlugin.loader,</span><br><span class=\"line\">          &#x27;css-loader&#x27;,</span><br><span class=\"line\">          &#x27;sass-loader&#x27;,</span><br><span class=\"line\">          // &#123;</span><br><span class=\"line\">          //   loader: &#x27;sass-resources-loader&#x27;,</span><br><span class=\"line\">          //   options: &#123;</span><br><span class=\"line\">          //     resources: [</span><br><span class=\"line\">          //       // 放置全局引入的公共scss文件</span><br><span class=\"line\">          //     ],</span><br><span class=\"line\">          //   &#125;,</span><br><span class=\"line\">          // &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时我们重新执行打包命令 npm run build ，可以发现出现了打包后的css文件，且 index.html 中自动引入了css文件：<br>我们可以看看页面，可以看到，body的背景已经变成蓝色，说明有效果了.</p>\n<h2 id=\"打包图片\"><a href=\"#打包图片\" class=\"headerlink\" title=\"打包图片\"></a>打包图片</h2><p>webpack5中已经废弃了 url-loader ，打包图片可以使用 asset-module ，我们先放置一张图片在 src/assets/images 中：并且改写一下 index.css</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">body &#123;</span><br><span class=\"line\">  width: 100vw;</span><br><span class=\"line\">  height: 100vh;</span><br><span class=\"line\">  // 引入背景图片</span><br><span class=\"line\">  background-image: url(&#x27;../assets/images/guang.png&#x27;);</span><br><span class=\"line\">  background-size: 100% 100%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们在 webpack.config.js 中添加打包图片的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    // 刚刚的代码...</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 匹配文件后缀的规则</span><br><span class=\"line\">      test: /\\.(png|jpe?g|gif|svg|webp)$/,</span><br><span class=\"line\">      type: &#x27;asset&#x27;,</span><br><span class=\"line\">      parser: &#123;</span><br><span class=\"line\">        // 转base64的条件</span><br><span class=\"line\">        dataUrlCondition: &#123;</span><br><span class=\"line\">           maxSize: 25 * 1024, // 25kb</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      generator: &#123;</span><br><span class=\"line\">        // 打包到 dist/image 文件下</span><br><span class=\"line\">       filename: &#x27;images/[contenthash][ext][query]&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  我们现在重新运行一下 npm run build ，发现dist下已经有了 images 这个文件夹<br>  我们看一下页面背景图片已经生效，说明打包成功了！</p>\n<h2 id=\"配置babel\"><a href=\"#配置babel\" class=\"headerlink\" title=\"配置babel\"></a>配置babel</h2><p>babel 可以将我们项目中的高级语法转化成比较低级的语法，比如可以将 ES6 转为 ES5 ，这样可以兼容一些低版本浏览器，所以是很有必要的</p>\n<p>首先安装所需的包：<br>@babel/core、babel-loader ：转换语法的工具<br>@babel/preset-env ：转换的一套现成规则<br>@babel/plugin-transform-runtime ：转换async/await所需插件</p>\n<p>npm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime -D<br>由于 babel 是针对js文件的语法转换，所以我们需要在 webpack.config.js 中去针对js进行操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    // 刚刚的代码...</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 匹配js后缀文件</span><br><span class=\"line\">      test: /\\.js$/,</span><br><span class=\"line\">      // 排除node_modules中的js</span><br><span class=\"line\">      exclude: /node_modules/,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        &#x27;babel-loader&#x27;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>单单配置了 babel-loader 还是不够的，我们还需要配置 babel 转换的规则，所以需要在根目录下创建 babel.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// babel.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">presets: [</span><br><span class=\"line\">  // 配置规则</span><br><span class=\"line\">  &quot;@babel/preset-env&quot;</span><br><span class=\"line\">],</span><br><span class=\"line\">// 配置插件</span><br><span class=\"line\">plugins: [&quot;@babel/plugin-transform-runtime&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时我们重新运行打包 npm run build ，我们可以发现打包后的js代码中，已经把刚刚代码中的 ES6 语法转成 ES5 语法了！可以看到刚刚代码中的 const 已经转成 ES5 语法了</p>\n<h2 id=\"打包Vue\"><a href=\"#打包Vue\" class=\"headerlink\" title=\"打包Vue\"></a>打包Vue</h2><p>打包Vue需要用到以下几个包：<br>vue ：Vue开发所需的依赖<br>vue-loader ：解析 .vue 文件的loader<br>vue-template-compiler ：解析vue中模板的工具<br>@vue/babel-preset-jsx ：支持解析vue中的jsx语法<br>注意： vue 和 vue-template-compiler 版本需要一致，这里我使用 2.6.14 这个版本， vue-loader 这里我使用了 15.9.8 这个版本<br>所以我们先安装一下：<br>npm i<br><a href=\"mailto:&#118;&#117;&#101;&#x40;&#50;&#x2e;&#x36;&#x2e;&#x31;&#x34;\">&#118;&#117;&#101;&#x40;&#50;&#x2e;&#x36;&#x2e;&#x31;&#x34;</a> <a href=\"mailto:&#118;&#117;&#101;&#45;&#x74;&#x65;&#109;&#112;&#108;&#x61;&#x74;&#101;&#45;&#x63;&#x6f;&#x6d;&#x70;&#105;&#108;&#101;&#x72;&#64;&#x32;&#x2e;&#x36;&#x2e;&#x31;&#x34;\">&#118;&#117;&#101;&#45;&#x74;&#x65;&#109;&#112;&#108;&#x61;&#x74;&#101;&#45;&#x63;&#x6f;&#x6d;&#x70;&#105;&#108;&#101;&#x72;&#64;&#x32;&#x2e;&#x36;&#x2e;&#x31;&#x34;</a> <a href=\"mailto:&#118;&#x75;&#x65;&#45;&#108;&#x6f;&#x61;&#100;&#101;&#x72;&#64;&#x31;&#53;&#46;&#x39;&#46;&#56;\">&#118;&#x75;&#x65;&#45;&#108;&#x6f;&#x61;&#100;&#101;&#x72;&#64;&#x31;&#53;&#46;&#x39;&#46;&#56;</a> @vue/babel-preset-jsx -D<br>然后我们需要去 webpack.config.js 中配置对 .vue 文件的解析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚才的代码...</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 刚才的代码...</span><br><span class=\"line\">    new VueLoaderPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      // 刚才的代码...</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        use: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且到 babel.config.js 中配置一下，让webpack支持 .vue 文件中的 jsx 语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  presets: [</span><br><span class=\"line\">    &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">    // 支持vue中的jsx语法</span><br><span class=\"line\">    &quot;@vue/babel-preset-jsx&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  plugins: [&quot;@babel/plugin-transform-runtime&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以在 src 下新建一个 App.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;box&quot;&gt;我是App哈哈哈哈&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class=\"line\">.box &#123;</span><br><span class=\"line\">  width: 500px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  background-color: #000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>然后改写一下 src/main.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  render: (h) =&gt; h(App),</span><br><span class=\"line\">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>\n<p>此时我们重新运行 npm run build ，我们可以看看页面的效果，说明打包成功啦！</p>\n<h2 id=\"配置路径别名\"><a href=\"#配置路径别名\" class=\"headerlink\" title=\"配置路径别名\"></a>配置路径别名</h2><p>有时候文件引用搁着太多层，引用起来会看起来很不明确，比如<br>../../../../../App.vue ，所以我们可以配置一下别名 alia</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚才的代码...</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    // 路径别名</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      &#x27;@&#x27;: path.resolve(&#x27;./src&#x27;),</span><br><span class=\"line\">      assets: &#x27;~/assets&#x27;,</span><br><span class=\"line\">      tools: &#x27;~/tools&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 引入文件时省略后缀</span><br><span class=\"line\">    extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.less&#x27;, &#x27;.vue&#x27;],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在别名配置完成啦：<br>配置前： ../../../../../App.vue<br>配置后： @/App.vue</p>\n<h2 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack-dev-server\"></a>webpack-dev-server</h2><p>刚刚我们发现，每改一次代码就得重新打包一次，非常繁琐，有没有可以改代码自动重新打包的呢？这就要用到 webpack-dev-server</p>\n<p>npm i webpack-dev-server -D<br>到 webpack.config.js 中配置 devServer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">  // 自定义端口号</span><br><span class=\"line\">  // port:7000,</span><br><span class=\"line\">  // 自动打开浏览器</span><br><span class=\"line\">  open: true</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>然后到 package.json 中配置一下启动命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;build&quot;: &quot;webpack&quot;,</span><br><span class=\"line\">  &quot;serve&quot;: &quot;webpack serve&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>此时我们运行 npm run serve 就可以启动项目啦！</p>\n<h2 id=\"区分环境\"><a href=\"#区分环境\" class=\"headerlink\" title=\"区分环境\"></a>区分环境</h2><p>我们不能把所有配置都配置在一个 webpack.config.js 中，因为我们有两个环境 development(开发环境)、production(生产环境) ，所以我们在根目录下创建 build文件夹 ，并创建三个文件<br>webpack.base.js ：两个环境共用配置<br>入口，输出配置<br>各种文件的处理<br>进度条展示<br>路径别名<br>webpack.dev.js ：开发环境独有配置<br>webpack-dev-server<br>不同的source-map模式<br>不同的环境变量<br>webpack.prod.js ：生产环境独有配置<br>不同的source-map模式<br>不同的环境变量<br>我们需要先安装一个合并插件 webpack-merge ，用于两个环境的配置可以合并公共的配置<br>npm i webpack-merge -D<br>然后我们在根目录下新建一个 build文件夹 ，并在此文件夹下新建 webpack.base.js、webpack.dev.js、webpack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 公共配置</span><br><span class=\"line\">const path = require(&#x27;path&#x27;)</span><br><span class=\"line\">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class=\"line\">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class=\"line\">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">// 入口文件 main.js</span><br><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  main: &#x27;./src/main.js&#x27;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 输出</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">  // 输出到 dist文件夹</span><br><span class=\"line\">  // 记得改路径</span><br><span class=\"line\">  path: path.resolve(__dirname, &#x27;../dist&#x27;),</span><br><span class=\"line\">  // js文件下</span><br><span class=\"line\">  filename: &#x27;js/chunk-[contenthash].js&#x27;,</span><br><span class=\"line\">  // 每次打包前自动清除旧的dist</span><br><span class=\"line\">  clean: true,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">    // 选择模板 public/index.html</span><br><span class=\"line\">    template: &#x27;./public/index.html&#x27;,</span><br><span class=\"line\">    // 打包后的名字</span><br><span class=\"line\">    filename: &#x27;index.html&#x27;,</span><br><span class=\"line\">    // js文件插入 body里</span><br><span class=\"line\">    inject: &#x27;body&#x27;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  new MiniCssExtractPlugin(&#123;</span><br><span class=\"line\">    // 将css代码输出到dist/styles文件夹下</span><br><span class=\"line\">    filename: &#x27;styles/chunk-[contenthash].css&#x27;,</span><br><span class=\"line\">    ignoreOrder: true,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  new VueLoaderPlugin()</span><br><span class=\"line\">],</span><br><span class=\"line\">module: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 匹配文件后缀的规则</span><br><span class=\"line\">      test: /\\.(css|s[cs]ss)$/,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        // loader执行顺序是从右到左</span><br><span class=\"line\">        MiniCssExtractPlugin.loader,</span><br><span class=\"line\">        &#x27;css-loader&#x27;,</span><br><span class=\"line\">        &#x27;sass-loader&#x27;,</span><br><span class=\"line\">        // &#123;</span><br><span class=\"line\">        //   loader: &#x27;sass-resources-loader&#x27;,</span><br><span class=\"line\">        //   options: &#123;</span><br><span class=\"line\">        //     resources: [</span><br><span class=\"line\">        //       // 放置全局引入的公共scss文件</span><br><span class=\"line\">        //     ],</span><br><span class=\"line\">        //   &#125;,</span><br><span class=\"line\">        // &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 匹配文件后缀的规则</span><br><span class=\"line\">      test: /\\.(png|jpe?g|gif|svg|webp)$/,</span><br><span class=\"line\">      type: &#x27;asset&#x27;,</span><br><span class=\"line\">      parser: &#123;</span><br><span class=\"line\">        // 转base64的条件</span><br><span class=\"line\">        dataUrlCondition: &#123;</span><br><span class=\"line\">          maxSize: 25 * 1024, // 25kb</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      generator: &#123;</span><br><span class=\"line\">        // 打包到 dist/image 文件下</span><br><span class=\"line\">        filename: &#x27;images/[contenthash][ext][query]&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: /\\.js$/,</span><br><span class=\"line\">      // 排除node_modules中的js</span><br><span class=\"line\">      exclude: /node_modules/,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        &#x27;babel-loader&#x27;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: /\\.vue$/,</span><br><span class=\"line\">      use: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">  // 路径别名</span><br><span class=\"line\">  alias: &#123;</span><br><span class=\"line\">    &#x27;@&#x27;: path.resolve(&#x27;./src&#x27;),</span><br><span class=\"line\">    assets: &#x27;~/assets&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 引入文件时省略后缀</span><br><span class=\"line\">  extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.less&#x27;, &#x27;.vue&#x27;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.dev.js</span><br><span class=\"line\">// 开发环境</span><br><span class=\"line\">const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)</span><br><span class=\"line\">const base = require(&#x27;./webpack.base&#x27;)</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">mode: &#x27;development&#x27;,</span><br><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">  open: true,</span><br><span class=\"line\">  // hot: true,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.prod.js</span><br><span class=\"line\">// 生产环境</span><br><span class=\"line\">const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)</span><br><span class=\"line\">const base = require(&#x27;./webpack.base&#x27;)</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">mode: &#x27;production&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后我们到 package.json 修改一下指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;serve&quot;: &quot;webpack serve --config ./build/webpack.dev&quot;,</span><br><span class=\"line\">  &quot;build&quot;: &quot;webpack --config ./build/webpack.prod&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>接下来我们运行这两个命令，发现都成功了：<br>npm run build<br>npm run serve</p>\n<h2 id=\"构建进度条\"><a href=\"#构建进度条\" class=\"headerlink\" title=\"构建进度条\"></a>构建进度条</h2><p>无论是启动项目时还是打包时，都需要进度条的展示，所以需要把进度条配置在 webpack.base 中，我们需要先安装进度条的插件 progress-bar-webpack-plugin</p>\n<p>npm i progress-bar-webpack-plugin -D</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.base.js</span><br><span class=\"line\">// 刚刚的代码...</span><br><span class=\"line\">const ProgressBarPlugin = require(&#x27;progress-bar-webpack-plugin&#x27;)</span><br><span class=\"line\">const chalk = require(&#x27;chalk&#x27;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 刚刚的代码...</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 刚刚的代码...</span><br><span class=\"line\">    new ProgressBarPlugin(&#123;</span><br><span class=\"line\">      format: ` build [:bar] $&#123;chalk.green.bold(&#x27;:percent&#x27;)&#125; (:elapsed seconds)`,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  // 刚刚的代码...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以看到无论启动项目或者打包，都会有进度条了</p>\n<h2 id=\"source-map\"><a href=\"#source-map\" class=\"headerlink\" title=\"source-map\"></a>source-map</h2><p>source-map 的作用：代码报错时，能快速定位到出错位置， webpack5 的所有 source-map模式 可以看webpack官网：<a href=\"https://webpack.docschina.org/\">https://webpack.docschina.org</a>…</p>\n<p>这里我使用两种模式：<br>development ：使用 eval-cheap-module-source-map 模式，能具体定位到源码位置和源码展示，适合开发模式，体积较小<br>production ：使用 nosources-source-map ，只能定位源码位置，不能源码展示，体积较小，适合生产模式<br>所以我们开始配置 source-map</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.dev.js</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">devtool: &#x27;eval-cheap-module-source-map&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">webpack.prod.js</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">devtool: &#x27;nosources-source-map&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>配置 devlopment、production 这两个环境的环境变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.dev.js</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">const webpack = require(&#x27;webpack&#x27;)</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  // 定义全局变量</span><br><span class=\"line\">  new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    process: &#123;</span><br><span class=\"line\">      env: &#123;</span><br><span class=\"line\">        NODE_DEV: JSON.stringify(&#x27;development&#x27;),</span><br><span class=\"line\">        // 这里可以定义你的环境变量</span><br><span class=\"line\">        // VUE_APP_URL: JSON.stringify(&#x27;https://xxx.com&#x27;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack.prod.js</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">const webpack = require(&#x27;webpack&#x27;)</span><br><span class=\"line\">module.exports = merge(base, &#123;</span><br><span class=\"line\">// 刚才的代码...</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  // 定义全局变量</span><br><span class=\"line\">  new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    process: &#123;</span><br><span class=\"line\">      env: &#123;</span><br><span class=\"line\">        NODE_DEV: JSON.stringify(&#x27;prodction&#x27;),</span><br><span class=\"line\">        // 这里可以定义你的环境变量</span><br><span class=\"line\">        // VUE_APP_URL: JSON.stringify(&#x27;https://xxx.com&#x27;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Vue-axios","date":"2022-12-19T10:08:31.000Z","_content":"众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。\n说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？\n在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。\n如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～\n\n# 一、前端从后端获取数据的方式通常采用http/https的方式\n方法通常有GET、POST、PUT、DELETE、PATCH这五种；\nGET==>用来获取数据，\nPOST==> 是用来新增数据表单提交或文件上传\nDELETE==>是用来删除数据\nPUT==>是用来更新数据（所有数据推送到后端）\nPATCH==>是用来更新数据（只将修改的数据推送到后端）\n# 二、从前端请求后端接口获取数据格式：\nGET方法：\n## 1、axios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n## 2、axios({method:'get',url:'xxxxx',config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。\n\n## POST方法（appcation/json或者form-data）：\n### 1、①appcation/json方式\n```\nlet data={id:12}\naxios.post(url,data,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n\n### ②appcation/json方式：\n```\nlet data={id:12}\naxios({method:'post',url,data:data,config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n\n### 2、①form-data方式\n```\nlet data={id:12}\nlet formData = new FormData()\nfor(let key in data){\nformData.append(key,data[key])\n}\naxios.post(url,formData,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n### ②form-data方式\n```\nlet data={id:12}\nlet formData = new FormData()\nfor(let key in data){\nformData.append(key,data[key])\n}\naxios({method:'post',url,formData:formData,config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\npost请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。\n## PUT和PATCH方式：\nput和patch跟post一样，就方法不一样而已，参考post方法。\n## DELETE方式：\n类似get方式，就方法不一样而已，参考get方法。\n可以在config中设置基础URL，超时时间、传参方式、请求头等信息，\n注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。\n# 三、axios并发请求\n## 并发请求：同时进行多个请求，并统一处理返回值。\n比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。\n这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。\n## axios.all()和axios.spread()方法\n其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。\n比如：arr[] =[axios.get(url),axios.post(url,data,config)]\n## 另一个axios.spread((A,B)=>{})\n这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。\n具体用法：\n```\naxios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=>{}))\n```\n# 四、axios实例\n你会不会有这样一个疑问，就是为什么要用axios实例呢？\n那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，\n那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。\n具体用法：\n```\nlet instance = axios.create(config);\ninstance.get(url).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n# 五、关于请求中的config\n```\nconfig的格式为：\n{\nbaseURL:'http:/xxxxxx', //基础url\ntimeout:6000, //超时时间\nurl:xxxxxx, //具体url\nmethod:'get/post/put/patch/delete', //请求方式\nheaders:{token:'xxxxx'等}, //请求头设置\nparams:{}, //请求参数对象，它会将请求参数拼接到url上\ndata:{} //请求参数对象，它会将请求参数放到请求体中\n}\n```\nconfig应用场景\n## 1、全局配置\n```\naxios.defaults.timeout = 1000\naxios.defaults.baseURL = 'http://XXXXX'\n```\n## 2、实例配置\n在axios创建实例中配置\n```\nlet instance = axios.create();\ninstance.defaults.timeout = 1000\n```\n## 3、请求配置\n在请求中配置\n```\naxios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n其中，配置优先级为：3>2>1\n# 六、axios拦截器\n## 什么是拦截器？\n拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。\n一般分为请求拦截器和响应拦截器两种。\n## 请求拦截器\n请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。\n```\nservice.interceptors.request.use(\nconfig => {\n//在发送请求前的额外处理\nreturn config\n},\n)\n```\n## 响应拦截器\n响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。\n```\nservice.interceptors.response.use(\nres => {\n//响应之后做一些额外操作\nreturn res\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：\naxios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n例子：发送请求前，在请求头中添加token，就可以用拦截器来实现\n```\nlet instance = axios.create(config);\ninstance.interceptors.request.use(confit=>{\nconfig.headers.token=\"sssssss\"\nreturn config\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n```\n## 取消拦截器\n顾名思义就是取消掉已经配置的拦截器\n\n例子：\n```\nlet instance = axios.create(config);\ninstance.interceptors.request.use(\nconfig=>{\nconfig.headers.token=\"sssssss\"\nreturn config\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n//取消拦截器操作：\naxios.interceptors.request.eject(instance)\n```\n# 七、取消请求\n取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，\n这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法\n例子：\n```\naxios.CancelToken.source()\naxios.get(url,{CancelToken:source,token}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n//触发取消请求：\nsource.cancel('错误信息')\n```\n就可以了\n\n\n\n","source":"_posts/Vue-axios.md","raw":"---\ntitle: Vue-axios\ndate: 2022-12-19 18:08:31\ntags: vue\ncategories: 知识点\n---\n众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。\n说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？\n在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。\n如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～\n\n# 一、前端从后端获取数据的方式通常采用http/https的方式\n方法通常有GET、POST、PUT、DELETE、PATCH这五种；\nGET==>用来获取数据，\nPOST==> 是用来新增数据表单提交或文件上传\nDELETE==>是用来删除数据\nPUT==>是用来更新数据（所有数据推送到后端）\nPATCH==>是用来更新数据（只将修改的数据推送到后端）\n# 二、从前端请求后端接口获取数据格式：\nGET方法：\n## 1、axios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n## 2、axios({method:'get',url:'xxxxx',config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。\n\n## POST方法（appcation/json或者form-data）：\n### 1、①appcation/json方式\n```\nlet data={id:12}\naxios.post(url,data,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n\n### ②appcation/json方式：\n```\nlet data={id:12}\naxios({method:'post',url,data:data,config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n\n### 2、①form-data方式\n```\nlet data={id:12}\nlet formData = new FormData()\nfor(let key in data){\nformData.append(key,data[key])\n}\naxios.post(url,formData,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n### ②form-data方式\n```\nlet data={id:12}\nlet formData = new FormData()\nfor(let key in data){\nformData.append(key,data[key])\n}\naxios({method:'post',url,formData:formData,config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\npost请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。\n## PUT和PATCH方式：\nput和patch跟post一样，就方法不一样而已，参考post方法。\n## DELETE方式：\n类似get方式，就方法不一样而已，参考get方法。\n可以在config中设置基础URL，超时时间、传参方式、请求头等信息，\n注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。\n# 三、axios并发请求\n## 并发请求：同时进行多个请求，并统一处理返回值。\n比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。\n这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。\n## axios.all()和axios.spread()方法\n其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。\n比如：arr[] =[axios.get(url),axios.post(url,data,config)]\n## 另一个axios.spread((A,B)=>{})\n这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。\n具体用法：\n```\naxios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=>{}))\n```\n# 四、axios实例\n你会不会有这样一个疑问，就是为什么要用axios实例呢？\n那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，\n那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。\n具体用法：\n```\nlet instance = axios.create(config);\ninstance.get(url).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n# 五、关于请求中的config\n```\nconfig的格式为：\n{\nbaseURL:'http:/xxxxxx', //基础url\ntimeout:6000, //超时时间\nurl:xxxxxx, //具体url\nmethod:'get/post/put/patch/delete', //请求方式\nheaders:{token:'xxxxx'等}, //请求头设置\nparams:{}, //请求参数对象，它会将请求参数拼接到url上\ndata:{} //请求参数对象，它会将请求参数放到请求体中\n}\n```\nconfig应用场景\n## 1、全局配置\n```\naxios.defaults.timeout = 1000\naxios.defaults.baseURL = 'http://XXXXX'\n```\n## 2、实例配置\n在axios创建实例中配置\n```\nlet instance = axios.create();\ninstance.defaults.timeout = 1000\n```\n## 3、请求配置\n在请求中配置\n```\naxios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n其中，配置优先级为：3>2>1\n# 六、axios拦截器\n## 什么是拦截器？\n拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。\n一般分为请求拦截器和响应拦截器两种。\n## 请求拦截器\n请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。\n```\nservice.interceptors.request.use(\nconfig => {\n//在发送请求前的额外处理\nreturn config\n},\n)\n```\n## 响应拦截器\n响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。\n```\nservice.interceptors.response.use(\nres => {\n//响应之后做一些额外操作\nreturn res\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：\naxios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n```\n例子：发送请求前，在请求头中添加token，就可以用拦截器来实现\n```\nlet instance = axios.create(config);\ninstance.interceptors.request.use(confit=>{\nconfig.headers.token=\"sssssss\"\nreturn config\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n```\n## 取消拦截器\n顾名思义就是取消掉已经配置的拦截器\n\n例子：\n```\nlet instance = axios.create(config);\ninstance.interceptors.request.use(\nconfig=>{\nconfig.headers.token=\"sssssss\"\nreturn config\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n//取消拦截器操作：\naxios.interceptors.request.eject(instance)\n```\n# 七、取消请求\n取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，\n这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法\n例子：\n```\naxios.CancelToken.source()\naxios.get(url,{CancelToken:source,token}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n//触发取消请求：\nsource.cancel('错误信息')\n```\n就可以了\n\n\n\n","slug":"Vue-axios","published":1,"updated":"2023-04-03T04:36:32.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml10009tit8e6lh73ra","content":"<p>众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。<br>说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？<br>在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。<br>如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～</p>\n<h1 id=\"一、前端从后端获取数据的方式通常采用http-https的方式\"><a href=\"#一、前端从后端获取数据的方式通常采用http-https的方式\" class=\"headerlink\" title=\"一、前端从后端获取数据的方式通常采用http/https的方式\"></a>一、前端从后端获取数据的方式通常采用http/https的方式</h1><p>方法通常有GET、POST、PUT、DELETE、PATCH这五种；<br>GET==&gt;用来获取数据，<br>POST==&gt; 是用来新增数据表单提交或文件上传<br>DELETE==&gt;是用来删除数据<br>PUT==&gt;是用来更新数据（所有数据推送到后端）<br>PATCH==&gt;是用来更新数据（只将修改的数据推送到后端）</p>\n<h1 id=\"二、从前端请求后端接口获取数据格式：\"><a href=\"#二、从前端请求后端接口获取数据格式：\" class=\"headerlink\" title=\"二、从前端请求后端接口获取数据格式：\"></a>二、从前端请求后端接口获取数据格式：</h1><p>GET方法：</p>\n<h2 id=\"1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\"><a href=\"#1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\" class=\"headerlink\" title=\"1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})\"></a>1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><h2 id=\"2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\"><a href=\"#2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\" class=\"headerlink\" title=\"2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})\"></a>2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><p>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。</p>\n<h2 id=\"POST方法（appcation-json或者form-data）：\"><a href=\"#POST方法（appcation-json或者form-data）：\" class=\"headerlink\" title=\"POST方法（appcation/json或者form-data）：\"></a>POST方法（appcation/json或者form-data）：</h2><h3 id=\"1、①appcation-json方式\"><a href=\"#1、①appcation-json方式\" class=\"headerlink\" title=\"1、①appcation/json方式\"></a>1、①appcation/json方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let data=&#123;id:12&#125;</span><br><span class=\"line\">axios.post(url,data,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"②appcation-json方式：\"><a href=\"#②appcation-json方式：\" class=\"headerlink\" title=\"②appcation/json方式：\"></a>②appcation/json方式：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let data=&#123;id:12&#125;</span><br><span class=\"line\">axios(&#123;method:&#x27;post&#x27;,url,data:data,config&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、①form-data方式\"><a href=\"#2、①form-data方式\" class=\"headerlink\" title=\"2、①form-data方式\"></a>2、①form-data方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let data=&#123;id:12&#125;</span><br><span class=\"line\">let formData = new FormData()</span><br><span class=\"line\">for(let key in data)&#123;</span><br><span class=\"line\">formData.append(key,data[key])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.post(url,formData,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"②form-data方式\"><a href=\"#②form-data方式\" class=\"headerlink\" title=\"②form-data方式\"></a>②form-data方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let data=&#123;id:12&#125;</span><br><span class=\"line\">let formData = new FormData()</span><br><span class=\"line\">for(let key in data)&#123;</span><br><span class=\"line\">formData.append(key,data[key])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios(&#123;method:&#x27;post&#x27;,url,formData:formData,config&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<p>post请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。</p>\n<h2 id=\"PUT和PATCH方式：\"><a href=\"#PUT和PATCH方式：\" class=\"headerlink\" title=\"PUT和PATCH方式：\"></a>PUT和PATCH方式：</h2><p>put和patch跟post一样，就方法不一样而已，参考post方法。</p>\n<h2 id=\"DELETE方式：\"><a href=\"#DELETE方式：\" class=\"headerlink\" title=\"DELETE方式：\"></a>DELETE方式：</h2><p>类似get方式，就方法不一样而已，参考get方法。<br>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，<br>注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。</p>\n<h1 id=\"三、axios并发请求\"><a href=\"#三、axios并发请求\" class=\"headerlink\" title=\"三、axios并发请求\"></a>三、axios并发请求</h1><h2 id=\"并发请求：同时进行多个请求，并统一处理返回值。\"><a href=\"#并发请求：同时进行多个请求，并统一处理返回值。\" class=\"headerlink\" title=\"并发请求：同时进行多个请求，并统一处理返回值。\"></a>并发请求：同时进行多个请求，并统一处理返回值。</h2><p>比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。<br>这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。</p>\n<h2 id=\"axios-all-和axios-spread-方法\"><a href=\"#axios-all-和axios-spread-方法\" class=\"headerlink\" title=\"axios.all()和axios.spread()方法\"></a>axios.all()和axios.spread()方法</h2><p>其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。<br>比如：arr[] =[axios.get(url),axios.post(url,data,config)]</p>\n<h2 id=\"另一个axios-spread-A-B-gt\"><a href=\"#另一个axios-spread-A-B-gt\" class=\"headerlink\" title=\"另一个axios.spread((A,B)=&gt;{})\"></a>另一个axios.spread((A,B)=&gt;{})</h2><p>这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。<br>具体用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=&gt;&#123;&#125;))</span><br></pre></td></tr></table></figure>\n<h1 id=\"四、axios实例\"><a href=\"#四、axios实例\" class=\"headerlink\" title=\"四、axios实例\"></a>四、axios实例</h1><p>你会不会有这样一个疑问，就是为什么要用axios实例呢？<br>那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，<br>那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。<br>具体用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let instance = axios.create(config);</span><br><span class=\"line\">instance.get(url).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"五、关于请求中的config\"><a href=\"#五、关于请求中的config\" class=\"headerlink\" title=\"五、关于请求中的config\"></a>五、关于请求中的config</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config的格式为：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">baseURL:&#x27;http:/xxxxxx&#x27;, //基础url</span><br><span class=\"line\">timeout:6000, //超时时间</span><br><span class=\"line\">url:xxxxxx, //具体url</span><br><span class=\"line\">method:&#x27;get/post/put/patch/delete&#x27;, //请求方式</span><br><span class=\"line\">headers:&#123;token:&#x27;xxxxx&#x27;等&#125;, //请求头设置</span><br><span class=\"line\">params:&#123;&#125;, //请求参数对象，它会将请求参数拼接到url上</span><br><span class=\"line\">data:&#123;&#125; //请求参数对象，它会将请求参数放到请求体中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>config应用场景</p>\n<h2 id=\"1、全局配置\"><a href=\"#1、全局配置\" class=\"headerlink\" title=\"1、全局配置\"></a>1、全局配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.defaults.timeout = 1000</span><br><span class=\"line\">axios.defaults.baseURL = &#x27;http://XXXXX&#x27;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、实例配置\"><a href=\"#2、实例配置\" class=\"headerlink\" title=\"2、实例配置\"></a>2、实例配置</h2><p>在axios创建实例中配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let instance = axios.create();</span><br><span class=\"line\">instance.defaults.timeout = 1000</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、请求配置\"><a href=\"#3、请求配置\" class=\"headerlink\" title=\"3、请求配置\"></a>3、请求配置</h2><p>在请求中配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.get(url,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中，配置优先级为：3&gt;2&gt;1</p>\n<h1 id=\"六、axios拦截器\"><a href=\"#六、axios拦截器\" class=\"headerlink\" title=\"六、axios拦截器\"></a>六、axios拦截器</h1><h2 id=\"什么是拦截器？\"><a href=\"#什么是拦截器？\" class=\"headerlink\" title=\"什么是拦截器？\"></a>什么是拦截器？</h2><p>拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。<br>一般分为请求拦截器和响应拦截器两种。</p>\n<h2 id=\"请求拦截器\"><a href=\"#请求拦截器\" class=\"headerlink\" title=\"请求拦截器\"></a>请求拦截器</h2><p>请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service.interceptors.request.use(</span><br><span class=\"line\">config =&gt; &#123;</span><br><span class=\"line\">//在发送请求前的额外处理</span><br><span class=\"line\">return config</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"响应拦截器\"><a href=\"#响应拦截器\" class=\"headerlink\" title=\"响应拦截器\"></a>响应拦截器</h2><p>响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service.interceptors.response.use(</span><br><span class=\"line\">res =&gt; &#123;</span><br><span class=\"line\">//响应之后做一些额外操作</span><br><span class=\"line\">return res</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">error =&gt; &#123;</span><br><span class=\"line\">//在发生错误后的额外处理</span><br><span class=\"line\">return Promise.reject(error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：</span><br><span class=\"line\">axios.get(url,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<p>例子：发送请求前，在请求头中添加token，就可以用拦截器来实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let instance = axios.create(config);</span><br><span class=\"line\">instance.interceptors.request.use(confit=&gt;&#123;</span><br><span class=\"line\">config.headers.token=&quot;sssssss&quot;</span><br><span class=\"line\">return config</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">error =&gt; &#123;</span><br><span class=\"line\">//在发生错误后的额外处理</span><br><span class=\"line\">return Promise.reject(error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"取消拦截器\"><a href=\"#取消拦截器\" class=\"headerlink\" title=\"取消拦截器\"></a>取消拦截器</h2><p>顾名思义就是取消掉已经配置的拦截器</p>\n<p>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let instance = axios.create(config);</span><br><span class=\"line\">instance.interceptors.request.use(</span><br><span class=\"line\">config=&gt;&#123;</span><br><span class=\"line\">config.headers.token=&quot;sssssss&quot;</span><br><span class=\"line\">return config</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">error =&gt; &#123;</span><br><span class=\"line\">//在发生错误后的额外处理</span><br><span class=\"line\">return Promise.reject(error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">//取消拦截器操作：</span><br><span class=\"line\">axios.interceptors.request.eject(instance)</span><br></pre></td></tr></table></figure>\n<h1 id=\"七、取消请求\"><a href=\"#七、取消请求\" class=\"headerlink\" title=\"七、取消请求\"></a>七、取消请求</h1><p>取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，<br>这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法<br>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.CancelToken.source()</span><br><span class=\"line\">axios.get(url,&#123;CancelToken:source,token&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br><span class=\"line\">//触发取消请求：</span><br><span class=\"line\">source.cancel(&#x27;错误信息&#x27;)</span><br></pre></td></tr></table></figure>\n<p>就可以了</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。<br>说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？<br>在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。<br>如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～</p>\n<h1 id=\"一、前端从后端获取数据的方式通常采用http-https的方式\"><a href=\"#一、前端从后端获取数据的方式通常采用http-https的方式\" class=\"headerlink\" title=\"一、前端从后端获取数据的方式通常采用http/https的方式\"></a>一、前端从后端获取数据的方式通常采用http/https的方式</h1><p>方法通常有GET、POST、PUT、DELETE、PATCH这五种；<br>GET==&gt;用来获取数据，<br>POST==&gt; 是用来新增数据表单提交或文件上传<br>DELETE==&gt;是用来删除数据<br>PUT==&gt;是用来更新数据（所有数据推送到后端）<br>PATCH==&gt;是用来更新数据（只将修改的数据推送到后端）</p>\n<h1 id=\"二、从前端请求后端接口获取数据格式：\"><a href=\"#二、从前端请求后端接口获取数据格式：\" class=\"headerlink\" title=\"二、从前端请求后端接口获取数据格式：\"></a>二、从前端请求后端接口获取数据格式：</h1><p>GET方法：</p>\n<h2 id=\"1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\"><a href=\"#1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\" class=\"headerlink\" title=\"1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})\"></a>1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><h2 id=\"2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\"><a href=\"#2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\" class=\"headerlink\" title=\"2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})\"></a>2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><p>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。</p>\n<h2 id=\"POST方法（appcation-json或者form-data）：\"><a href=\"#POST方法（appcation-json或者form-data）：\" class=\"headerlink\" title=\"POST方法（appcation/json或者form-data）：\"></a>POST方法（appcation/json或者form-data）：</h2><h3 id=\"1、①appcation-json方式\"><a href=\"#1、①appcation-json方式\" class=\"headerlink\" title=\"1、①appcation/json方式\"></a>1、①appcation/json方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let data=&#123;id:12&#125;</span><br><span class=\"line\">axios.post(url,data,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"②appcation-json方式：\"><a href=\"#②appcation-json方式：\" class=\"headerlink\" title=\"②appcation/json方式：\"></a>②appcation/json方式：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let data=&#123;id:12&#125;</span><br><span class=\"line\">axios(&#123;method:&#x27;post&#x27;,url,data:data,config&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、①form-data方式\"><a href=\"#2、①form-data方式\" class=\"headerlink\" title=\"2、①form-data方式\"></a>2、①form-data方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let data=&#123;id:12&#125;</span><br><span class=\"line\">let formData = new FormData()</span><br><span class=\"line\">for(let key in data)&#123;</span><br><span class=\"line\">formData.append(key,data[key])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.post(url,formData,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"②form-data方式\"><a href=\"#②form-data方式\" class=\"headerlink\" title=\"②form-data方式\"></a>②form-data方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let data=&#123;id:12&#125;</span><br><span class=\"line\">let formData = new FormData()</span><br><span class=\"line\">for(let key in data)&#123;</span><br><span class=\"line\">formData.append(key,data[key])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios(&#123;method:&#x27;post&#x27;,url,formData:formData,config&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<p>post请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。</p>\n<h2 id=\"PUT和PATCH方式：\"><a href=\"#PUT和PATCH方式：\" class=\"headerlink\" title=\"PUT和PATCH方式：\"></a>PUT和PATCH方式：</h2><p>put和patch跟post一样，就方法不一样而已，参考post方法。</p>\n<h2 id=\"DELETE方式：\"><a href=\"#DELETE方式：\" class=\"headerlink\" title=\"DELETE方式：\"></a>DELETE方式：</h2><p>类似get方式，就方法不一样而已，参考get方法。<br>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，<br>注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。</p>\n<h1 id=\"三、axios并发请求\"><a href=\"#三、axios并发请求\" class=\"headerlink\" title=\"三、axios并发请求\"></a>三、axios并发请求</h1><h2 id=\"并发请求：同时进行多个请求，并统一处理返回值。\"><a href=\"#并发请求：同时进行多个请求，并统一处理返回值。\" class=\"headerlink\" title=\"并发请求：同时进行多个请求，并统一处理返回值。\"></a>并发请求：同时进行多个请求，并统一处理返回值。</h2><p>比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。<br>这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。</p>\n<h2 id=\"axios-all-和axios-spread-方法\"><a href=\"#axios-all-和axios-spread-方法\" class=\"headerlink\" title=\"axios.all()和axios.spread()方法\"></a>axios.all()和axios.spread()方法</h2><p>其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。<br>比如：arr[] =[axios.get(url),axios.post(url,data,config)]</p>\n<h2 id=\"另一个axios-spread-A-B-gt\"><a href=\"#另一个axios-spread-A-B-gt\" class=\"headerlink\" title=\"另一个axios.spread((A,B)=&gt;{})\"></a>另一个axios.spread((A,B)=&gt;{})</h2><p>这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。<br>具体用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=&gt;&#123;&#125;))</span><br></pre></td></tr></table></figure>\n<h1 id=\"四、axios实例\"><a href=\"#四、axios实例\" class=\"headerlink\" title=\"四、axios实例\"></a>四、axios实例</h1><p>你会不会有这样一个疑问，就是为什么要用axios实例呢？<br>那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，<br>那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。<br>具体用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let instance = axios.create(config);</span><br><span class=\"line\">instance.get(url).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"五、关于请求中的config\"><a href=\"#五、关于请求中的config\" class=\"headerlink\" title=\"五、关于请求中的config\"></a>五、关于请求中的config</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config的格式为：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">baseURL:&#x27;http:/xxxxxx&#x27;, //基础url</span><br><span class=\"line\">timeout:6000, //超时时间</span><br><span class=\"line\">url:xxxxxx, //具体url</span><br><span class=\"line\">method:&#x27;get/post/put/patch/delete&#x27;, //请求方式</span><br><span class=\"line\">headers:&#123;token:&#x27;xxxxx&#x27;等&#125;, //请求头设置</span><br><span class=\"line\">params:&#123;&#125;, //请求参数对象，它会将请求参数拼接到url上</span><br><span class=\"line\">data:&#123;&#125; //请求参数对象，它会将请求参数放到请求体中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>config应用场景</p>\n<h2 id=\"1、全局配置\"><a href=\"#1、全局配置\" class=\"headerlink\" title=\"1、全局配置\"></a>1、全局配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.defaults.timeout = 1000</span><br><span class=\"line\">axios.defaults.baseURL = &#x27;http://XXXXX&#x27;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、实例配置\"><a href=\"#2、实例配置\" class=\"headerlink\" title=\"2、实例配置\"></a>2、实例配置</h2><p>在axios创建实例中配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let instance = axios.create();</span><br><span class=\"line\">instance.defaults.timeout = 1000</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、请求配置\"><a href=\"#3、请求配置\" class=\"headerlink\" title=\"3、请求配置\"></a>3、请求配置</h2><p>在请求中配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.get(url,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中，配置优先级为：3&gt;2&gt;1</p>\n<h1 id=\"六、axios拦截器\"><a href=\"#六、axios拦截器\" class=\"headerlink\" title=\"六、axios拦截器\"></a>六、axios拦截器</h1><h2 id=\"什么是拦截器？\"><a href=\"#什么是拦截器？\" class=\"headerlink\" title=\"什么是拦截器？\"></a>什么是拦截器？</h2><p>拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。<br>一般分为请求拦截器和响应拦截器两种。</p>\n<h2 id=\"请求拦截器\"><a href=\"#请求拦截器\" class=\"headerlink\" title=\"请求拦截器\"></a>请求拦截器</h2><p>请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service.interceptors.request.use(</span><br><span class=\"line\">config =&gt; &#123;</span><br><span class=\"line\">//在发送请求前的额外处理</span><br><span class=\"line\">return config</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"响应拦截器\"><a href=\"#响应拦截器\" class=\"headerlink\" title=\"响应拦截器\"></a>响应拦截器</h2><p>响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service.interceptors.response.use(</span><br><span class=\"line\">res =&gt; &#123;</span><br><span class=\"line\">//响应之后做一些额外操作</span><br><span class=\"line\">return res</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">error =&gt; &#123;</span><br><span class=\"line\">//在发生错误后的额外处理</span><br><span class=\"line\">return Promise.reject(error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：</span><br><span class=\"line\">axios.get(url,config).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br></pre></td></tr></table></figure>\n<p>例子：发送请求前，在请求头中添加token，就可以用拦截器来实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let instance = axios.create(config);</span><br><span class=\"line\">instance.interceptors.request.use(confit=&gt;&#123;</span><br><span class=\"line\">config.headers.token=&quot;sssssss&quot;</span><br><span class=\"line\">return config</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">error =&gt; &#123;</span><br><span class=\"line\">//在发生错误后的额外处理</span><br><span class=\"line\">return Promise.reject(error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"取消拦截器\"><a href=\"#取消拦截器\" class=\"headerlink\" title=\"取消拦截器\"></a>取消拦截器</h2><p>顾名思义就是取消掉已经配置的拦截器</p>\n<p>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let instance = axios.create(config);</span><br><span class=\"line\">instance.interceptors.request.use(</span><br><span class=\"line\">config=&gt;&#123;</span><br><span class=\"line\">config.headers.token=&quot;sssssss&quot;</span><br><span class=\"line\">return config</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">error =&gt; &#123;</span><br><span class=\"line\">//在发生错误后的额外处理</span><br><span class=\"line\">return Promise.reject(error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">//取消拦截器操作：</span><br><span class=\"line\">axios.interceptors.request.eject(instance)</span><br></pre></td></tr></table></figure>\n<h1 id=\"七、取消请求\"><a href=\"#七、取消请求\" class=\"headerlink\" title=\"七、取消请求\"></a>七、取消请求</h1><p>取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，<br>这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法<br>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.CancelToken.source()</span><br><span class=\"line\">axios.get(url,&#123;CancelToken:source,token&#125;).then(res=&gt;&#123;数据处理逻辑&#125;).catch(err=&gt;&#123;错误处理逻辑&#125;)</span><br><span class=\"line\">//触发取消请求：</span><br><span class=\"line\">source.cancel(&#x27;错误信息&#x27;)</span><br></pre></td></tr></table></figure>\n<p>就可以了</p>\n"},{"title":"Vue-搜索引擎SEO优化","date":"2023-04-05T08:25:21.000Z","cover":["/images/vueseocover.png"],"banner":{"type":"img","bgurl":["/images/vueseocover.png"]},"_content":"众所周知，Vue SPA 单页应用对 SEO 不友好，当然也有相应的解决方案。\n# 1. SSR 服务器渲染\nVue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将他们直接发送到浏览器，最后将这些静态标记“激活”为客户端上完全可交互的应用程序。\n服务器渲染的 Vue.js 应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。\n## 权衡之处：\n+ 开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数（lifecyle hook）中使用；一些外部扩展库（external library）可能需要特殊处理，才能在服务器渲染应用程序中运行。\n+ 环境和部署要求更高，需要 Node.js server 运行环境。\n+ 高流量的情况下，请准备相应的服务器负载，并明智的采用缓存策略。\n## 优势：\n+ 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。\n+ 更快的内容到达时间（time-to-content），特别是对于换忙的网络情况或运行缓慢的设备。\n\n## 不足：\n+ 一套代码两套执行环境，会引起各种问题，比如服务端没有 window、document 对象，处理方式是增加判断，如果是客户端才执行。\n+ 引用 npm 包，带有 dom 操作的，例如：wowjs，不能用 import 的方式。\n+ Nuxt asyncData 方法，初始化页面前先得到数据，但仅限于页面组件调用。\n\n# 2. Nuxt 静态化\nNuxt.js 框架，官方是这样介绍的，从头搭建一个服务端渲染的应用是相当复杂的，幸运的是，我们有一个优秀的社区项目 Nuxt.js 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来作为静态站点生成器。\n静态化是 Nuxt.js 打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。\n在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。\n如果你的动态路由参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有 id，然后打包时遍历 id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。\n## 优势：\n+ 纯静态文件，访问速度超快。\n+ 对比 SSR，不涉及到服务器负载方面问题。\n+ 静态网页不宜遭到黑客攻击，安全性更高。\n## 不足：\n+ 如果动态路由参数多的话不适用。\n\n# 3. 预渲染 prerender-spa-plugin\n如果你只是用来改善少数营销页面（例如 /about，/contact等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时（build time）简单的生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。\n## 优势：\n+ 改动小，引入插件配置即可\n## 不足：\n+ 无法使用动态路由\n+ 只适用少量页面的项目，页面多达几百个的情况下，打包回非常慢。\n\n# 4. 使用 Phantomjs 针对爬虫做处理\nPhantomjs 是一个基于 webkit 内核的无头浏览器，即没有 UI 界面，只是其内的点击、翻页等人为相关操作需要程序设计实现。\n虽然“Phantomjs 宣布终止开发”，但是已经满足对 Vue 的 SEO 处理。\n这种解决方案其实是一种旁路机制，原理就是通过 Nginx 配置，判断访问的来源 UA 是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个 node serve，在通过 Phantomjs 来解析完整的 HTML，返回给爬虫。\n## 优势：\n+ 完全不用改动项目代码，按原本的 SPA 开发即可，对比开发 SSR 成本小不要太多。\n+ 对已用 SPA 开发完成的项目，可以直接使用。\n## 不足：\n+ 部署需要 node 服务器支持。\n+ 爬虫访问比网页访问要慢一些，因为要定时资源加载完成才返回给爬虫。\n+ 如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决办法是判断访问的 IP，是否是百度官方爬虫的 IP。\n\n# 总结\n如果构建大型网站，如商场类，别犹豫，直接上 SSR 服务器渲染，当然也有相应的坑等你，不过社区比较成熟，英文过关，一切问题都可以解决。\n如果只是个人博客、公司官网的项目，其余三种都可以。\n如果对已用 SPA 开发完成的项目进行 SEO 优化，而且支持 node 服务器，请使用 Phantomjs。\n","source":"_posts/Vue-搜索引擎SEO优化.md","raw":"---\ntitle: Vue-搜索引擎SEO优化\ndate: 2023-04-05 16:25:21\ntags: Vue\ncategories: 性能优化\ncover: [/images/vueseocover.png]\nbanner: \n  type: img\n  bgurl: [/images/vueseocover.png]\n---\n众所周知，Vue SPA 单页应用对 SEO 不友好，当然也有相应的解决方案。\n# 1. SSR 服务器渲染\nVue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将他们直接发送到浏览器，最后将这些静态标记“激活”为客户端上完全可交互的应用程序。\n服务器渲染的 Vue.js 应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。\n## 权衡之处：\n+ 开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数（lifecyle hook）中使用；一些外部扩展库（external library）可能需要特殊处理，才能在服务器渲染应用程序中运行。\n+ 环境和部署要求更高，需要 Node.js server 运行环境。\n+ 高流量的情况下，请准备相应的服务器负载，并明智的采用缓存策略。\n## 优势：\n+ 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。\n+ 更快的内容到达时间（time-to-content），特别是对于换忙的网络情况或运行缓慢的设备。\n\n## 不足：\n+ 一套代码两套执行环境，会引起各种问题，比如服务端没有 window、document 对象，处理方式是增加判断，如果是客户端才执行。\n+ 引用 npm 包，带有 dom 操作的，例如：wowjs，不能用 import 的方式。\n+ Nuxt asyncData 方法，初始化页面前先得到数据，但仅限于页面组件调用。\n\n# 2. Nuxt 静态化\nNuxt.js 框架，官方是这样介绍的，从头搭建一个服务端渲染的应用是相当复杂的，幸运的是，我们有一个优秀的社区项目 Nuxt.js 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来作为静态站点生成器。\n静态化是 Nuxt.js 打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。\n在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。\n如果你的动态路由参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有 id，然后打包时遍历 id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。\n## 优势：\n+ 纯静态文件，访问速度超快。\n+ 对比 SSR，不涉及到服务器负载方面问题。\n+ 静态网页不宜遭到黑客攻击，安全性更高。\n## 不足：\n+ 如果动态路由参数多的话不适用。\n\n# 3. 预渲染 prerender-spa-plugin\n如果你只是用来改善少数营销页面（例如 /about，/contact等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时（build time）简单的生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。\n## 优势：\n+ 改动小，引入插件配置即可\n## 不足：\n+ 无法使用动态路由\n+ 只适用少量页面的项目，页面多达几百个的情况下，打包回非常慢。\n\n# 4. 使用 Phantomjs 针对爬虫做处理\nPhantomjs 是一个基于 webkit 内核的无头浏览器，即没有 UI 界面，只是其内的点击、翻页等人为相关操作需要程序设计实现。\n虽然“Phantomjs 宣布终止开发”，但是已经满足对 Vue 的 SEO 处理。\n这种解决方案其实是一种旁路机制，原理就是通过 Nginx 配置，判断访问的来源 UA 是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个 node serve，在通过 Phantomjs 来解析完整的 HTML，返回给爬虫。\n## 优势：\n+ 完全不用改动项目代码，按原本的 SPA 开发即可，对比开发 SSR 成本小不要太多。\n+ 对已用 SPA 开发完成的项目，可以直接使用。\n## 不足：\n+ 部署需要 node 服务器支持。\n+ 爬虫访问比网页访问要慢一些，因为要定时资源加载完成才返回给爬虫。\n+ 如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决办法是判断访问的 IP，是否是百度官方爬虫的 IP。\n\n# 总结\n如果构建大型网站，如商场类，别犹豫，直接上 SSR 服务器渲染，当然也有相应的坑等你，不过社区比较成熟，英文过关，一切问题都可以解决。\n如果只是个人博客、公司官网的项目，其余三种都可以。\n如果对已用 SPA 开发完成的项目进行 SEO 优化，而且支持 node 服务器，请使用 Phantomjs。\n","slug":"Vue-搜索引擎SEO优化","published":1,"updated":"2023-04-11T06:11:19.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml2000btit81kpvfmcg","content":"<p>众所周知，Vue SPA 单页应用对 SEO 不友好，当然也有相应的解决方案。</p>\n<h1 id=\"1-SSR-服务器渲染\"><a href=\"#1-SSR-服务器渲染\" class=\"headerlink\" title=\"1. SSR 服务器渲染\"></a>1. SSR 服务器渲染</h1><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将他们直接发送到浏览器，最后将这些静态标记“激活”为客户端上完全可交互的应用程序。<br>服务器渲染的 Vue.js 应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。</p>\n<h2 id=\"权衡之处：\"><a href=\"#权衡之处：\" class=\"headerlink\" title=\"权衡之处：\"></a>权衡之处：</h2><ul>\n<li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数（lifecyle hook）中使用；一些外部扩展库（external library）可能需要特殊处理，才能在服务器渲染应用程序中运行。</li>\n<li>环境和部署要求更高，需要 Node.js server 运行环境。</li>\n<li>高流量的情况下，请准备相应的服务器负载，并明智的采用缓存策略。<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2></li>\n<li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li>\n<li>更快的内容到达时间（time-to-content），特别是对于换忙的网络情况或运行缓慢的设备。</li>\n</ul>\n<h2 id=\"不足：\"><a href=\"#不足：\" class=\"headerlink\" title=\"不足：\"></a>不足：</h2><ul>\n<li>一套代码两套执行环境，会引起各种问题，比如服务端没有 window、document 对象，处理方式是增加判断，如果是客户端才执行。</li>\n<li>引用 npm 包，带有 dom 操作的，例如：wowjs，不能用 import 的方式。</li>\n<li>Nuxt asyncData 方法，初始化页面前先得到数据，但仅限于页面组件调用。</li>\n</ul>\n<h1 id=\"2-Nuxt-静态化\"><a href=\"#2-Nuxt-静态化\" class=\"headerlink\" title=\"2. Nuxt 静态化\"></a>2. Nuxt 静态化</h1><p>Nuxt.js 框架，官方是这样介绍的，从头搭建一个服务端渲染的应用是相当复杂的，幸运的是，我们有一个优秀的社区项目 Nuxt.js 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来作为静态站点生成器。<br>静态化是 Nuxt.js 打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。<br>在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。<br>如果你的动态路由参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有 id，然后打包时遍历 id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。</p>\n<h2 id=\"优势：-1\"><a href=\"#优势：-1\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>纯静态文件，访问速度超快。</li>\n<li>对比 SSR，不涉及到服务器负载方面问题。</li>\n<li>静态网页不宜遭到黑客攻击，安全性更高。<h2 id=\"不足：-1\"><a href=\"#不足：-1\" class=\"headerlink\" title=\"不足：\"></a>不足：</h2></li>\n<li>如果动态路由参数多的话不适用。</li>\n</ul>\n<h1 id=\"3-预渲染-prerender-spa-plugin\"><a href=\"#3-预渲染-prerender-spa-plugin\" class=\"headerlink\" title=\"3. 预渲染 prerender-spa-plugin\"></a>3. 预渲染 prerender-spa-plugin</h1><p>如果你只是用来改善少数营销页面（例如 /about，/contact等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时（build time）简单的生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p>\n<h2 id=\"优势：-2\"><a href=\"#优势：-2\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>改动小，引入插件配置即可<h2 id=\"不足：-2\"><a href=\"#不足：-2\" class=\"headerlink\" title=\"不足：\"></a>不足：</h2></li>\n<li>无法使用动态路由</li>\n<li>只适用少量页面的项目，页面多达几百个的情况下，打包回非常慢。</li>\n</ul>\n<h1 id=\"4-使用-Phantomjs-针对爬虫做处理\"><a href=\"#4-使用-Phantomjs-针对爬虫做处理\" class=\"headerlink\" title=\"4. 使用 Phantomjs 针对爬虫做处理\"></a>4. 使用 Phantomjs 针对爬虫做处理</h1><p>Phantomjs 是一个基于 webkit 内核的无头浏览器，即没有 UI 界面，只是其内的点击、翻页等人为相关操作需要程序设计实现。<br>虽然“Phantomjs 宣布终止开发”，但是已经满足对 Vue 的 SEO 处理。<br>这种解决方案其实是一种旁路机制，原理就是通过 Nginx 配置，判断访问的来源 UA 是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个 node serve，在通过 Phantomjs 来解析完整的 HTML，返回给爬虫。</p>\n<h2 id=\"优势：-3\"><a href=\"#优势：-3\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>完全不用改动项目代码，按原本的 SPA 开发即可，对比开发 SSR 成本小不要太多。</li>\n<li>对已用 SPA 开发完成的项目，可以直接使用。<h2 id=\"不足：-3\"><a href=\"#不足：-3\" class=\"headerlink\" title=\"不足：\"></a>不足：</h2></li>\n<li>部署需要 node 服务器支持。</li>\n<li>爬虫访问比网页访问要慢一些，因为要定时资源加载完成才返回给爬虫。</li>\n<li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决办法是判断访问的 IP，是否是百度官方爬虫的 IP。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>如果构建大型网站，如商场类，别犹豫，直接上 SSR 服务器渲染，当然也有相应的坑等你，不过社区比较成熟，英文过关，一切问题都可以解决。<br>如果只是个人博客、公司官网的项目，其余三种都可以。<br>如果对已用 SPA 开发完成的项目进行 SEO 优化，而且支持 node 服务器，请使用 Phantomjs。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>众所周知，Vue SPA 单页应用对 SEO 不友好，当然也有相应的解决方案。</p>\n<h1 id=\"1-SSR-服务器渲染\"><a href=\"#1-SSR-服务器渲染\" class=\"headerlink\" title=\"1. SSR 服务器渲染\"></a>1. SSR 服务器渲染</h1><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将他们直接发送到浏览器，最后将这些静态标记“激活”为客户端上完全可交互的应用程序。<br>服务器渲染的 Vue.js 应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。</p>\n<h2 id=\"权衡之处：\"><a href=\"#权衡之处：\" class=\"headerlink\" title=\"权衡之处：\"></a>权衡之处：</h2><ul>\n<li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数（lifecyle hook）中使用；一些外部扩展库（external library）可能需要特殊处理，才能在服务器渲染应用程序中运行。</li>\n<li>环境和部署要求更高，需要 Node.js server 运行环境。</li>\n<li>高流量的情况下，请准备相应的服务器负载，并明智的采用缓存策略。<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2></li>\n<li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li>\n<li>更快的内容到达时间（time-to-content），特别是对于换忙的网络情况或运行缓慢的设备。</li>\n</ul>\n<h2 id=\"不足：\"><a href=\"#不足：\" class=\"headerlink\" title=\"不足：\"></a>不足：</h2><ul>\n<li>一套代码两套执行环境，会引起各种问题，比如服务端没有 window、document 对象，处理方式是增加判断，如果是客户端才执行。</li>\n<li>引用 npm 包，带有 dom 操作的，例如：wowjs，不能用 import 的方式。</li>\n<li>Nuxt asyncData 方法，初始化页面前先得到数据，但仅限于页面组件调用。</li>\n</ul>\n<h1 id=\"2-Nuxt-静态化\"><a href=\"#2-Nuxt-静态化\" class=\"headerlink\" title=\"2. Nuxt 静态化\"></a>2. Nuxt 静态化</h1><p>Nuxt.js 框架，官方是这样介绍的，从头搭建一个服务端渲染的应用是相当复杂的，幸运的是，我们有一个优秀的社区项目 Nuxt.js 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来作为静态站点生成器。<br>静态化是 Nuxt.js 打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。<br>在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。<br>如果你的动态路由参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有 id，然后打包时遍历 id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。</p>\n<h2 id=\"优势：-1\"><a href=\"#优势：-1\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>纯静态文件，访问速度超快。</li>\n<li>对比 SSR，不涉及到服务器负载方面问题。</li>\n<li>静态网页不宜遭到黑客攻击，安全性更高。<h2 id=\"不足：-1\"><a href=\"#不足：-1\" class=\"headerlink\" title=\"不足：\"></a>不足：</h2></li>\n<li>如果动态路由参数多的话不适用。</li>\n</ul>\n<h1 id=\"3-预渲染-prerender-spa-plugin\"><a href=\"#3-预渲染-prerender-spa-plugin\" class=\"headerlink\" title=\"3. 预渲染 prerender-spa-plugin\"></a>3. 预渲染 prerender-spa-plugin</h1><p>如果你只是用来改善少数营销页面（例如 /about，/contact等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时（build time）简单的生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p>\n<h2 id=\"优势：-2\"><a href=\"#优势：-2\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>改动小，引入插件配置即可<h2 id=\"不足：-2\"><a href=\"#不足：-2\" class=\"headerlink\" title=\"不足：\"></a>不足：</h2></li>\n<li>无法使用动态路由</li>\n<li>只适用少量页面的项目，页面多达几百个的情况下，打包回非常慢。</li>\n</ul>\n<h1 id=\"4-使用-Phantomjs-针对爬虫做处理\"><a href=\"#4-使用-Phantomjs-针对爬虫做处理\" class=\"headerlink\" title=\"4. 使用 Phantomjs 针对爬虫做处理\"></a>4. 使用 Phantomjs 针对爬虫做处理</h1><p>Phantomjs 是一个基于 webkit 内核的无头浏览器，即没有 UI 界面，只是其内的点击、翻页等人为相关操作需要程序设计实现。<br>虽然“Phantomjs 宣布终止开发”，但是已经满足对 Vue 的 SEO 处理。<br>这种解决方案其实是一种旁路机制，原理就是通过 Nginx 配置，判断访问的来源 UA 是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个 node serve，在通过 Phantomjs 来解析完整的 HTML，返回给爬虫。</p>\n<h2 id=\"优势：-3\"><a href=\"#优势：-3\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>完全不用改动项目代码，按原本的 SPA 开发即可，对比开发 SSR 成本小不要太多。</li>\n<li>对已用 SPA 开发完成的项目，可以直接使用。<h2 id=\"不足：-3\"><a href=\"#不足：-3\" class=\"headerlink\" title=\"不足：\"></a>不足：</h2></li>\n<li>部署需要 node 服务器支持。</li>\n<li>爬虫访问比网页访问要慢一些，因为要定时资源加载完成才返回给爬虫。</li>\n<li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决办法是判断访问的 IP，是否是百度官方爬虫的 IP。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>如果构建大型网站，如商场类，别犹豫，直接上 SSR 服务器渲染，当然也有相应的坑等你，不过社区比较成熟，英文过关，一切问题都可以解决。<br>如果只是个人博客、公司官网的项目，其余三种都可以。<br>如果对已用 SPA 开发完成的项目进行 SEO 优化，而且支持 node 服务器，请使用 Phantomjs。</p>\n"},{"title":"Vue3:Pinia使用","date":"2022-10-24T13:44:07.000Z","_content":"在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。\n\n# 什么是 Pinia\nPinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。\n# Pinia 的优点\nPinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：\npinia 符合直觉，易于学习。\npinia 是轻量级状态管理工具，大小只有1KB.\npinia 模块化设计，方便拆分。\npinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。\nstore 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。\n支持多个 store。\n支持 Vue devtools、SSR、webpack 代码拆分。\n\n# 相关资料\nPinia 中文网：https://pinia.web3doc.top/\n\n# Pinia 安装\n安装 pinia 就很简单了，直接命令安装就可以了。\n![](安装.png)\n\n# Pinia 使用\n安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia\n## 1.Pinia 导入\n首先在 main.js 文件中引入\n vue3 的写法：\n```\nimport {createPinia} from 'pinia'\n```\n然后，这个 pinia 就在项目中导入了\nPinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：\n```\nimport {PiniaVuePlugin} from 'pinia'\n```\n我们还是以 vue3 来介绍这个 Pinia\n导入的时候是 hook ，我们需要调用一下\n```\nconst state = createPinia()\n```\n调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。\n```\napp.use(state)\n```\n## 2.Pinia 基本使用\n### 1.创建 index.ts 文件\n使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。\n创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。\n### 2.编写 index.ts 文件\n首先我们先引入 pinia\n```\nimport { defineStore } from \"pinia\";\n```\n由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下\n这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。\n我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出\n```\nexport const enum Names {\n  TEST = \"TEST\"\n}\n```\n然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。\n这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。\nstate 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。\ngetters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。\nactions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。\n![](indexts.png)\n其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。\n![](截图1代码.png)\n![](截图1结果.png)\n### 3.修改 Pinia 的值\n修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值\n修改值的方式呢，常见的有五种\n#### 方式一：直接修改\n![](截图2代码.png)\n![](截图2结果.png)\n#### 方式二：$patch 函数修改\n在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。\n![](截图3代码.png)\n![](截图3结果1.png)\n![](截图3结果2.png)\n#### 方式三：$patch 函数修改\n咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。\n![](截图4代码.png)\n效果其实和方式二是一模一样的\n#### 方式四：$state 方式\n![](截图5代码.png)\n#### 方式五： action 方式\n这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action\n![](截图6代码1.png)\n写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。\n![](截图6代码2.png)\n查看一下效果，可以看到\n![](截图6结果1.png)\n![](截图6结果2.png)\n当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。\n![](截图7代码1.png)\n![](截图7代码2.png)\n查看一下效果，可以看到\n![](截图7结果1.png)\n![](截图7结果2.png)\n以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用\n# pinia 解构\n上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的\n![](截图8代码.png)\n在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到\n![](截图8结果.png)\n我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。\n但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。\n做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染\n![](截图9代码.png)\n在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到\n![](截图9代码.png)\n通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。\n解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。\n就是 storeToRefs，使用 storeToRefs 需要导入一下。\n```\nimport { storeToRefs } from 'pinia'\n```\n然后把我们解构的对象包裹一下就可以了\n```\nconst { name, age } = storeToRefs(userInfo)\n```\n![](截图10代码.png)\n![](截图10结果.png)\n或者我们换一个写法，直接操作结构后的数据，记得，要 .value\n![](截图11代码.png)\n# Pinia 的 actions\nactions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步\n接下来我们重点介绍一下actions异步\nactions 异步\n首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用\n![](截图11代码1.png)\n![](截图11代码2.png)\n查看一下效果，可以看到\n![](截图11结果1.png)\n![](截图11结果2.png)\nactions 同步、异步连用\n这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。\n上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。\n![](截图12代码.png)\n查看一下效果，可以看到\n![](截图12结果.png)\n# getter 函数\ngetters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。\n有两种写法:\n普通函数方式写法\n![](截图13代码1.png)\n![](截图13代码2.png)\n查看一下效果，可以看到\n![](截图13结果1.png)\n然后我们点一下按钮，修改一下 name，然后看一下效果\n![](截图13结果2.png)\n我们可以看见，点击修改 name 之后getter 也会实时的渲染出来\n相互调用\n![](截图14代码.png)\n查看一下效果，可以看到\n![](截图14结果1.png)\n然后我们点一下按钮，修改一下 name和 age，然后看一下效果\n![](截图14结果2.png)\n# API 的使用\n$reset ：重置到初始值\n这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。\n![](截图15代码.png)\n我们点击修改用户按钮，查看一下效果，可以看到\n![](截图15结果1.png)\n然后我们点一下$reset按钮，然后看一下效果\n![](截图15结果2.png)\n$subscribe：监听 state 数据变化\n$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。\n![](截图16代码.png)\n我们点击修改用户按钮，查看一下效果，可以看到\n![](截图16结果1.png)\n控制台打印出监听到的变化结果\n![](截图16结果2.png)\n$onAction：一调用 actions 就触发\n![](截图17代码.png)\n控制台打印出监听到的变化结果\n![](截图17结果.png)","source":"_posts/Vue3-Pinia使用.md","raw":"---\ntitle: 'Vue3:Pinia使用'\ndate: 2022-10-24 21:44:07\ntags: vue3\ncategories: vue3\n---\n在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。\n\n# 什么是 Pinia\nPinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。\n# Pinia 的优点\nPinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：\npinia 符合直觉，易于学习。\npinia 是轻量级状态管理工具，大小只有1KB.\npinia 模块化设计，方便拆分。\npinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。\nstore 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。\n支持多个 store。\n支持 Vue devtools、SSR、webpack 代码拆分。\n\n# 相关资料\nPinia 中文网：https://pinia.web3doc.top/\n\n# Pinia 安装\n安装 pinia 就很简单了，直接命令安装就可以了。\n![](安装.png)\n\n# Pinia 使用\n安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia\n## 1.Pinia 导入\n首先在 main.js 文件中引入\n vue3 的写法：\n```\nimport {createPinia} from 'pinia'\n```\n然后，这个 pinia 就在项目中导入了\nPinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：\n```\nimport {PiniaVuePlugin} from 'pinia'\n```\n我们还是以 vue3 来介绍这个 Pinia\n导入的时候是 hook ，我们需要调用一下\n```\nconst state = createPinia()\n```\n调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。\n```\napp.use(state)\n```\n## 2.Pinia 基本使用\n### 1.创建 index.ts 文件\n使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。\n创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。\n### 2.编写 index.ts 文件\n首先我们先引入 pinia\n```\nimport { defineStore } from \"pinia\";\n```\n由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下\n这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。\n我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出\n```\nexport const enum Names {\n  TEST = \"TEST\"\n}\n```\n然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。\n这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。\nstate 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。\ngetters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。\nactions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。\n![](indexts.png)\n其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。\n![](截图1代码.png)\n![](截图1结果.png)\n### 3.修改 Pinia 的值\n修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值\n修改值的方式呢，常见的有五种\n#### 方式一：直接修改\n![](截图2代码.png)\n![](截图2结果.png)\n#### 方式二：$patch 函数修改\n在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。\n![](截图3代码.png)\n![](截图3结果1.png)\n![](截图3结果2.png)\n#### 方式三：$patch 函数修改\n咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。\n![](截图4代码.png)\n效果其实和方式二是一模一样的\n#### 方式四：$state 方式\n![](截图5代码.png)\n#### 方式五： action 方式\n这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action\n![](截图6代码1.png)\n写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。\n![](截图6代码2.png)\n查看一下效果，可以看到\n![](截图6结果1.png)\n![](截图6结果2.png)\n当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。\n![](截图7代码1.png)\n![](截图7代码2.png)\n查看一下效果，可以看到\n![](截图7结果1.png)\n![](截图7结果2.png)\n以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用\n# pinia 解构\n上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的\n![](截图8代码.png)\n在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到\n![](截图8结果.png)\n我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。\n但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。\n做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染\n![](截图9代码.png)\n在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到\n![](截图9代码.png)\n通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。\n解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。\n就是 storeToRefs，使用 storeToRefs 需要导入一下。\n```\nimport { storeToRefs } from 'pinia'\n```\n然后把我们解构的对象包裹一下就可以了\n```\nconst { name, age } = storeToRefs(userInfo)\n```\n![](截图10代码.png)\n![](截图10结果.png)\n或者我们换一个写法，直接操作结构后的数据，记得，要 .value\n![](截图11代码.png)\n# Pinia 的 actions\nactions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步\n接下来我们重点介绍一下actions异步\nactions 异步\n首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用\n![](截图11代码1.png)\n![](截图11代码2.png)\n查看一下效果，可以看到\n![](截图11结果1.png)\n![](截图11结果2.png)\nactions 同步、异步连用\n这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。\n上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。\n![](截图12代码.png)\n查看一下效果，可以看到\n![](截图12结果.png)\n# getter 函数\ngetters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。\n有两种写法:\n普通函数方式写法\n![](截图13代码1.png)\n![](截图13代码2.png)\n查看一下效果，可以看到\n![](截图13结果1.png)\n然后我们点一下按钮，修改一下 name，然后看一下效果\n![](截图13结果2.png)\n我们可以看见，点击修改 name 之后getter 也会实时的渲染出来\n相互调用\n![](截图14代码.png)\n查看一下效果，可以看到\n![](截图14结果1.png)\n然后我们点一下按钮，修改一下 name和 age，然后看一下效果\n![](截图14结果2.png)\n# API 的使用\n$reset ：重置到初始值\n这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。\n![](截图15代码.png)\n我们点击修改用户按钮，查看一下效果，可以看到\n![](截图15结果1.png)\n然后我们点一下$reset按钮，然后看一下效果\n![](截图15结果2.png)\n$subscribe：监听 state 数据变化\n$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。\n![](截图16代码.png)\n我们点击修改用户按钮，查看一下效果，可以看到\n![](截图16结果1.png)\n控制台打印出监听到的变化结果\n![](截图16结果2.png)\n$onAction：一调用 actions 就触发\n![](截图17代码.png)\n控制台打印出监听到的变化结果\n![](截图17结果.png)","slug":"Vue3-Pinia使用","published":1,"updated":"2023-04-03T04:44:50.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml2000ftit8fcbcbz33","content":"<p>在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。</p>\n<h1 id=\"什么是-Pinia\"><a href=\"#什么是-Pinia\" class=\"headerlink\" title=\"什么是 Pinia\"></a>什么是 Pinia</h1><p>Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。</p>\n<h1 id=\"Pinia-的优点\"><a href=\"#Pinia-的优点\" class=\"headerlink\" title=\"Pinia 的优点\"></a>Pinia 的优点</h1><p>Pinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：<br>pinia 符合直觉，易于学习。<br>pinia 是轻量级状态管理工具，大小只有1KB.<br>pinia 模块化设计，方便拆分。<br>pinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。<br>store 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。<br>支持多个 store。<br>支持 Vue devtools、SSR、webpack 代码拆分。</p>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p>Pinia 中文网：<a href=\"https://pinia.web3doc.top/\">https://pinia.web3doc.top/</a></p>\n<h1 id=\"Pinia-安装\"><a href=\"#Pinia-安装\" class=\"headerlink\" title=\"Pinia 安装\"></a>Pinia 安装</h1><p>安装 pinia 就很简单了，直接命令安装就可以了。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E5%AE%89%E8%A3%85.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"Pinia-使用\"><a href=\"#Pinia-使用\" class=\"headerlink\" title=\"Pinia 使用\"></a>Pinia 使用</h1><p>安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia</p>\n<h2 id=\"1-Pinia-导入\"><a href=\"#1-Pinia-导入\" class=\"headerlink\" title=\"1.Pinia 导入\"></a>1.Pinia 导入</h2><p>首先在 main.js 文件中引入<br> vue3 的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123;createPinia&#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>\n<p>然后，这个 pinia 就在项目中导入了<br>Pinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123;PiniaVuePlugin&#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>\n<p>我们还是以 vue3 来介绍这个 Pinia<br>导入的时候是 hook ，我们需要调用一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const state = createPinia()</span><br></pre></td></tr></table></figure>\n<p>调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">app.use(state)</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-Pinia-基本使用\"><a href=\"#2-Pinia-基本使用\" class=\"headerlink\" title=\"2.Pinia 基本使用\"></a>2.Pinia 基本使用</h2><h3 id=\"1-创建-index-ts-文件\"><a href=\"#1-创建-index-ts-文件\" class=\"headerlink\" title=\"1.创建 index.ts 文件\"></a>1.创建 index.ts 文件</h3><p>使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。<br>创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。</p>\n<h3 id=\"2-编写-index-ts-文件\"><a href=\"#2-编写-index-ts-文件\" class=\"headerlink\" title=\"2.编写 index.ts 文件\"></a>2.编写 index.ts 文件</h3><p>首先我们先引入 pinia</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; defineStore &#125; from &quot;pinia&quot;;</span><br></pre></td></tr></table></figure>\n<p>由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下<br>这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。<br>我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export const enum Names &#123;</span><br><span class=\"line\">  TEST = &quot;TEST&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。<br>这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。<br>state 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。<br>getters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。<br>actions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/indexts.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h3 id=\"3-修改-Pinia-的值\"><a href=\"#3-修改-Pinia-的值\" class=\"headerlink\" title=\"3.修改 Pinia 的值\"></a>3.修改 Pinia 的值</h3><p>修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值<br>修改值的方式呢，常见的有五种</p>\n<h4 id=\"方式一：直接修改\"><a href=\"#方式一：直接修改\" class=\"headerlink\" title=\"方式一：直接修改\"></a>方式一：直接修改</h4><p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h4 id=\"方式二：-patch-函数修改\"><a href=\"#方式二：-patch-函数修改\" class=\"headerlink\" title=\"方式二：$patch 函数修改\"></a>方式二：$patch 函数修改</h4><p>在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h4 id=\"方式三：-patch-函数修改\"><a href=\"#方式三：-patch-函数修改\" class=\"headerlink\" title=\"方式三：$patch 函数修改\"></a>方式三：$patch 函数修改</h4><p>咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE4%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>效果其实和方式二是一模一样的</p>\n<h4 id=\"方式四：-state-方式\"><a href=\"#方式四：-state-方式\" class=\"headerlink\" title=\"方式四：$state 方式\"></a>方式四：$state 方式</h4><p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE5%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h4 id=\"方式五：-action-方式\"><a href=\"#方式五：-action-方式\" class=\"headerlink\" title=\"方式五： action 方式\"></a>方式五： action 方式</h4><p>这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%811.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%812.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%811.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%812.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用</p>\n<h1 id=\"pinia-解构\"><a href=\"#pinia-解构\" class=\"headerlink\" title=\"pinia 解构\"></a>pinia 解构</h1><p>上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。<br>但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。<br>做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。<br>解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。<br>就是 storeToRefs，使用 storeToRefs 需要导入一下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>\n<p>然后把我们解构的对象包裹一下就可以了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123; name, age &#125; = storeToRefs(userInfo)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>或者我们换一个写法，直接操作结构后的数据，记得，要 .value<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"Pinia-的-actions\"><a href=\"#Pinia-的-actions\" class=\"headerlink\" title=\"Pinia 的 actions\"></a>Pinia 的 actions</h1><p>actions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步<br>接下来我们重点介绍一下actions异步<br>actions 异步<br>首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%811.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%812.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>actions 同步、异步连用<br>这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。<br>上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"getter-函数\"><a href=\"#getter-函数\" class=\"headerlink\" title=\"getter 函数\"></a>getter 函数</h1><p>getters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。<br>有两种写法:<br>普通函数方式写法<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%811.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%812.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>然后我们点一下按钮，修改一下 name，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们可以看见，点击修改 name 之后getter 也会实时的渲染出来<br>相互调用<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>然后我们点一下按钮，修改一下 name和 age，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"API-的使用\"><a href=\"#API-的使用\" class=\"headerlink\" title=\"API 的使用\"></a>API 的使用</h1><p>$reset ：重置到初始值<br>这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>然后我们点一下$reset按钮，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>$subscribe：监听 state 数据变化<br>$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>控制台打印出监听到的变化结果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>$onAction：一调用 actions 就触发<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>控制台打印出监听到的变化结果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。</p>\n<h1 id=\"什么是-Pinia\"><a href=\"#什么是-Pinia\" class=\"headerlink\" title=\"什么是 Pinia\"></a>什么是 Pinia</h1><p>Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。</p>\n<h1 id=\"Pinia-的优点\"><a href=\"#Pinia-的优点\" class=\"headerlink\" title=\"Pinia 的优点\"></a>Pinia 的优点</h1><p>Pinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：<br>pinia 符合直觉，易于学习。<br>pinia 是轻量级状态管理工具，大小只有1KB.<br>pinia 模块化设计，方便拆分。<br>pinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。<br>store 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。<br>支持多个 store。<br>支持 Vue devtools、SSR、webpack 代码拆分。</p>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p>Pinia 中文网：<a href=\"https://pinia.web3doc.top/\">https://pinia.web3doc.top/</a></p>\n<h1 id=\"Pinia-安装\"><a href=\"#Pinia-安装\" class=\"headerlink\" title=\"Pinia 安装\"></a>Pinia 安装</h1><p>安装 pinia 就很简单了，直接命令安装就可以了。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E5%AE%89%E8%A3%85.png\"></p>\n<h1 id=\"Pinia-使用\"><a href=\"#Pinia-使用\" class=\"headerlink\" title=\"Pinia 使用\"></a>Pinia 使用</h1><p>安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia</p>\n<h2 id=\"1-Pinia-导入\"><a href=\"#1-Pinia-导入\" class=\"headerlink\" title=\"1.Pinia 导入\"></a>1.Pinia 导入</h2><p>首先在 main.js 文件中引入<br> vue3 的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123;createPinia&#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>\n<p>然后，这个 pinia 就在项目中导入了<br>Pinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123;PiniaVuePlugin&#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>\n<p>我们还是以 vue3 来介绍这个 Pinia<br>导入的时候是 hook ，我们需要调用一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const state = createPinia()</span><br></pre></td></tr></table></figure>\n<p>调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">app.use(state)</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-Pinia-基本使用\"><a href=\"#2-Pinia-基本使用\" class=\"headerlink\" title=\"2.Pinia 基本使用\"></a>2.Pinia 基本使用</h2><h3 id=\"1-创建-index-ts-文件\"><a href=\"#1-创建-index-ts-文件\" class=\"headerlink\" title=\"1.创建 index.ts 文件\"></a>1.创建 index.ts 文件</h3><p>使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。<br>创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。</p>\n<h3 id=\"2-编写-index-ts-文件\"><a href=\"#2-编写-index-ts-文件\" class=\"headerlink\" title=\"2.编写 index.ts 文件\"></a>2.编写 index.ts 文件</h3><p>首先我们先引入 pinia</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; defineStore &#125; from &quot;pinia&quot;;</span><br></pre></td></tr></table></figure>\n<p>由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下<br>这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。<br>我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export const enum Names &#123;</span><br><span class=\"line\">  TEST = &quot;TEST&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。<br>这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。<br>state 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。<br>getters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。<br>actions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/indexts.png\"><br>其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E7%BB%93%E6%9E%9C.png\"></p>\n<h3 id=\"3-修改-Pinia-的值\"><a href=\"#3-修改-Pinia-的值\" class=\"headerlink\" title=\"3.修改 Pinia 的值\"></a>3.修改 Pinia 的值</h3><p>修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值<br>修改值的方式呢，常见的有五种</p>\n<h4 id=\"方式一：直接修改\"><a href=\"#方式一：直接修改\" class=\"headerlink\" title=\"方式一：直接修改\"></a>方式一：直接修改</h4><p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E7%BB%93%E6%9E%9C.png\"></p>\n<h4 id=\"方式二：-patch-函数修改\"><a href=\"#方式二：-patch-函数修改\" class=\"headerlink\" title=\"方式二：$patch 函数修改\"></a>方式二：$patch 函数修改</h4><p>在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C2.png\"></p>\n<h4 id=\"方式三：-patch-函数修改\"><a href=\"#方式三：-patch-函数修改\" class=\"headerlink\" title=\"方式三：$patch 函数修改\"></a>方式三：$patch 函数修改</h4><p>咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE4%E4%BB%A3%E7%A0%81.png\"><br>效果其实和方式二是一模一样的</p>\n<h4 id=\"方式四：-state-方式\"><a href=\"#方式四：-state-方式\" class=\"headerlink\" title=\"方式四：$state 方式\"></a>方式四：$state 方式</h4><p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE5%E4%BB%A3%E7%A0%81.png\"></p>\n<h4 id=\"方式五：-action-方式\"><a href=\"#方式五：-action-方式\" class=\"headerlink\" title=\"方式五： action 方式\"></a>方式五： action 方式</h4><p>这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%811.png\"><br>写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C2.png\"><br>当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C2.png\"><br>以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用</p>\n<h1 id=\"pinia-解构\"><a href=\"#pinia-解构\" class=\"headerlink\" title=\"pinia 解构\"></a>pinia 解构</h1><p>上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E4%BB%A3%E7%A0%81.png\"><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E7%BB%93%E6%9E%9C.png\"><br>我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。<br>但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。<br>做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png\"><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png\"><br>通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。<br>解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。<br>就是 storeToRefs，使用 storeToRefs 需要导入一下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br></pre></td></tr></table></figure>\n<p>然后把我们解构的对象包裹一下就可以了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123; name, age &#125; = storeToRefs(userInfo)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E7%BB%93%E6%9E%9C.png\"><br>或者我们换一个写法，直接操作结构后的数据，记得，要 .value<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%81.png\"></p>\n<h1 id=\"Pinia-的-actions\"><a href=\"#Pinia-的-actions\" class=\"headerlink\" title=\"Pinia 的 actions\"></a>Pinia 的 actions</h1><p>actions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步<br>接下来我们重点介绍一下actions异步<br>actions 异步<br>首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C2.png\"><br>actions 同步、异步连用<br>这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。<br>上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E4%BB%A3%E7%A0%81.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"getter-函数\"><a href=\"#getter-函数\" class=\"headerlink\" title=\"getter 函数\"></a>getter 函数</h1><p>getters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。<br>有两种写法:<br>普通函数方式写法<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下按钮，修改一下 name，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C2.png\"><br>我们可以看见，点击修改 name 之后getter 也会实时的渲染出来<br>相互调用<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E4%BB%A3%E7%A0%81.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下按钮，修改一下 name和 age，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C2.png\"></p>\n<h1 id=\"API-的使用\"><a href=\"#API-的使用\" class=\"headerlink\" title=\"API 的使用\"></a>API 的使用</h1><p>$reset ：重置到初始值<br>这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E4%BB%A3%E7%A0%81.png\"><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下$reset按钮，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C2.png\"><br>$subscribe：监听 state 数据变化<br>$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E4%BB%A3%E7%A0%81.png\"><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C1.png\"><br>控制台打印出监听到的变化结果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C2.png\"><br>$onAction：一调用 actions 就触发<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E4%BB%A3%E7%A0%81.png\"><br>控制台打印出监听到的变化结果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"Vue3setup函数","date":"2022-10-13T02:45:33.000Z","_content":"# vue2 和 vue3 开发的区别\n首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。\n\nvue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。\n\n# 使用 setup 原因\n在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。\n\n为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。\n\n# setup 用法\n1. setup 函数是组合式 API 的入口。\n2. setup 函数是启动页面后自动执行的函数。\n3. 页面中所涉及的变量和方法等，都需要写在 setup 函数中。\n4. 在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。\n5. setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。\n\n# setup 可以接受哪些参数\nsetup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。\n\n# setup 函数定义变量\n组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。\n\n## 定义一个基本类型变量\n在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。\n![](基本变量.png)\n\n上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。\n![](名称渲染失败.png)\n![](提示找不到.png)\n\n出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。\n![](name.png)\n将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。\n![](渲染成功.png)\n\n同样，创建其他基本类型也是一样的编写方式。\n![](基本数据代码.png)\n切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。\n![](基本数据类型.png)\n\n## setup 创建复杂数据类型\nsetup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。\n![](复杂数据代码.png)\n刷新页面，渲染正常\n![](复杂数据类型.png)\n\n# setup 创建方法\n除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。\n创建方法的方式有两种：\n## 第一种就是很常见的通过 function 的方式创建\n    // 一、通过 function 的方式创建\n        function btn() {\n            console.log('按钮被点击了')\n        }\n## 另一种使用过箭头函数的方式创建\n      // 二、通过箭头函数的方式创建\n      const btn = () => {\n        console.log('按钮被点击了')\n      }\n例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。\n![](点击代码.png)\n保存代码，刷新页面，点击按钮在控制台输出内容。\n![](被点击.png)","source":"_posts/Vue3setup函数.md","raw":"---\ntitle: Vue3setup函数\ndate: 2022-10-13 10:45:33\ntags: vue3\ncategories: vue3\n---\n# vue2 和 vue3 开发的区别\n首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。\n\nvue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。\n\n# 使用 setup 原因\n在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。\n\n为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。\n\n# setup 用法\n1. setup 函数是组合式 API 的入口。\n2. setup 函数是启动页面后自动执行的函数。\n3. 页面中所涉及的变量和方法等，都需要写在 setup 函数中。\n4. 在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。\n5. setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。\n\n# setup 可以接受哪些参数\nsetup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。\n\n# setup 函数定义变量\n组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。\n\n## 定义一个基本类型变量\n在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。\n![](基本变量.png)\n\n上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。\n![](名称渲染失败.png)\n![](提示找不到.png)\n\n出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。\n![](name.png)\n将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。\n![](渲染成功.png)\n\n同样，创建其他基本类型也是一样的编写方式。\n![](基本数据代码.png)\n切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。\n![](基本数据类型.png)\n\n## setup 创建复杂数据类型\nsetup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。\n![](复杂数据代码.png)\n刷新页面，渲染正常\n![](复杂数据类型.png)\n\n# setup 创建方法\n除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。\n创建方法的方式有两种：\n## 第一种就是很常见的通过 function 的方式创建\n    // 一、通过 function 的方式创建\n        function btn() {\n            console.log('按钮被点击了')\n        }\n## 另一种使用过箭头函数的方式创建\n      // 二、通过箭头函数的方式创建\n      const btn = () => {\n        console.log('按钮被点击了')\n      }\n例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。\n![](点击代码.png)\n保存代码，刷新页面，点击按钮在控制台输出内容。\n![](被点击.png)","slug":"Vue3setup函数","published":1,"updated":"2023-03-22T06:27:38.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml3000gtit85vl1a80y","content":"<h1 id=\"vue2-和-vue3-开发的区别\"><a href=\"#vue2-和-vue3-开发的区别\" class=\"headerlink\" title=\"vue2 和 vue3 开发的区别\"></a>vue2 和 vue3 开发的区别</h1><p>首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。</p>\n<p>vue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。</p>\n<h1 id=\"使用-setup-原因\"><a href=\"#使用-setup-原因\" class=\"headerlink\" title=\"使用 setup 原因\"></a>使用 setup 原因</h1><p>在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。</p>\n<p>为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。</p>\n<h1 id=\"setup-用法\"><a href=\"#setup-用法\" class=\"headerlink\" title=\"setup 用法\"></a>setup 用法</h1><ol>\n<li>setup 函数是组合式 API 的入口。</li>\n<li>setup 函数是启动页面后自动执行的函数。</li>\n<li>页面中所涉及的变量和方法等，都需要写在 setup 函数中。</li>\n<li>在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。</li>\n<li>setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。</li>\n</ol>\n<h1 id=\"setup-可以接受哪些参数\"><a href=\"#setup-可以接受哪些参数\" class=\"headerlink\" title=\"setup 可以接受哪些参数\"></a>setup 可以接受哪些参数</h1><p>setup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。</p>\n<h1 id=\"setup-函数定义变量\"><a href=\"#setup-函数定义变量\" class=\"headerlink\" title=\"setup 函数定义变量\"></a>setup 函数定义变量</h1><p>组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。</p>\n<h2 id=\"定义一个基本类型变量\"><a href=\"#定义一个基本类型变量\" class=\"headerlink\" title=\"定义一个基本类型变量\"></a>定义一个基本类型变量</h2><p>在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%90%8D%E7%A7%B0%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/name.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%B8%B2%E6%9F%93%E6%88%90%E5%8A%9F.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>同样，创建其他基本类型也是一样的编写方式。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h2 id=\"setup-创建复杂数据类型\"><a href=\"#setup-创建复杂数据类型\" class=\"headerlink\" title=\"setup 创建复杂数据类型\"></a>setup 创建复杂数据类型</h2><p>setup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>刷新页面，渲染正常<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"setup-创建方法\"><a href=\"#setup-创建方法\" class=\"headerlink\" title=\"setup 创建方法\"></a>setup 创建方法</h1><p>除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。<br>创建方法的方式有两种：</p>\n<h2 id=\"第一种就是很常见的通过-function-的方式创建\"><a href=\"#第一种就是很常见的通过-function-的方式创建\" class=\"headerlink\" title=\"第一种就是很常见的通过 function 的方式创建\"></a>第一种就是很常见的通过 function 的方式创建</h2><pre><code>// 一、通过 function 的方式创建\n    function btn() &#123;\n        console.log(&#39;按钮被点击了&#39;)\n    &#125;\n</code></pre>\n<h2 id=\"另一种使用过箭头函数的方式创建\"><a href=\"#另一种使用过箭头函数的方式创建\" class=\"headerlink\" title=\"另一种使用过箭头函数的方式创建\"></a>另一种使用过箭头函数的方式创建</h2><pre><code>  // 二、通过箭头函数的方式创建\n  const btn = () =&gt; &#123;\n    console.log(&#39;按钮被点击了&#39;)\n  &#125;\n</code></pre>\n<p>例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E7%82%B9%E5%87%BB%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>保存代码，刷新页面，点击按钮在控制台输出内容。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E8%A2%AB%E7%82%B9%E5%87%BB.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"vue2-和-vue3-开发的区别\"><a href=\"#vue2-和-vue3-开发的区别\" class=\"headerlink\" title=\"vue2 和 vue3 开发的区别\"></a>vue2 和 vue3 开发的区别</h1><p>首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。</p>\n<p>vue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。</p>\n<h1 id=\"使用-setup-原因\"><a href=\"#使用-setup-原因\" class=\"headerlink\" title=\"使用 setup 原因\"></a>使用 setup 原因</h1><p>在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。</p>\n<p>为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。</p>\n<h1 id=\"setup-用法\"><a href=\"#setup-用法\" class=\"headerlink\" title=\"setup 用法\"></a>setup 用法</h1><ol>\n<li>setup 函数是组合式 API 的入口。</li>\n<li>setup 函数是启动页面后自动执行的函数。</li>\n<li>页面中所涉及的变量和方法等，都需要写在 setup 函数中。</li>\n<li>在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。</li>\n<li>setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。</li>\n</ol>\n<h1 id=\"setup-可以接受哪些参数\"><a href=\"#setup-可以接受哪些参数\" class=\"headerlink\" title=\"setup 可以接受哪些参数\"></a>setup 可以接受哪些参数</h1><p>setup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。</p>\n<h1 id=\"setup-函数定义变量\"><a href=\"#setup-函数定义变量\" class=\"headerlink\" title=\"setup 函数定义变量\"></a>setup 函数定义变量</h1><p>组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。</p>\n<h2 id=\"定义一个基本类型变量\"><a href=\"#定义一个基本类型变量\" class=\"headerlink\" title=\"定义一个基本类型变量\"></a>定义一个基本类型变量</h2><p>在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F.png\"></p>\n<p>上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%90%8D%E7%A7%B0%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5.png\"><br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0.png\"></p>\n<p>出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/name.png\"><br>将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%B8%B2%E6%9F%93%E6%88%90%E5%8A%9F.png\"></p>\n<p>同样，创建其他基本类型也是一样的编写方式。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\"></p>\n<h2 id=\"setup-创建复杂数据类型\"><a href=\"#setup-创建复杂数据类型\" class=\"headerlink\" title=\"setup 创建复杂数据类型\"></a>setup 创建复杂数据类型</h2><p>setup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，渲染正常<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\"></p>\n<h1 id=\"setup-创建方法\"><a href=\"#setup-创建方法\" class=\"headerlink\" title=\"setup 创建方法\"></a>setup 创建方法</h1><p>除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。<br>创建方法的方式有两种：</p>\n<h2 id=\"第一种就是很常见的通过-function-的方式创建\"><a href=\"#第一种就是很常见的通过-function-的方式创建\" class=\"headerlink\" title=\"第一种就是很常见的通过 function 的方式创建\"></a>第一种就是很常见的通过 function 的方式创建</h2><pre><code>// 一、通过 function 的方式创建\n    function btn() &#123;\n        console.log(&#39;按钮被点击了&#39;)\n    &#125;\n</code></pre>\n<h2 id=\"另一种使用过箭头函数的方式创建\"><a href=\"#另一种使用过箭头函数的方式创建\" class=\"headerlink\" title=\"另一种使用过箭头函数的方式创建\"></a>另一种使用过箭头函数的方式创建</h2><pre><code>  // 二、通过箭头函数的方式创建\n  const btn = () =&gt; &#123;\n    console.log(&#39;按钮被点击了&#39;)\n  &#125;\n</code></pre>\n<p>例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E7%82%B9%E5%87%BB%E4%BB%A3%E7%A0%81.png\"><br>保存代码，刷新页面，点击按钮在控制台输出内容。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E8%A2%AB%E7%82%B9%E5%87%BB.png\"></p>\n"},{"title":"Vue3shallowRef和shallowReactive","date":"2022-10-19T11:20:37.000Z","_content":"# shallowRef 和 shallowReactive\n1. shallowRef 函数，只处理基本类型数据。\n2. shallowReactive 函数，只处理第一层数据。\n3. 两个在使用的时候都需要引入才可以。\nref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。\n但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。\n\n# 深度监听的问题：\n1. 无论 ref 函数还是 reactive 函数都是深度监听。\n2. 如果数据量过大，超级超级消耗性能。\n3. 如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。\n\n# 使用 shallowReactive 非深度监听\n记住一点，shallowReactive 函数，只能处理第一层数据。\n![](shallowReactive一代码.png)\n我们分别点击两个按钮，看一下页面变化。\n![](shallowReactive一代码结果.png)\n通过效果，我们稍微总结一下：\n1. shallowReactive只会包装第一层的数据\n2. 默认情况它只能够监听数据的第一层。\n3. 如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。\n\n# 使用 shallowRef 非深度监听\nshallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。\n![](shallowRef代码.png)\n点击按钮，修改 boy 的值\n![](shallowRef代码结果.png)\n\n有一个问题：shallowRef 函数，只处理基本类型数据吗？\n![](shallowRef二代码.png)\n在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。\n![](shallowRef二代码结果.png)\n所以说呢，shallowRef 函数，只能处理基本类型数据。\n","source":"_posts/Vue3shallowRef和shallowReactive.md","raw":"---\ntitle: Vue3shallowRef和shallowReactive\ndate: 2022-10-19 19:20:37\ntags: vue3\ncategories: vue3\n---\n# shallowRef 和 shallowReactive\n1. shallowRef 函数，只处理基本类型数据。\n2. shallowReactive 函数，只处理第一层数据。\n3. 两个在使用的时候都需要引入才可以。\nref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。\n但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。\n\n# 深度监听的问题：\n1. 无论 ref 函数还是 reactive 函数都是深度监听。\n2. 如果数据量过大，超级超级消耗性能。\n3. 如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。\n\n# 使用 shallowReactive 非深度监听\n记住一点，shallowReactive 函数，只能处理第一层数据。\n![](shallowReactive一代码.png)\n我们分别点击两个按钮，看一下页面变化。\n![](shallowReactive一代码结果.png)\n通过效果，我们稍微总结一下：\n1. shallowReactive只会包装第一层的数据\n2. 默认情况它只能够监听数据的第一层。\n3. 如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。\n\n# 使用 shallowRef 非深度监听\nshallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。\n![](shallowRef代码.png)\n点击按钮，修改 boy 的值\n![](shallowRef代码结果.png)\n\n有一个问题：shallowRef 函数，只处理基本类型数据吗？\n![](shallowRef二代码.png)\n在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。\n![](shallowRef二代码结果.png)\n所以说呢，shallowRef 函数，只能处理基本类型数据。\n","slug":"Vue3shallowRef和shallowReactive","published":1,"updated":"2023-03-22T06:28:05.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml3000ltit8g1vp1nwf","content":"<h1 id=\"shallowRef-和-shallowReactive\"><a href=\"#shallowRef-和-shallowReactive\" class=\"headerlink\" title=\"shallowRef 和 shallowReactive\"></a>shallowRef 和 shallowReactive</h1><ol>\n<li>shallowRef 函数，只处理基本类型数据。</li>\n<li>shallowReactive 函数，只处理第一层数据。</li>\n<li>两个在使用的时候都需要引入才可以。<br>ref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。<br>但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。</li>\n</ol>\n<h1 id=\"深度监听的问题：\"><a href=\"#深度监听的问题：\" class=\"headerlink\" title=\"深度监听的问题：\"></a>深度监听的问题：</h1><ol>\n<li>无论 ref 函数还是 reactive 函数都是深度监听。</li>\n<li>如果数据量过大，超级超级消耗性能。</li>\n<li>如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。</li>\n</ol>\n<h1 id=\"使用-shallowReactive-非深度监听\"><a href=\"#使用-shallowReactive-非深度监听\" class=\"headerlink\" title=\"使用 shallowReactive 非深度监听\"></a>使用 shallowReactive 非深度监听</h1><p>记住一点，shallowReactive 函数，只能处理第一层数据。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们分别点击两个按钮，看一下页面变化。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>通过效果，我们稍微总结一下：</p>\n<ol>\n<li>shallowReactive只会包装第一层的数据</li>\n<li>默认情况它只能够监听数据的第一层。</li>\n<li>如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。</li>\n</ol>\n<h1 id=\"使用-shallowRef-非深度监听\"><a href=\"#使用-shallowRef-非深度监听\" class=\"headerlink\" title=\"使用 shallowRef 非深度监听\"></a>使用 shallowRef 非深度监听</h1><p>shallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>点击按钮，修改 boy 的值<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>有一个问题：shallowRef 函数，只处理基本类型数据吗？<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>所以说呢，shallowRef 函数，只能处理基本类型数据。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"shallowRef-和-shallowReactive\"><a href=\"#shallowRef-和-shallowReactive\" class=\"headerlink\" title=\"shallowRef 和 shallowReactive\"></a>shallowRef 和 shallowReactive</h1><ol>\n<li>shallowRef 函数，只处理基本类型数据。</li>\n<li>shallowReactive 函数，只处理第一层数据。</li>\n<li>两个在使用的时候都需要引入才可以。<br>ref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。<br>但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。</li>\n</ol>\n<h1 id=\"深度监听的问题：\"><a href=\"#深度监听的问题：\" class=\"headerlink\" title=\"深度监听的问题：\"></a>深度监听的问题：</h1><ol>\n<li>无论 ref 函数还是 reactive 函数都是深度监听。</li>\n<li>如果数据量过大，超级超级消耗性能。</li>\n<li>如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。</li>\n</ol>\n<h1 id=\"使用-shallowReactive-非深度监听\"><a href=\"#使用-shallowReactive-非深度监听\" class=\"headerlink\" title=\"使用 shallowReactive 非深度监听\"></a>使用 shallowReactive 非深度监听</h1><p>记住一点，shallowReactive 函数，只能处理第一层数据。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81.png\"><br>我们分别点击两个按钮，看一下页面变化。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"><br>通过效果，我们稍微总结一下：</p>\n<ol>\n<li>shallowReactive只会包装第一层的数据</li>\n<li>默认情况它只能够监听数据的第一层。</li>\n<li>如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。</li>\n</ol>\n<h1 id=\"使用-shallowRef-非深度监听\"><a href=\"#使用-shallowRef-非深度监听\" class=\"headerlink\" title=\"使用 shallowRef 非深度监听\"></a>使用 shallowRef 非深度监听</h1><p>shallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81.png\"><br>点击按钮，修改 boy 的值<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"></p>\n<p>有一个问题：shallowRef 函数，只处理基本类型数据吗？<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"><br>所以说呢，shallowRef 函数，只能处理基本类型数据。</p>\n"},{"title":"Vue3toRef和toRefs函数","date":"2022-10-14T13:48:21.000Z","_content":"# toRef 函数\n我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？\n\n首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。\n什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。\n但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。\n\n# toRef 函数使用\n## 首先呢， toRef 函数有两个参数\ntoRef(操作对象, 对象属性)\n## 接下来我们使用 toRef 函数写一个案例\n![](toref代码.png)\n![](toref页面成功.png)\n\n我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。\n![](toref修改代码.png)\n然后点击按钮看一下页面效果\n![](toref修改结果.png)\n\n通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。\n这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。\n![](toref源数据.png)\n\ntoRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。\n所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。\n![](toref打印body代码.png)\n\n刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象\n![](torefbody打印结果.png)\n发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。\n记住了！\ntoRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。\n\n# ref 函数验证\n那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下\n![](ref函数验证代码.png)\n刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图\n![](ref函数验证结果.png)\n所以再记住！\nref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新\n\n# toRefs 函数\ntoRefs 函数的使用呢，其实和 toRef 函数类似。\ntoRefs 函数用于批量设置多个数据为响应式数据。\ntoRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。\ntoRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。\n\n# toRefs 函数使用\n![](refs使用代码.png)\n![](refs使用结果.png)\n![](refs使用控制台信息.png)\n修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value\n![](修改代码.png)\n查看效果\n![](refs使用正常.png)\n现在可以看到数据显示正常啦！\n这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？\n这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。\n![](reactive代码.png)\n我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。\n![](refs使用正常.png)\n我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？\n其实是有原因的。\n其实 toRefs 函数最大的用处在这里！\n我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。\n![](refs解决代码.png)\n在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。\n![](refs使用正常.png)\n但是呢，深层次的对象依旧需要通过点来实现。\n也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。\n记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。\n看下面代码：\n![](原始数据代码.png)\n![](数据源结果.png)\n从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。\n\n# 总结\n如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。\n如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。\ntoRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。\n\n\n\n\n\n","source":"_posts/Vue3toRef和toRefs函数.md","raw":"---\ntitle: Vue3toRef和toRefs函数\ndate: 2022-10-14 21:48:21\ntags: vue3\ncategories: vue3\n---\n# toRef 函数\n我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？\n\n首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。\n什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。\n但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。\n\n# toRef 函数使用\n## 首先呢， toRef 函数有两个参数\ntoRef(操作对象, 对象属性)\n## 接下来我们使用 toRef 函数写一个案例\n![](toref代码.png)\n![](toref页面成功.png)\n\n我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。\n![](toref修改代码.png)\n然后点击按钮看一下页面效果\n![](toref修改结果.png)\n\n通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。\n这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。\n![](toref源数据.png)\n\ntoRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。\n所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。\n![](toref打印body代码.png)\n\n刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象\n![](torefbody打印结果.png)\n发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。\n记住了！\ntoRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。\n\n# ref 函数验证\n那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下\n![](ref函数验证代码.png)\n刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图\n![](ref函数验证结果.png)\n所以再记住！\nref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新\n\n# toRefs 函数\ntoRefs 函数的使用呢，其实和 toRef 函数类似。\ntoRefs 函数用于批量设置多个数据为响应式数据。\ntoRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。\ntoRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。\n\n# toRefs 函数使用\n![](refs使用代码.png)\n![](refs使用结果.png)\n![](refs使用控制台信息.png)\n修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value\n![](修改代码.png)\n查看效果\n![](refs使用正常.png)\n现在可以看到数据显示正常啦！\n这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？\n这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。\n![](reactive代码.png)\n我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。\n![](refs使用正常.png)\n我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？\n其实是有原因的。\n其实 toRefs 函数最大的用处在这里！\n我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。\n![](refs解决代码.png)\n在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。\n![](refs使用正常.png)\n但是呢，深层次的对象依旧需要通过点来实现。\n也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。\n记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。\n看下面代码：\n![](原始数据代码.png)\n![](数据源结果.png)\n从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。\n\n# 总结\n如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。\n如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。\ntoRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。\n\n\n\n\n\n","slug":"Vue3toRef和toRefs函数","published":1,"updated":"2023-03-22T06:29:13.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml3000ntit8c66scnbc","content":"<h1 id=\"toRef-函数\"><a href=\"#toRef-函数\" class=\"headerlink\" title=\"toRef 函数\"></a>toRef 函数</h1><p>我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？</p>\n<p>首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。<br>什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。<br>但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>\n<h1 id=\"toRef-函数使用\"><a href=\"#toRef-函数使用\" class=\"headerlink\" title=\"toRef 函数使用\"></a>toRef 函数使用</h1><h2 id=\"首先呢，-toRef-函数有两个参数\"><a href=\"#首先呢，-toRef-函数有两个参数\" class=\"headerlink\" title=\"首先呢， toRef 函数有两个参数\"></a>首先呢， toRef 函数有两个参数</h2><p>toRef(操作对象, 对象属性)</p>\n<h2 id=\"接下来我们使用-toRef-函数写一个案例\"><a href=\"#接下来我们使用-toRef-函数写一个案例\" class=\"headerlink\" title=\"接下来我们使用 toRef 函数写一个案例\"></a>接下来我们使用 toRef 函数写一个案例</h2><p><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E9%A1%B5%E9%9D%A2%E6%88%90%E5%8A%9F.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>然后点击按钮看一下页面效果<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。<br>这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%BA%90%E6%95%B0%E6%8D%AE.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>toRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。<br>所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%89%93%E5%8D%B0body%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/torefbody%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。<br>记住了！<br>toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>\n<h1 id=\"ref-函数验证\"><a href=\"#ref-函数验证\" class=\"headerlink\" title=\"ref 函数验证\"></a>ref 函数验证</h1><p>那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>所以再记住！<br>ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新</p>\n<h1 id=\"toRefs-函数\"><a href=\"#toRefs-函数\" class=\"headerlink\" title=\"toRefs 函数\"></a>toRefs 函数</h1><p>toRefs 函数的使用呢，其实和 toRef 函数类似。<br>toRefs 函数用于批量设置多个数据为响应式数据。<br>toRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。<br>toRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。</p>\n<h1 id=\"toRefs-函数使用\"><a href=\"#toRefs-函数使用\" class=\"headerlink\" title=\"toRefs 函数使用\"></a>toRefs 函数使用</h1><p><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%A1%E6%81%AF.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value<br><img src=\"/%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>查看效果<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>现在可以看到数据显示正常啦！<br>这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？<br>这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/reactive%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？<br>其实是有原因的。<br>其实 toRefs 函数最大的用处在这里！<br>我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>但是呢，深层次的对象依旧需要通过点来实现。<br>也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。<br>记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。<br>看下面代码：<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E6%95%B0%E6%8D%AE%E6%BA%90%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。<br>如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。<br>toRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"toRef-函数\"><a href=\"#toRef-函数\" class=\"headerlink\" title=\"toRef 函数\"></a>toRef 函数</h1><p>我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？</p>\n<p>首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。<br>什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。<br>但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>\n<h1 id=\"toRef-函数使用\"><a href=\"#toRef-函数使用\" class=\"headerlink\" title=\"toRef 函数使用\"></a>toRef 函数使用</h1><h2 id=\"首先呢，-toRef-函数有两个参数\"><a href=\"#首先呢，-toRef-函数有两个参数\" class=\"headerlink\" title=\"首先呢， toRef 函数有两个参数\"></a>首先呢， toRef 函数有两个参数</h2><p>toRef(操作对象, 对象属性)</p>\n<h2 id=\"接下来我们使用-toRef-函数写一个案例\"><a href=\"#接下来我们使用-toRef-函数写一个案例\" class=\"headerlink\" title=\"接下来我们使用 toRef 函数写一个案例\"></a>接下来我们使用 toRef 函数写一个案例</h2><p><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E9%A1%B5%E9%9D%A2%E6%88%90%E5%8A%9F.png\"></p>\n<p>我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>然后点击按钮看一下页面效果<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"></p>\n<p>通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。<br>这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%BA%90%E6%95%B0%E6%8D%AE.png\"></p>\n<p>toRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。<br>所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%89%93%E5%8D%B0body%E4%BB%A3%E7%A0%81.png\"></p>\n<p>刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/torefbody%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png\"><br>发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。<br>记住了！<br>toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>\n<h1 id=\"ref-函数验证\"><a href=\"#ref-函数验证\" class=\"headerlink\" title=\"ref 函数验证\"></a>ref 函数验证</h1><p>那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C.png\"><br>所以再记住！<br>ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新</p>\n<h1 id=\"toRefs-函数\"><a href=\"#toRefs-函数\" class=\"headerlink\" title=\"toRefs 函数\"></a>toRefs 函数</h1><p>toRefs 函数的使用呢，其实和 toRef 函数类似。<br>toRefs 函数用于批量设置多个数据为响应式数据。<br>toRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。<br>toRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。</p>\n<h1 id=\"toRefs-函数使用\"><a href=\"#toRefs-函数使用\" class=\"headerlink\" title=\"toRefs 函数使用\"></a>toRefs 函数使用</h1><p><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%A1%E6%81%AF.png\"><br>修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value<br><img src=\"/%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>查看效果<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>现在可以看到数据显示正常啦！<br>这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？<br>这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/reactive%E4%BB%A3%E7%A0%81.png\"><br>我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？<br>其实是有原因的。<br>其实 toRefs 函数最大的用处在这里！<br>我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81.png\"><br>在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>但是呢，深层次的对象依旧需要通过点来实现。<br>也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。<br>记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。<br>看下面代码：<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E6%95%B0%E6%8D%AE%E6%BA%90%E7%BB%93%E6%9E%9C.png\"><br>从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。<br>如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。<br>toRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。</p>\n"},{"title":"Vue3侦听器watch","date":"2022-10-18T10:02:06.000Z","_content":"学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑\n\n# watch 侦听器使用\nwatch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source \n![](侦听器一代码.png)\n上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。\n![](侦听器一结果.png)\n![](侦听器一控制台.png)\n上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。\nwatch API 至少需要指定两个参数: source 和 callback。\n通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。\n\n在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。\n\n案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。\n![](侦听器一数据更新代码.png)\n![](侦听器一数据更新.png)\n我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。\n\n# 侦听器监听 reactive\n![](侦听器监听reactive代码.png)\n![](侦听器监听reactive结果.png)\n在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？\n如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。\n如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。\n![](侦听器二代码.png)\n我们监听对象直接是 num.age， 监听年龄属性值\n![](侦听器二警告.png)\n我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。\n当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。\n![](侦听器二修改代码.png)\n![](侦听器二修改结果.png)\n通过箭头函数，我们就可以实现对象属性的监听。\n很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。\n我们监听深层嵌套的 time 属性值。\n![](侦听器三代码.png)\n发现点击之后没有监听到\n![](侦听器三报错.png)\n这个时候就可以加上 deep 深度监听。\n![](侦听器三修改代码.png)\n加上深度监听 { deep:true }\n![](侦听器三修改结果.png)\n我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。\n\n监听多个参数执行各自逻辑\n比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听\n![](多个侦听器代码.png)\n\n监听多个参数执行相同逻辑\n![](侦听多个参数.png)\n修改 name 和 age 的值\n![](侦听多个参数结果.png)\n\n\n\n","source":"_posts/Vue3侦听器watch.md","raw":"---\ntitle: Vue3侦听器watch\ndate: 2022-10-18 18:02:06\ntags: vue3\ncategories: vue3\n---\n学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑\n\n# watch 侦听器使用\nwatch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source \n![](侦听器一代码.png)\n上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。\n![](侦听器一结果.png)\n![](侦听器一控制台.png)\n上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。\nwatch API 至少需要指定两个参数: source 和 callback。\n通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。\n\n在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。\n\n案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。\n![](侦听器一数据更新代码.png)\n![](侦听器一数据更新.png)\n我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。\n\n# 侦听器监听 reactive\n![](侦听器监听reactive代码.png)\n![](侦听器监听reactive结果.png)\n在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？\n如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。\n如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。\n![](侦听器二代码.png)\n我们监听对象直接是 num.age， 监听年龄属性值\n![](侦听器二警告.png)\n我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。\n当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。\n![](侦听器二修改代码.png)\n![](侦听器二修改结果.png)\n通过箭头函数，我们就可以实现对象属性的监听。\n很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。\n我们监听深层嵌套的 time 属性值。\n![](侦听器三代码.png)\n发现点击之后没有监听到\n![](侦听器三报错.png)\n这个时候就可以加上 deep 深度监听。\n![](侦听器三修改代码.png)\n加上深度监听 { deep:true }\n![](侦听器三修改结果.png)\n我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。\n\n监听多个参数执行各自逻辑\n比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听\n![](多个侦听器代码.png)\n\n监听多个参数执行相同逻辑\n![](侦听多个参数.png)\n修改 name 和 age 的值\n![](侦听多个参数结果.png)\n\n\n\n","slug":"Vue3侦听器watch","published":1,"updated":"2023-03-22T06:25:29.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml4000stit8eyfghsd1","content":"<p>学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑</p>\n<h1 id=\"watch-侦听器使用\"><a href=\"#watch-侦听器使用\" class=\"headerlink\" title=\"watch 侦听器使用\"></a>watch 侦听器使用</h1><p>watch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%8E%A7%E5%88%B6%E5%8F%B0.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。<br>watch API 至少需要指定两个参数: source 和 callback。<br>通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。</p>\n<p>在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。</p>\n<p>案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。</p>\n<h1 id=\"侦听器监听-reactive\"><a href=\"#侦听器监听-reactive\" class=\"headerlink\" title=\"侦听器监听 reactive\"></a>侦听器监听 reactive</h1><p><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？<br>如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。<br>如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们监听对象直接是 num.age， 监听年龄属性值<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E8%AD%A6%E5%91%8A.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。<br>当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>通过箭头函数，我们就可以实现对象属性的监听。<br>很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。<br>我们监听深层嵌套的 time 属性值。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>发现点击之后没有监听到<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E6%8A%A5%E9%94%99.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>这个时候就可以加上 deep 深度监听。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>加上深度监听 { deep:true }<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。</p>\n<p>监听多个参数执行各自逻辑<br>比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E5%A4%9A%E4%B8%AA%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>监听多个参数执行相同逻辑<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>修改 name 和 age 的值<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑</p>\n<h1 id=\"watch-侦听器使用\"><a href=\"#watch-侦听器使用\" class=\"headerlink\" title=\"watch 侦听器使用\"></a>watch 侦听器使用</h1><p>watch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E4%BB%A3%E7%A0%81.png\"><br>上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%8E%A7%E5%88%B6%E5%8F%B0.png\"><br>上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。<br>watch API 至少需要指定两个参数: source 和 callback。<br>通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。</p>\n<p>在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。</p>\n<p>案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png\"><br>我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。</p>\n<h1 id=\"侦听器监听-reactive\"><a href=\"#侦听器监听-reactive\" class=\"headerlink\" title=\"侦听器监听 reactive\"></a>侦听器监听 reactive</h1><p><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E7%BB%93%E6%9E%9C.png\"><br>在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？<br>如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。<br>如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>我们监听对象直接是 num.age， 监听年龄属性值<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E8%AD%A6%E5%91%8A.png\"><br>我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。<br>当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"><br>通过箭头函数，我们就可以实现对象属性的监听。<br>很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。<br>我们监听深层嵌套的 time 属性值。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br>发现点击之后没有监听到<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E6%8A%A5%E9%94%99.png\"><br>这个时候就可以加上 deep 深度监听。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>加上深度监听 { deep:true }<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"><br>我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。</p>\n<p>监听多个参数执行各自逻辑<br>比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E5%A4%9A%E4%B8%AA%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BB%A3%E7%A0%81.png\"></p>\n<p>监听多个参数执行相同逻辑<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0.png\"><br>修改 name 和 age 的值<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"Vue3计算属性","date":"2022-10-17T12:06:38.000Z","_content":"# computed 计算属性说明\ncomputed 表示计算属性，通常是用来进行数据处理。\n比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型\n但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。\n计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。\n# 计算属性使用\n首先呢，使用 computed 需要引入\n![](引入.png)\n我们编写一个案例\n![](案例一.png)\n但是有一点需要注意！\n如果我们直接修改计算属性的值会报一个错误！\n![](案例二.png)\n这个意思就是计算属性是只读的不允许修改 \n如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。\n那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。\n![](计算属性求和.png)\n也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。\n# 总结\n1. vue.3.0 中要从vue 按需导入 computed 计算属性。\n2. 如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。\n3. 使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。\n4. 传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。\n5. 只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。\n6. 既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。","source":"_posts/Vue3计算属性.md","raw":"---\ntitle: Vue3计算属性\ndate: 2022-10-17 20:06:38\ntags: vue3\ncategories: vue3\n---\n# computed 计算属性说明\ncomputed 表示计算属性，通常是用来进行数据处理。\n比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型\n但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。\n计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。\n# 计算属性使用\n首先呢，使用 computed 需要引入\n![](引入.png)\n我们编写一个案例\n![](案例一.png)\n但是有一点需要注意！\n如果我们直接修改计算属性的值会报一个错误！\n![](案例二.png)\n这个意思就是计算属性是只读的不允许修改 \n如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。\n那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。\n![](计算属性求和.png)\n也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。\n# 总结\n1. vue.3.0 中要从vue 按需导入 computed 计算属性。\n2. 如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。\n3. 使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。\n4. 传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。\n5. 只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。\n6. 既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。","slug":"Vue3计算属性","published":1,"updated":"2023-03-22T06:24:56.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml5000vtit89wsf7qyg","content":"<h1 id=\"computed-计算属性说明\"><a href=\"#computed-计算属性说明\" class=\"headerlink\" title=\"computed 计算属性说明\"></a>computed 计算属性说明</h1><p>computed 表示计算属性，通常是用来进行数据处理。<br>比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型<br>但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。<br>计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。</p>\n<h1 id=\"计算属性使用\"><a href=\"#计算属性使用\" class=\"headerlink\" title=\"计算属性使用\"></a>计算属性使用</h1><p>首先呢，使用 computed 需要引入<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E5%BC%95%E5%85%A5.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们编写一个案例<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%B8%80.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>但是有一点需要注意！<br>如果我们直接修改计算属性的值会报一个错误！<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%BA%8C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>这个意思就是计算属性是只读的不允许修改<br>如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。<br>那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%B1%82%E5%92%8C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>vue.3.0 中要从vue 按需导入 computed 计算属性。</li>\n<li>如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。</li>\n<li>使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。</li>\n<li>传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。</li>\n<li>只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。</li>\n<li>既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。</li>\n</ol>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"computed-计算属性说明\"><a href=\"#computed-计算属性说明\" class=\"headerlink\" title=\"computed 计算属性说明\"></a>computed 计算属性说明</h1><p>computed 表示计算属性，通常是用来进行数据处理。<br>比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型<br>但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。<br>计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。</p>\n<h1 id=\"计算属性使用\"><a href=\"#计算属性使用\" class=\"headerlink\" title=\"计算属性使用\"></a>计算属性使用</h1><p>首先呢，使用 computed 需要引入<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E5%BC%95%E5%85%A5.png\"><br>我们编写一个案例<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%B8%80.png\"><br>但是有一点需要注意！<br>如果我们直接修改计算属性的值会报一个错误！<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%BA%8C.png\"><br>这个意思就是计算属性是只读的不允许修改<br>如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。<br>那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%B1%82%E5%92%8C.png\"><br>也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>vue.3.0 中要从vue 按需导入 computed 计算属性。</li>\n<li>如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。</li>\n<li>使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。</li>\n<li>传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。</li>\n<li>只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。</li>\n<li>既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。</li>\n</ol>\n"},{"title":"Vuex","date":"2023-04-05T11:49:07.000Z","cover":["/images/vuexcover.png"],"banner":{"type":"img","bgurl":["/images/vuexcover.png"]},"_content":"Vuex它是一个程序里面的状态管理模式，它是集中式存储所有组件的状态的小仓库，并且保持我们存储的状态以一种可以预测的方式发生变化。\n# 第一步，了解Vuex\n## 问题假设:\n如果你的项目里有很多页面（组件/视图），页面之间存在多级的嵌套关系，此时，这些页面假如都需要共享一个状态的时候，此时就会产生以下两个问题：\n1. 多个视图依赖同一个状态\n2. 来自不同视图的行为需要变更同一个状态\n## 解决以上方法的方案:🤪\n1. 对于第一个问题:\n+ 假如是多级嵌套关系，你可以使用父子组件传参进行解决；\n+ 对于兄弟组件或者关系更复杂组件之间，就很难办了，虽然可以通过各种各样的办法解决，可实在很不优雅，而且项目是越做越大，代码就会变得越多。\n2. 对于第二个问题：\n+ 你可以通过父子组件直接引用，或者通过事件来变更或者同步状态的多份拷贝，这种模式很脆弱，往往使得代码难以维护，而且同样会让代码就会变得越多。\n## 不如换一种思路：\n+ 把各个组件都需要依赖的同一个状态抽取出来，在全局使用进行管理。\n+ 在这种模式下，任何组件都可以直接访问到这个状态，或者当状态发生改变时，所有的组件都获得更新。\n## 这时候，就要用到Vuex\n这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux。与其他模式不同的是，Vuex 是专门为 Vue 设计的状态管理库，以利用 Vue.js 的数据响应机制来进行高效的状态更新。\n## vuex使用周期图\n![](vuex.png)\n## 那什么时候应该用vuex呢？🤔\n+ 如果你不需要开发大型的单页应用，此时你完全没有必要使用vuex，比如你的页面就两三个，使用vuex后增加的文件比你现在的页面还要多，那就没这个必要了。\n+ 假如你的项目达到了中大型应用的规模，此时你很可能会考虑，如何更好地在组件外部管理状态，Vuex将会成为你的选择。\n# 第二步，安装vuex\n1. 首先，安装vuex\n```\nnpm install vuex --save\n```\n2. 然后配置vuex，在src路径下创建store文件夹，然后创建index.js文件，文件内容如下：\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  state: {\n    // 定义一个name，以供全局使用\n    name: 'wnxx',\n    // 定义一个number，以供全局使用\n    number: 0,\n    // 定义一个list，以供全局使用\n    list: [\n      { id: 1, name: 'welcome' },\n      { id: 2, name: 'to' },\n      { id: 3, name: 'vuex' },\n    ],\n  },\n});\nexport default store;\n```\n3. 修改main.js：\n```js\nimport Vue from 'vue';\nimport App from './App';\nimport router from './router';\n// 引入我们前面导出的store对象\nimport store from './store'; \nVue.config.productionTip = false;\nnew Vue({\n  el: '#app',\n  router,\n  store, // 把store对象添加到vue实例上\n  components: { App },\n  template: '<App/>',\n});\n```\n4. 最后修改App.vue：\n```html\n<template>\n  <div></div>\n</template>\n<script>\nexport default {\n  mounted() {\n    // 使用this.$store.state.XXX可以直接访问到仓库中的状态\n    console.log(this.$store.state.name);\n  },\n};\n</script>\n```\n此时，启动项目,即可在控制台输出刚才我们定义在store中的name的值。\n## 官方建议1: \n官方建议我们以上操作this.$store.state.XXX最好放在计算属性中，就像这样：\n```js\nexport default {\n  mounted() {\n    console.log(this.getName);\n  },\n  computed: {\n    getName() {\n      return this.$store.state.name;\n    },\n  },\n};\n```\n## 官方建议2:\n是不是每次都写this.$store.state.XXX让你感到繁琐，你实在不想写，当然有简便的写法，就像下面这样：\n```html\n<script>\n // 从vuex中导入mapState\nimport { mapState } from 'vuex';\nexport default {\n  mounted() {\n    console.log(this.name);\n  },\n  computed: {\n    // 经过解构后，自动就添加到了计算属性中，此时就可以直接像访问计算属性一样访问它\n    ...mapState(['name']), \n  },\n};\n</script>\n```\n你甚至可以在解构的时候给它赋别名，取外号，就像这样：\n```js\n// 赋别名的话，这里接收对象，而不是数组\n...mapState({ aliasName: 'name' }),  \n```\n🤗现在，安装vuex并且初始化的工作就结束了，此时你可以很轻易的在项目的任意地方访问到仓库里的状态。\n# 第三步，了解修饰器：Getter\n接下来，我们介绍一个读取操作的 “修饰利器” ---Getter\n## 问题假设:\n😡设想，你已经将store中的name展示到页面上了，而且是很多页面都展示了，此时产品经理要求：所有的name前面都要加上“hello”！\n这时候，你第一想到的是怎么加呢？\nemm...在每个页面上，使用this.$store.state.name获取到值之后，进行遍历，前面追加\"hello\"即可。\nNo,No,No\n## 这样很不好，原因如下：\n+ 第一，假如你在A、B、C三个页面都用到了name，那么你要在这A、B、C三个页面都修改一遍，多个页面你就要加很多遍这个方法，这样只会造成代码冗余；\n+ 第二，假如下次产品经理让你把 “hello” 改成 “GoodBye” 的时候，你又得把三个页面都改一遍，这时候你只能...😇\n## 新的思路:👏🏻 \n我们可以直接在store中对name进行一些操作或者加工，从源头解决问题！那么具体应该怎么写呢？\n1. 首先，在store对象中增加getters属性\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  state: {\n    // 定义一个name，以供全局使用\n    name: 'wnxx',\n    // 定义一个number，以供全局使用\n    number: 0,\n    // 定义一个list，以供全局使用\n    list: [\n      { id: 1, name: 'welcome' },\n      { id: 2, name: 'to' },\n      { id: 3, name: 'vuex' },\n    ],\n  },\n    // 在store对象中增加getters属性\n      getters: {\n         getMessage(state) {\n      // 获取修饰后的name，第一个参数state为必要参数，必须写在形参上\n         return `hello${state.name}`;\n    },\n  },\n});\nexport default store;\n```\n2. 在组件中使用:\n```js\nexport default {\n  mounted() {\n    // 注意不是$store.state了，而是$store.getters\n    console.log(this.$store.state.name);\n    console.log(this.$store.getters.getMessage);\n  },\n};\n```\n## 官方建议:\n不要每次都写this.$store.getters.XXX，官方建议我们可以使用mapGetters去解构到计算属性中，就像使用mapState一样，就可以直接使用this调用了，就像下面这样：\n```html\n<script>\nimport { mapState, mapGetters } from 'vuex';\nexport default {\n  mounted() {\n    console.log(this.name);\n    console.log(this.getMessage);\n  },\n  computed: {\n    ...mapState(['name']),\n    ...mapGetters(['getMessage']),\n  },\n};\n</script>\n```\n当然，和mapState一样你也可以取别名，取外号，就像下面这样：\n```js\n...mapGetters({ aliasName: 'getMessage' }),  \n// 赋别名的话，这里接收对象，而不是数组\n```\n🤗 OK，当你看到这里，你已经成功的了解了getters啦！\n😎 读取值的操作我们有 “原生读（state）” 和 “修饰读（getters）”，接下来就要介绍怎么修改值了！\n# 第四步，了解如何修改值：Mutation\n🤗OK！我们已经成功访问到了store里面的值，接下来我来介绍一下怎么修改state里面的值。\n## 错误示范\n```js\n// 错误示范\nthis.$store.state.XXX = XXX;\n```\n## 错误原因:\n因为这个store仓库比较奇怪，你可以随便拿，但是你不能随便改。\n我举个例子：假如你打开微信朋友圈，看到你的好友发了动态，但是动态里有个错别字，你要怎么办呢？你可以帮他改掉吗？当然不可以！我们只能通知他本人去修改，因为是别人的朋友圈，你是无权操作的，只有他自己才能操作。同理，在vuex中，我们不能直接修改仓库里的值，必须用vuex自带的方法去修改。\n## 案例\n我们准备完成一个效果：我们先输出state中的number的默认值0，然后我们在vue组件里通过提交Mutations改变number的默认值0，改成我们想修改的值，然后再输出出来。\n1. 修改store/index.js\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  state: {\n    name: 'wnxx',\n    number: 0,\n  },\n  mutations: {\n    // 增加mutations属性\n    setNumber(state) {\n      // 增加一个mutations的方法，方法的作用是让num从0变成10\n      state.number = 10;\n    },\n  },\n});\nexport default store;\n```\n2. 修改App.vue\n```html\n<script>\nexport default {\n  mounted() {\n    console.log(`旧值：${this.$store.state.number}`);\n    this.$store.commit('setNumber');\n    console.log(`新值：${this.$store.state.number}`);\n  },\n};\n</script>\n```\n以上是简单实现mutations的方法，是没有传参的，如果我们想传不固定的参数怎么办？\n1. 修改store/index.js\n```js\nmutations: {\n    setNumber(state) {\n      state.number = 10;\n    },\n    setNumberIsWhat(state, payload) {\n      // 增加一个带参数的mutations方法，并且官方建议payload为一个对象\n      state.number = payload.number;\n    },\n  },\n```\n2. 修改App.vue\n```html\n<script>\nexport default {\n  mounted() {\n    console.log(`旧值：${this.$store.state.number}`);\n    // 调用的时候也需要传递一个对象\n    this.$store.commit('setNumberIsWhat', { number: 666 }); \n    console.log(`新值：${this.$store.state.number}`);\n  },\n};\n</script>\n```\n😱这里说一条重要原则：Mutations里面的函数必须是同步操作，不能包含异步操作！\n## 官方建议:\n就像mapState和mapGetters一样，我们在组件中可以使用mapMutations代替this.$store.commit('XXX')\n```html\n<script>\nimport { mapMutations } from 'vuex';\nexport default {\n  mounted() {\n    this.setNumberIsWhat({ number: 999 });\n  },\n  methods: {\n    // 注意，mapMutations是解构到methods里面的，而不是计算属性了\n    ...mapMutations(['setNumberIsWhat']),\n  },\n};\n</script>\n```\n当然你也可以给它叫别名，取外号，就像这样：\n```js\nmethods: {\n    // 赋别名的话，这里接收对象，而不是数组\n  ...mapMutations({ setNumberIsAlias: 'setNumberIsWhat' }), \n},\n```\n🤪 OK，关于Mutation的介绍大致就是这样。\n# 第五步，了解异步操作：Actions\n上面提到，Mutations只能进行同步操作，Actions存在的意义是假设你在修改state的时候有异步操作，让你放异步操作。\n## 案例\n1. 修改store/index.js\n```js\nconst store = new Vuex.Store({\n  state: {\n    name: 'wnxx',\n    number: 0,\n  },\n  mutations: {\n    setNumberIsWhat(state, payload) {\n      state.number = payload.number;\n    },\n  },\n  actions: {\n    // 增加actions属性\n    setNum(content) {\n      // 增加setNum方法，默认第一个参数是content，其值是复制的一份store\n      return new Promise(resolve => {\n        // 我们模拟一个异步操作，1秒后修改number为666\n        setTimeout(() => {\n          content.commit('setNumberIsWhat', { number: 666 });\n          resolve();\n        }, 1000);\n      });\n    },\n  },\n});\n```\n2. 修改App.vue\n```js\nasync mounted() {\n  console.log(`旧值：${this.$store.state.number}`);\n  await this.$store.dispatch('setNum');\n  console.log(`新值：${this.$store.state.number}`);\n},\n```\n## 官方建议1:\n不要一直使用this.$store.dispatch('XXX')这样的写法调用action，你可以采用mapActions的方式，把相关的actions解构到methods中，用this直接调用：\n```html\n<script>\nimport { mapActions } from 'vuex';\nexport default {\n  methods: {\n    // 就像这样，解构到methods中\n    ...mapActions(['setNum']), \n  },\n  async mounted() {\n    // 直接这样调用即可\n    await this.setNum({ number: 123 }); \n  },\n};\n</script>\n```\n当然你也可以给它叫别名，取外号，就像这样：\n```js\nmethods: {\n    // 赋别名的话，这里接收对象，而不是数组\n  ...mapActions({ setNumAlias: 'setNum' }),\n},\n```\n## 官方建议2:\n在store/index.js中的actions里面，方法的形参可以直接将commit解构出来\n```js\nactions: {\n  setNum({ commit }) {\n    // 直接将content解构掉，解构出commit，下面就可以直接调用了\n    return new Promise(resolve => {\n      setTimeout(() => {\n        commit('XXXX'); // 直接调用\n        resolve();\n      }, 1000);\n    });\n  },\n},\n```\nOK，不要将action和mutation混为一谈，action其实就是mutation的上一级，在action这里处理完异步的一些操作后，后面的修改state就交给mutation去做了。\n# 第六步，按属性进行拆分\n我们看到，一个store/index.js里面大致包含state/getters/mutations/actions这四个属性，我们可以彻底点，index.js里面就保持这个架子，把里面的内容四散到其他文件中。\n我们可以这样拆分：分别是state.js、 getters.js、 mutations.js 、actions.js\n1. 拆出来state放到state.js中\n```js\n// state.js\nexport const state = {\n    name: 'wnxx',\n    number: 0,\n    list: [\n      { id: 1, name: 'welcome' },\n      { id: 2, name: 'to' },\n      { id: 3, name: 'vuex' },\n    ],\n  },\n```\n2. 拆出来getters放到getters.js中\n```js\n// getters.js\nexport const getters = {\n  getMessage(state) {\n    return `hello${state.name}`;\n  },\n};\n```\n3. 拆出来mutations放到mutations.js中\n```js\n// mutations.js\nexport const mutations = {\n  setNumber(state) {\n    state.number = 10;\n  },\n};\n```\n4. 拆出来actions放到actions.js中\n```js\n// actions.js\nexport const actions = {\n  setNum(content) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        content.commit('setNumberIsWhat', { number: 888 });\n        resolve();\n      }, 1000);\n    });\n  },\n};\n```\n5. 组装到主文件里面\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport { state } from './state'; // 引入 state\nimport { getters } from './getters'; // 引入 getters\nimport { mutations } from './mutations'; // 引入 mutations\nimport { actions } from './actions'; // 引入 actions\nVue.use(Vuex);\nconst store = new Vuex.Store({ state, getters, mutations, actions });\nexport default store;\n```\n# 第七步，按功能进行拆分-Module\n上面我们介绍如何拆分项目，采用的是按属性的方式去拆分，接下来，我们介绍一下按另外的一个维度去拆分我们的store，按功能拆分。\n1. 我们在之前的store上，增加一个新的仓库store2，主要代码如下：\n```js\n// store2.js\nconst store2 = {\n  state: {\n    name: '我是store2',\n  },\n  mutations: {},\n  getters: {},\n  actions: {},\n};\nexport default store2;\n```\n2. 然后在store中引入我们新创建的store2模块：\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport { state } from './state';\nimport { getters } from './getters';\nimport { mutations } from './mutations';\nimport { actions } from './actions';\nimport store2 from './store2'; // 引入store2模块\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  // 把store2模块挂载到store里面\n  modules: { store2 }, \n  state: state,\n  getters: getters,\n  mutations: mutations,\n  actions: actions,\n});\nexport default store;\n```\n3. 访问state - 我们在App.vue测试访问store2模块中的state中的name，结果如下：\n```html\n<template>\n  <div></div>\n</template>\n<script>\nexport default {\n  mounted() {\n    // 访问store2里面的name属性\n    console.log(this.$store.state.store2.name); \n  },\n};\n</script>\n```\n我们通过下面的代码可以了解到在不同的属性里是怎么访问模块内的状态或者根状态：\n```js\nmutations: {\n  changeName(state, payload) {\n    // state 局部状态\n    console.log(state);\n    console.log(payload.where);\n  },\n},\ngetters: {\n  testGetters(state, getters, rootState) {\n    // state 局部状态\n    console.log(state);\n    // 局部 getters,\n    console.log(getters);\n    // rootState 根节点状态\n    console.log(rootState);\n  },\n},\nactions: {\n  increment({ state, commit, rootState }) {\n    // state 局部状态\n    console.log(state);\n    // rootState 根节点状态\n    console.log(rootState);\n  },\n},\n```\n还有一些关于module的内容，比如命名空间、模块注册全局 action、带命名空间的绑定函数、模块动态注册、模块重用等方法，自己查阅即可。🤗\n","source":"_posts/Vuex.md","raw":"---\ntitle: Vuex\ndate: 2023-04-05 19:49:07\ntags: Vuex\ncategories: Vue\ncover: [/images/vuexcover.png]\nbanner: \n  type: img\n  bgurl: [/images/vuexcover.png]\n---\nVuex它是一个程序里面的状态管理模式，它是集中式存储所有组件的状态的小仓库，并且保持我们存储的状态以一种可以预测的方式发生变化。\n# 第一步，了解Vuex\n## 问题假设:\n如果你的项目里有很多页面（组件/视图），页面之间存在多级的嵌套关系，此时，这些页面假如都需要共享一个状态的时候，此时就会产生以下两个问题：\n1. 多个视图依赖同一个状态\n2. 来自不同视图的行为需要变更同一个状态\n## 解决以上方法的方案:🤪\n1. 对于第一个问题:\n+ 假如是多级嵌套关系，你可以使用父子组件传参进行解决；\n+ 对于兄弟组件或者关系更复杂组件之间，就很难办了，虽然可以通过各种各样的办法解决，可实在很不优雅，而且项目是越做越大，代码就会变得越多。\n2. 对于第二个问题：\n+ 你可以通过父子组件直接引用，或者通过事件来变更或者同步状态的多份拷贝，这种模式很脆弱，往往使得代码难以维护，而且同样会让代码就会变得越多。\n## 不如换一种思路：\n+ 把各个组件都需要依赖的同一个状态抽取出来，在全局使用进行管理。\n+ 在这种模式下，任何组件都可以直接访问到这个状态，或者当状态发生改变时，所有的组件都获得更新。\n## 这时候，就要用到Vuex\n这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux。与其他模式不同的是，Vuex 是专门为 Vue 设计的状态管理库，以利用 Vue.js 的数据响应机制来进行高效的状态更新。\n## vuex使用周期图\n![](vuex.png)\n## 那什么时候应该用vuex呢？🤔\n+ 如果你不需要开发大型的单页应用，此时你完全没有必要使用vuex，比如你的页面就两三个，使用vuex后增加的文件比你现在的页面还要多，那就没这个必要了。\n+ 假如你的项目达到了中大型应用的规模，此时你很可能会考虑，如何更好地在组件外部管理状态，Vuex将会成为你的选择。\n# 第二步，安装vuex\n1. 首先，安装vuex\n```\nnpm install vuex --save\n```\n2. 然后配置vuex，在src路径下创建store文件夹，然后创建index.js文件，文件内容如下：\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  state: {\n    // 定义一个name，以供全局使用\n    name: 'wnxx',\n    // 定义一个number，以供全局使用\n    number: 0,\n    // 定义一个list，以供全局使用\n    list: [\n      { id: 1, name: 'welcome' },\n      { id: 2, name: 'to' },\n      { id: 3, name: 'vuex' },\n    ],\n  },\n});\nexport default store;\n```\n3. 修改main.js：\n```js\nimport Vue from 'vue';\nimport App from './App';\nimport router from './router';\n// 引入我们前面导出的store对象\nimport store from './store'; \nVue.config.productionTip = false;\nnew Vue({\n  el: '#app',\n  router,\n  store, // 把store对象添加到vue实例上\n  components: { App },\n  template: '<App/>',\n});\n```\n4. 最后修改App.vue：\n```html\n<template>\n  <div></div>\n</template>\n<script>\nexport default {\n  mounted() {\n    // 使用this.$store.state.XXX可以直接访问到仓库中的状态\n    console.log(this.$store.state.name);\n  },\n};\n</script>\n```\n此时，启动项目,即可在控制台输出刚才我们定义在store中的name的值。\n## 官方建议1: \n官方建议我们以上操作this.$store.state.XXX最好放在计算属性中，就像这样：\n```js\nexport default {\n  mounted() {\n    console.log(this.getName);\n  },\n  computed: {\n    getName() {\n      return this.$store.state.name;\n    },\n  },\n};\n```\n## 官方建议2:\n是不是每次都写this.$store.state.XXX让你感到繁琐，你实在不想写，当然有简便的写法，就像下面这样：\n```html\n<script>\n // 从vuex中导入mapState\nimport { mapState } from 'vuex';\nexport default {\n  mounted() {\n    console.log(this.name);\n  },\n  computed: {\n    // 经过解构后，自动就添加到了计算属性中，此时就可以直接像访问计算属性一样访问它\n    ...mapState(['name']), \n  },\n};\n</script>\n```\n你甚至可以在解构的时候给它赋别名，取外号，就像这样：\n```js\n// 赋别名的话，这里接收对象，而不是数组\n...mapState({ aliasName: 'name' }),  \n```\n🤗现在，安装vuex并且初始化的工作就结束了，此时你可以很轻易的在项目的任意地方访问到仓库里的状态。\n# 第三步，了解修饰器：Getter\n接下来，我们介绍一个读取操作的 “修饰利器” ---Getter\n## 问题假设:\n😡设想，你已经将store中的name展示到页面上了，而且是很多页面都展示了，此时产品经理要求：所有的name前面都要加上“hello”！\n这时候，你第一想到的是怎么加呢？\nemm...在每个页面上，使用this.$store.state.name获取到值之后，进行遍历，前面追加\"hello\"即可。\nNo,No,No\n## 这样很不好，原因如下：\n+ 第一，假如你在A、B、C三个页面都用到了name，那么你要在这A、B、C三个页面都修改一遍，多个页面你就要加很多遍这个方法，这样只会造成代码冗余；\n+ 第二，假如下次产品经理让你把 “hello” 改成 “GoodBye” 的时候，你又得把三个页面都改一遍，这时候你只能...😇\n## 新的思路:👏🏻 \n我们可以直接在store中对name进行一些操作或者加工，从源头解决问题！那么具体应该怎么写呢？\n1. 首先，在store对象中增加getters属性\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  state: {\n    // 定义一个name，以供全局使用\n    name: 'wnxx',\n    // 定义一个number，以供全局使用\n    number: 0,\n    // 定义一个list，以供全局使用\n    list: [\n      { id: 1, name: 'welcome' },\n      { id: 2, name: 'to' },\n      { id: 3, name: 'vuex' },\n    ],\n  },\n    // 在store对象中增加getters属性\n      getters: {\n         getMessage(state) {\n      // 获取修饰后的name，第一个参数state为必要参数，必须写在形参上\n         return `hello${state.name}`;\n    },\n  },\n});\nexport default store;\n```\n2. 在组件中使用:\n```js\nexport default {\n  mounted() {\n    // 注意不是$store.state了，而是$store.getters\n    console.log(this.$store.state.name);\n    console.log(this.$store.getters.getMessage);\n  },\n};\n```\n## 官方建议:\n不要每次都写this.$store.getters.XXX，官方建议我们可以使用mapGetters去解构到计算属性中，就像使用mapState一样，就可以直接使用this调用了，就像下面这样：\n```html\n<script>\nimport { mapState, mapGetters } from 'vuex';\nexport default {\n  mounted() {\n    console.log(this.name);\n    console.log(this.getMessage);\n  },\n  computed: {\n    ...mapState(['name']),\n    ...mapGetters(['getMessage']),\n  },\n};\n</script>\n```\n当然，和mapState一样你也可以取别名，取外号，就像下面这样：\n```js\n...mapGetters({ aliasName: 'getMessage' }),  \n// 赋别名的话，这里接收对象，而不是数组\n```\n🤗 OK，当你看到这里，你已经成功的了解了getters啦！\n😎 读取值的操作我们有 “原生读（state）” 和 “修饰读（getters）”，接下来就要介绍怎么修改值了！\n# 第四步，了解如何修改值：Mutation\n🤗OK！我们已经成功访问到了store里面的值，接下来我来介绍一下怎么修改state里面的值。\n## 错误示范\n```js\n// 错误示范\nthis.$store.state.XXX = XXX;\n```\n## 错误原因:\n因为这个store仓库比较奇怪，你可以随便拿，但是你不能随便改。\n我举个例子：假如你打开微信朋友圈，看到你的好友发了动态，但是动态里有个错别字，你要怎么办呢？你可以帮他改掉吗？当然不可以！我们只能通知他本人去修改，因为是别人的朋友圈，你是无权操作的，只有他自己才能操作。同理，在vuex中，我们不能直接修改仓库里的值，必须用vuex自带的方法去修改。\n## 案例\n我们准备完成一个效果：我们先输出state中的number的默认值0，然后我们在vue组件里通过提交Mutations改变number的默认值0，改成我们想修改的值，然后再输出出来。\n1. 修改store/index.js\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  state: {\n    name: 'wnxx',\n    number: 0,\n  },\n  mutations: {\n    // 增加mutations属性\n    setNumber(state) {\n      // 增加一个mutations的方法，方法的作用是让num从0变成10\n      state.number = 10;\n    },\n  },\n});\nexport default store;\n```\n2. 修改App.vue\n```html\n<script>\nexport default {\n  mounted() {\n    console.log(`旧值：${this.$store.state.number}`);\n    this.$store.commit('setNumber');\n    console.log(`新值：${this.$store.state.number}`);\n  },\n};\n</script>\n```\n以上是简单实现mutations的方法，是没有传参的，如果我们想传不固定的参数怎么办？\n1. 修改store/index.js\n```js\nmutations: {\n    setNumber(state) {\n      state.number = 10;\n    },\n    setNumberIsWhat(state, payload) {\n      // 增加一个带参数的mutations方法，并且官方建议payload为一个对象\n      state.number = payload.number;\n    },\n  },\n```\n2. 修改App.vue\n```html\n<script>\nexport default {\n  mounted() {\n    console.log(`旧值：${this.$store.state.number}`);\n    // 调用的时候也需要传递一个对象\n    this.$store.commit('setNumberIsWhat', { number: 666 }); \n    console.log(`新值：${this.$store.state.number}`);\n  },\n};\n</script>\n```\n😱这里说一条重要原则：Mutations里面的函数必须是同步操作，不能包含异步操作！\n## 官方建议:\n就像mapState和mapGetters一样，我们在组件中可以使用mapMutations代替this.$store.commit('XXX')\n```html\n<script>\nimport { mapMutations } from 'vuex';\nexport default {\n  mounted() {\n    this.setNumberIsWhat({ number: 999 });\n  },\n  methods: {\n    // 注意，mapMutations是解构到methods里面的，而不是计算属性了\n    ...mapMutations(['setNumberIsWhat']),\n  },\n};\n</script>\n```\n当然你也可以给它叫别名，取外号，就像这样：\n```js\nmethods: {\n    // 赋别名的话，这里接收对象，而不是数组\n  ...mapMutations({ setNumberIsAlias: 'setNumberIsWhat' }), \n},\n```\n🤪 OK，关于Mutation的介绍大致就是这样。\n# 第五步，了解异步操作：Actions\n上面提到，Mutations只能进行同步操作，Actions存在的意义是假设你在修改state的时候有异步操作，让你放异步操作。\n## 案例\n1. 修改store/index.js\n```js\nconst store = new Vuex.Store({\n  state: {\n    name: 'wnxx',\n    number: 0,\n  },\n  mutations: {\n    setNumberIsWhat(state, payload) {\n      state.number = payload.number;\n    },\n  },\n  actions: {\n    // 增加actions属性\n    setNum(content) {\n      // 增加setNum方法，默认第一个参数是content，其值是复制的一份store\n      return new Promise(resolve => {\n        // 我们模拟一个异步操作，1秒后修改number为666\n        setTimeout(() => {\n          content.commit('setNumberIsWhat', { number: 666 });\n          resolve();\n        }, 1000);\n      });\n    },\n  },\n});\n```\n2. 修改App.vue\n```js\nasync mounted() {\n  console.log(`旧值：${this.$store.state.number}`);\n  await this.$store.dispatch('setNum');\n  console.log(`新值：${this.$store.state.number}`);\n},\n```\n## 官方建议1:\n不要一直使用this.$store.dispatch('XXX')这样的写法调用action，你可以采用mapActions的方式，把相关的actions解构到methods中，用this直接调用：\n```html\n<script>\nimport { mapActions } from 'vuex';\nexport default {\n  methods: {\n    // 就像这样，解构到methods中\n    ...mapActions(['setNum']), \n  },\n  async mounted() {\n    // 直接这样调用即可\n    await this.setNum({ number: 123 }); \n  },\n};\n</script>\n```\n当然你也可以给它叫别名，取外号，就像这样：\n```js\nmethods: {\n    // 赋别名的话，这里接收对象，而不是数组\n  ...mapActions({ setNumAlias: 'setNum' }),\n},\n```\n## 官方建议2:\n在store/index.js中的actions里面，方法的形参可以直接将commit解构出来\n```js\nactions: {\n  setNum({ commit }) {\n    // 直接将content解构掉，解构出commit，下面就可以直接调用了\n    return new Promise(resolve => {\n      setTimeout(() => {\n        commit('XXXX'); // 直接调用\n        resolve();\n      }, 1000);\n    });\n  },\n},\n```\nOK，不要将action和mutation混为一谈，action其实就是mutation的上一级，在action这里处理完异步的一些操作后，后面的修改state就交给mutation去做了。\n# 第六步，按属性进行拆分\n我们看到，一个store/index.js里面大致包含state/getters/mutations/actions这四个属性，我们可以彻底点，index.js里面就保持这个架子，把里面的内容四散到其他文件中。\n我们可以这样拆分：分别是state.js、 getters.js、 mutations.js 、actions.js\n1. 拆出来state放到state.js中\n```js\n// state.js\nexport const state = {\n    name: 'wnxx',\n    number: 0,\n    list: [\n      { id: 1, name: 'welcome' },\n      { id: 2, name: 'to' },\n      { id: 3, name: 'vuex' },\n    ],\n  },\n```\n2. 拆出来getters放到getters.js中\n```js\n// getters.js\nexport const getters = {\n  getMessage(state) {\n    return `hello${state.name}`;\n  },\n};\n```\n3. 拆出来mutations放到mutations.js中\n```js\n// mutations.js\nexport const mutations = {\n  setNumber(state) {\n    state.number = 10;\n  },\n};\n```\n4. 拆出来actions放到actions.js中\n```js\n// actions.js\nexport const actions = {\n  setNum(content) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        content.commit('setNumberIsWhat', { number: 888 });\n        resolve();\n      }, 1000);\n    });\n  },\n};\n```\n5. 组装到主文件里面\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport { state } from './state'; // 引入 state\nimport { getters } from './getters'; // 引入 getters\nimport { mutations } from './mutations'; // 引入 mutations\nimport { actions } from './actions'; // 引入 actions\nVue.use(Vuex);\nconst store = new Vuex.Store({ state, getters, mutations, actions });\nexport default store;\n```\n# 第七步，按功能进行拆分-Module\n上面我们介绍如何拆分项目，采用的是按属性的方式去拆分，接下来，我们介绍一下按另外的一个维度去拆分我们的store，按功能拆分。\n1. 我们在之前的store上，增加一个新的仓库store2，主要代码如下：\n```js\n// store2.js\nconst store2 = {\n  state: {\n    name: '我是store2',\n  },\n  mutations: {},\n  getters: {},\n  actions: {},\n};\nexport default store2;\n```\n2. 然后在store中引入我们新创建的store2模块：\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport { state } from './state';\nimport { getters } from './getters';\nimport { mutations } from './mutations';\nimport { actions } from './actions';\nimport store2 from './store2'; // 引入store2模块\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  // 把store2模块挂载到store里面\n  modules: { store2 }, \n  state: state,\n  getters: getters,\n  mutations: mutations,\n  actions: actions,\n});\nexport default store;\n```\n3. 访问state - 我们在App.vue测试访问store2模块中的state中的name，结果如下：\n```html\n<template>\n  <div></div>\n</template>\n<script>\nexport default {\n  mounted() {\n    // 访问store2里面的name属性\n    console.log(this.$store.state.store2.name); \n  },\n};\n</script>\n```\n我们通过下面的代码可以了解到在不同的属性里是怎么访问模块内的状态或者根状态：\n```js\nmutations: {\n  changeName(state, payload) {\n    // state 局部状态\n    console.log(state);\n    console.log(payload.where);\n  },\n},\ngetters: {\n  testGetters(state, getters, rootState) {\n    // state 局部状态\n    console.log(state);\n    // 局部 getters,\n    console.log(getters);\n    // rootState 根节点状态\n    console.log(rootState);\n  },\n},\nactions: {\n  increment({ state, commit, rootState }) {\n    // state 局部状态\n    console.log(state);\n    // rootState 根节点状态\n    console.log(rootState);\n  },\n},\n```\n还有一些关于module的内容，比如命名空间、模块注册全局 action、带命名空间的绑定函数、模块动态注册、模块重用等方法，自己查阅即可。🤗\n","slug":"Vuex","published":1,"updated":"2023-04-11T06:00:16.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml50010tit8b009aoff","content":"<p>Vuex它是一个程序里面的状态管理模式，它是集中式存储所有组件的状态的小仓库，并且保持我们存储的状态以一种可以预测的方式发生变化。</p>\n<h1 id=\"第一步，了解Vuex\"><a href=\"#第一步，了解Vuex\" class=\"headerlink\" title=\"第一步，了解Vuex\"></a>第一步，了解Vuex</h1><h2 id=\"问题假设\"><a href=\"#问题假设\" class=\"headerlink\" title=\"问题假设:\"></a>问题假设:</h2><p>如果你的项目里有很多页面（组件/视图），页面之间存在多级的嵌套关系，此时，这些页面假如都需要共享一个状态的时候，此时就会产生以下两个问题：</p>\n<ol>\n<li>多个视图依赖同一个状态</li>\n<li>来自不同视图的行为需要变更同一个状态<h2 id=\"解决以上方法的方案-🤪\"><a href=\"#解决以上方法的方案-🤪\" class=\"headerlink\" title=\"解决以上方法的方案:🤪\"></a>解决以上方法的方案:🤪</h2></li>\n<li>对于第一个问题:</li>\n</ol>\n<ul>\n<li>假如是多级嵌套关系，你可以使用父子组件传参进行解决；</li>\n<li>对于兄弟组件或者关系更复杂组件之间，就很难办了，虽然可以通过各种各样的办法解决，可实在很不优雅，而且项目是越做越大，代码就会变得越多。</li>\n</ul>\n<ol start=\"2\">\n<li>对于第二个问题：</li>\n</ol>\n<ul>\n<li>你可以通过父子组件直接引用，或者通过事件来变更或者同步状态的多份拷贝，这种模式很脆弱，往往使得代码难以维护，而且同样会让代码就会变得越多。<h2 id=\"不如换一种思路：\"><a href=\"#不如换一种思路：\" class=\"headerlink\" title=\"不如换一种思路：\"></a>不如换一种思路：</h2></li>\n<li>把各个组件都需要依赖的同一个状态抽取出来，在全局使用进行管理。</li>\n<li>在这种模式下，任何组件都可以直接访问到这个状态，或者当状态发生改变时，所有的组件都获得更新。<h2 id=\"这时候，就要用到Vuex\"><a href=\"#这时候，就要用到Vuex\" class=\"headerlink\" title=\"这时候，就要用到Vuex\"></a>这时候，就要用到Vuex</h2>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux。与其他模式不同的是，Vuex 是专门为 Vue 设计的状态管理库，以利用 Vue.js 的数据响应机制来进行高效的状态更新。<h2 id=\"vuex使用周期图\"><a href=\"#vuex使用周期图\" class=\"headerlink\" title=\"vuex使用周期图\"></a>vuex使用周期图</h2><img src=\"/2023/04/05/Vuex/vuex.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><h2 id=\"那什么时候应该用vuex呢？🤔\"><a href=\"#那什么时候应该用vuex呢？🤔\" class=\"headerlink\" title=\"那什么时候应该用vuex呢？🤔\"></a>那什么时候应该用vuex呢？🤔</h2></li>\n<li>如果你不需要开发大型的单页应用，此时你完全没有必要使用vuex，比如你的页面就两三个，使用vuex后增加的文件比你现在的页面还要多，那就没这个必要了。</li>\n<li>假如你的项目达到了中大型应用的规模，此时你很可能会考虑，如何更好地在组件外部管理状态，Vuex将会成为你的选择。<h1 id=\"第二步，安装vuex\"><a href=\"#第二步，安装vuex\" class=\"headerlink\" title=\"第二步，安装vuex\"></a>第二步，安装vuex</h1></li>\n</ul>\n<ol>\n<li>首先，安装vuex<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install vuex --save</span><br></pre></td></tr></table></figure></li>\n<li>然后配置vuex，在src路径下创建store文件夹，然后创建index.js文件，文件内容如下：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个name，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个number，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个list，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">list</span>: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;welcome&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;to&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vuex&#x27;</span> &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></li>\n<li>修改main.js：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./router&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 引入我们前面导出的store对象</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store&#x27;</span>; </span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\">config</span>.<span class=\"property\">productionTip</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store, <span class=\"comment\">// 把store对象添加到vue实例上</span></span><br><span class=\"line\">  <span class=\"attr\">components</span>: &#123; <span class=\"title class_\">App</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>最后修改App.vue：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 使用this.$store.state.XXX可以直接访问到仓库中的状态</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">name</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n此时，启动项目,即可在控制台输出刚才我们定义在store中的name的值。<h2 id=\"官方建议1\"><a href=\"#官方建议1\" class=\"headerlink\" title=\"官方建议1:\"></a>官方建议1:</h2>官方建议我们以上操作this.$store.state.XXX最好放在计算属性中，就像这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">getName</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方建议2\"><a href=\"#官方建议2\" class=\"headerlink\" title=\"官方建议2:\"></a>官方建议2:</h2>是不是每次都写this.$store.state.XXX让你感到繁琐，你实在不想写，当然有简便的写法，就像下面这样：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"> <span class=\"comment\">// 从vuex中导入mapState</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">computed</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 经过解构后，自动就添加到了计算属性中，此时就可以直接像访问计算属性一样访问它</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapState</span>([<span class=\"string\">&#x27;name&#x27;</span>]), </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n你甚至可以在解构的时候给它赋别名，取外号，就像这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class=\"line\">...<span class=\"title function_\">mapState</span>(&#123; <span class=\"attr\">aliasName</span>: <span class=\"string\">&#x27;name&#x27;</span> &#125;),  </span><br></pre></td></tr></table></figure>\n🤗现在，安装vuex并且初始化的工作就结束了，此时你可以很轻易的在项目的任意地方访问到仓库里的状态。<h1 id=\"第三步，了解修饰器：Getter\"><a href=\"#第三步，了解修饰器：Getter\" class=\"headerlink\" title=\"第三步，了解修饰器：Getter\"></a>第三步，了解修饰器：Getter</h1>接下来，我们介绍一个读取操作的 “修饰利器” —Getter<h2 id=\"问题假设-1\"><a href=\"#问题假设-1\" class=\"headerlink\" title=\"问题假设:\"></a>问题假设:</h2>😡设想，你已经将store中的name展示到页面上了，而且是很多页面都展示了，此时产品经理要求：所有的name前面都要加上“hello”！<br>这时候，你第一想到的是怎么加呢？<br>emm…在每个页面上，使用this.$store.state.name获取到值之后，进行遍历，前面追加”hello”即可。<br>No,No,No<h2 id=\"这样很不好，原因如下：\"><a href=\"#这样很不好，原因如下：\" class=\"headerlink\" title=\"这样很不好，原因如下：\"></a>这样很不好，原因如下：</h2></li>\n</ol>\n<ul>\n<li>第一，假如你在A、B、C三个页面都用到了name，那么你要在这A、B、C三个页面都修改一遍，多个页面你就要加很多遍这个方法，这样只会造成代码冗余；</li>\n<li>第二，假如下次产品经理让你把 “hello” 改成 “GoodBye” 的时候，你又得把三个页面都改一遍，这时候你只能…😇<h2 id=\"新的思路-👏🏻\"><a href=\"#新的思路-👏🏻\" class=\"headerlink\" title=\"新的思路:👏🏻\"></a>新的思路:👏🏻</h2>我们可以直接在store中对name进行一些操作或者加工，从源头解决问题！那么具体应该怎么写呢？</li>\n</ul>\n<ol>\n<li>首先，在store对象中增加getters属性<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个name，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个number，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个list，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">list</span>: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;welcome&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;to&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vuex&#x27;</span> &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 在store对象中增加getters属性</span></span><br><span class=\"line\">      <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">         <span class=\"title function_\">getMessage</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取修饰后的name，第一个参数state为必要参数，必须写在形参上</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">`hello<span class=\"subst\">$&#123;state.name&#125;</span>`</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></li>\n<li>在组件中使用:<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意不是$store.state了，而是$store.getters</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">getters</span>.<span class=\"property\">getMessage</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方建议\"><a href=\"#官方建议\" class=\"headerlink\" title=\"官方建议:\"></a>官方建议:</h2>不要每次都写this.$store.getters.XXX，官方建议我们可以使用mapGetters去解构到计算属性中，就像使用mapState一样，就可以直接使用this调用了，就像下面这样：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; mapState, mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">getMessage</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">computed</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapState</span>([<span class=\"string\">&#x27;name&#x27;</span>]),</span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapGetters</span>([<span class=\"string\">&#x27;getMessage&#x27;</span>]),</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n当然，和mapState一样你也可以取别名，取外号，就像下面这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">...<span class=\"title function_\">mapGetters</span>(&#123; <span class=\"attr\">aliasName</span>: <span class=\"string\">&#x27;getMessage&#x27;</span> &#125;),  </span><br><span class=\"line\"><span class=\"comment\">// 赋别名的话，这里接收对象，而不是数组</span></span><br></pre></td></tr></table></figure>\n🤗 OK，当你看到这里，你已经成功的了解了getters啦！<br>😎 读取值的操作我们有 “原生读（state）” 和 “修饰读（getters）”，接下来就要介绍怎么修改值了！<h1 id=\"第四步，了解如何修改值：Mutation\"><a href=\"#第四步，了解如何修改值：Mutation\" class=\"headerlink\" title=\"第四步，了解如何修改值：Mutation\"></a>第四步，了解如何修改值：Mutation</h1>🤗OK！我们已经成功访问到了store里面的值，接下来我来介绍一下怎么修改state里面的值。<h2 id=\"错误示范\"><a href=\"#错误示范\" class=\"headerlink\" title=\"错误示范\"></a>错误示范</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误示范</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">XXX</span> = <span class=\"variable constant_\">XXX</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因:\"></a>错误原因:</h2>因为这个store仓库比较奇怪，你可以随便拿，但是你不能随便改。<br>我举个例子：假如你打开微信朋友圈，看到你的好友发了动态，但是动态里有个错别字，你要怎么办呢？你可以帮他改掉吗？当然不可以！我们只能通知他本人去修改，因为是别人的朋友圈，你是无权操作的，只有他自己才能操作。同理，在vuex中，我们不能直接修改仓库里的值，必须用vuex自带的方法去修改。<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2>我们准备完成一个效果：我们先输出state中的number的默认值0，然后我们在vue组件里通过提交Mutations改变number的默认值0，改成我们想修改的值，然后再输出出来。</li>\n<li>修改store/index.js<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 增加mutations属性</span></span><br><span class=\"line\">    <span class=\"title function_\">setNumber</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 增加一个mutations的方法，方法的作用是让num从0变成10</span></span><br><span class=\"line\">      state.<span class=\"property\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></li>\n<li>修改App.vue<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`旧值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setNumber&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`新值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n以上是简单实现mutations的方法，是没有传参的，如果我们想传不固定的参数怎么办？</li>\n<li>修改store/index.js<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setNumber</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">setNumberIsWhat</span>(<span class=\"params\">state, payload</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 增加一个带参数的mutations方法，并且官方建议payload为一个对象</span></span><br><span class=\"line\">      state.<span class=\"property\">number</span> = payload.<span class=\"property\">number</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></li>\n<li>修改App.vue<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`旧值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 调用的时候也需要传递一个对象</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class=\"attr\">number</span>: <span class=\"number\">666</span> &#125;); </span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`新值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n😱这里说一条重要原则：Mutations里面的函数必须是同步操作，不能包含异步操作！<h2 id=\"官方建议-1\"><a href=\"#官方建议-1\" class=\"headerlink\" title=\"官方建议:\"></a>官方建议:</h2>就像mapState和mapGetters一样，我们在组件中可以使用mapMutations代替this.$store.commit(‘XXX’)<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setNumberIsWhat</span>(&#123; <span class=\"attr\">number</span>: <span class=\"number\">999</span> &#125;);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">methods</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 注意，mapMutations是解构到methods里面的，而不是计算属性了</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapMutations</span>([<span class=\"string\">&#x27;setNumberIsWhat&#x27;</span>]),</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n当然你也可以给它叫别名，取外号，就像这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class=\"line\">  ...<span class=\"title function_\">mapMutations</span>(&#123; <span class=\"attr\">setNumberIsAlias</span>: <span class=\"string\">&#x27;setNumberIsWhat&#x27;</span> &#125;), </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n🤪 OK，关于Mutation的介绍大致就是这样。<h1 id=\"第五步，了解异步操作：Actions\"><a href=\"#第五步，了解异步操作：Actions\" class=\"headerlink\" title=\"第五步，了解异步操作：Actions\"></a>第五步，了解异步操作：Actions</h1>上面提到，Mutations只能进行同步操作，Actions存在的意义是假设你在修改state的时候有异步操作，让你放异步操作。<h2 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h2></li>\n<li>修改store/index.js<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setNumberIsWhat</span>(<span class=\"params\">state, payload</span>) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">number</span> = payload.<span class=\"property\">number</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 增加actions属性</span></span><br><span class=\"line\">    <span class=\"title function_\">setNum</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 增加setNum方法，默认第一个参数是content，其值是复制的一份store</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 我们模拟一个异步操作，1秒后修改number为666</span></span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          content.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class=\"attr\">number</span>: <span class=\"number\">666</span> &#125;);</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>修改App.vue<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`旧值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">dispatch</span>(<span class=\"string\">&#x27;setNum&#x27;</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`新值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方建议1-1\"><a href=\"#官方建议1-1\" class=\"headerlink\" title=\"官方建议1:\"></a>官方建议1:</h2>不要一直使用this.$store.dispatch(‘XXX’)这样的写法调用action，你可以采用mapActions的方式，把相关的actions解构到methods中，用this直接调用：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">methods</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 就像这样，解构到methods中</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapActions</span>([<span class=\"string\">&#x27;setNum&#x27;</span>]), </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">async</span> <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 直接这样调用即可</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">setNum</span>(&#123; <span class=\"attr\">number</span>: <span class=\"number\">123</span> &#125;); </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n当然你也可以给它叫别名，取外号，就像这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class=\"line\">  ...<span class=\"title function_\">mapActions</span>(&#123; <span class=\"attr\">setNumAlias</span>: <span class=\"string\">&#x27;setNum&#x27;</span> &#125;),</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方建议2-1\"><a href=\"#官方建议2-1\" class=\"headerlink\" title=\"官方建议2:\"></a>官方建议2:</h2>在store/index.js中的actions里面，方法的形参可以直接将commit解构出来<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">setNum</span>(<span class=\"params\">&#123; commit &#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接将content解构掉，解构出commit，下面就可以直接调用了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;XXXX&#x27;</span>); <span class=\"comment\">// 直接调用</span></span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\nOK，不要将action和mutation混为一谈，action其实就是mutation的上一级，在action这里处理完异步的一些操作后，后面的修改state就交给mutation去做了。<h1 id=\"第六步，按属性进行拆分\"><a href=\"#第六步，按属性进行拆分\" class=\"headerlink\" title=\"第六步，按属性进行拆分\"></a>第六步，按属性进行拆分</h1>我们看到，一个store/index.js里面大致包含state/getters/mutations/actions这四个属性，我们可以彻底点，index.js里面就保持这个架子，把里面的内容四散到其他文件中。<br>我们可以这样拆分：分别是state.js、 getters.js、 mutations.js 、actions.js</li>\n<li>拆出来state放到state.js中<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// state.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">list</span>: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;welcome&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;to&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vuex&#x27;</span> &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></li>\n<li>拆出来getters放到getters.js中<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// getters.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getters = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">getMessage</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`hello<span class=\"subst\">$&#123;state.name&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>拆出来mutations放到mutations.js中<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mutations.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mutations = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">setNumber</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">    state.<span class=\"property\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>拆出来actions放到actions.js中<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// actions.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">setNum</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        content.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class=\"attr\">number</span>: <span class=\"number\">888</span> &#125;);</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>组装到主文件里面<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; state &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./state&#x27;</span>; <span class=\"comment\">// 引入 state</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./getters&#x27;</span>; <span class=\"comment\">// 引入 getters</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./mutations&#x27;</span>; <span class=\"comment\">// 引入 mutations</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; actions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./actions&#x27;</span>; <span class=\"comment\">// 引入 actions</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123; state, getters, mutations, actions &#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n<h1 id=\"第七步，按功能进行拆分-Module\"><a href=\"#第七步，按功能进行拆分-Module\" class=\"headerlink\" title=\"第七步，按功能进行拆分-Module\"></a>第七步，按功能进行拆分-Module</h1>上面我们介绍如何拆分项目，采用的是按属性的方式去拆分，接下来，我们介绍一下按另外的一个维度去拆分我们的store，按功能拆分。</li>\n<li>我们在之前的store上，增加一个新的仓库store2，主要代码如下：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// store2.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store2 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;我是store2&#x27;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store2;</span><br></pre></td></tr></table></figure></li>\n<li>然后在store中引入我们新创建的store2模块：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; state &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./state&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./getters&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./mutations&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; actions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./actions&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store2 <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store2&#x27;</span>; <span class=\"comment\">// 引入store2模块</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 把store2模块挂载到store里面</span></span><br><span class=\"line\">  <span class=\"attr\">modules</span>: &#123; store2 &#125;, </span><br><span class=\"line\">  <span class=\"attr\">state</span>: state,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: getters,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: mutations,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: actions,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></li>\n<li>访问state - 我们在App.vue测试访问store2模块中的state中的name，结果如下：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 访问store2里面的name属性</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">store2</span>.<span class=\"property\">name</span>); </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n我们通过下面的代码可以了解到在不同的属性里是怎么访问模块内的状态或者根状态：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">changeName</span>(<span class=\"params\">state, payload</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// state 局部状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(payload.<span class=\"property\">where</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">testGetters</span>(<span class=\"params\">state, getters, rootState</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// state 局部状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state);</span><br><span class=\"line\">    <span class=\"comment\">// 局部 getters,</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(getters);</span><br><span class=\"line\">    <span class=\"comment\">// rootState 根节点状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rootState);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">increment</span>(<span class=\"params\">&#123; state, commit, rootState &#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// state 局部状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state);</span><br><span class=\"line\">    <span class=\"comment\">// rootState 根节点状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rootState);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n还有一些关于module的内容，比如命名空间、模块注册全局 action、带命名空间的绑定函数、模块动态注册、模块重用等方法，自己查阅即可。🤗</li>\n</ol>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>Vuex它是一个程序里面的状态管理模式，它是集中式存储所有组件的状态的小仓库，并且保持我们存储的状态以一种可以预测的方式发生变化。</p>\n<h1 id=\"第一步，了解Vuex\"><a href=\"#第一步，了解Vuex\" class=\"headerlink\" title=\"第一步，了解Vuex\"></a>第一步，了解Vuex</h1><h2 id=\"问题假设\"><a href=\"#问题假设\" class=\"headerlink\" title=\"问题假设:\"></a>问题假设:</h2><p>如果你的项目里有很多页面（组件/视图），页面之间存在多级的嵌套关系，此时，这些页面假如都需要共享一个状态的时候，此时就会产生以下两个问题：</p>\n<ol>\n<li>多个视图依赖同一个状态</li>\n<li>来自不同视图的行为需要变更同一个状态<h2 id=\"解决以上方法的方案-🤪\"><a href=\"#解决以上方法的方案-🤪\" class=\"headerlink\" title=\"解决以上方法的方案:🤪\"></a>解决以上方法的方案:🤪</h2></li>\n<li>对于第一个问题:</li>\n</ol>\n<ul>\n<li>假如是多级嵌套关系，你可以使用父子组件传参进行解决；</li>\n<li>对于兄弟组件或者关系更复杂组件之间，就很难办了，虽然可以通过各种各样的办法解决，可实在很不优雅，而且项目是越做越大，代码就会变得越多。</li>\n</ul>\n<ol start=\"2\">\n<li>对于第二个问题：</li>\n</ol>\n<ul>\n<li>你可以通过父子组件直接引用，或者通过事件来变更或者同步状态的多份拷贝，这种模式很脆弱，往往使得代码难以维护，而且同样会让代码就会变得越多。<h2 id=\"不如换一种思路：\"><a href=\"#不如换一种思路：\" class=\"headerlink\" title=\"不如换一种思路：\"></a>不如换一种思路：</h2></li>\n<li>把各个组件都需要依赖的同一个状态抽取出来，在全局使用进行管理。</li>\n<li>在这种模式下，任何组件都可以直接访问到这个状态，或者当状态发生改变时，所有的组件都获得更新。<h2 id=\"这时候，就要用到Vuex\"><a href=\"#这时候，就要用到Vuex\" class=\"headerlink\" title=\"这时候，就要用到Vuex\"></a>这时候，就要用到Vuex</h2>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux。与其他模式不同的是，Vuex 是专门为 Vue 设计的状态管理库，以利用 Vue.js 的数据响应机制来进行高效的状态更新。<h2 id=\"vuex使用周期图\"><a href=\"#vuex使用周期图\" class=\"headerlink\" title=\"vuex使用周期图\"></a>vuex使用周期图</h2><img src=\"/2023/04/05/Vuex/vuex.png\"><h2 id=\"那什么时候应该用vuex呢？🤔\"><a href=\"#那什么时候应该用vuex呢？🤔\" class=\"headerlink\" title=\"那什么时候应该用vuex呢？🤔\"></a>那什么时候应该用vuex呢？🤔</h2></li>\n<li>如果你不需要开发大型的单页应用，此时你完全没有必要使用vuex，比如你的页面就两三个，使用vuex后增加的文件比你现在的页面还要多，那就没这个必要了。</li>\n<li>假如你的项目达到了中大型应用的规模，此时你很可能会考虑，如何更好地在组件外部管理状态，Vuex将会成为你的选择。<h1 id=\"第二步，安装vuex\"><a href=\"#第二步，安装vuex\" class=\"headerlink\" title=\"第二步，安装vuex\"></a>第二步，安装vuex</h1></li>\n</ul>\n<ol>\n<li>首先，安装vuex<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install vuex --save</span><br></pre></td></tr></table></figure></li>\n<li>然后配置vuex，在src路径下创建store文件夹，然后创建index.js文件，文件内容如下：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个name，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个number，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个list，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">list</span>: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;welcome&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;to&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vuex&#x27;</span> &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></li>\n<li>修改main.js：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./router&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 引入我们前面导出的store对象</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store&#x27;</span>; </span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\">config</span>.<span class=\"property\">productionTip</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store, <span class=\"comment\">// 把store对象添加到vue实例上</span></span><br><span class=\"line\">  <span class=\"attr\">components</span>: &#123; <span class=\"title class_\">App</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>最后修改App.vue：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 使用this.$store.state.XXX可以直接访问到仓库中的状态</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">name</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n此时，启动项目,即可在控制台输出刚才我们定义在store中的name的值。<h2 id=\"官方建议1\"><a href=\"#官方建议1\" class=\"headerlink\" title=\"官方建议1:\"></a>官方建议1:</h2>官方建议我们以上操作this.$store.state.XXX最好放在计算属性中，就像这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">getName</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方建议2\"><a href=\"#官方建议2\" class=\"headerlink\" title=\"官方建议2:\"></a>官方建议2:</h2>是不是每次都写this.$store.state.XXX让你感到繁琐，你实在不想写，当然有简便的写法，就像下面这样：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"> <span class=\"comment\">// 从vuex中导入mapState</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">computed</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 经过解构后，自动就添加到了计算属性中，此时就可以直接像访问计算属性一样访问它</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapState</span>([<span class=\"string\">&#x27;name&#x27;</span>]), </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n你甚至可以在解构的时候给它赋别名，取外号，就像这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class=\"line\">...<span class=\"title function_\">mapState</span>(&#123; <span class=\"attr\">aliasName</span>: <span class=\"string\">&#x27;name&#x27;</span> &#125;),  </span><br></pre></td></tr></table></figure>\n🤗现在，安装vuex并且初始化的工作就结束了，此时你可以很轻易的在项目的任意地方访问到仓库里的状态。<h1 id=\"第三步，了解修饰器：Getter\"><a href=\"#第三步，了解修饰器：Getter\" class=\"headerlink\" title=\"第三步，了解修饰器：Getter\"></a>第三步，了解修饰器：Getter</h1>接下来，我们介绍一个读取操作的 “修饰利器” —Getter<h2 id=\"问题假设-1\"><a href=\"#问题假设-1\" class=\"headerlink\" title=\"问题假设:\"></a>问题假设:</h2>😡设想，你已经将store中的name展示到页面上了，而且是很多页面都展示了，此时产品经理要求：所有的name前面都要加上“hello”！<br>这时候，你第一想到的是怎么加呢？<br>emm…在每个页面上，使用this.$store.state.name获取到值之后，进行遍历，前面追加”hello”即可。<br>No,No,No<h2 id=\"这样很不好，原因如下：\"><a href=\"#这样很不好，原因如下：\" class=\"headerlink\" title=\"这样很不好，原因如下：\"></a>这样很不好，原因如下：</h2></li>\n</ol>\n<ul>\n<li>第一，假如你在A、B、C三个页面都用到了name，那么你要在这A、B、C三个页面都修改一遍，多个页面你就要加很多遍这个方法，这样只会造成代码冗余；</li>\n<li>第二，假如下次产品经理让你把 “hello” 改成 “GoodBye” 的时候，你又得把三个页面都改一遍，这时候你只能…😇<h2 id=\"新的思路-👏🏻\"><a href=\"#新的思路-👏🏻\" class=\"headerlink\" title=\"新的思路:👏🏻\"></a>新的思路:👏🏻</h2>我们可以直接在store中对name进行一些操作或者加工，从源头解决问题！那么具体应该怎么写呢？</li>\n</ul>\n<ol>\n<li>首先，在store对象中增加getters属性<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个name，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个number，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个list，以供全局使用</span></span><br><span class=\"line\">    <span class=\"attr\">list</span>: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;welcome&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;to&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vuex&#x27;</span> &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 在store对象中增加getters属性</span></span><br><span class=\"line\">      <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">         <span class=\"title function_\">getMessage</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取修饰后的name，第一个参数state为必要参数，必须写在形参上</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">`hello<span class=\"subst\">$&#123;state.name&#125;</span>`</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></li>\n<li>在组件中使用:<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意不是$store.state了，而是$store.getters</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">getters</span>.<span class=\"property\">getMessage</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方建议\"><a href=\"#官方建议\" class=\"headerlink\" title=\"官方建议:\"></a>官方建议:</h2>不要每次都写this.$store.getters.XXX，官方建议我们可以使用mapGetters去解构到计算属性中，就像使用mapState一样，就可以直接使用this调用了，就像下面这样：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; mapState, mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">getMessage</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">computed</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapState</span>([<span class=\"string\">&#x27;name&#x27;</span>]),</span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapGetters</span>([<span class=\"string\">&#x27;getMessage&#x27;</span>]),</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n当然，和mapState一样你也可以取别名，取外号，就像下面这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">...<span class=\"title function_\">mapGetters</span>(&#123; <span class=\"attr\">aliasName</span>: <span class=\"string\">&#x27;getMessage&#x27;</span> &#125;),  </span><br><span class=\"line\"><span class=\"comment\">// 赋别名的话，这里接收对象，而不是数组</span></span><br></pre></td></tr></table></figure>\n🤗 OK，当你看到这里，你已经成功的了解了getters啦！<br>😎 读取值的操作我们有 “原生读（state）” 和 “修饰读（getters）”，接下来就要介绍怎么修改值了！<h1 id=\"第四步，了解如何修改值：Mutation\"><a href=\"#第四步，了解如何修改值：Mutation\" class=\"headerlink\" title=\"第四步，了解如何修改值：Mutation\"></a>第四步，了解如何修改值：Mutation</h1>🤗OK！我们已经成功访问到了store里面的值，接下来我来介绍一下怎么修改state里面的值。<h2 id=\"错误示范\"><a href=\"#错误示范\" class=\"headerlink\" title=\"错误示范\"></a>错误示范</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误示范</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">XXX</span> = <span class=\"variable constant_\">XXX</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因:\"></a>错误原因:</h2>因为这个store仓库比较奇怪，你可以随便拿，但是你不能随便改。<br>我举个例子：假如你打开微信朋友圈，看到你的好友发了动态，但是动态里有个错别字，你要怎么办呢？你可以帮他改掉吗？当然不可以！我们只能通知他本人去修改，因为是别人的朋友圈，你是无权操作的，只有他自己才能操作。同理，在vuex中，我们不能直接修改仓库里的值，必须用vuex自带的方法去修改。<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2>我们准备完成一个效果：我们先输出state中的number的默认值0，然后我们在vue组件里通过提交Mutations改变number的默认值0，改成我们想修改的值，然后再输出出来。</li>\n<li>修改store/index.js<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 增加mutations属性</span></span><br><span class=\"line\">    <span class=\"title function_\">setNumber</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 增加一个mutations的方法，方法的作用是让num从0变成10</span></span><br><span class=\"line\">      state.<span class=\"property\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></li>\n<li>修改App.vue<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`旧值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setNumber&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`新值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n以上是简单实现mutations的方法，是没有传参的，如果我们想传不固定的参数怎么办？</li>\n<li>修改store/index.js<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setNumber</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">setNumberIsWhat</span>(<span class=\"params\">state, payload</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 增加一个带参数的mutations方法，并且官方建议payload为一个对象</span></span><br><span class=\"line\">      state.<span class=\"property\">number</span> = payload.<span class=\"property\">number</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></li>\n<li>修改App.vue<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`旧值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 调用的时候也需要传递一个对象</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class=\"attr\">number</span>: <span class=\"number\">666</span> &#125;); </span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`新值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n😱这里说一条重要原则：Mutations里面的函数必须是同步操作，不能包含异步操作！<h2 id=\"官方建议-1\"><a href=\"#官方建议-1\" class=\"headerlink\" title=\"官方建议:\"></a>官方建议:</h2>就像mapState和mapGetters一样，我们在组件中可以使用mapMutations代替this.$store.commit(‘XXX’)<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setNumberIsWhat</span>(&#123; <span class=\"attr\">number</span>: <span class=\"number\">999</span> &#125;);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">methods</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 注意，mapMutations是解构到methods里面的，而不是计算属性了</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapMutations</span>([<span class=\"string\">&#x27;setNumberIsWhat&#x27;</span>]),</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n当然你也可以给它叫别名，取外号，就像这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class=\"line\">  ...<span class=\"title function_\">mapMutations</span>(&#123; <span class=\"attr\">setNumberIsAlias</span>: <span class=\"string\">&#x27;setNumberIsWhat&#x27;</span> &#125;), </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n🤪 OK，关于Mutation的介绍大致就是这样。<h1 id=\"第五步，了解异步操作：Actions\"><a href=\"#第五步，了解异步操作：Actions\" class=\"headerlink\" title=\"第五步，了解异步操作：Actions\"></a>第五步，了解异步操作：Actions</h1>上面提到，Mutations只能进行同步操作，Actions存在的意义是假设你在修改state的时候有异步操作，让你放异步操作。<h2 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h2></li>\n<li>修改store/index.js<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setNumberIsWhat</span>(<span class=\"params\">state, payload</span>) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">number</span> = payload.<span class=\"property\">number</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 增加actions属性</span></span><br><span class=\"line\">    <span class=\"title function_\">setNum</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 增加setNum方法，默认第一个参数是content，其值是复制的一份store</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 我们模拟一个异步操作，1秒后修改number为666</span></span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          content.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class=\"attr\">number</span>: <span class=\"number\">666</span> &#125;);</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>修改App.vue<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`旧值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">dispatch</span>(<span class=\"string\">&#x27;setNum&#x27;</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`新值：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.$store.state.number&#125;</span>`</span>);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方建议1-1\"><a href=\"#官方建议1-1\" class=\"headerlink\" title=\"官方建议1:\"></a>官方建议1:</h2>不要一直使用this.$store.dispatch(‘XXX’)这样的写法调用action，你可以采用mapActions的方式，把相关的actions解构到methods中，用this直接调用：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">methods</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 就像这样，解构到methods中</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    ...<span class=\"title function_\">mapActions</span>([<span class=\"string\">&#x27;setNum&#x27;</span>]), </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">async</span> <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 直接这样调用即可</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">setNum</span>(&#123; <span class=\"attr\">number</span>: <span class=\"number\">123</span> &#125;); </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n当然你也可以给它叫别名，取外号，就像这样：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 赋别名的话，这里接收对象，而不是数组</span></span><br><span class=\"line\">  ...<span class=\"title function_\">mapActions</span>(&#123; <span class=\"attr\">setNumAlias</span>: <span class=\"string\">&#x27;setNum&#x27;</span> &#125;),</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方建议2-1\"><a href=\"#官方建议2-1\" class=\"headerlink\" title=\"官方建议2:\"></a>官方建议2:</h2>在store/index.js中的actions里面，方法的形参可以直接将commit解构出来<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">setNum</span>(<span class=\"params\">&#123; commit &#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接将content解构掉，解构出commit，下面就可以直接调用了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;XXXX&#x27;</span>); <span class=\"comment\">// 直接调用</span></span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\nOK，不要将action和mutation混为一谈，action其实就是mutation的上一级，在action这里处理完异步的一些操作后，后面的修改state就交给mutation去做了。<h1 id=\"第六步，按属性进行拆分\"><a href=\"#第六步，按属性进行拆分\" class=\"headerlink\" title=\"第六步，按属性进行拆分\"></a>第六步，按属性进行拆分</h1>我们看到，一个store/index.js里面大致包含state/getters/mutations/actions这四个属性，我们可以彻底点，index.js里面就保持这个架子，把里面的内容四散到其他文件中。<br>我们可以这样拆分：分别是state.js、 getters.js、 mutations.js 、actions.js</li>\n<li>拆出来state放到state.js中<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// state.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;wnxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">number</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">list</span>: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;welcome&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;to&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vuex&#x27;</span> &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></li>\n<li>拆出来getters放到getters.js中<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// getters.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getters = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">getMessage</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`hello<span class=\"subst\">$&#123;state.name&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>拆出来mutations放到mutations.js中<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mutations.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mutations = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">setNumber</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">    state.<span class=\"property\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>拆出来actions放到actions.js中<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// actions.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">setNum</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        content.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setNumberIsWhat&#x27;</span>, &#123; <span class=\"attr\">number</span>: <span class=\"number\">888</span> &#125;);</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>组装到主文件里面<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; state &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./state&#x27;</span>; <span class=\"comment\">// 引入 state</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./getters&#x27;</span>; <span class=\"comment\">// 引入 getters</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./mutations&#x27;</span>; <span class=\"comment\">// 引入 mutations</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; actions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./actions&#x27;</span>; <span class=\"comment\">// 引入 actions</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123; state, getters, mutations, actions &#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n<h1 id=\"第七步，按功能进行拆分-Module\"><a href=\"#第七步，按功能进行拆分-Module\" class=\"headerlink\" title=\"第七步，按功能进行拆分-Module\"></a>第七步，按功能进行拆分-Module</h1>上面我们介绍如何拆分项目，采用的是按属性的方式去拆分，接下来，我们介绍一下按另外的一个维度去拆分我们的store，按功能拆分。</li>\n<li>我们在之前的store上，增加一个新的仓库store2，主要代码如下：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// store2.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store2 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;我是store2&#x27;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store2;</span><br></pre></td></tr></table></figure></li>\n<li>然后在store中引入我们新创建的store2模块：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; state &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./state&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./getters&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./mutations&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; actions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./actions&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store2 <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store2&#x27;</span>; <span class=\"comment\">// 引入store2模块</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 把store2模块挂载到store里面</span></span><br><span class=\"line\">  <span class=\"attr\">modules</span>: &#123; store2 &#125;, </span><br><span class=\"line\">  <span class=\"attr\">state</span>: state,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: getters,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: mutations,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: actions,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></li>\n<li>访问state - 我们在App.vue测试访问store2模块中的state中的name，结果如下：<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 访问store2里面的name属性</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">store2</span>.<span class=\"property\">name</span>); </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n我们通过下面的代码可以了解到在不同的属性里是怎么访问模块内的状态或者根状态：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">changeName</span>(<span class=\"params\">state, payload</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// state 局部状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(payload.<span class=\"property\">where</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">testGetters</span>(<span class=\"params\">state, getters, rootState</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// state 局部状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state);</span><br><span class=\"line\">    <span class=\"comment\">// 局部 getters,</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(getters);</span><br><span class=\"line\">    <span class=\"comment\">// rootState 根节点状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rootState);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">  <span class=\"title function_\">increment</span>(<span class=\"params\">&#123; state, commit, rootState &#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// state 局部状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state);</span><br><span class=\"line\">    <span class=\"comment\">// rootState 根节点状态</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rootState);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n还有一些关于module的内容，比如命名空间、模块注册全局 action、带命名空间的绑定函数、模块动态注册、模块重用等方法，自己查阅即可。🤗</li>\n</ol>\n"},{"title":"Vuex的namespaced属性","date":"2023-04-05T12:16:39.000Z","cover":["/images/namespacedcover.png"],"banner":{"type":"img","bgurl":["/images/namespacedcover.png"]},"_content":"举个例子试一下\n# namespaced为false时\n```\n// 模块test\nexport default {\n    state: {\n        name: 'zb',\n        age: 18\n    },\n    getters: {\n        ageDouble(state){\n            return (state.age)*2\n        }\n    },\n    mutations: {\n        addAge(state, num){\n            state.age += num \n        }\n    },\n    actions: {\n        addAge(context, num){\n            context.commit('addAge', num)\n        }\n    }\n}\n// 在store/index.js中引入并注册\nimport test from './modules/test'   // 引入\n**略**\nmodules: {\n    test        // 注册\n  }\n```\nnamespaced属性默认为false，命名空间默认是关闭的，即模块内部的 action、mutation 和 getter 是注册在全局命名空间的。\n## 使用模块test的state数据\nthis.$store.state.test.age\n```\nimport { mapState } from 'vuex';\ncomputed: {\n    ...mapState({\n      testName: state=>state.test.name,\n      testAge: state=>state.test.age\n    })\n  },\nthis.testName\nthis.testAge\n```\n## 使用模块test的getters，mutation，action\n调用模块test的getters，mutations，actions和store/index.js下的计算属性和方法没有区别，因为都在全局命名空间\n### getters\nthis.$store.getters.ageDouble\n```\nimport { mapGetters } from 'vuex';\ncomputed: {\n    // 起别名\n    ...mapGetters({\n      testAgeDouble: 'ageDouble'\n    }),\n    // 不起别名\n    ...mapGetters(['ageDouble'])\n  }, \nthis.testAgeDouble\nthis.ageDouble\n```\n### mutations\nthis.$store.commit('addAge', 2)\n```\nimport { mapMutations } from 'vuex';\nmethods:{\n    // 起别名\n    ...mapMutations({\n      testAddAge: 'addAge'\n    }),\n    // 不起别名\n    ...mapMutations(['addAge'])\n  },\nthis.testAddAge(2)\nthis.addAge(2)\n```\n### actions\nthis.$store.dispatch('addAge', 2)\n```\nimport { mapActions } from 'vuex';\nmethods:{\n    // 起别名\n    ...mapActions({\n      testAddAge: 'addAge'\n    }),\n    // 不起别名\n    ...mapActions(['addAge'])\n  },\nthis.testAddAge(2)\nthis.addAge(2)\n```\n# namespaced为true时\n```\nexport default {\n    namespaced: true,\n    state: {\n        name: 'zb',\n        age: 18\n    },\n    getters: {\n        ageDouble(state){\n            return (state.age)*2\n        }\n    },\n    mutations: {\n        addAge(state, num){\n            state.age += num \n        }\n    },\n    actions: {\n        addAge(context, num){\n            context.commit('addAge', num)\n        }\n    }\n}\n// 在store/index.js中引入并注册\nimport test from './modules/test'   // 引入\n**略**\nmodules: {\n    test        // 注册\n  }\n```\nnamespaced属性设为true时，说明模块test拥有自己的命名空间，可以防止与其他模块的计算属性和方法混杂，看起来也更清晰。\n## 使用模块test的state数据\n同命名空间为false没有区别\nthis.$store.state.test.age\n```\nimport { mapState } from 'vuex';\ncomputed: {\n    ...mapState({\n      testName: state=>state.test.name,\n      testAge: state=>state.test.age\n    })\n  },\nthis.testName\nthis.testAge\n```\n## 使用模块test的getters，mutation，action\n### getters\nthis.$store.getters['test/ageDouble']\n```\nimport { mapGetters } from 'vuex';\ncomputed: {\n    // 起别名\n    ...mapGetters({\n      testAgeDouble: 'test/ageDouble'\n    }),\n    // 不起别名\n    ...mapGetters('test', ['ageDouble'])\n  },\nthis.testAgeDouble\nthis.ageDouble\n```\n### mutations\nthis.$store.commit('test/addAge', 2)\n```\nimport { mapMutations } from 'vuex';\nmethods:{\n    // 起别名\n    ...mapMutations({\n      testAddAge: 'test/addAge'\n    }),\n    // 不起别名\n    ...mapMutations('test', ['addAge'])\n  },\nthis.testAddAge(2)\nthis.addAge(2)\n```\n### actions\nthis.$store.dispatch('test/addAge', 2)\n```\nimport { mapActions } from 'vuex';\nmethods:{\n    // 起别名\n    ...mapActions({\n      testAddAge: 'test/addAge'\n    }),\n    // 不起别名\n    ...mapActions('test', ['addAge'])\n  },\nthis.testAddAge(2)\nthis.addAge(2)\n```\n当命名空间开启之后，再使用模块test的计算属性和方法就要添加一个模块名的前缀。\n\n","source":"_posts/Vuex的namespaced属性.md","raw":"---\ntitle: Vuex的namespaced属性\ndate: 2023-04-05 20:16:39\ntags: Vuex\ncategories: Vue\ncover: [/images/namespacedcover.png]\nbanner: \n  type: img\n  bgurl: [/images/namespacedcover.png]\n---\n举个例子试一下\n# namespaced为false时\n```\n// 模块test\nexport default {\n    state: {\n        name: 'zb',\n        age: 18\n    },\n    getters: {\n        ageDouble(state){\n            return (state.age)*2\n        }\n    },\n    mutations: {\n        addAge(state, num){\n            state.age += num \n        }\n    },\n    actions: {\n        addAge(context, num){\n            context.commit('addAge', num)\n        }\n    }\n}\n// 在store/index.js中引入并注册\nimport test from './modules/test'   // 引入\n**略**\nmodules: {\n    test        // 注册\n  }\n```\nnamespaced属性默认为false，命名空间默认是关闭的，即模块内部的 action、mutation 和 getter 是注册在全局命名空间的。\n## 使用模块test的state数据\nthis.$store.state.test.age\n```\nimport { mapState } from 'vuex';\ncomputed: {\n    ...mapState({\n      testName: state=>state.test.name,\n      testAge: state=>state.test.age\n    })\n  },\nthis.testName\nthis.testAge\n```\n## 使用模块test的getters，mutation，action\n调用模块test的getters，mutations，actions和store/index.js下的计算属性和方法没有区别，因为都在全局命名空间\n### getters\nthis.$store.getters.ageDouble\n```\nimport { mapGetters } from 'vuex';\ncomputed: {\n    // 起别名\n    ...mapGetters({\n      testAgeDouble: 'ageDouble'\n    }),\n    // 不起别名\n    ...mapGetters(['ageDouble'])\n  }, \nthis.testAgeDouble\nthis.ageDouble\n```\n### mutations\nthis.$store.commit('addAge', 2)\n```\nimport { mapMutations } from 'vuex';\nmethods:{\n    // 起别名\n    ...mapMutations({\n      testAddAge: 'addAge'\n    }),\n    // 不起别名\n    ...mapMutations(['addAge'])\n  },\nthis.testAddAge(2)\nthis.addAge(2)\n```\n### actions\nthis.$store.dispatch('addAge', 2)\n```\nimport { mapActions } from 'vuex';\nmethods:{\n    // 起别名\n    ...mapActions({\n      testAddAge: 'addAge'\n    }),\n    // 不起别名\n    ...mapActions(['addAge'])\n  },\nthis.testAddAge(2)\nthis.addAge(2)\n```\n# namespaced为true时\n```\nexport default {\n    namespaced: true,\n    state: {\n        name: 'zb',\n        age: 18\n    },\n    getters: {\n        ageDouble(state){\n            return (state.age)*2\n        }\n    },\n    mutations: {\n        addAge(state, num){\n            state.age += num \n        }\n    },\n    actions: {\n        addAge(context, num){\n            context.commit('addAge', num)\n        }\n    }\n}\n// 在store/index.js中引入并注册\nimport test from './modules/test'   // 引入\n**略**\nmodules: {\n    test        // 注册\n  }\n```\nnamespaced属性设为true时，说明模块test拥有自己的命名空间，可以防止与其他模块的计算属性和方法混杂，看起来也更清晰。\n## 使用模块test的state数据\n同命名空间为false没有区别\nthis.$store.state.test.age\n```\nimport { mapState } from 'vuex';\ncomputed: {\n    ...mapState({\n      testName: state=>state.test.name,\n      testAge: state=>state.test.age\n    })\n  },\nthis.testName\nthis.testAge\n```\n## 使用模块test的getters，mutation，action\n### getters\nthis.$store.getters['test/ageDouble']\n```\nimport { mapGetters } from 'vuex';\ncomputed: {\n    // 起别名\n    ...mapGetters({\n      testAgeDouble: 'test/ageDouble'\n    }),\n    // 不起别名\n    ...mapGetters('test', ['ageDouble'])\n  },\nthis.testAgeDouble\nthis.ageDouble\n```\n### mutations\nthis.$store.commit('test/addAge', 2)\n```\nimport { mapMutations } from 'vuex';\nmethods:{\n    // 起别名\n    ...mapMutations({\n      testAddAge: 'test/addAge'\n    }),\n    // 不起别名\n    ...mapMutations('test', ['addAge'])\n  },\nthis.testAddAge(2)\nthis.addAge(2)\n```\n### actions\nthis.$store.dispatch('test/addAge', 2)\n```\nimport { mapActions } from 'vuex';\nmethods:{\n    // 起别名\n    ...mapActions({\n      testAddAge: 'test/addAge'\n    }),\n    // 不起别名\n    ...mapActions('test', ['addAge'])\n  },\nthis.testAddAge(2)\nthis.addAge(2)\n```\n当命名空间开启之后，再使用模块test的计算属性和方法就要添加一个模块名的前缀。\n\n","slug":"Vuex的namespaced属性","published":1,"updated":"2023-04-11T05:54:52.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml60013tit80tb21n1z","content":"<p>举个例子试一下</p>\n<h1 id=\"namespaced为false时\"><a href=\"#namespaced为false时\" class=\"headerlink\" title=\"namespaced为false时\"></a>namespaced为false时</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 模块test</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    state: &#123;</span><br><span class=\"line\">        name: &#x27;zb&#x27;,</span><br><span class=\"line\">        age: 18</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getters: &#123;</span><br><span class=\"line\">        ageDouble(state)&#123;</span><br><span class=\"line\">            return (state.age)*2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mutations: &#123;</span><br><span class=\"line\">        addAge(state, num)&#123;</span><br><span class=\"line\">            state.age += num </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">        addAge(context, num)&#123;</span><br><span class=\"line\">            context.commit(&#x27;addAge&#x27;, num)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 在store/index.js中引入并注册</span><br><span class=\"line\">import test from &#x27;./modules/test&#x27;   // 引入</span><br><span class=\"line\">**略**</span><br><span class=\"line\">modules: &#123;</span><br><span class=\"line\">    test        // 注册</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>namespaced属性默认为false，命名空间默认是关闭的，即模块内部的 action、mutation 和 getter 是注册在全局命名空间的。</p>\n<h2 id=\"使用模块test的state数据\"><a href=\"#使用模块test的state数据\" class=\"headerlink\" title=\"使用模块test的state数据\"></a>使用模块test的state数据</h2><p>this.$store.state.test.age</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapState &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    ...mapState(&#123;</span><br><span class=\"line\">      testName: state=&gt;state.test.name,</span><br><span class=\"line\">      testAge: state=&gt;state.test.age</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testName</span><br><span class=\"line\">this.testAge</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用模块test的getters，mutation，action\"><a href=\"#使用模块test的getters，mutation，action\" class=\"headerlink\" title=\"使用模块test的getters，mutation，action\"></a>使用模块test的getters，mutation，action</h2><p>调用模块test的getters，mutations，actions和store/index.js下的计算属性和方法没有区别，因为都在全局命名空间</p>\n<h3 id=\"getters\"><a href=\"#getters\" class=\"headerlink\" title=\"getters\"></a>getters</h3><p>this.$store.getters.ageDouble</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapGetters &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapGetters(&#123;</span><br><span class=\"line\">      testAgeDouble: &#x27;ageDouble&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapGetters([&#x27;ageDouble&#x27;])</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">this.testAgeDouble</span><br><span class=\"line\">this.ageDouble</span><br></pre></td></tr></table></figure>\n<h3 id=\"mutations\"><a href=\"#mutations\" class=\"headerlink\" title=\"mutations\"></a>mutations</h3><p>this.$store.commit(‘addAge’, 2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      testAddAge: &#x27;addAge&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapMutations([&#x27;addAge&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAddAge(2)</span><br><span class=\"line\">this.addAge(2)</span><br></pre></td></tr></table></figure>\n<h3 id=\"actions\"><a href=\"#actions\" class=\"headerlink\" title=\"actions\"></a>actions</h3><p>this.$store.dispatch(‘addAge’, 2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapActions &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      testAddAge: &#x27;addAge&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapActions([&#x27;addAge&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAddAge(2)</span><br><span class=\"line\">this.addAge(2)</span><br></pre></td></tr></table></figure>\n<h1 id=\"namespaced为true时\"><a href=\"#namespaced为true时\" class=\"headerlink\" title=\"namespaced为true时\"></a>namespaced为true时</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">    namespaced: true,</span><br><span class=\"line\">    state: &#123;</span><br><span class=\"line\">        name: &#x27;zb&#x27;,</span><br><span class=\"line\">        age: 18</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getters: &#123;</span><br><span class=\"line\">        ageDouble(state)&#123;</span><br><span class=\"line\">            return (state.age)*2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mutations: &#123;</span><br><span class=\"line\">        addAge(state, num)&#123;</span><br><span class=\"line\">            state.age += num </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">        addAge(context, num)&#123;</span><br><span class=\"line\">            context.commit(&#x27;addAge&#x27;, num)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 在store/index.js中引入并注册</span><br><span class=\"line\">import test from &#x27;./modules/test&#x27;   // 引入</span><br><span class=\"line\">**略**</span><br><span class=\"line\">modules: &#123;</span><br><span class=\"line\">    test        // 注册</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>namespaced属性设为true时，说明模块test拥有自己的命名空间，可以防止与其他模块的计算属性和方法混杂，看起来也更清晰。</p>\n<h2 id=\"使用模块test的state数据-1\"><a href=\"#使用模块test的state数据-1\" class=\"headerlink\" title=\"使用模块test的state数据\"></a>使用模块test的state数据</h2><p>同命名空间为false没有区别<br>this.$store.state.test.age</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapState &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    ...mapState(&#123;</span><br><span class=\"line\">      testName: state=&gt;state.test.name,</span><br><span class=\"line\">      testAge: state=&gt;state.test.age</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testName</span><br><span class=\"line\">this.testAge</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用模块test的getters，mutation，action-1\"><a href=\"#使用模块test的getters，mutation，action-1\" class=\"headerlink\" title=\"使用模块test的getters，mutation，action\"></a>使用模块test的getters，mutation，action</h2><h3 id=\"getters-1\"><a href=\"#getters-1\" class=\"headerlink\" title=\"getters\"></a>getters</h3><p>this.$store.getters[‘test/ageDouble’]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapGetters &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapGetters(&#123;</span><br><span class=\"line\">      testAgeDouble: &#x27;test/ageDouble&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapGetters(&#x27;test&#x27;, [&#x27;ageDouble&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAgeDouble</span><br><span class=\"line\">this.ageDouble</span><br></pre></td></tr></table></figure>\n<h3 id=\"mutations-1\"><a href=\"#mutations-1\" class=\"headerlink\" title=\"mutations\"></a>mutations</h3><p>this.$store.commit(‘test/addAge’, 2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      testAddAge: &#x27;test/addAge&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapMutations(&#x27;test&#x27;, [&#x27;addAge&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAddAge(2)</span><br><span class=\"line\">this.addAge(2)</span><br></pre></td></tr></table></figure>\n<h3 id=\"actions-1\"><a href=\"#actions-1\" class=\"headerlink\" title=\"actions\"></a>actions</h3><p>this.$store.dispatch(‘test/addAge’, 2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapActions &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      testAddAge: &#x27;test/addAge&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapActions(&#x27;test&#x27;, [&#x27;addAge&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAddAge(2)</span><br><span class=\"line\">this.addAge(2)</span><br></pre></td></tr></table></figure>\n<p>当命名空间开启之后，再使用模块test的计算属性和方法就要添加一个模块名的前缀。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>举个例子试一下</p>\n<h1 id=\"namespaced为false时\"><a href=\"#namespaced为false时\" class=\"headerlink\" title=\"namespaced为false时\"></a>namespaced为false时</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 模块test</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    state: &#123;</span><br><span class=\"line\">        name: &#x27;zb&#x27;,</span><br><span class=\"line\">        age: 18</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getters: &#123;</span><br><span class=\"line\">        ageDouble(state)&#123;</span><br><span class=\"line\">            return (state.age)*2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mutations: &#123;</span><br><span class=\"line\">        addAge(state, num)&#123;</span><br><span class=\"line\">            state.age += num </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">        addAge(context, num)&#123;</span><br><span class=\"line\">            context.commit(&#x27;addAge&#x27;, num)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 在store/index.js中引入并注册</span><br><span class=\"line\">import test from &#x27;./modules/test&#x27;   // 引入</span><br><span class=\"line\">**略**</span><br><span class=\"line\">modules: &#123;</span><br><span class=\"line\">    test        // 注册</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>namespaced属性默认为false，命名空间默认是关闭的，即模块内部的 action、mutation 和 getter 是注册在全局命名空间的。</p>\n<h2 id=\"使用模块test的state数据\"><a href=\"#使用模块test的state数据\" class=\"headerlink\" title=\"使用模块test的state数据\"></a>使用模块test的state数据</h2><p>this.$store.state.test.age</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapState &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    ...mapState(&#123;</span><br><span class=\"line\">      testName: state=&gt;state.test.name,</span><br><span class=\"line\">      testAge: state=&gt;state.test.age</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testName</span><br><span class=\"line\">this.testAge</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用模块test的getters，mutation，action\"><a href=\"#使用模块test的getters，mutation，action\" class=\"headerlink\" title=\"使用模块test的getters，mutation，action\"></a>使用模块test的getters，mutation，action</h2><p>调用模块test的getters，mutations，actions和store/index.js下的计算属性和方法没有区别，因为都在全局命名空间</p>\n<h3 id=\"getters\"><a href=\"#getters\" class=\"headerlink\" title=\"getters\"></a>getters</h3><p>this.$store.getters.ageDouble</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapGetters &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapGetters(&#123;</span><br><span class=\"line\">      testAgeDouble: &#x27;ageDouble&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapGetters([&#x27;ageDouble&#x27;])</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">this.testAgeDouble</span><br><span class=\"line\">this.ageDouble</span><br></pre></td></tr></table></figure>\n<h3 id=\"mutations\"><a href=\"#mutations\" class=\"headerlink\" title=\"mutations\"></a>mutations</h3><p>this.$store.commit(‘addAge’, 2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      testAddAge: &#x27;addAge&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapMutations([&#x27;addAge&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAddAge(2)</span><br><span class=\"line\">this.addAge(2)</span><br></pre></td></tr></table></figure>\n<h3 id=\"actions\"><a href=\"#actions\" class=\"headerlink\" title=\"actions\"></a>actions</h3><p>this.$store.dispatch(‘addAge’, 2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapActions &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      testAddAge: &#x27;addAge&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapActions([&#x27;addAge&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAddAge(2)</span><br><span class=\"line\">this.addAge(2)</span><br></pre></td></tr></table></figure>\n<h1 id=\"namespaced为true时\"><a href=\"#namespaced为true时\" class=\"headerlink\" title=\"namespaced为true时\"></a>namespaced为true时</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">    namespaced: true,</span><br><span class=\"line\">    state: &#123;</span><br><span class=\"line\">        name: &#x27;zb&#x27;,</span><br><span class=\"line\">        age: 18</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getters: &#123;</span><br><span class=\"line\">        ageDouble(state)&#123;</span><br><span class=\"line\">            return (state.age)*2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mutations: &#123;</span><br><span class=\"line\">        addAge(state, num)&#123;</span><br><span class=\"line\">            state.age += num </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">        addAge(context, num)&#123;</span><br><span class=\"line\">            context.commit(&#x27;addAge&#x27;, num)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 在store/index.js中引入并注册</span><br><span class=\"line\">import test from &#x27;./modules/test&#x27;   // 引入</span><br><span class=\"line\">**略**</span><br><span class=\"line\">modules: &#123;</span><br><span class=\"line\">    test        // 注册</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>namespaced属性设为true时，说明模块test拥有自己的命名空间，可以防止与其他模块的计算属性和方法混杂，看起来也更清晰。</p>\n<h2 id=\"使用模块test的state数据-1\"><a href=\"#使用模块test的state数据-1\" class=\"headerlink\" title=\"使用模块test的state数据\"></a>使用模块test的state数据</h2><p>同命名空间为false没有区别<br>this.$store.state.test.age</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapState &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    ...mapState(&#123;</span><br><span class=\"line\">      testName: state=&gt;state.test.name,</span><br><span class=\"line\">      testAge: state=&gt;state.test.age</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testName</span><br><span class=\"line\">this.testAge</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用模块test的getters，mutation，action-1\"><a href=\"#使用模块test的getters，mutation，action-1\" class=\"headerlink\" title=\"使用模块test的getters，mutation，action\"></a>使用模块test的getters，mutation，action</h2><h3 id=\"getters-1\"><a href=\"#getters-1\" class=\"headerlink\" title=\"getters\"></a>getters</h3><p>this.$store.getters[‘test/ageDouble’]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapGetters &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapGetters(&#123;</span><br><span class=\"line\">      testAgeDouble: &#x27;test/ageDouble&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapGetters(&#x27;test&#x27;, [&#x27;ageDouble&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAgeDouble</span><br><span class=\"line\">this.ageDouble</span><br></pre></td></tr></table></figure>\n<h3 id=\"mutations-1\"><a href=\"#mutations-1\" class=\"headerlink\" title=\"mutations\"></a>mutations</h3><p>this.$store.commit(‘test/addAge’, 2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      testAddAge: &#x27;test/addAge&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapMutations(&#x27;test&#x27;, [&#x27;addAge&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAddAge(2)</span><br><span class=\"line\">this.addAge(2)</span><br></pre></td></tr></table></figure>\n<h3 id=\"actions-1\"><a href=\"#actions-1\" class=\"headerlink\" title=\"actions\"></a>actions</h3><p>this.$store.dispatch(‘test/addAge’, 2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; mapActions &#125; from &#x27;vuex&#x27;;</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    // 起别名</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      testAddAge: &#x27;test/addAge&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    // 不起别名</span><br><span class=\"line\">    ...mapActions(&#x27;test&#x27;, [&#x27;addAge&#x27;])</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">this.testAddAge(2)</span><br><span class=\"line\">this.addAge(2)</span><br></pre></td></tr></table></figure>\n<p>当命名空间开启之后，再使用模块test的计算属性和方法就要添加一个模块名的前缀。</p>\n"},{"title":"Vue项目SEO优化-Nuxt","date":"2023-04-10T14:12:36.000Z","cover":["/images/cover.png"],"banner":{"type":"img","bgurl":["/images/cover.png"]},"_content":"# 为什么SPA需要SEO\n通常我们用前端框架（这里以Vue为例）产出的代码一般是这样的：\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>title</title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script src=\"index.js\"></script>\n</body>\n</html>\n```\n页面实际展示的内容（用户实际看到的内容）都是通过js渲染出来的，所以搜索引擎爬虫在对我们的页面进行爬取的时候，拿到的也是上面的html代码。虽然我们可以通过在<head></head>中添加<meta/>标签来添加一些描述信息，但是远远不够，我们实际展示的内容搜索引擎爬虫还是拿不到，所以就需要对项目进行SEO优化。\n# 关于Nuxt.js\n## 官方介绍\n从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目Nuxt.js这让一切变得非常简单。Nuxt是一个基于Vue生态的更高层的框架，为开发服务端渲染的Vue应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。\n## 简单的理解：\n代替浏览器的工作,笼统理解就是在created时的请求数据和页面渲染，第二点是当作静态文件服务器，把渲染好的页面返回给用户。\n## 优势：\n+ 纯静态文件，访问速度快\n+ 对比SSR,不涉及服务器负载方面问题\n+ 静态网页不宜遭到黑客工具，安全性高\n## 服务端渲染和客户端渲染\n1. 浏览器（客户端）通过AJAX向服务端（java servlet）发送http请求数据接口\n2. 服务端将获取的接口数据封装成JSON，响应给浏览器\n3. 浏览器拿到JSON就进行渲染html页面，生成DOM元素，然后将页面展示给用户\n![](服务端渲染.png)\n![](客户端渲染.png)\n## Nuxt.js工作原理\n1. 浏览器(客户端)发送http请求到Node.js服务端。\n2. 部署在Node.js的应用Nuxt.js接收到浏览器请求，它会去请求后台服务端。\n3. 后台接口服务端会响应JSON数据，Nuxt.js获取数据后进行服务端渲染成html。\n4. 然后Nuxt.js将html页面响应给浏览器\n5. 浏览器直接将接收到html页面进行展示\n![](nuxt渲染.png)\n## 操作\n### 首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。\n### 目录结构\n```\n.nuxt\n1. assets //资源目录 组织为编译的静态资源 大家都懂\n      image.png\n2.components // 组织 Vue.js 组件，NUXT不会扩展增强该目录下的组件，这意味着组件不能使用 \n3.asyncData 方法\n4.layout // 布局目录 如果没有额外配置，目录不能重命名--不建议改名\n5.middleware // 用于存放应用的中间件\n6.node_modules \n7.pages // 页面目录用于组织应用路由及视图，NUXT会读取该目录下所有.vue文件并自动生成路由（路由文件在 .nuxt/router.js）\n      index.vue\n8.plugins // 插件目录 用于组织那些需要在跟vue.js应用，实例化之前需要运行的Javascript插件\n9.static // 用于存放应用的静态文件，此类文件不会被NUXT.js调用Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径  `/`  下。例如 /static/root.txt 映射至 /root.txt\n10.store // Nuxt.js 框架集成了 [Vuex 状态树] 的相关功能配置，在  `store`  目录下创建一个  `index.js`  文件可激活这些配置。 新建一个index.js 这事就算妥了\n11.nuxt.config.js // 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置 不要gai'ming'zi\n12.package.json // 用于描述应用的依赖关系和对外暴露的脚本接口\n```\n### NUXT开发中需要注意哪些。\n#### 静态资源的引入和路由\n```\n//引入静态资源 和 跳转路由\n<template>\n  <!--我们不需要去配置 @去指向根目录  NUXT中可以直接使用 -->\n  <img src=\"~/assets/image.png\" />\n  <!--NUXT中我们不需要去写路由表  👇 '/'指的是 page/index.vue 其它语法和日常无恙  -->\n  <nuxt-link :to=\"{name:'userPage',query:{id:'111'}}\">个人中心</nuxt-link>\n</template>\n```\n#### asyncData\nNuxt.js扩展了Vue.js 增加了asyncData的方法，这样我们可以在渲染组件之前异步获取数据，asyncData方法会在组件（只限于页面组件）每次加载之前被调用，它可以在服务端或路由更新之前被调用，在这个方法被调用的时候，第一个参数context被设定为当前页的上下文对象。\n```\nasync asyncData({ params }){  // params 就是传进来的值\n//asyncData 函数去执行我们的异步操作 当我们获取到接口返回的内容是 此时我们Vue还没有实例化 所以this获取不到  我们通过返回 方法 去获取  因此标签内如果需要展示内容  {{info.XXX}}\n\tconst data = await $axios.$get('/api/user')\n\treturn {data}\n}\n```\n#### @nuxtjs/axios\n我们在asyncData中调用接口，在Nuxt.js官方提供了@nuxtjs/axios模块，此模块还包含了axios、@nuxtjs/proxy（解决异步,进行代理转发）模块。\n```\n// 1.安装@nuxtjs/axios：\nnpm install @nuxtjs/axios\n// 2.在nuxt.config.js中配置axios\nmodule.exports={\n\tmodules:['@nuxtjs/axios']\n}\n```\n#### 中间件\n中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。可用于权限判断，有权限才可访问对应页面\n中间件应放置在middleware/ 目录。文件名的名称将成为中间件名称（middleware/auth.js将成为auth中间件）\n```\n//创建权限中间件\n//在 middleware/ 下创建 auth.js 文件，其中auth就是中间件的名称。\n//一个中间件接收content作为第一个参数\nexport default({ store, redirect }) => {\n\tif(/* 没有token */){\n\t\treturn redirect('/')\n\t}\n}\n```\n# Nuxt对Vue项目首页进行SEO优化\nNuxt.js 集成了以下组件/框架，用于开发完整而强大的Web 应用：\n+ Vue 2\n+ Vue-Router\n+ Vuex(当配置了Vuex状态树配置项时才会引入)\n+ Vue服务器端渲染 (排除使用mode:'spa')\n+ Vue-Meta\n另外，Nuxt.js使用Webpack和vue-loader 、babel-loader来处理代码的自动化构建工作（如打包、代码分层、压缩等等）。\n## 具体步骤\n### 新建项目\n因为是对项目的一部分进行改造，所以新建了一个项目。\n新创建的项目目录大致如下：\n```\n+ assets:静态资源\n+ components:组件，该文件夹下的组件使用时无需引入，类似于已经全局注册了，这些组件无法使用asyncData。\n+ layouts:用于组织应用的布局组件，我理解类似于Vue项目中的App.vue\n+ middlwware:应用的中间件，这个没有用到\n+ node_modules:依赖包\n+ pages:页面，Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。在这个目录里使用其他类型的文件在npm run generate时可能会报错\n+ plugins:插件目录。用于组织需要再根Vue.js应用实例化之前需要运行的JavaScript插件。在任何 Vue 组件的生命周期内，只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。\n+ static:静态文件目录。\n静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。\nstore\n+ Vuex状态树。\nNuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。\n+ nuxt.config.js\nnuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。\n+ 其他\n.babelrc、.editorconfig、package.json、package-lock.json等，和其他项目中同名文件功能相同。\n+ 别名\n~或@ => srcDir\n~~或@@ => rootDir\n```\n在vue模板中, 如果需要引入assets或者static目录, 使用~/assets/your_image.png和~/static/your_image.png方式。\n### 迁移文件\n把老项目首页及宣传页的代码以及依赖的静态文件，还有一些eslint的配置，webpack配置等，能用的都拿过来，然后修改引用路径，删除不需要的代码。\n下面是目录的对应关系：\n```\n+ assets:css、icon、font等静态资源\n+ components:首页及宣传页用到的组件\n+ layouts:App.vue\n+ middlwware\n+ node_modules:依赖包\n+ pages:首页及宣传页涉及到的页面。\n+ plugins:用到的各种插件。\n      + axios封装（没有用Nuxt.js默认的@nuxtjs/axios）\n      + elementUI\n      + 其他一些用到的插件（video、zepto等）\n      + 工具函数（这里有疑问，是不是应该放在assets下面）\n+ static:.ico文件\n+ store:vuex相关文件\n+ nuxt.config.js:nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。\n+ 其他:.babelrc、.editorconfig、package.json、package-lock.json等，和其他功能相同。\n```\n### 修改配置\n这部分是重点，因为Nuxt很多东西其实在一开始就都配置好了，比如像它的目录结构，官方都建议一般不要修改。如果想修改配置的话，必须在nuxt.config.js中进行修改。Nuxt关于配置的文档很多，这里直说我用到的部分。\n```js\nimport webpack from 'webpack'\nexport default {\n  ssr: false, // 是否启用服务端渲染。默认为false，创建时可选择\n  target: 'static', // server：用于服务器端渲染，static：用于静态网站\n  root: {\n    base: '/page/' // 应用程序的基本URL，如果在此路径下提供了整个应用程序，则应该使用root.base。使用之后，访问***.com/home路由应该使用***.com/page/home\n  },\n  head: { // 一些静态资源的引入，填写头信息\n    title: 'nuxt-demo',\n    meta: [\n      { charset: 'utf-8' },\n      { name: 'viewport', content: 'width=device-width, initial-scale=1' },\n      { hid: '', name: 'description', content: '' }\n    ],\n    script: [\n      {\n        src: 'https://cdn.bootcdn.net/ajax/libs/zepto/1.2.0/zepto.js'\n      }\n    ]\n  },\n  css: [ // 全局使用的css\n    'element-ui/lib/theme-chalk/index.css',\n    '~/assets/css/common.css',\n    '~/assets/css/element-variables.scss',\n  ],\n  plugins: [ //  使用插件\n    {src: '~plugins/element-ui'},\n    {\n      src: '~plugins/log.js',\n      mode: 'client' // client或server：文件仅包含在客户端或服务器端，如果代码中使用了window或document等浏览器端才有的API，只能使用client\n    },\n    {\n      src: '~plugins/route.js',\n\n mode: 'client'\n    }\n  ],\n  components: true, // 自动引入组件\n  buildModules: [ // 某些模块仅在开发和构建期间需要。使用buildModules有助于加快生产启动速度，并大大减少node_modules生产部署的规模。\n    '@nuxtjs/eslint-module'\n  ],\n  build: { // Nuxt.js 允许你根据服务端需求，自定义 webpack 的构建配置。\n    transpile: [/^element-ui/], // 使用Babel与特定的依赖关系进行转换。应该是element-ui使用了ES6语法，所以需要进行转化\n    publicPath: '', // 静态资源引用路径（通常使用CND地址）\n    plugins: [ // 配置webpack插件  nuxt使用的webpack版本比较旧，有一些新功能无法使用\n      new webpack.DefinePlugin({\n        __ENV__: JSON.stringify(process.env.ENV || 'dev')\n      })\n    ]\n  }\n}\n```\n### 项目部署\n由于该项目与其他项目共用一个域名：www.###.com，需要保证另一个项目也可用。所有在部署的时候把Nuxt的项目放在了www.###.com/page目录下\n在server中添加location /page的配置项\n让根路径重定向到www.###.com/page/home\n对旧项目已有的一些访问路径进行兼容\n首页项目和旧项目（主站）的相互跳转（登录登出跳转等）\n### 常见问题\n一、document is not defined or window is not defined\n解决方法：\n此问题产生是由于在服务端渲染时使用了window或document等DOM相关的API，常见的原因有两个：\n+ 页面中生命周期使用错误，比如在created中使用了window\nnuxt在服务端执行时会执行Vue生命周期中的beforeCreate和created，如果在这两个生命周期里使用了DOM相关的API是获取不到的，构建时会报错。\n+ 第三方插件使用了window或document等DOM相关的API\nNuxt.js 允许在运行Vue.js应用程序之前执行js插件。这在您需要使用自己的库或第三方模块时特别有用。但是要注意插件是否在客户端和服务端都需要，还有就是插件中是否用到了DOM相关的API（会导致构建时报错）\n解决方法：\n+ 正确使用生命周期，在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。\n这里获取不到window或document等API，可以放在mounted中执行。\n+ 使用第三方插件时：\n```\nplugins: [\n  {\n    src: '~plugins/log.js',\n    mode: 'client'\n  }\n]\n```\n添加mode: 'client'使第三方插件仅在客户端渲染时使用。\n二、NuxtLink无法打开新页面\nNuxtjs中在进行路由导航时提供了<nuxt-link to=\"/\"></nuxt-link>，但是此标签有一个问题：无法在新窗口打开链接，建议改为a标签，既能满足需求，也利于搜索引擎爬取相关链接。\n三、注册全局方法\n有时想在整个项目中使用函数或值，在Vue项目中我们有可能把方法挂在在Vue实例上，但是官方文档中明确提出：\n请勿全局使用Vue.use()，Vue.component()，也不要在此功能内专门用于Nuxt注入的Vue中插入任何内容。这将导致服务器端内存泄漏。\n另外也为我们提供了一种方法（inject(key, value)）来注册全局方法（变量）：\n```\n// plugins/hello.js\nexport default ({ app }, inject) => {\n  // Inject $hello(msg) in Vue, context and store.\n  inject('hello', msg => console.log(`Hello ${msg}!`))\n}\n```\n```\n// nuxt.config.js\nexport default {\n  plugins: ['~/plugins/hello.js']\n}\n```\n然后就可以在页面、组件、插件中使用了。\n```\n// a.vue\nexport default {\n  mounted() {\n    this.$hello('mounted')\n    // will console.log 'Hello mounted!'\n  },\n  asyncData({ app, $hello }) {\n    $hello('asyncData')\n    // If using Nuxt <= 2.12, use 👇\n    app.$hello('asyncData')\n  }\n}\n```\n四、Nuxt支持在页面中加入head信息。\n```\nexport default {\n  data () {\n    return {}\n  },\n  created () {},\n  ...,\n  head () {\n    return {\n      title: '',\n      meta: [\n        { hid: '', name: '', content: ''}\n      ]\n    }\n  }\n}\n```\n五、路由相关\nNuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。\n基础路由\npages/\n--| user/\n-----| index.vue\n-----| one.vue\n--| index.vue\n那么，Nuxt.js 自动生成的路由配置如下：\n```\nrouter: {\n  routes: [\n    {\n      name: 'index',\n      path: '/',\n      component: 'pages/index.vue'\n    },\n    {\n      name: 'user',\n      path: '/user',\n      component: 'pages/user/index.vue'\n    },\n    {\n      name: 'user-one',\n      path: '/user/one',\n      component: 'pages/user/one.vue'\n    }\n  ]\n}\n```\n嵌套路由\n你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。\n创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。\n文件路径：\npages/\n--| users/\n-----| _id.vue // 以下划线作为前缀的Vue文件：动态路由，做SSR的时候可能会用到\n-----| index.vue\n--| users.vue\nNuxt.js 自动生成的路由配置如下：\n```\nrouter: {\n  routes: [\n    {\n      path: '/users',\n      component: 'pages/users.vue',\n      children: [\n        {\n          path: '',\n          component: 'pages/users/index.vue',\n          name: 'users'\n        },\n        {\n          path: ':id',\n          component: 'pages/users/_id.vue',\n          name: 'users-id'\n        }\n      ]\n    }\n  ]\n}\n```\n六、常用命令：\nnuxt\n启用一个热加载的Web服务器（开发模式）localhost:3000\nnuxt build\n利用webpack编译应用，压缩JS和CSS资源（发布用）。\nnuxt start\n以生产模式启动一个Web服务器 (基于dist目录，需要先执行nuxt build)。\nnuxt generate\n编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)。","source":"_posts/Vue项目SEO优化-Nuxt.md","raw":"---\ntitle: Vue项目SEO优化-Nuxt\ndate: 2023-04-10 22:12:36\ntags: vue\ncategories: 性能优化\ncover: [/images/cover.png]\nbanner: \n  type: img\n  bgurl: [/images/cover.png]\n---\n# 为什么SPA需要SEO\n通常我们用前端框架（这里以Vue为例）产出的代码一般是这样的：\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>title</title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script src=\"index.js\"></script>\n</body>\n</html>\n```\n页面实际展示的内容（用户实际看到的内容）都是通过js渲染出来的，所以搜索引擎爬虫在对我们的页面进行爬取的时候，拿到的也是上面的html代码。虽然我们可以通过在<head></head>中添加<meta/>标签来添加一些描述信息，但是远远不够，我们实际展示的内容搜索引擎爬虫还是拿不到，所以就需要对项目进行SEO优化。\n# 关于Nuxt.js\n## 官方介绍\n从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目Nuxt.js这让一切变得非常简单。Nuxt是一个基于Vue生态的更高层的框架，为开发服务端渲染的Vue应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。\n## 简单的理解：\n代替浏览器的工作,笼统理解就是在created时的请求数据和页面渲染，第二点是当作静态文件服务器，把渲染好的页面返回给用户。\n## 优势：\n+ 纯静态文件，访问速度快\n+ 对比SSR,不涉及服务器负载方面问题\n+ 静态网页不宜遭到黑客工具，安全性高\n## 服务端渲染和客户端渲染\n1. 浏览器（客户端）通过AJAX向服务端（java servlet）发送http请求数据接口\n2. 服务端将获取的接口数据封装成JSON，响应给浏览器\n3. 浏览器拿到JSON就进行渲染html页面，生成DOM元素，然后将页面展示给用户\n![](服务端渲染.png)\n![](客户端渲染.png)\n## Nuxt.js工作原理\n1. 浏览器(客户端)发送http请求到Node.js服务端。\n2. 部署在Node.js的应用Nuxt.js接收到浏览器请求，它会去请求后台服务端。\n3. 后台接口服务端会响应JSON数据，Nuxt.js获取数据后进行服务端渲染成html。\n4. 然后Nuxt.js将html页面响应给浏览器\n5. 浏览器直接将接收到html页面进行展示\n![](nuxt渲染.png)\n## 操作\n### 首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。\n### 目录结构\n```\n.nuxt\n1. assets //资源目录 组织为编译的静态资源 大家都懂\n      image.png\n2.components // 组织 Vue.js 组件，NUXT不会扩展增强该目录下的组件，这意味着组件不能使用 \n3.asyncData 方法\n4.layout // 布局目录 如果没有额外配置，目录不能重命名--不建议改名\n5.middleware // 用于存放应用的中间件\n6.node_modules \n7.pages // 页面目录用于组织应用路由及视图，NUXT会读取该目录下所有.vue文件并自动生成路由（路由文件在 .nuxt/router.js）\n      index.vue\n8.plugins // 插件目录 用于组织那些需要在跟vue.js应用，实例化之前需要运行的Javascript插件\n9.static // 用于存放应用的静态文件，此类文件不会被NUXT.js调用Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径  `/`  下。例如 /static/root.txt 映射至 /root.txt\n10.store // Nuxt.js 框架集成了 [Vuex 状态树] 的相关功能配置，在  `store`  目录下创建一个  `index.js`  文件可激活这些配置。 新建一个index.js 这事就算妥了\n11.nuxt.config.js // 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置 不要gai'ming'zi\n12.package.json // 用于描述应用的依赖关系和对外暴露的脚本接口\n```\n### NUXT开发中需要注意哪些。\n#### 静态资源的引入和路由\n```\n//引入静态资源 和 跳转路由\n<template>\n  <!--我们不需要去配置 @去指向根目录  NUXT中可以直接使用 -->\n  <img src=\"~/assets/image.png\" />\n  <!--NUXT中我们不需要去写路由表  👇 '/'指的是 page/index.vue 其它语法和日常无恙  -->\n  <nuxt-link :to=\"{name:'userPage',query:{id:'111'}}\">个人中心</nuxt-link>\n</template>\n```\n#### asyncData\nNuxt.js扩展了Vue.js 增加了asyncData的方法，这样我们可以在渲染组件之前异步获取数据，asyncData方法会在组件（只限于页面组件）每次加载之前被调用，它可以在服务端或路由更新之前被调用，在这个方法被调用的时候，第一个参数context被设定为当前页的上下文对象。\n```\nasync asyncData({ params }){  // params 就是传进来的值\n//asyncData 函数去执行我们的异步操作 当我们获取到接口返回的内容是 此时我们Vue还没有实例化 所以this获取不到  我们通过返回 方法 去获取  因此标签内如果需要展示内容  {{info.XXX}}\n\tconst data = await $axios.$get('/api/user')\n\treturn {data}\n}\n```\n#### @nuxtjs/axios\n我们在asyncData中调用接口，在Nuxt.js官方提供了@nuxtjs/axios模块，此模块还包含了axios、@nuxtjs/proxy（解决异步,进行代理转发）模块。\n```\n// 1.安装@nuxtjs/axios：\nnpm install @nuxtjs/axios\n// 2.在nuxt.config.js中配置axios\nmodule.exports={\n\tmodules:['@nuxtjs/axios']\n}\n```\n#### 中间件\n中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。可用于权限判断，有权限才可访问对应页面\n中间件应放置在middleware/ 目录。文件名的名称将成为中间件名称（middleware/auth.js将成为auth中间件）\n```\n//创建权限中间件\n//在 middleware/ 下创建 auth.js 文件，其中auth就是中间件的名称。\n//一个中间件接收content作为第一个参数\nexport default({ store, redirect }) => {\n\tif(/* 没有token */){\n\t\treturn redirect('/')\n\t}\n}\n```\n# Nuxt对Vue项目首页进行SEO优化\nNuxt.js 集成了以下组件/框架，用于开发完整而强大的Web 应用：\n+ Vue 2\n+ Vue-Router\n+ Vuex(当配置了Vuex状态树配置项时才会引入)\n+ Vue服务器端渲染 (排除使用mode:'spa')\n+ Vue-Meta\n另外，Nuxt.js使用Webpack和vue-loader 、babel-loader来处理代码的自动化构建工作（如打包、代码分层、压缩等等）。\n## 具体步骤\n### 新建项目\n因为是对项目的一部分进行改造，所以新建了一个项目。\n新创建的项目目录大致如下：\n```\n+ assets:静态资源\n+ components:组件，该文件夹下的组件使用时无需引入，类似于已经全局注册了，这些组件无法使用asyncData。\n+ layouts:用于组织应用的布局组件，我理解类似于Vue项目中的App.vue\n+ middlwware:应用的中间件，这个没有用到\n+ node_modules:依赖包\n+ pages:页面，Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。在这个目录里使用其他类型的文件在npm run generate时可能会报错\n+ plugins:插件目录。用于组织需要再根Vue.js应用实例化之前需要运行的JavaScript插件。在任何 Vue 组件的生命周期内，只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。\n+ static:静态文件目录。\n静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。\nstore\n+ Vuex状态树。\nNuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。\n+ nuxt.config.js\nnuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。\n+ 其他\n.babelrc、.editorconfig、package.json、package-lock.json等，和其他项目中同名文件功能相同。\n+ 别名\n~或@ => srcDir\n~~或@@ => rootDir\n```\n在vue模板中, 如果需要引入assets或者static目录, 使用~/assets/your_image.png和~/static/your_image.png方式。\n### 迁移文件\n把老项目首页及宣传页的代码以及依赖的静态文件，还有一些eslint的配置，webpack配置等，能用的都拿过来，然后修改引用路径，删除不需要的代码。\n下面是目录的对应关系：\n```\n+ assets:css、icon、font等静态资源\n+ components:首页及宣传页用到的组件\n+ layouts:App.vue\n+ middlwware\n+ node_modules:依赖包\n+ pages:首页及宣传页涉及到的页面。\n+ plugins:用到的各种插件。\n      + axios封装（没有用Nuxt.js默认的@nuxtjs/axios）\n      + elementUI\n      + 其他一些用到的插件（video、zepto等）\n      + 工具函数（这里有疑问，是不是应该放在assets下面）\n+ static:.ico文件\n+ store:vuex相关文件\n+ nuxt.config.js:nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。\n+ 其他:.babelrc、.editorconfig、package.json、package-lock.json等，和其他功能相同。\n```\n### 修改配置\n这部分是重点，因为Nuxt很多东西其实在一开始就都配置好了，比如像它的目录结构，官方都建议一般不要修改。如果想修改配置的话，必须在nuxt.config.js中进行修改。Nuxt关于配置的文档很多，这里直说我用到的部分。\n```js\nimport webpack from 'webpack'\nexport default {\n  ssr: false, // 是否启用服务端渲染。默认为false，创建时可选择\n  target: 'static', // server：用于服务器端渲染，static：用于静态网站\n  root: {\n    base: '/page/' // 应用程序的基本URL，如果在此路径下提供了整个应用程序，则应该使用root.base。使用之后，访问***.com/home路由应该使用***.com/page/home\n  },\n  head: { // 一些静态资源的引入，填写头信息\n    title: 'nuxt-demo',\n    meta: [\n      { charset: 'utf-8' },\n      { name: 'viewport', content: 'width=device-width, initial-scale=1' },\n      { hid: '', name: 'description', content: '' }\n    ],\n    script: [\n      {\n        src: 'https://cdn.bootcdn.net/ajax/libs/zepto/1.2.0/zepto.js'\n      }\n    ]\n  },\n  css: [ // 全局使用的css\n    'element-ui/lib/theme-chalk/index.css',\n    '~/assets/css/common.css',\n    '~/assets/css/element-variables.scss',\n  ],\n  plugins: [ //  使用插件\n    {src: '~plugins/element-ui'},\n    {\n      src: '~plugins/log.js',\n      mode: 'client' // client或server：文件仅包含在客户端或服务器端，如果代码中使用了window或document等浏览器端才有的API，只能使用client\n    },\n    {\n      src: '~plugins/route.js',\n\n mode: 'client'\n    }\n  ],\n  components: true, // 自动引入组件\n  buildModules: [ // 某些模块仅在开发和构建期间需要。使用buildModules有助于加快生产启动速度，并大大减少node_modules生产部署的规模。\n    '@nuxtjs/eslint-module'\n  ],\n  build: { // Nuxt.js 允许你根据服务端需求，自定义 webpack 的构建配置。\n    transpile: [/^element-ui/], // 使用Babel与特定的依赖关系进行转换。应该是element-ui使用了ES6语法，所以需要进行转化\n    publicPath: '', // 静态资源引用路径（通常使用CND地址）\n    plugins: [ // 配置webpack插件  nuxt使用的webpack版本比较旧，有一些新功能无法使用\n      new webpack.DefinePlugin({\n        __ENV__: JSON.stringify(process.env.ENV || 'dev')\n      })\n    ]\n  }\n}\n```\n### 项目部署\n由于该项目与其他项目共用一个域名：www.###.com，需要保证另一个项目也可用。所有在部署的时候把Nuxt的项目放在了www.###.com/page目录下\n在server中添加location /page的配置项\n让根路径重定向到www.###.com/page/home\n对旧项目已有的一些访问路径进行兼容\n首页项目和旧项目（主站）的相互跳转（登录登出跳转等）\n### 常见问题\n一、document is not defined or window is not defined\n解决方法：\n此问题产生是由于在服务端渲染时使用了window或document等DOM相关的API，常见的原因有两个：\n+ 页面中生命周期使用错误，比如在created中使用了window\nnuxt在服务端执行时会执行Vue生命周期中的beforeCreate和created，如果在这两个生命周期里使用了DOM相关的API是获取不到的，构建时会报错。\n+ 第三方插件使用了window或document等DOM相关的API\nNuxt.js 允许在运行Vue.js应用程序之前执行js插件。这在您需要使用自己的库或第三方模块时特别有用。但是要注意插件是否在客户端和服务端都需要，还有就是插件中是否用到了DOM相关的API（会导致构建时报错）\n解决方法：\n+ 正确使用生命周期，在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。\n这里获取不到window或document等API，可以放在mounted中执行。\n+ 使用第三方插件时：\n```\nplugins: [\n  {\n    src: '~plugins/log.js',\n    mode: 'client'\n  }\n]\n```\n添加mode: 'client'使第三方插件仅在客户端渲染时使用。\n二、NuxtLink无法打开新页面\nNuxtjs中在进行路由导航时提供了<nuxt-link to=\"/\"></nuxt-link>，但是此标签有一个问题：无法在新窗口打开链接，建议改为a标签，既能满足需求，也利于搜索引擎爬取相关链接。\n三、注册全局方法\n有时想在整个项目中使用函数或值，在Vue项目中我们有可能把方法挂在在Vue实例上，但是官方文档中明确提出：\n请勿全局使用Vue.use()，Vue.component()，也不要在此功能内专门用于Nuxt注入的Vue中插入任何内容。这将导致服务器端内存泄漏。\n另外也为我们提供了一种方法（inject(key, value)）来注册全局方法（变量）：\n```\n// plugins/hello.js\nexport default ({ app }, inject) => {\n  // Inject $hello(msg) in Vue, context and store.\n  inject('hello', msg => console.log(`Hello ${msg}!`))\n}\n```\n```\n// nuxt.config.js\nexport default {\n  plugins: ['~/plugins/hello.js']\n}\n```\n然后就可以在页面、组件、插件中使用了。\n```\n// a.vue\nexport default {\n  mounted() {\n    this.$hello('mounted')\n    // will console.log 'Hello mounted!'\n  },\n  asyncData({ app, $hello }) {\n    $hello('asyncData')\n    // If using Nuxt <= 2.12, use 👇\n    app.$hello('asyncData')\n  }\n}\n```\n四、Nuxt支持在页面中加入head信息。\n```\nexport default {\n  data () {\n    return {}\n  },\n  created () {},\n  ...,\n  head () {\n    return {\n      title: '',\n      meta: [\n        { hid: '', name: '', content: ''}\n      ]\n    }\n  }\n}\n```\n五、路由相关\nNuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。\n基础路由\npages/\n--| user/\n-----| index.vue\n-----| one.vue\n--| index.vue\n那么，Nuxt.js 自动生成的路由配置如下：\n```\nrouter: {\n  routes: [\n    {\n      name: 'index',\n      path: '/',\n      component: 'pages/index.vue'\n    },\n    {\n      name: 'user',\n      path: '/user',\n      component: 'pages/user/index.vue'\n    },\n    {\n      name: 'user-one',\n      path: '/user/one',\n      component: 'pages/user/one.vue'\n    }\n  ]\n}\n```\n嵌套路由\n你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。\n创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。\n文件路径：\npages/\n--| users/\n-----| _id.vue // 以下划线作为前缀的Vue文件：动态路由，做SSR的时候可能会用到\n-----| index.vue\n--| users.vue\nNuxt.js 自动生成的路由配置如下：\n```\nrouter: {\n  routes: [\n    {\n      path: '/users',\n      component: 'pages/users.vue',\n      children: [\n        {\n          path: '',\n          component: 'pages/users/index.vue',\n          name: 'users'\n        },\n        {\n          path: ':id',\n          component: 'pages/users/_id.vue',\n          name: 'users-id'\n        }\n      ]\n    }\n  ]\n}\n```\n六、常用命令：\nnuxt\n启用一个热加载的Web服务器（开发模式）localhost:3000\nnuxt build\n利用webpack编译应用，压缩JS和CSS资源（发布用）。\nnuxt start\n以生产模式启动一个Web服务器 (基于dist目录，需要先执行nuxt build)。\nnuxt generate\n编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)。","slug":"Vue项目SEO优化-Nuxt","published":1,"updated":"2023-04-11T04:46:30.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml60016tit816ja41on","content":"<h1 id=\"为什么SPA需要SEO\"><a href=\"#为什么SPA需要SEO\" class=\"headerlink\" title=\"为什么SPA需要SEO\"></a>为什么SPA需要SEO</h1><p>通常我们用前端框架（这里以Vue为例）产出的代码一般是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;index.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>页面实际展示的内容（用户实际看到的内容）都是通过js渲染出来的，所以搜索引擎爬虫在对我们的页面进行爬取的时候，拿到的也是上面的html代码。虽然我们可以通过在<head></head>中添加<meta/>标签来添加一些描述信息，但是远远不够，我们实际展示的内容搜索引擎爬虫还是拿不到，所以就需要对项目进行SEO优化。</p>\n<h1 id=\"关于Nuxt-js\"><a href=\"#关于Nuxt-js\" class=\"headerlink\" title=\"关于Nuxt.js\"></a>关于Nuxt.js</h1><h2 id=\"官方介绍\"><a href=\"#官方介绍\" class=\"headerlink\" title=\"官方介绍\"></a>官方介绍</h2><p>从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目Nuxt.js这让一切变得非常简单。Nuxt是一个基于Vue生态的更高层的框架，为开发服务端渲染的Vue应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。</p>\n<h2 id=\"简单的理解：\"><a href=\"#简单的理解：\" class=\"headerlink\" title=\"简单的理解：\"></a>简单的理解：</h2><p>代替浏览器的工作,笼统理解就是在created时的请求数据和页面渲染，第二点是当作静态文件服务器，把渲染好的页面返回给用户。</p>\n<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>纯静态文件，访问速度快</li>\n<li>对比SSR,不涉及服务器负载方面问题</li>\n<li>静态网页不宜遭到黑客工具，安全性高<h2 id=\"服务端渲染和客户端渲染\"><a href=\"#服务端渲染和客户端渲染\" class=\"headerlink\" title=\"服务端渲染和客户端渲染\"></a>服务端渲染和客户端渲染</h2></li>\n</ul>\n<ol>\n<li>浏览器（客户端）通过AJAX向服务端（java servlet）发送http请求数据接口</li>\n<li>服务端将获取的接口数据封装成JSON，响应给浏览器</li>\n<li>浏览器拿到JSON就进行渲染html页面，生成DOM元素，然后将页面展示给用户<br><img src=\"/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><h2 id=\"Nuxt-js工作原理\"><a href=\"#Nuxt-js工作原理\" class=\"headerlink\" title=\"Nuxt.js工作原理\"></a>Nuxt.js工作原理</h2></li>\n<li>浏览器(客户端)发送http请求到Node.js服务端。</li>\n<li>部署在Node.js的应用Nuxt.js接收到浏览器请求，它会去请求后台服务端。</li>\n<li>后台接口服务端会响应JSON数据，Nuxt.js获取数据后进行服务端渲染成html。</li>\n<li>然后Nuxt.js将html页面响应给浏览器</li>\n<li>浏览器直接将接收到html页面进行展示<br><img src=\"/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/nuxt%E6%B8%B2%E6%9F%93.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。\"><a href=\"#首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。\" class=\"headerlink\" title=\"首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。\"></a>首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。</h3><h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.nuxt</span><br><span class=\"line\">1. assets //资源目录 组织为编译的静态资源 大家都懂</span><br><span class=\"line\">      image.png</span><br><span class=\"line\">2.components // 组织 Vue.js 组件，NUXT不会扩展增强该目录下的组件，这意味着组件不能使用 </span><br><span class=\"line\">3.asyncData 方法</span><br><span class=\"line\">4.layout // 布局目录 如果没有额外配置，目录不能重命名--不建议改名</span><br><span class=\"line\">5.middleware // 用于存放应用的中间件</span><br><span class=\"line\">6.node_modules </span><br><span class=\"line\">7.pages // 页面目录用于组织应用路由及视图，NUXT会读取该目录下所有.vue文件并自动生成路由（路由文件在 .nuxt/router.js）</span><br><span class=\"line\">      index.vue</span><br><span class=\"line\">8.plugins // 插件目录 用于组织那些需要在跟vue.js应用，实例化之前需要运行的Javascript插件</span><br><span class=\"line\">9.static // 用于存放应用的静态文件，此类文件不会被NUXT.js调用Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径  `/`  下。例如 /static/root.txt 映射至 /root.txt</span><br><span class=\"line\">10.store // Nuxt.js 框架集成了 [Vuex 状态树] 的相关功能配置，在  `store`  目录下创建一个  `index.js`  文件可激活这些配置。 新建一个index.js 这事就算妥了</span><br><span class=\"line\">11.nuxt.config.js // 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置 不要gai&#x27;ming&#x27;zi</span><br><span class=\"line\">12.package.json // 用于描述应用的依赖关系和对外暴露的脚本接口</span><br></pre></td></tr></table></figure>\n<h3 id=\"NUXT开发中需要注意哪些。\"><a href=\"#NUXT开发中需要注意哪些。\" class=\"headerlink\" title=\"NUXT开发中需要注意哪些。\"></a>NUXT开发中需要注意哪些。</h3><h4 id=\"静态资源的引入和路由\"><a href=\"#静态资源的引入和路由\" class=\"headerlink\" title=\"静态资源的引入和路由\"></a>静态资源的引入和路由</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//引入静态资源 和 跳转路由</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!--我们不需要去配置 @去指向根目录  NUXT中可以直接使用 --&gt;</span><br><span class=\"line\">  &lt;img src=&quot;~/assets/image.png&quot; /&gt;</span><br><span class=\"line\">  &lt;!--NUXT中我们不需要去写路由表  👇 &#x27;/&#x27;指的是 page/index.vue 其它语法和日常无恙  --&gt;</span><br><span class=\"line\">  &lt;nuxt-link :to=&quot;&#123;name:&#x27;userPage&#x27;,query:&#123;id:&#x27;111&#x27;&#125;&#125;&quot;&gt;个人中心&lt;/nuxt-link&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"asyncData\"><a href=\"#asyncData\" class=\"headerlink\" title=\"asyncData\"></a>asyncData</h4>Nuxt.js扩展了Vue.js 增加了asyncData的方法，这样我们可以在渲染组件之前异步获取数据，asyncData方法会在组件（只限于页面组件）每次加载之前被调用，它可以在服务端或路由更新之前被调用，在这个方法被调用的时候，第一个参数context被设定为当前页的上下文对象。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">async asyncData(&#123; params &#125;)&#123;  // params 就是传进来的值</span><br><span class=\"line\">//asyncData 函数去执行我们的异步操作 当我们获取到接口返回的内容是 此时我们Vue还没有实例化 所以this获取不到  我们通过返回 方法 去获取  因此标签内如果需要展示内容  &#123;&#123;info.XXX&#125;&#125;</span><br><span class=\"line\">\tconst data = await $axios.$get(&#x27;/api/user&#x27;)</span><br><span class=\"line\">\treturn &#123;data&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"nuxtjs-axios\"><a href=\"#nuxtjs-axios\" class=\"headerlink\" title=\"@nuxtjs/axios\"></a>@nuxtjs/axios</h4>我们在asyncData中调用接口，在Nuxt.js官方提供了@nuxtjs/axios模块，此模块还包含了axios、@nuxtjs/proxy（解决异步,进行代理转发）模块。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 1.安装@nuxtjs/axios：</span><br><span class=\"line\">npm install @nuxtjs/axios</span><br><span class=\"line\">// 2.在nuxt.config.js中配置axios</span><br><span class=\"line\">module.exports=&#123;</span><br><span class=\"line\">\tmodules:[&#x27;@nuxtjs/axios&#x27;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h4>中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。可用于权限判断，有权限才可访问对应页面<br>中间件应放置在middleware/ 目录。文件名的名称将成为中间件名称（middleware/auth.js将成为auth中间件）<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建权限中间件</span><br><span class=\"line\">//在 middleware/ 下创建 auth.js 文件，其中auth就是中间件的名称。</span><br><span class=\"line\">//一个中间件接收content作为第一个参数</span><br><span class=\"line\">export default(&#123; store, redirect &#125;) =&gt; &#123;</span><br><span class=\"line\">\tif(/* 没有token */)&#123;</span><br><span class=\"line\">\t\treturn redirect(&#x27;/&#x27;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Nuxt对Vue项目首页进行SEO优化\"><a href=\"#Nuxt对Vue项目首页进行SEO优化\" class=\"headerlink\" title=\"Nuxt对Vue项目首页进行SEO优化\"></a>Nuxt对Vue项目首页进行SEO优化</h1>Nuxt.js 集成了以下组件/框架，用于开发完整而强大的Web 应用：</li>\n</ol>\n<ul>\n<li>Vue 2</li>\n<li>Vue-Router</li>\n<li>Vuex(当配置了Vuex状态树配置项时才会引入)</li>\n<li>Vue服务器端渲染 (排除使用mode:’spa’)</li>\n<li>Vue-Meta<br>另外，Nuxt.js使用Webpack和vue-loader 、babel-loader来处理代码的自动化构建工作（如打包、代码分层、压缩等等）。<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h3>因为是对项目的一部分进行改造，所以新建了一个项目。<br>新创建的项目目录大致如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ assets:静态资源</span><br><span class=\"line\">+ components:组件，该文件夹下的组件使用时无需引入，类似于已经全局注册了，这些组件无法使用asyncData。</span><br><span class=\"line\">+ layouts:用于组织应用的布局组件，我理解类似于Vue项目中的App.vue</span><br><span class=\"line\">+ middlwware:应用的中间件，这个没有用到</span><br><span class=\"line\">+ node_modules:依赖包</span><br><span class=\"line\">+ pages:页面，Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。在这个目录里使用其他类型的文件在npm run generate时可能会报错</span><br><span class=\"line\">+ plugins:插件目录。用于组织需要再根Vue.js应用实例化之前需要运行的JavaScript插件。在任何 Vue 组件的生命周期内，只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。</span><br><span class=\"line\">+ static:静态文件目录。</span><br><span class=\"line\">静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。</span><br><span class=\"line\">store</span><br><span class=\"line\">+ Vuex状态树。</span><br><span class=\"line\">Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。</span><br><span class=\"line\">+ nuxt.config.js</span><br><span class=\"line\">nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。</span><br><span class=\"line\">+ 其他</span><br><span class=\"line\">.babelrc、.editorconfig、package.json、package-lock.json等，和其他项目中同名文件功能相同。</span><br><span class=\"line\">+ 别名</span><br><span class=\"line\">~或@ =&gt; srcDir</span><br><span class=\"line\">~~或@@ =&gt; rootDir</span><br></pre></td></tr></table></figure>\n在vue模板中, 如果需要引入assets或者static目录, 使用<del>/assets/your_image.png和</del>/static/your_image.png方式。<h3 id=\"迁移文件\"><a href=\"#迁移文件\" class=\"headerlink\" title=\"迁移文件\"></a>迁移文件</h3>把老项目首页及宣传页的代码以及依赖的静态文件，还有一些eslint的配置，webpack配置等，能用的都拿过来，然后修改引用路径，删除不需要的代码。<br>下面是目录的对应关系：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ assets:css、icon、font等静态资源</span><br><span class=\"line\">+ components:首页及宣传页用到的组件</span><br><span class=\"line\">+ layouts:App.vue</span><br><span class=\"line\">+ middlwware</span><br><span class=\"line\">+ node_modules:依赖包</span><br><span class=\"line\">+ pages:首页及宣传页涉及到的页面。</span><br><span class=\"line\">+ plugins:用到的各种插件。</span><br><span class=\"line\">      + axios封装（没有用Nuxt.js默认的@nuxtjs/axios）</span><br><span class=\"line\">      + elementUI</span><br><span class=\"line\">      + 其他一些用到的插件（video、zepto等）</span><br><span class=\"line\">      + 工具函数（这里有疑问，是不是应该放在assets下面）</span><br><span class=\"line\">+ static:.ico文件</span><br><span class=\"line\">+ store:vuex相关文件</span><br><span class=\"line\">+ nuxt.config.js:nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。</span><br><span class=\"line\">+ 其他:.babelrc、.editorconfig、package.json、package-lock.json等，和其他功能相同。</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3>这部分是重点，因为Nuxt很多东西其实在一开始就都配置好了，比如像它的目录结构，官方都建议一般不要修改。如果想修改配置的话，必须在nuxt.config.js中进行修改。Nuxt关于配置的文档很多，这里直说我用到的部分。<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> webpack <span class=\"keyword\">from</span> <span class=\"string\">&#x27;webpack&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">ssr</span>: <span class=\"literal\">false</span>, <span class=\"comment\">// 是否启用服务端渲染。默认为false，创建时可选择</span></span><br><span class=\"line\">  <span class=\"attr\">target</span>: <span class=\"string\">&#x27;static&#x27;</span>, <span class=\"comment\">// server：用于服务器端渲染，static：用于静态网站</span></span><br><span class=\"line\">  <span class=\"attr\">root</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">base</span>: <span class=\"string\">&#x27;/page/&#x27;</span> <span class=\"comment\">// 应用程序的基本URL，如果在此路径下提供了整个应用程序，则应该使用root.base。使用之后，访问***.com/home路由应该使用***.com/page/home</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">head</span>: &#123; <span class=\"comment\">// 一些静态资源的引入，填写头信息</span></span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;nuxt-demo&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">meta</span>: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">charset</span>: <span class=\"string\">&#x27;utf-8&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;viewport&#x27;</span>, <span class=\"attr\">content</span>: <span class=\"string\">&#x27;width=device-width, initial-scale=1&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">hid</span>: <span class=\"string\">&#x27;&#x27;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;description&#x27;</span>, <span class=\"attr\">content</span>: <span class=\"string\">&#x27;&#x27;</span> &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">script</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">src</span>: <span class=\"string\">&#x27;https://cdn.bootcdn.net/ajax/libs/zepto/1.2.0/zepto.js&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">css</span>: [ <span class=\"comment\">// 全局使用的css</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;~/assets/css/common.css&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;~/assets/css/element-variables.scss&#x27;</span>,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [ <span class=\"comment\">//  使用插件</span></span><br><span class=\"line\">    &#123;<span class=\"attr\">src</span>: <span class=\"string\">&#x27;~plugins/element-ui&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">src</span>: <span class=\"string\">&#x27;~plugins/log.js&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;client&#x27;</span> <span class=\"comment\">// client或server：文件仅包含在客户端或服务器端，如果代码中使用了window或document等浏览器端才有的API，只能使用client</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">src</span>: <span class=\"string\">&#x27;~plugins/route.js&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;client&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">components</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 自动引入组件</span></span><br><span class=\"line\">  <span class=\"attr\">buildModules</span>: [ <span class=\"comment\">// 某些模块仅在开发和构建期间需要。使用buildModules有助于加快生产启动速度，并大大减少node_modules生产部署的规模。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;@nuxtjs/eslint-module&#x27;</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">build</span>: &#123; <span class=\"comment\">// Nuxt.js 允许你根据服务端需求，自定义 webpack 的构建配置。</span></span><br><span class=\"line\">    <span class=\"attr\">transpile</span>: [<span class=\"regexp\">/^element-ui/</span>], <span class=\"comment\">// 使用Babel与特定的依赖关系进行转换。应该是element-ui使用了ES6语法，所以需要进行转化</span></span><br><span class=\"line\">    <span class=\"attr\">publicPath</span>: <span class=\"string\">&#x27;&#x27;</span>, <span class=\"comment\">// 静态资源引用路径（通常使用CND地址）</span></span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [ <span class=\"comment\">// 配置webpack插件  nuxt使用的webpack版本比较旧，有一些新功能无法使用</span></span><br><span class=\"line\">      <span class=\"keyword\">new</span> webpack.<span class=\"title class_\">DefinePlugin</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">__ENV__</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(process.<span class=\"property\">env</span>.<span class=\"property\">ENV</span> || <span class=\"string\">&#x27;dev&#x27;</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目部署\"><a href=\"#项目部署\" class=\"headerlink\" title=\"项目部署\"></a>项目部署</h3>由于该项目与其他项目共用一个域名：www.###.com，需要保证另一个项目也可用。所有在部署的时候把Nuxt的项目放在了www.###.com/page目录下<br>在server中添加location /page的配置项<br>让根路径重定向到www.###.com/page/home<br>对旧项目已有的一些访问路径进行兼容<br>首页项目和旧项目（主站）的相互跳转（登录登出跳转等）<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3>一、document is not defined or window is not defined<br>解决方法：<br>此问题产生是由于在服务端渲染时使用了window或document等DOM相关的API，常见的原因有两个：</li>\n<li>页面中生命周期使用错误，比如在created中使用了window<br>nuxt在服务端执行时会执行Vue生命周期中的beforeCreate和created，如果在这两个生命周期里使用了DOM相关的API是获取不到的，构建时会报错。</li>\n<li>第三方插件使用了window或document等DOM相关的API<br>Nuxt.js 允许在运行Vue.js应用程序之前执行js插件。这在您需要使用自己的库或第三方模块时特别有用。但是要注意插件是否在客户端和服务端都需要，还有就是插件中是否用到了DOM相关的API（会导致构建时报错）<br>解决方法：</li>\n<li>正确使用生命周期，在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。<br>这里获取不到window或document等API，可以放在mounted中执行。</li>\n<li>使用第三方插件时：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    src: &#x27;~plugins/log.js&#x27;,</span><br><span class=\"line\">    mode: &#x27;client&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n添加mode: ‘client’使第三方插件仅在客户端渲染时使用。<br>二、NuxtLink无法打开新页面<br>Nuxtjs中在进行路由导航时提供了<nuxt-link to=\"/\"></nuxt-link>，但是此标签有一个问题：无法在新窗口打开链接，建议改为a标签，既能满足需求，也利于搜索引擎爬取相关链接。<br>三、注册全局方法<br>有时想在整个项目中使用函数或值，在Vue项目中我们有可能把方法挂在在Vue实例上，但是官方文档中明确提出：<br>请勿全局使用Vue.use()，Vue.component()，也不要在此功能内专门用于Nuxt注入的Vue中插入任何内容。这将导致服务器端内存泄漏。<br>另外也为我们提供了一种方法（inject(key, value)）来注册全局方法（变量）：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// plugins/hello.js</span><br><span class=\"line\">export default (&#123; app &#125;, inject) =&gt; &#123;</span><br><span class=\"line\">  // Inject $hello(msg) in Vue, context and store.</span><br><span class=\"line\">  inject(&#x27;hello&#x27;, msg =&gt; console.log(`Hello $&#123;msg&#125;!`))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// nuxt.config.js</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  plugins: [&#x27;~/plugins/hello.js&#x27;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n然后就可以在页面、组件、插件中使用了。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// a.vue</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    this.$hello(&#x27;mounted&#x27;)</span><br><span class=\"line\">    // will console.log &#x27;Hello mounted!&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  asyncData(&#123; app, $hello &#125;) &#123;</span><br><span class=\"line\">    $hello(&#x27;asyncData&#x27;)</span><br><span class=\"line\">    // If using Nuxt &lt;= 2.12, use 👇</span><br><span class=\"line\">    app.$hello(&#x27;asyncData&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n四、Nuxt支持在页面中加入head信息。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created () &#123;&#125;,</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  head () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      title: &#x27;&#x27;,</span><br><span class=\"line\">      meta: [</span><br><span class=\"line\">        &#123; hid: &#x27;&#x27;, name: &#x27;&#x27;, content: &#x27;&#x27;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n五、路由相关<br>Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。<br>基础路由<br>pages/</li>\n</ul>\n<p>–| user/<br>—–| index.vue<br>—–| one.vue<br>–| index.vue<br>那么，Nuxt.js 自动生成的路由配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">router: &#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      name: &#x27;index&#x27;,</span><br><span class=\"line\">      path: &#x27;/&#x27;,</span><br><span class=\"line\">      component: &#x27;pages/index.vue&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      name: &#x27;user&#x27;,</span><br><span class=\"line\">      path: &#x27;/user&#x27;,</span><br><span class=\"line\">      component: &#x27;pages/user/index.vue&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      name: &#x27;user-one&#x27;,</span><br><span class=\"line\">      path: &#x27;/user/one&#x27;,</span><br><span class=\"line\">      component: &#x27;pages/user/one.vue&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嵌套路由<br>你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。<br>创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。<br>文件路径：<br>pages/<br>–| users/<br>—–| _id.vue // 以下划线作为前缀的Vue文件：动态路由，做SSR的时候可能会用到<br>—–| index.vue<br>–| users.vue<br>Nuxt.js 自动生成的路由配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">router: &#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/users&#x27;,</span><br><span class=\"line\">      component: &#x27;pages/users.vue&#x27;,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path: &#x27;&#x27;,</span><br><span class=\"line\">          component: &#x27;pages/users/index.vue&#x27;,</span><br><span class=\"line\">          name: &#x27;users&#x27;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path: &#x27;:id&#x27;,</span><br><span class=\"line\">          component: &#x27;pages/users/_id.vue&#x27;,</span><br><span class=\"line\">          name: &#x27;users-id&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>六、常用命令：<br>nuxt<br>启用一个热加载的Web服务器（开发模式）localhost:3000<br>nuxt build<br>利用webpack编译应用，压缩JS和CSS资源（发布用）。<br>nuxt start<br>以生产模式启动一个Web服务器 (基于dist目录，需要先执行nuxt build)。<br>nuxt generate<br>编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"为什么SPA需要SEO\"><a href=\"#为什么SPA需要SEO\" class=\"headerlink\" title=\"为什么SPA需要SEO\"></a>为什么SPA需要SEO</h1><p>通常我们用前端框架（这里以Vue为例）产出的代码一般是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;index.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>页面实际展示的内容（用户实际看到的内容）都是通过js渲染出来的，所以搜索引擎爬虫在对我们的页面进行爬取的时候，拿到的也是上面的html代码。虽然我们可以通过在<head></head>中添加<meta/>标签来添加一些描述信息，但是远远不够，我们实际展示的内容搜索引擎爬虫还是拿不到，所以就需要对项目进行SEO优化。</p>\n<h1 id=\"关于Nuxt-js\"><a href=\"#关于Nuxt-js\" class=\"headerlink\" title=\"关于Nuxt.js\"></a>关于Nuxt.js</h1><h2 id=\"官方介绍\"><a href=\"#官方介绍\" class=\"headerlink\" title=\"官方介绍\"></a>官方介绍</h2><p>从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目Nuxt.js这让一切变得非常简单。Nuxt是一个基于Vue生态的更高层的框架，为开发服务端渲染的Vue应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。</p>\n<h2 id=\"简单的理解：\"><a href=\"#简单的理解：\" class=\"headerlink\" title=\"简单的理解：\"></a>简单的理解：</h2><p>代替浏览器的工作,笼统理解就是在created时的请求数据和页面渲染，第二点是当作静态文件服务器，把渲染好的页面返回给用户。</p>\n<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>纯静态文件，访问速度快</li>\n<li>对比SSR,不涉及服务器负载方面问题</li>\n<li>静态网页不宜遭到黑客工具，安全性高<h2 id=\"服务端渲染和客户端渲染\"><a href=\"#服务端渲染和客户端渲染\" class=\"headerlink\" title=\"服务端渲染和客户端渲染\"></a>服务端渲染和客户端渲染</h2></li>\n</ul>\n<ol>\n<li>浏览器（客户端）通过AJAX向服务端（java servlet）发送http请求数据接口</li>\n<li>服务端将获取的接口数据封装成JSON，响应给浏览器</li>\n<li>浏览器拿到JSON就进行渲染html页面，生成DOM元素，然后将页面展示给用户<br><img src=\"/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93.png\"><br><img src=\"/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93.png\"><h2 id=\"Nuxt-js工作原理\"><a href=\"#Nuxt-js工作原理\" class=\"headerlink\" title=\"Nuxt.js工作原理\"></a>Nuxt.js工作原理</h2></li>\n<li>浏览器(客户端)发送http请求到Node.js服务端。</li>\n<li>部署在Node.js的应用Nuxt.js接收到浏览器请求，它会去请求后台服务端。</li>\n<li>后台接口服务端会响应JSON数据，Nuxt.js获取数据后进行服务端渲染成html。</li>\n<li>然后Nuxt.js将html页面响应给浏览器</li>\n<li>浏览器直接将接收到html页面进行展示<br><img src=\"/2023/04/10/Vue%E9%A1%B9%E7%9B%AESEO%E4%BC%98%E5%8C%96-Nuxt/nuxt%E6%B8%B2%E6%9F%93.png\"><h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。\"><a href=\"#首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。\" class=\"headerlink\" title=\"首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。\"></a>首先就是安装NUXT这个简单，大家按照官网的操作步骤就可以了。</h3><h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.nuxt</span><br><span class=\"line\">1. assets //资源目录 组织为编译的静态资源 大家都懂</span><br><span class=\"line\">      image.png</span><br><span class=\"line\">2.components // 组织 Vue.js 组件，NUXT不会扩展增强该目录下的组件，这意味着组件不能使用 </span><br><span class=\"line\">3.asyncData 方法</span><br><span class=\"line\">4.layout // 布局目录 如果没有额外配置，目录不能重命名--不建议改名</span><br><span class=\"line\">5.middleware // 用于存放应用的中间件</span><br><span class=\"line\">6.node_modules </span><br><span class=\"line\">7.pages // 页面目录用于组织应用路由及视图，NUXT会读取该目录下所有.vue文件并自动生成路由（路由文件在 .nuxt/router.js）</span><br><span class=\"line\">      index.vue</span><br><span class=\"line\">8.plugins // 插件目录 用于组织那些需要在跟vue.js应用，实例化之前需要运行的Javascript插件</span><br><span class=\"line\">9.static // 用于存放应用的静态文件，此类文件不会被NUXT.js调用Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径  `/`  下。例如 /static/root.txt 映射至 /root.txt</span><br><span class=\"line\">10.store // Nuxt.js 框架集成了 [Vuex 状态树] 的相关功能配置，在  `store`  目录下创建一个  `index.js`  文件可激活这些配置。 新建一个index.js 这事就算妥了</span><br><span class=\"line\">11.nuxt.config.js // 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置 不要gai&#x27;ming&#x27;zi</span><br><span class=\"line\">12.package.json // 用于描述应用的依赖关系和对外暴露的脚本接口</span><br></pre></td></tr></table></figure>\n<h3 id=\"NUXT开发中需要注意哪些。\"><a href=\"#NUXT开发中需要注意哪些。\" class=\"headerlink\" title=\"NUXT开发中需要注意哪些。\"></a>NUXT开发中需要注意哪些。</h3><h4 id=\"静态资源的引入和路由\"><a href=\"#静态资源的引入和路由\" class=\"headerlink\" title=\"静态资源的引入和路由\"></a>静态资源的引入和路由</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//引入静态资源 和 跳转路由</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!--我们不需要去配置 @去指向根目录  NUXT中可以直接使用 --&gt;</span><br><span class=\"line\">  &lt;img src=&quot;~/assets/image.png&quot; /&gt;</span><br><span class=\"line\">  &lt;!--NUXT中我们不需要去写路由表  👇 &#x27;/&#x27;指的是 page/index.vue 其它语法和日常无恙  --&gt;</span><br><span class=\"line\">  &lt;nuxt-link :to=&quot;&#123;name:&#x27;userPage&#x27;,query:&#123;id:&#x27;111&#x27;&#125;&#125;&quot;&gt;个人中心&lt;/nuxt-link&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"asyncData\"><a href=\"#asyncData\" class=\"headerlink\" title=\"asyncData\"></a>asyncData</h4>Nuxt.js扩展了Vue.js 增加了asyncData的方法，这样我们可以在渲染组件之前异步获取数据，asyncData方法会在组件（只限于页面组件）每次加载之前被调用，它可以在服务端或路由更新之前被调用，在这个方法被调用的时候，第一个参数context被设定为当前页的上下文对象。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">async asyncData(&#123; params &#125;)&#123;  // params 就是传进来的值</span><br><span class=\"line\">//asyncData 函数去执行我们的异步操作 当我们获取到接口返回的内容是 此时我们Vue还没有实例化 所以this获取不到  我们通过返回 方法 去获取  因此标签内如果需要展示内容  &#123;&#123;info.XXX&#125;&#125;</span><br><span class=\"line\">\tconst data = await $axios.$get(&#x27;/api/user&#x27;)</span><br><span class=\"line\">\treturn &#123;data&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"nuxtjs-axios\"><a href=\"#nuxtjs-axios\" class=\"headerlink\" title=\"@nuxtjs/axios\"></a>@nuxtjs/axios</h4>我们在asyncData中调用接口，在Nuxt.js官方提供了@nuxtjs/axios模块，此模块还包含了axios、@nuxtjs/proxy（解决异步,进行代理转发）模块。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 1.安装@nuxtjs/axios：</span><br><span class=\"line\">npm install @nuxtjs/axios</span><br><span class=\"line\">// 2.在nuxt.config.js中配置axios</span><br><span class=\"line\">module.exports=&#123;</span><br><span class=\"line\">\tmodules:[&#x27;@nuxtjs/axios&#x27;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h4>中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。可用于权限判断，有权限才可访问对应页面<br>中间件应放置在middleware/ 目录。文件名的名称将成为中间件名称（middleware/auth.js将成为auth中间件）<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建权限中间件</span><br><span class=\"line\">//在 middleware/ 下创建 auth.js 文件，其中auth就是中间件的名称。</span><br><span class=\"line\">//一个中间件接收content作为第一个参数</span><br><span class=\"line\">export default(&#123; store, redirect &#125;) =&gt; &#123;</span><br><span class=\"line\">\tif(/* 没有token */)&#123;</span><br><span class=\"line\">\t\treturn redirect(&#x27;/&#x27;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Nuxt对Vue项目首页进行SEO优化\"><a href=\"#Nuxt对Vue项目首页进行SEO优化\" class=\"headerlink\" title=\"Nuxt对Vue项目首页进行SEO优化\"></a>Nuxt对Vue项目首页进行SEO优化</h1>Nuxt.js 集成了以下组件/框架，用于开发完整而强大的Web 应用：</li>\n</ol>\n<ul>\n<li>Vue 2</li>\n<li>Vue-Router</li>\n<li>Vuex(当配置了Vuex状态树配置项时才会引入)</li>\n<li>Vue服务器端渲染 (排除使用mode:’spa’)</li>\n<li>Vue-Meta<br>另外，Nuxt.js使用Webpack和vue-loader 、babel-loader来处理代码的自动化构建工作（如打包、代码分层、压缩等等）。<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h3>因为是对项目的一部分进行改造，所以新建了一个项目。<br>新创建的项目目录大致如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ assets:静态资源</span><br><span class=\"line\">+ components:组件，该文件夹下的组件使用时无需引入，类似于已经全局注册了，这些组件无法使用asyncData。</span><br><span class=\"line\">+ layouts:用于组织应用的布局组件，我理解类似于Vue项目中的App.vue</span><br><span class=\"line\">+ middlwware:应用的中间件，这个没有用到</span><br><span class=\"line\">+ node_modules:依赖包</span><br><span class=\"line\">+ pages:页面，Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。在这个目录里使用其他类型的文件在npm run generate时可能会报错</span><br><span class=\"line\">+ plugins:插件目录。用于组织需要再根Vue.js应用实例化之前需要运行的JavaScript插件。在任何 Vue 组件的生命周期内，只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。</span><br><span class=\"line\">+ static:静态文件目录。</span><br><span class=\"line\">静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。</span><br><span class=\"line\">store</span><br><span class=\"line\">+ Vuex状态树。</span><br><span class=\"line\">Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。</span><br><span class=\"line\">+ nuxt.config.js</span><br><span class=\"line\">nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。</span><br><span class=\"line\">+ 其他</span><br><span class=\"line\">.babelrc、.editorconfig、package.json、package-lock.json等，和其他项目中同名文件功能相同。</span><br><span class=\"line\">+ 别名</span><br><span class=\"line\">~或@ =&gt; srcDir</span><br><span class=\"line\">~~或@@ =&gt; rootDir</span><br></pre></td></tr></table></figure>\n在vue模板中, 如果需要引入assets或者static目录, 使用<del>/assets/your_image.png和</del>/static/your_image.png方式。<h3 id=\"迁移文件\"><a href=\"#迁移文件\" class=\"headerlink\" title=\"迁移文件\"></a>迁移文件</h3>把老项目首页及宣传页的代码以及依赖的静态文件，还有一些eslint的配置，webpack配置等，能用的都拿过来，然后修改引用路径，删除不需要的代码。<br>下面是目录的对应关系：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ assets:css、icon、font等静态资源</span><br><span class=\"line\">+ components:首页及宣传页用到的组件</span><br><span class=\"line\">+ layouts:App.vue</span><br><span class=\"line\">+ middlwware</span><br><span class=\"line\">+ node_modules:依赖包</span><br><span class=\"line\">+ pages:首页及宣传页涉及到的页面。</span><br><span class=\"line\">+ plugins:用到的各种插件。</span><br><span class=\"line\">      + axios封装（没有用Nuxt.js默认的@nuxtjs/axios）</span><br><span class=\"line\">      + elementUI</span><br><span class=\"line\">      + 其他一些用到的插件（video、zepto等）</span><br><span class=\"line\">      + 工具函数（这里有疑问，是不是应该放在assets下面）</span><br><span class=\"line\">+ static:.ico文件</span><br><span class=\"line\">+ store:vuex相关文件</span><br><span class=\"line\">+ nuxt.config.js:nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。</span><br><span class=\"line\">+ 其他:.babelrc、.editorconfig、package.json、package-lock.json等，和其他功能相同。</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3>这部分是重点，因为Nuxt很多东西其实在一开始就都配置好了，比如像它的目录结构，官方都建议一般不要修改。如果想修改配置的话，必须在nuxt.config.js中进行修改。Nuxt关于配置的文档很多，这里直说我用到的部分。<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> webpack <span class=\"keyword\">from</span> <span class=\"string\">&#x27;webpack&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">ssr</span>: <span class=\"literal\">false</span>, <span class=\"comment\">// 是否启用服务端渲染。默认为false，创建时可选择</span></span><br><span class=\"line\">  <span class=\"attr\">target</span>: <span class=\"string\">&#x27;static&#x27;</span>, <span class=\"comment\">// server：用于服务器端渲染，static：用于静态网站</span></span><br><span class=\"line\">  <span class=\"attr\">root</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">base</span>: <span class=\"string\">&#x27;/page/&#x27;</span> <span class=\"comment\">// 应用程序的基本URL，如果在此路径下提供了整个应用程序，则应该使用root.base。使用之后，访问***.com/home路由应该使用***.com/page/home</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">head</span>: &#123; <span class=\"comment\">// 一些静态资源的引入，填写头信息</span></span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;nuxt-demo&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">meta</span>: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">charset</span>: <span class=\"string\">&#x27;utf-8&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;viewport&#x27;</span>, <span class=\"attr\">content</span>: <span class=\"string\">&#x27;width=device-width, initial-scale=1&#x27;</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">hid</span>: <span class=\"string\">&#x27;&#x27;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;description&#x27;</span>, <span class=\"attr\">content</span>: <span class=\"string\">&#x27;&#x27;</span> &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">script</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">src</span>: <span class=\"string\">&#x27;https://cdn.bootcdn.net/ajax/libs/zepto/1.2.0/zepto.js&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">css</span>: [ <span class=\"comment\">// 全局使用的css</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;~/assets/css/common.css&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;~/assets/css/element-variables.scss&#x27;</span>,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [ <span class=\"comment\">//  使用插件</span></span><br><span class=\"line\">    &#123;<span class=\"attr\">src</span>: <span class=\"string\">&#x27;~plugins/element-ui&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">src</span>: <span class=\"string\">&#x27;~plugins/log.js&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;client&#x27;</span> <span class=\"comment\">// client或server：文件仅包含在客户端或服务器端，如果代码中使用了window或document等浏览器端才有的API，只能使用client</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">src</span>: <span class=\"string\">&#x27;~plugins/route.js&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;client&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">components</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 自动引入组件</span></span><br><span class=\"line\">  <span class=\"attr\">buildModules</span>: [ <span class=\"comment\">// 某些模块仅在开发和构建期间需要。使用buildModules有助于加快生产启动速度，并大大减少node_modules生产部署的规模。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;@nuxtjs/eslint-module&#x27;</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">build</span>: &#123; <span class=\"comment\">// Nuxt.js 允许你根据服务端需求，自定义 webpack 的构建配置。</span></span><br><span class=\"line\">    <span class=\"attr\">transpile</span>: [<span class=\"regexp\">/^element-ui/</span>], <span class=\"comment\">// 使用Babel与特定的依赖关系进行转换。应该是element-ui使用了ES6语法，所以需要进行转化</span></span><br><span class=\"line\">    <span class=\"attr\">publicPath</span>: <span class=\"string\">&#x27;&#x27;</span>, <span class=\"comment\">// 静态资源引用路径（通常使用CND地址）</span></span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [ <span class=\"comment\">// 配置webpack插件  nuxt使用的webpack版本比较旧，有一些新功能无法使用</span></span><br><span class=\"line\">      <span class=\"keyword\">new</span> webpack.<span class=\"title class_\">DefinePlugin</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">__ENV__</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(process.<span class=\"property\">env</span>.<span class=\"property\">ENV</span> || <span class=\"string\">&#x27;dev&#x27;</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目部署\"><a href=\"#项目部署\" class=\"headerlink\" title=\"项目部署\"></a>项目部署</h3>由于该项目与其他项目共用一个域名：www.###.com，需要保证另一个项目也可用。所有在部署的时候把Nuxt的项目放在了www.###.com/page目录下<br>在server中添加location /page的配置项<br>让根路径重定向到www.###.com/page/home<br>对旧项目已有的一些访问路径进行兼容<br>首页项目和旧项目（主站）的相互跳转（登录登出跳转等）<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3>一、document is not defined or window is not defined<br>解决方法：<br>此问题产生是由于在服务端渲染时使用了window或document等DOM相关的API，常见的原因有两个：</li>\n<li>页面中生命周期使用错误，比如在created中使用了window<br>nuxt在服务端执行时会执行Vue生命周期中的beforeCreate和created，如果在这两个生命周期里使用了DOM相关的API是获取不到的，构建时会报错。</li>\n<li>第三方插件使用了window或document等DOM相关的API<br>Nuxt.js 允许在运行Vue.js应用程序之前执行js插件。这在您需要使用自己的库或第三方模块时特别有用。但是要注意插件是否在客户端和服务端都需要，还有就是插件中是否用到了DOM相关的API（会导致构建时报错）<br>解决方法：</li>\n<li>正确使用生命周期，在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。<br>这里获取不到window或document等API，可以放在mounted中执行。</li>\n<li>使用第三方插件时：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    src: &#x27;~plugins/log.js&#x27;,</span><br><span class=\"line\">    mode: &#x27;client&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n添加mode: ‘client’使第三方插件仅在客户端渲染时使用。<br>二、NuxtLink无法打开新页面<br>Nuxtjs中在进行路由导航时提供了<nuxt-link to=\"/\"></nuxt-link>，但是此标签有一个问题：无法在新窗口打开链接，建议改为a标签，既能满足需求，也利于搜索引擎爬取相关链接。<br>三、注册全局方法<br>有时想在整个项目中使用函数或值，在Vue项目中我们有可能把方法挂在在Vue实例上，但是官方文档中明确提出：<br>请勿全局使用Vue.use()，Vue.component()，也不要在此功能内专门用于Nuxt注入的Vue中插入任何内容。这将导致服务器端内存泄漏。<br>另外也为我们提供了一种方法（inject(key, value)）来注册全局方法（变量）：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// plugins/hello.js</span><br><span class=\"line\">export default (&#123; app &#125;, inject) =&gt; &#123;</span><br><span class=\"line\">  // Inject $hello(msg) in Vue, context and store.</span><br><span class=\"line\">  inject(&#x27;hello&#x27;, msg =&gt; console.log(`Hello $&#123;msg&#125;!`))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// nuxt.config.js</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  plugins: [&#x27;~/plugins/hello.js&#x27;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n然后就可以在页面、组件、插件中使用了。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// a.vue</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    this.$hello(&#x27;mounted&#x27;)</span><br><span class=\"line\">    // will console.log &#x27;Hello mounted!&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  asyncData(&#123; app, $hello &#125;) &#123;</span><br><span class=\"line\">    $hello(&#x27;asyncData&#x27;)</span><br><span class=\"line\">    // If using Nuxt &lt;= 2.12, use 👇</span><br><span class=\"line\">    app.$hello(&#x27;asyncData&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n四、Nuxt支持在页面中加入head信息。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created () &#123;&#125;,</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  head () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      title: &#x27;&#x27;,</span><br><span class=\"line\">      meta: [</span><br><span class=\"line\">        &#123; hid: &#x27;&#x27;, name: &#x27;&#x27;, content: &#x27;&#x27;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n五、路由相关<br>Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。<br>基础路由<br>pages/</li>\n</ul>\n<p>–| user/<br>—–| index.vue<br>—–| one.vue<br>–| index.vue<br>那么，Nuxt.js 自动生成的路由配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">router: &#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      name: &#x27;index&#x27;,</span><br><span class=\"line\">      path: &#x27;/&#x27;,</span><br><span class=\"line\">      component: &#x27;pages/index.vue&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      name: &#x27;user&#x27;,</span><br><span class=\"line\">      path: &#x27;/user&#x27;,</span><br><span class=\"line\">      component: &#x27;pages/user/index.vue&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      name: &#x27;user-one&#x27;,</span><br><span class=\"line\">      path: &#x27;/user/one&#x27;,</span><br><span class=\"line\">      component: &#x27;pages/user/one.vue&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嵌套路由<br>你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。<br>创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。<br>文件路径：<br>pages/<br>–| users/<br>—–| _id.vue // 以下划线作为前缀的Vue文件：动态路由，做SSR的时候可能会用到<br>—–| index.vue<br>–| users.vue<br>Nuxt.js 自动生成的路由配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">router: &#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/users&#x27;,</span><br><span class=\"line\">      component: &#x27;pages/users.vue&#x27;,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path: &#x27;&#x27;,</span><br><span class=\"line\">          component: &#x27;pages/users/index.vue&#x27;,</span><br><span class=\"line\">          name: &#x27;users&#x27;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path: &#x27;:id&#x27;,</span><br><span class=\"line\">          component: &#x27;pages/users/_id.vue&#x27;,</span><br><span class=\"line\">          name: &#x27;users-id&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>六、常用命令：<br>nuxt<br>启用一个热加载的Web服务器（开发模式）localhost:3000<br>nuxt build<br>利用webpack编译应用，压缩JS和CSS资源（发布用）。<br>nuxt start<br>以生产模式启动一个Web服务器 (基于dist目录，需要先执行nuxt build)。<br>nuxt generate<br>编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)。</p>\n"},{"title":"Vue项目遇到问题","date":"2023-04-12T04:46:31.000Z","_content":"列表进入详情页的传参问题。\n例如商品列表页面前往商品详情页面，需要传一个商品id;\n```\n<router-link :to=\"{path: 'detail', query: {id: 1}}\">\n```\n前往detail页面</router-link>c页面的路径为http://localhost:8080/#/detail?id=1，可以看到传了一个参数id=1，并且就算刷新页面id也还会存在。此时在c页面可以通过id来获取对应的详情数据，获取id的方式是this.$route.query.idvue传参方式有：query、params+动态路由传参。\n说下两者的区别：    \n1.query通过path切换路由，params通过name切换路由\n```\n// query通过path切换路由\n<router-link :to=\"{path: 'Detail', query: { id: 1 }}\">前往Detail页面</router-link>\n// params通过name切换路由\n<router-link :to=\"{name: 'Detail', params: { id: 1 }}\">前往Detail页面</router-link> \n```\n2.query通过this.$route.query来接收参数，params通过this.$route.params来接收参数。\n```\n// query通过this.$route.query接收参数\ncreated () {\n    const id = this.$route.query.id;\n}\n// params通过this.$route.params来接收参数\ncreated () {\n    const id = this.$route.params.id;\n}    \n```\n3.query传参的url展现方式：/detail?id=1&user=123&identity=1&更多参数       params＋动态路由的url方式：/detail/123    \n4.params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面：\n```\n{      \n    path: '/detail/:id',      \n    name: 'Detail',      \n    component: Detail    \n},\n```\n注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如：\n```\n// 定义的路由中，只定义一个id参数\n{\n    path: 'detail/:id',\n    name: 'Detail',\n    components: Detail\n}\n// template中的路由传参，\n// 传了一个id参数和一个token参数\n// id是在路由中已经定义的参数，而token没有定义\n<router-link :to=\"{name: 'Detail', params: { id: 1, token: '123456' }}\">前往Detail页面</router-link>\n// 在详情页接收\ncreated () {\n    // 以下都可以正常获取到\n    // 但是页面刷新后，id依然可以获取，而token此时就不存在了\n    const id = this.$route.params.id;\n    const token = this.$route.params.token;\n}\n```","source":"_posts/Vue项目遇到问题.md","raw":"---\ntitle: Vue项目遇到问题\ndate: 2023-04-12 12:46:31\ntags: Vue\ncategories: Vue\n---\n列表进入详情页的传参问题。\n例如商品列表页面前往商品详情页面，需要传一个商品id;\n```\n<router-link :to=\"{path: 'detail', query: {id: 1}}\">\n```\n前往detail页面</router-link>c页面的路径为http://localhost:8080/#/detail?id=1，可以看到传了一个参数id=1，并且就算刷新页面id也还会存在。此时在c页面可以通过id来获取对应的详情数据，获取id的方式是this.$route.query.idvue传参方式有：query、params+动态路由传参。\n说下两者的区别：    \n1.query通过path切换路由，params通过name切换路由\n```\n// query通过path切换路由\n<router-link :to=\"{path: 'Detail', query: { id: 1 }}\">前往Detail页面</router-link>\n// params通过name切换路由\n<router-link :to=\"{name: 'Detail', params: { id: 1 }}\">前往Detail页面</router-link> \n```\n2.query通过this.$route.query来接收参数，params通过this.$route.params来接收参数。\n```\n// query通过this.$route.query接收参数\ncreated () {\n    const id = this.$route.query.id;\n}\n// params通过this.$route.params来接收参数\ncreated () {\n    const id = this.$route.params.id;\n}    \n```\n3.query传参的url展现方式：/detail?id=1&user=123&identity=1&更多参数       params＋动态路由的url方式：/detail/123    \n4.params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面：\n```\n{      \n    path: '/detail/:id',      \n    name: 'Detail',      \n    component: Detail    \n},\n```\n注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如：\n```\n// 定义的路由中，只定义一个id参数\n{\n    path: 'detail/:id',\n    name: 'Detail',\n    components: Detail\n}\n// template中的路由传参，\n// 传了一个id参数和一个token参数\n// id是在路由中已经定义的参数，而token没有定义\n<router-link :to=\"{name: 'Detail', params: { id: 1, token: '123456' }}\">前往Detail页面</router-link>\n// 在详情页接收\ncreated () {\n    // 以下都可以正常获取到\n    // 但是页面刷新后，id依然可以获取，而token此时就不存在了\n    const id = this.$route.params.id;\n    const token = this.$route.params.token;\n}\n```","slug":"Vue项目遇到问题","published":1,"updated":"2023-04-13T09:44:08.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml60019tit864bdg58d","content":"<p>列表进入详情页的传参问题。<br>例如商品列表页面前往商品详情页面，需要传一个商品id;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;&#123;path: &#x27;detail&#x27;, query: &#123;id: 1&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>前往detail页面</router-link>c页面的路径为<a href=\"http://localhost:8080/#/detail?id=1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BC%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0id=1%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%B1%E7%AE%97%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2id%E4%B9%9F%E8%BF%98%E4%BC%9A%E5%AD%98%E5%9C%A8%E3%80%82%E6%AD%A4%E6%97%B6%E5%9C%A8c%E9%A1%B5%E9%9D%A2%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87id%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84%E8%AF%A6%E6%83%85%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%8E%B7%E5%8F%96id%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AFthis.$route.query.idvue%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%E6%9C%89%EF%BC%9Aquery%E3%80%81params+%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E3%80%82\">http://localhost:8080/#/detail?id=1，可以看到传了一个参数id=1，并且就算刷新页面id也还会存在。此时在c页面可以通过id来获取对应的详情数据，获取id的方式是this.$route.query.idvue传参方式有：query、params+动态路由传参。</a><br>说下两者的区别：   <br>1.query通过path切换路由，params通过name切换路由</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// query通过path切换路由</span><br><span class=\"line\">&lt;router-link :to=&quot;&#123;path: &#x27;Detail&#x27;, query: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;</span><br><span class=\"line\">// params通过name切换路由</span><br><span class=\"line\">&lt;router-link :to=&quot;&#123;name: &#x27;Detail&#x27;, params: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt; </span><br></pre></td></tr></table></figure>\n<p>2.query通过this.$route.query来接收参数，params通过this.$route.params来接收参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// query通过this.$route.query接收参数</span><br><span class=\"line\">created () &#123;</span><br><span class=\"line\">    const id = this.$route.query.id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// params通过this.$route.params来接收参数</span><br><span class=\"line\">created () &#123;</span><br><span class=\"line\">    const id = this.$route.params.id;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>3.query传参的url展现方式：/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数       params＋动态路由的url方式：/detail/123   <br>4.params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;      </span><br><span class=\"line\">    path: &#x27;/detail/:id&#x27;,      </span><br><span class=\"line\">    name: &#x27;Detail&#x27;,      </span><br><span class=\"line\">    component: Detail    </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 定义的路由中，只定义一个id参数</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &#x27;detail/:id&#x27;,</span><br><span class=\"line\">    name: &#x27;Detail&#x27;,</span><br><span class=\"line\">    components: Detail</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// template中的路由传参，</span><br><span class=\"line\">// 传了一个id参数和一个token参数</span><br><span class=\"line\">// id是在路由中已经定义的参数，而token没有定义</span><br><span class=\"line\">&lt;router-link :to=&quot;&#123;name: &#x27;Detail&#x27;, params: &#123; id: 1, token: &#x27;123456&#x27; &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;</span><br><span class=\"line\">// 在详情页接收</span><br><span class=\"line\">created () &#123;</span><br><span class=\"line\">    // 以下都可以正常获取到</span><br><span class=\"line\">    // 但是页面刷新后，id依然可以获取，而token此时就不存在了</span><br><span class=\"line\">    const id = this.$route.params.id;</span><br><span class=\"line\">    const token = this.$route.params.token;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>列表进入详情页的传参问题。<br>例如商品列表页面前往商品详情页面，需要传一个商品id;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;&#123;path: &#x27;detail&#x27;, query: &#123;id: 1&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>前往detail页面</router-link>c页面的路径为<a href=\"http://localhost:8080/#/detail?id=1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BC%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0id=1%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%B1%E7%AE%97%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2id%E4%B9%9F%E8%BF%98%E4%BC%9A%E5%AD%98%E5%9C%A8%E3%80%82%E6%AD%A4%E6%97%B6%E5%9C%A8c%E9%A1%B5%E9%9D%A2%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87id%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84%E8%AF%A6%E6%83%85%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%8E%B7%E5%8F%96id%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AFthis.$route.query.idvue%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%E6%9C%89%EF%BC%9Aquery%E3%80%81params+%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E3%80%82\">http://localhost:8080/#/detail?id=1，可以看到传了一个参数id=1，并且就算刷新页面id也还会存在。此时在c页面可以通过id来获取对应的详情数据，获取id的方式是this.$route.query.idvue传参方式有：query、params+动态路由传参。</a><br>说下两者的区别：   <br>1.query通过path切换路由，params通过name切换路由</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// query通过path切换路由</span><br><span class=\"line\">&lt;router-link :to=&quot;&#123;path: &#x27;Detail&#x27;, query: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;</span><br><span class=\"line\">// params通过name切换路由</span><br><span class=\"line\">&lt;router-link :to=&quot;&#123;name: &#x27;Detail&#x27;, params: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt; </span><br></pre></td></tr></table></figure>\n<p>2.query通过this.$route.query来接收参数，params通过this.$route.params来接收参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// query通过this.$route.query接收参数</span><br><span class=\"line\">created () &#123;</span><br><span class=\"line\">    const id = this.$route.query.id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// params通过this.$route.params来接收参数</span><br><span class=\"line\">created () &#123;</span><br><span class=\"line\">    const id = this.$route.params.id;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>3.query传参的url展现方式：/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数       params＋动态路由的url方式：/detail/123   <br>4.params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;      </span><br><span class=\"line\">    path: &#x27;/detail/:id&#x27;,      </span><br><span class=\"line\">    name: &#x27;Detail&#x27;,      </span><br><span class=\"line\">    component: Detail    </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 定义的路由中，只定义一个id参数</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &#x27;detail/:id&#x27;,</span><br><span class=\"line\">    name: &#x27;Detail&#x27;,</span><br><span class=\"line\">    components: Detail</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// template中的路由传参，</span><br><span class=\"line\">// 传了一个id参数和一个token参数</span><br><span class=\"line\">// id是在路由中已经定义的参数，而token没有定义</span><br><span class=\"line\">&lt;router-link :to=&quot;&#123;name: &#x27;Detail&#x27;, params: &#123; id: 1, token: &#x27;123456&#x27; &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;</span><br><span class=\"line\">// 在详情页接收</span><br><span class=\"line\">created () &#123;</span><br><span class=\"line\">    // 以下都可以正常获取到</span><br><span class=\"line\">    // 但是页面刷新后，id依然可以获取，而token此时就不存在了</span><br><span class=\"line\">    const id = this.$route.params.id;</span><br><span class=\"line\">    const token = this.$route.params.token;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"component动态组件","date":"2023-03-23T13:27:48.000Z","_content":"# 一、什么是动态组件？\n定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。\n书写形式：<component :is=\"componentName\"></component>\n内置组件：\ncomponent：是vue里面的一个内置组件。作用是：配合is动态渲染组件。\nvue内置的组件还包括：\ntransition：作为单个元素/组件的过渡效果。\ntransition-group：作为多个元素/组件的过渡效果。\nkeep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\nslot：作为组件模板之中的内容分发插槽。\n# 二、使用方式\n通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。\n如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。\n1.在不同组件之间进行动态切换\ncomponent动态组件就是通过控制currentTabComponent来切换不同的组件。\n```\n<div @click=\"reload\">点击切换</div> \n<component :is=\"currentTabComponent\"></component>\n<script>\nimport childOne from './childOne'\nimport childTwo from './childTwo'\nexport default {\n    componets:{\n        childOne,\n        childTwo\n    },\n    data(){\n        currentTabComponent: 'childOne'\n    },\n    methods:{\n        reload(){\n            this.currentTabComponent = 'childTwo'\n        }\n    }\n}\n</script>\n```\n# 三、动态组件的缓存\n使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n<keep-alive></keep-alive>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。\n大白话:比如有一个列表和一个详情，那么用户就会经常执行打开详情=>返回列表=>打开详情…这样的话,列表和详情都是一个使用频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。\n\n```\n<keep-alive>\n    <component :is=\"componentName\"></component>\n</keep-alive>\n```\n","source":"_posts/component动态组件.md","raw":"---\ntitle: component动态组件\ndate: 2023-03-23 21:27:48\ntags: vue\ncategories: 知识点\n---\n# 一、什么是动态组件？\n定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。\n书写形式：<component :is=\"componentName\"></component>\n内置组件：\ncomponent：是vue里面的一个内置组件。作用是：配合is动态渲染组件。\nvue内置的组件还包括：\ntransition：作为单个元素/组件的过渡效果。\ntransition-group：作为多个元素/组件的过渡效果。\nkeep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\nslot：作为组件模板之中的内容分发插槽。\n# 二、使用方式\n通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。\n如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。\n1.在不同组件之间进行动态切换\ncomponent动态组件就是通过控制currentTabComponent来切换不同的组件。\n```\n<div @click=\"reload\">点击切换</div> \n<component :is=\"currentTabComponent\"></component>\n<script>\nimport childOne from './childOne'\nimport childTwo from './childTwo'\nexport default {\n    componets:{\n        childOne,\n        childTwo\n    },\n    data(){\n        currentTabComponent: 'childOne'\n    },\n    methods:{\n        reload(){\n            this.currentTabComponent = 'childTwo'\n        }\n    }\n}\n</script>\n```\n# 三、动态组件的缓存\n使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n<keep-alive></keep-alive>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。\n大白话:比如有一个列表和一个详情，那么用户就会经常执行打开详情=>返回列表=>打开详情…这样的话,列表和详情都是一个使用频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。\n\n```\n<keep-alive>\n    <component :is=\"componentName\"></component>\n</keep-alive>\n```\n","slug":"component动态组件","published":1,"updated":"2023-04-13T09:56:00.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml6001ctit8d4foehyu","content":"<h1 id=\"一、什么是动态组件？\"><a href=\"#一、什么是动态组件？\" class=\"headerlink\" title=\"一、什么是动态组件？\"></a>一、什么是动态组件？</h1><p>定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。<br>书写形式：<component :is=\"componentName\"></component><br>内置组件：<br>component：是vue里面的一个内置组件。作用是：配合is动态渲染组件。<br>vue内置的组件还包括：<br>transition：作为单个元素/组件的过渡效果。<br>transition-group：作为多个元素/组件的过渡效果。<br>keep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。<br>slot：作为组件模板之中的内容分发插槽。</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。<br>如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。<br>1.在不同组件之间进行动态切换<br>component动态组件就是通过控制currentTabComponent来切换不同的组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div @click=&quot;reload&quot;&gt;点击切换&lt;/div&gt; </span><br><span class=\"line\">&lt;component :is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import childOne from &#x27;./childOne&#x27;</span><br><span class=\"line\">import childTwo from &#x27;./childTwo&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    componets:&#123;</span><br><span class=\"line\">        childOne,</span><br><span class=\"line\">        childTwo</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    data()&#123;</span><br><span class=\"line\">        currentTabComponent: &#x27;childOne&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">        reload()&#123;</span><br><span class=\"line\">            this.currentTabComponent = &#x27;childTwo&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、动态组件的缓存\"><a href=\"#三、动态组件的缓存\" class=\"headerlink\" title=\"三、动态组件的缓存\"></a>三、动态组件的缓存</h1><p>使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br><keep-alive></keep-alive>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。<br>大白话:比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话,列表和详情都是一个使用频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;keep-alive&gt;</span><br><span class=\"line\">    &lt;component :is=&quot;componentName&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"一、什么是动态组件？\"><a href=\"#一、什么是动态组件？\" class=\"headerlink\" title=\"一、什么是动态组件？\"></a>一、什么是动态组件？</h1><p>定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。<br>书写形式：<component :is=\"componentName\"></component><br>内置组件：<br>component：是vue里面的一个内置组件。作用是：配合is动态渲染组件。<br>vue内置的组件还包括：<br>transition：作为单个元素/组件的过渡效果。<br>transition-group：作为多个元素/组件的过渡效果。<br>keep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。<br>slot：作为组件模板之中的内容分发插槽。</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。<br>如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。<br>1.在不同组件之间进行动态切换<br>component动态组件就是通过控制currentTabComponent来切换不同的组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div @click=&quot;reload&quot;&gt;点击切换&lt;/div&gt; </span><br><span class=\"line\">&lt;component :is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import childOne from &#x27;./childOne&#x27;</span><br><span class=\"line\">import childTwo from &#x27;./childTwo&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    componets:&#123;</span><br><span class=\"line\">        childOne,</span><br><span class=\"line\">        childTwo</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    data()&#123;</span><br><span class=\"line\">        currentTabComponent: &#x27;childOne&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">        reload()&#123;</span><br><span class=\"line\">            this.currentTabComponent = &#x27;childTwo&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、动态组件的缓存\"><a href=\"#三、动态组件的缓存\" class=\"headerlink\" title=\"三、动态组件的缓存\"></a>三、动态组件的缓存</h1><p>使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br><keep-alive></keep-alive>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。<br>大白话:比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话,列表和详情都是一个使用频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;keep-alive&gt;</span><br><span class=\"line\">    &lt;component :is=&quot;componentName&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"浅析vue项目中npm run dev和npm run serve的区别","date":"2023-03-13T03:03:47.000Z","_content":"# 先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\n通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？\n## 在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\n# 首先看看npm是什么？\nnpm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本\n# 在看看npm install命令\n在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹\n主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下\n# 然后看看运行npm run ×××命令的原理\n大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？\n在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段\n![](npm区别.png)\n***\n我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？\n答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目\n\n# 既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？\n正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？\n我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。\n\n\n\n\n\n\n\n\n","source":"_posts/serve的区别.md","raw":"---\ntitle: 浅析vue项目中npm run dev和npm run serve的区别\ndate: 2023-03-13 11:03:47\ntags: vue\ncategories: 知识点\n---\n# 先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\n通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？\n## 在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\n# 首先看看npm是什么？\nnpm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本\n# 在看看npm install命令\n在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹\n主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下\n# 然后看看运行npm run ×××命令的原理\n大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？\n在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段\n![](npm区别.png)\n***\n我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？\n答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目\n\n# 既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？\n正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？\n我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。\n\n\n\n\n\n\n\n\n","slug":"serve的区别","published":1,"updated":"2023-03-22T06:14:54.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml7001ftit8774ccwae","content":"<h1 id=\"先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\"><a href=\"#先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\" class=\"headerlink\" title=\"先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\"></a>先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？</h1><p>通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？</p>\n<h2 id=\"在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\"><a href=\"#在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\" class=\"headerlink\" title=\"在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\"></a>在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。</h2><h1 id=\"首先看看npm是什么？\"><a href=\"#首先看看npm是什么？\" class=\"headerlink\" title=\"首先看看npm是什么？\"></a>首先看看npm是什么？</h1><p>npm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本</p>\n<h1 id=\"在看看npm-install命令\"><a href=\"#在看看npm-install命令\" class=\"headerlink\" title=\"在看看npm install命令\"></a>在看看npm install命令</h1><p>在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹<br>主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下</p>\n<h1 id=\"然后看看运行npm-run-×××命令的原理\"><a href=\"#然后看看运行npm-run-×××命令的原理\" class=\"headerlink\" title=\"然后看看运行npm run ×××命令的原理\"></a>然后看看运行npm run ×××命令的原理</h1><p>大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？<br>在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段<br><img src=\"/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/npm%E5%8C%BA%E5%88%AB.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<hr>\n<p>我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？<br>答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目</p>\n<h1 id=\"既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？\"><a href=\"#既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？\" class=\"headerlink\" title=\"既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？\"></a>既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？</h1><p>正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？<br>我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\"><a href=\"#先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\" class=\"headerlink\" title=\"先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\"></a>先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？</h1><p>通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？</p>\n<h2 id=\"在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\"><a href=\"#在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\" class=\"headerlink\" title=\"在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\"></a>在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。</h2><h1 id=\"首先看看npm是什么？\"><a href=\"#首先看看npm是什么？\" class=\"headerlink\" title=\"首先看看npm是什么？\"></a>首先看看npm是什么？</h1><p>npm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本</p>\n<h1 id=\"在看看npm-install命令\"><a href=\"#在看看npm-install命令\" class=\"headerlink\" title=\"在看看npm install命令\"></a>在看看npm install命令</h1><p>在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹<br>主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下</p>\n<h1 id=\"然后看看运行npm-run-×××命令的原理\"><a href=\"#然后看看运行npm-run-×××命令的原理\" class=\"headerlink\" title=\"然后看看运行npm run ×××命令的原理\"></a>然后看看运行npm run ×××命令的原理</h1><p>大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？<br>在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段<br><img src=\"/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/npm%E5%8C%BA%E5%88%AB.png\"></p>\n<hr>\n<p>我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？<br>答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目</p>\n<h1 id=\"既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？\"><a href=\"#既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？\" class=\"headerlink\" title=\"既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？\"></a>既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？</h1><p>正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？<br>我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。</p>\n"},{"title":"vue-cropper","date":"2023-04-11T13:34:50.000Z","_content":"# vue-cropper的使用\n## 安装\n```\nnpm install vue-cropper --save\n```\n## 在main.js中引入\n```\nimport VueCropper from 'vue-cropper'\nVue.use(VueCropper)\n```\n# 封装组件\n```\n<template>\n    <!-- 图片裁剪组件 -->\n    <div class=\"img-cut\">\n      <!-- 图片 -->\n      <div class=\"img-wrap\">\n        <img class=\"edit-img\" :src=\"imgUrl\" />\n      </div>\n      <!-- 按钮 -->\n      <div class=\"btn-wrap\">\n        <el-upload\n          ref=\"upload\"\n          :action=\"action\"\n          :auto-upload=\"false\"\n          :on-change=\"handleChange\"\n          :show-file-list=\"false\"\n          accept=\"image/*\"\n        >\n          <button slot=\"trigger\" class=\"btn btn-white\">{{ btnText }}</button>\n        </el-upload>\n      </div>\n      <!-- 图片裁剪 -->\n      <el-dialog\n        title=\"图片剪裁\"\n        :visible.sync=\"ImgdialogVisible\"\n        :modal=\"false\"\n        :close-on-click-modal=\"false\"\n        append-to-body\n        :destroy-on-close=\"true\"\n        :center=\"true\"\n      >\n        <div class=\"cropper-content\">\n          <div class=\"cropper\" style=\"text-align: center\">\n            <vueCropper\n              ref=\"cropper\"\n              :img=\"option.img\"\n              :outputSize=\"option.size\"\n              :outputType=\"option.outputType\"\n              :info=\"option.info\"\n              :full=\"option.full\"\n              :canMove=\"option.canMove\"\n              :canMoveBox=\"option.canMoveBox\"\n              :original=\"option.original\"\n              :autoCrop=\"option.autoCrop\"\n              :fixed=\"option.fixed\"\n              :fixedNumber=\"option.fixedNumber\"\n              :centerBox=\"option.centerBox\"\n              :infoTrue=\"option.infoTrue\"\n              :fixedBox=\"option.fixedBox\"\n              :mode=\"option.mode\"\n              :canScale=\"option.canScale\"\n            >\n            </vueCropper>\n          </div>\n        </div>\n        <div slot=\"footer\" class=\"dialog-footer\">\n          <button class=\"btn btn-white\" @click=\"ImgdialogVisible = false\">\n            取消\n          </button>\n          <button class=\"btn btn-red mleft-10\" @click=\"getSliceImg\">\n            保存并关闭\n          </button>\n        </div>\n      </el-dialog>\n    </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    imgUrl: {\n      type: String,\n      required: true\n    },\n    btnText: {\n      type: String,\n      default: '选择图片'\n    }\n  },\n  data () {\n    return {\n      action: '/xxxx',\n      ImgdialogVisible: false,\n      option: {\n        img: '', // 裁剪图片的地址\n        info: true, // 裁剪框的大小信息\n        outputSize: 0.8, // 裁剪生成图片的质量\n        outputType: 'jpeg', // 裁剪生成图片的格式\n        canScale: true, // 图片是否允许滚轮缩放\n        autoCrop: true, // 是否默认生成截图框\n        fixedBox: true, // 固定截图框大小 不允许改变\n        fixed: true, // 是否开启截图框宽高固定比例\n        fixedNumber: [1, 1], // 截图框的宽高比例\n        full: true, // 是否输出原图比例的截图\n        canMoveBox: false, // 截图框能否拖动\n        original: false, // 上传图片按照原始比例渲染\n        centerBox: true, // 截图框是否被限制在图片里面\n        infoTrue: true, // true 为展示真实输出图片宽高 false 展示看到的截图框宽高\n        mode: 'contain'\n      }\n    }\n  },\n  methods: {\n    getSliceImg () {\n      this.$refs.cropper.getCropBlob(async (data) => {\n        const imgSize = await this.getImgSize(data)\n        /* 把blob对象和最终图像的size传给父组件 */\n        this.$emit('upload', { file: data, imgSize })\n        this.ImgdialogVisible = false\n      })\n    },\n    /* 处理element upload组件change事件 */\n    handleChange (file) {\n      this.openImgDialog(file.raw)\n    },\n    /* 打开裁剪页面 */\n    openImgDialog (file) {\n      let reader = new FileReader()\n      reader.onload = (theFile) => {\n        this.option.img = theFile.target.result\n        this.ImgdialogVisible = true\n      }\n      if (file) {\n        reader.readAsDataURL(file)\n      }\n    },\n    /* 计算图片大小 */\n    getImgSize (file) {\n      return new Promise((resolve, reject) => {\n        let reader = new FileReader()\n        reader.onload = function (theFile) {\n          let image = new Image()\n          image.src = theFile.target.result\n          image.onload = function () {\n            resolve({\n              width: this.width,\n              height: this.height\n            })\n          }\n        }\n        if (file) {\n          reader.readAsDataURL(file)\n        } else {\n          reject('出错了')\n        }\n      })\n    }\n  }\n}\n</script>\n```\n# 问题总结\n问题一、如何阻止upload上传完之后就上传？　　\n将el-upload 的 auto-upload 设置为 false即可\n问题二、如何将获取到文件传给vue-cropper?　　\nvue-cropper 可以接受一个 blob，此时需要 new FileReader()，参考 MDN\n问题三、el-upload 选择完文件后不能更改，如何上传裁剪之后的图片？\n使用自定义上传，点击上传时直接调用submit 方法，这时会自动触发http-request中的自定义方法，可以拿到file中的所有属性，在函数里面使用 axios 自定义上传参数和文件。此方法比较好控制。\n\n","source":"_posts/vue-cropper.md","raw":"---\ntitle: vue-cropper\ndate: 2023-04-11 21:34:50\ntags: vue-cropper\ncategories: Vue\n---\n# vue-cropper的使用\n## 安装\n```\nnpm install vue-cropper --save\n```\n## 在main.js中引入\n```\nimport VueCropper from 'vue-cropper'\nVue.use(VueCropper)\n```\n# 封装组件\n```\n<template>\n    <!-- 图片裁剪组件 -->\n    <div class=\"img-cut\">\n      <!-- 图片 -->\n      <div class=\"img-wrap\">\n        <img class=\"edit-img\" :src=\"imgUrl\" />\n      </div>\n      <!-- 按钮 -->\n      <div class=\"btn-wrap\">\n        <el-upload\n          ref=\"upload\"\n          :action=\"action\"\n          :auto-upload=\"false\"\n          :on-change=\"handleChange\"\n          :show-file-list=\"false\"\n          accept=\"image/*\"\n        >\n          <button slot=\"trigger\" class=\"btn btn-white\">{{ btnText }}</button>\n        </el-upload>\n      </div>\n      <!-- 图片裁剪 -->\n      <el-dialog\n        title=\"图片剪裁\"\n        :visible.sync=\"ImgdialogVisible\"\n        :modal=\"false\"\n        :close-on-click-modal=\"false\"\n        append-to-body\n        :destroy-on-close=\"true\"\n        :center=\"true\"\n      >\n        <div class=\"cropper-content\">\n          <div class=\"cropper\" style=\"text-align: center\">\n            <vueCropper\n              ref=\"cropper\"\n              :img=\"option.img\"\n              :outputSize=\"option.size\"\n              :outputType=\"option.outputType\"\n              :info=\"option.info\"\n              :full=\"option.full\"\n              :canMove=\"option.canMove\"\n              :canMoveBox=\"option.canMoveBox\"\n              :original=\"option.original\"\n              :autoCrop=\"option.autoCrop\"\n              :fixed=\"option.fixed\"\n              :fixedNumber=\"option.fixedNumber\"\n              :centerBox=\"option.centerBox\"\n              :infoTrue=\"option.infoTrue\"\n              :fixedBox=\"option.fixedBox\"\n              :mode=\"option.mode\"\n              :canScale=\"option.canScale\"\n            >\n            </vueCropper>\n          </div>\n        </div>\n        <div slot=\"footer\" class=\"dialog-footer\">\n          <button class=\"btn btn-white\" @click=\"ImgdialogVisible = false\">\n            取消\n          </button>\n          <button class=\"btn btn-red mleft-10\" @click=\"getSliceImg\">\n            保存并关闭\n          </button>\n        </div>\n      </el-dialog>\n    </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    imgUrl: {\n      type: String,\n      required: true\n    },\n    btnText: {\n      type: String,\n      default: '选择图片'\n    }\n  },\n  data () {\n    return {\n      action: '/xxxx',\n      ImgdialogVisible: false,\n      option: {\n        img: '', // 裁剪图片的地址\n        info: true, // 裁剪框的大小信息\n        outputSize: 0.8, // 裁剪生成图片的质量\n        outputType: 'jpeg', // 裁剪生成图片的格式\n        canScale: true, // 图片是否允许滚轮缩放\n        autoCrop: true, // 是否默认生成截图框\n        fixedBox: true, // 固定截图框大小 不允许改变\n        fixed: true, // 是否开启截图框宽高固定比例\n        fixedNumber: [1, 1], // 截图框的宽高比例\n        full: true, // 是否输出原图比例的截图\n        canMoveBox: false, // 截图框能否拖动\n        original: false, // 上传图片按照原始比例渲染\n        centerBox: true, // 截图框是否被限制在图片里面\n        infoTrue: true, // true 为展示真实输出图片宽高 false 展示看到的截图框宽高\n        mode: 'contain'\n      }\n    }\n  },\n  methods: {\n    getSliceImg () {\n      this.$refs.cropper.getCropBlob(async (data) => {\n        const imgSize = await this.getImgSize(data)\n        /* 把blob对象和最终图像的size传给父组件 */\n        this.$emit('upload', { file: data, imgSize })\n        this.ImgdialogVisible = false\n      })\n    },\n    /* 处理element upload组件change事件 */\n    handleChange (file) {\n      this.openImgDialog(file.raw)\n    },\n    /* 打开裁剪页面 */\n    openImgDialog (file) {\n      let reader = new FileReader()\n      reader.onload = (theFile) => {\n        this.option.img = theFile.target.result\n        this.ImgdialogVisible = true\n      }\n      if (file) {\n        reader.readAsDataURL(file)\n      }\n    },\n    /* 计算图片大小 */\n    getImgSize (file) {\n      return new Promise((resolve, reject) => {\n        let reader = new FileReader()\n        reader.onload = function (theFile) {\n          let image = new Image()\n          image.src = theFile.target.result\n          image.onload = function () {\n            resolve({\n              width: this.width,\n              height: this.height\n            })\n          }\n        }\n        if (file) {\n          reader.readAsDataURL(file)\n        } else {\n          reject('出错了')\n        }\n      })\n    }\n  }\n}\n</script>\n```\n# 问题总结\n问题一、如何阻止upload上传完之后就上传？　　\n将el-upload 的 auto-upload 设置为 false即可\n问题二、如何将获取到文件传给vue-cropper?　　\nvue-cropper 可以接受一个 blob，此时需要 new FileReader()，参考 MDN\n问题三、el-upload 选择完文件后不能更改，如何上传裁剪之后的图片？\n使用自定义上传，点击上传时直接调用submit 方法，这时会自动触发http-request中的自定义方法，可以拿到file中的所有属性，在函数里面使用 axios 自定义上传参数和文件。此方法比较好控制。\n\n","slug":"vue-cropper","published":1,"updated":"2023-04-11T14:14:22.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml7001itit8ccib1dyq","content":"<h1 id=\"vue-cropper的使用\"><a href=\"#vue-cropper的使用\" class=\"headerlink\" title=\"vue-cropper的使用\"></a>vue-cropper的使用</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install vue-cropper --save</span><br></pre></td></tr></table></figure>\n<h2 id=\"在main-js中引入\"><a href=\"#在main-js中引入\" class=\"headerlink\" title=\"在main.js中引入\"></a>在main.js中引入</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import VueCropper from &#x27;vue-cropper&#x27;</span><br><span class=\"line\">Vue.use(VueCropper)</span><br></pre></td></tr></table></figure>\n<h1 id=\"封装组件\"><a href=\"#封装组件\" class=\"headerlink\" title=\"封装组件\"></a>封装组件</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;!-- 图片裁剪组件 --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;img-cut&quot;&gt;</span><br><span class=\"line\">      &lt;!-- 图片 --&gt;</span><br><span class=\"line\">      &lt;div class=&quot;img-wrap&quot;&gt;</span><br><span class=\"line\">        &lt;img class=&quot;edit-img&quot; :src=&quot;imgUrl&quot; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;!-- 按钮 --&gt;</span><br><span class=\"line\">      &lt;div class=&quot;btn-wrap&quot;&gt;</span><br><span class=\"line\">        &lt;el-upload</span><br><span class=\"line\">          ref=&quot;upload&quot;</span><br><span class=\"line\">          :action=&quot;action&quot;</span><br><span class=\"line\">          :auto-upload=&quot;false&quot;</span><br><span class=\"line\">          :on-change=&quot;handleChange&quot;</span><br><span class=\"line\">          :show-file-list=&quot;false&quot;</span><br><span class=\"line\">          accept=&quot;image/*&quot;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &lt;button slot=&quot;trigger&quot; class=&quot;btn btn-white&quot;&gt;&#123;&#123; btnText &#125;&#125;&lt;/button&gt;</span><br><span class=\"line\">        &lt;/el-upload&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;!-- 图片裁剪 --&gt;</span><br><span class=\"line\">      &lt;el-dialog</span><br><span class=\"line\">        title=&quot;图片剪裁&quot;</span><br><span class=\"line\">        :visible.sync=&quot;ImgdialogVisible&quot;</span><br><span class=\"line\">        :modal=&quot;false&quot;</span><br><span class=\"line\">        :close-on-click-modal=&quot;false&quot;</span><br><span class=\"line\">        append-to-body</span><br><span class=\"line\">        :destroy-on-close=&quot;true&quot;</span><br><span class=\"line\">        :center=&quot;true&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;div class=&quot;cropper-content&quot;&gt;</span><br><span class=\"line\">          &lt;div class=&quot;cropper&quot; style=&quot;text-align: center&quot;&gt;</span><br><span class=\"line\">            &lt;vueCropper</span><br><span class=\"line\">              ref=&quot;cropper&quot;</span><br><span class=\"line\">              :img=&quot;option.img&quot;</span><br><span class=\"line\">              :outputSize=&quot;option.size&quot;</span><br><span class=\"line\">              :outputType=&quot;option.outputType&quot;</span><br><span class=\"line\">              :info=&quot;option.info&quot;</span><br><span class=\"line\">              :full=&quot;option.full&quot;</span><br><span class=\"line\">              :canMove=&quot;option.canMove&quot;</span><br><span class=\"line\">              :canMoveBox=&quot;option.canMoveBox&quot;</span><br><span class=\"line\">              :original=&quot;option.original&quot;</span><br><span class=\"line\">              :autoCrop=&quot;option.autoCrop&quot;</span><br><span class=\"line\">              :fixed=&quot;option.fixed&quot;</span><br><span class=\"line\">              :fixedNumber=&quot;option.fixedNumber&quot;</span><br><span class=\"line\">              :centerBox=&quot;option.centerBox&quot;</span><br><span class=\"line\">              :infoTrue=&quot;option.infoTrue&quot;</span><br><span class=\"line\">              :fixedBox=&quot;option.fixedBox&quot;</span><br><span class=\"line\">              :mode=&quot;option.mode&quot;</span><br><span class=\"line\">              :canScale=&quot;option.canScale&quot;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">            &lt;/vueCropper&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class=\"line\">          &lt;button class=&quot;btn btn-white&quot; @click=&quot;ImgdialogVisible = false&quot;&gt;</span><br><span class=\"line\">            取消</span><br><span class=\"line\">          &lt;/button&gt;</span><br><span class=\"line\">          &lt;button class=&quot;btn btn-red mleft-10&quot; @click=&quot;getSliceImg&quot;&gt;</span><br><span class=\"line\">            保存并关闭</span><br><span class=\"line\">          &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/el-dialog&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    imgUrl: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    btnText: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &#x27;选择图片&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      action: &#x27;/xxxx&#x27;,</span><br><span class=\"line\">      ImgdialogVisible: false,</span><br><span class=\"line\">      option: &#123;</span><br><span class=\"line\">        img: &#x27;&#x27;, // 裁剪图片的地址</span><br><span class=\"line\">        info: true, // 裁剪框的大小信息</span><br><span class=\"line\">        outputSize: 0.8, // 裁剪生成图片的质量</span><br><span class=\"line\">        outputType: &#x27;jpeg&#x27;, // 裁剪生成图片的格式</span><br><span class=\"line\">        canScale: true, // 图片是否允许滚轮缩放</span><br><span class=\"line\">        autoCrop: true, // 是否默认生成截图框</span><br><span class=\"line\">        fixedBox: true, // 固定截图框大小 不允许改变</span><br><span class=\"line\">        fixed: true, // 是否开启截图框宽高固定比例</span><br><span class=\"line\">        fixedNumber: [1, 1], // 截图框的宽高比例</span><br><span class=\"line\">        full: true, // 是否输出原图比例的截图</span><br><span class=\"line\">        canMoveBox: false, // 截图框能否拖动</span><br><span class=\"line\">        original: false, // 上传图片按照原始比例渲染</span><br><span class=\"line\">        centerBox: true, // 截图框是否被限制在图片里面</span><br><span class=\"line\">        infoTrue: true, // true 为展示真实输出图片宽高 false 展示看到的截图框宽高</span><br><span class=\"line\">        mode: &#x27;contain&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getSliceImg () &#123;</span><br><span class=\"line\">      this.$refs.cropper.getCropBlob(async (data) =&gt; &#123;</span><br><span class=\"line\">        const imgSize = await this.getImgSize(data)</span><br><span class=\"line\">        /* 把blob对象和最终图像的size传给父组件 */</span><br><span class=\"line\">        this.$emit(&#x27;upload&#x27;, &#123; file: data, imgSize &#125;)</span><br><span class=\"line\">        this.ImgdialogVisible = false</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 处理element upload组件change事件 */</span><br><span class=\"line\">    handleChange (file) &#123;</span><br><span class=\"line\">      this.openImgDialog(file.raw)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 打开裁剪页面 */</span><br><span class=\"line\">    openImgDialog (file) &#123;</span><br><span class=\"line\">      let reader = new FileReader()</span><br><span class=\"line\">      reader.onload = (theFile) =&gt; &#123;</span><br><span class=\"line\">        this.option.img = theFile.target.result</span><br><span class=\"line\">        this.ImgdialogVisible = true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (file) &#123;</span><br><span class=\"line\">        reader.readAsDataURL(file)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 计算图片大小 */</span><br><span class=\"line\">    getImgSize (file) &#123;</span><br><span class=\"line\">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        let reader = new FileReader()</span><br><span class=\"line\">        reader.onload = function (theFile) &#123;</span><br><span class=\"line\">          let image = new Image()</span><br><span class=\"line\">          image.src = theFile.target.result</span><br><span class=\"line\">          image.onload = function () &#123;</span><br><span class=\"line\">            resolve(&#123;</span><br><span class=\"line\">              width: this.width,</span><br><span class=\"line\">              height: this.height</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (file) &#123;</span><br><span class=\"line\">          reader.readAsDataURL(file)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          reject(&#x27;出错了&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题总结\"><a href=\"#问题总结\" class=\"headerlink\" title=\"问题总结\"></a>问题总结</h1><p>问题一、如何阻止upload上传完之后就上传？　　<br>将el-upload 的 auto-upload 设置为 false即可<br>问题二、如何将获取到文件传给vue-cropper?　　<br>vue-cropper 可以接受一个 blob，此时需要 new FileReader()，参考 MDN<br>问题三、el-upload 选择完文件后不能更改，如何上传裁剪之后的图片？<br>使用自定义上传，点击上传时直接调用submit 方法，这时会自动触发http-request中的自定义方法，可以拿到file中的所有属性，在函数里面使用 axios 自定义上传参数和文件。此方法比较好控制。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"vue-cropper的使用\"><a href=\"#vue-cropper的使用\" class=\"headerlink\" title=\"vue-cropper的使用\"></a>vue-cropper的使用</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install vue-cropper --save</span><br></pre></td></tr></table></figure>\n<h2 id=\"在main-js中引入\"><a href=\"#在main-js中引入\" class=\"headerlink\" title=\"在main.js中引入\"></a>在main.js中引入</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import VueCropper from &#x27;vue-cropper&#x27;</span><br><span class=\"line\">Vue.use(VueCropper)</span><br></pre></td></tr></table></figure>\n<h1 id=\"封装组件\"><a href=\"#封装组件\" class=\"headerlink\" title=\"封装组件\"></a>封装组件</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;!-- 图片裁剪组件 --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;img-cut&quot;&gt;</span><br><span class=\"line\">      &lt;!-- 图片 --&gt;</span><br><span class=\"line\">      &lt;div class=&quot;img-wrap&quot;&gt;</span><br><span class=\"line\">        &lt;img class=&quot;edit-img&quot; :src=&quot;imgUrl&quot; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;!-- 按钮 --&gt;</span><br><span class=\"line\">      &lt;div class=&quot;btn-wrap&quot;&gt;</span><br><span class=\"line\">        &lt;el-upload</span><br><span class=\"line\">          ref=&quot;upload&quot;</span><br><span class=\"line\">          :action=&quot;action&quot;</span><br><span class=\"line\">          :auto-upload=&quot;false&quot;</span><br><span class=\"line\">          :on-change=&quot;handleChange&quot;</span><br><span class=\"line\">          :show-file-list=&quot;false&quot;</span><br><span class=\"line\">          accept=&quot;image/*&quot;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &lt;button slot=&quot;trigger&quot; class=&quot;btn btn-white&quot;&gt;&#123;&#123; btnText &#125;&#125;&lt;/button&gt;</span><br><span class=\"line\">        &lt;/el-upload&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;!-- 图片裁剪 --&gt;</span><br><span class=\"line\">      &lt;el-dialog</span><br><span class=\"line\">        title=&quot;图片剪裁&quot;</span><br><span class=\"line\">        :visible.sync=&quot;ImgdialogVisible&quot;</span><br><span class=\"line\">        :modal=&quot;false&quot;</span><br><span class=\"line\">        :close-on-click-modal=&quot;false&quot;</span><br><span class=\"line\">        append-to-body</span><br><span class=\"line\">        :destroy-on-close=&quot;true&quot;</span><br><span class=\"line\">        :center=&quot;true&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;div class=&quot;cropper-content&quot;&gt;</span><br><span class=\"line\">          &lt;div class=&quot;cropper&quot; style=&quot;text-align: center&quot;&gt;</span><br><span class=\"line\">            &lt;vueCropper</span><br><span class=\"line\">              ref=&quot;cropper&quot;</span><br><span class=\"line\">              :img=&quot;option.img&quot;</span><br><span class=\"line\">              :outputSize=&quot;option.size&quot;</span><br><span class=\"line\">              :outputType=&quot;option.outputType&quot;</span><br><span class=\"line\">              :info=&quot;option.info&quot;</span><br><span class=\"line\">              :full=&quot;option.full&quot;</span><br><span class=\"line\">              :canMove=&quot;option.canMove&quot;</span><br><span class=\"line\">              :canMoveBox=&quot;option.canMoveBox&quot;</span><br><span class=\"line\">              :original=&quot;option.original&quot;</span><br><span class=\"line\">              :autoCrop=&quot;option.autoCrop&quot;</span><br><span class=\"line\">              :fixed=&quot;option.fixed&quot;</span><br><span class=\"line\">              :fixedNumber=&quot;option.fixedNumber&quot;</span><br><span class=\"line\">              :centerBox=&quot;option.centerBox&quot;</span><br><span class=\"line\">              :infoTrue=&quot;option.infoTrue&quot;</span><br><span class=\"line\">              :fixedBox=&quot;option.fixedBox&quot;</span><br><span class=\"line\">              :mode=&quot;option.mode&quot;</span><br><span class=\"line\">              :canScale=&quot;option.canScale&quot;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">            &lt;/vueCropper&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class=\"line\">          &lt;button class=&quot;btn btn-white&quot; @click=&quot;ImgdialogVisible = false&quot;&gt;</span><br><span class=\"line\">            取消</span><br><span class=\"line\">          &lt;/button&gt;</span><br><span class=\"line\">          &lt;button class=&quot;btn btn-red mleft-10&quot; @click=&quot;getSliceImg&quot;&gt;</span><br><span class=\"line\">            保存并关闭</span><br><span class=\"line\">          &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/el-dialog&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    imgUrl: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    btnText: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &#x27;选择图片&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      action: &#x27;/xxxx&#x27;,</span><br><span class=\"line\">      ImgdialogVisible: false,</span><br><span class=\"line\">      option: &#123;</span><br><span class=\"line\">        img: &#x27;&#x27;, // 裁剪图片的地址</span><br><span class=\"line\">        info: true, // 裁剪框的大小信息</span><br><span class=\"line\">        outputSize: 0.8, // 裁剪生成图片的质量</span><br><span class=\"line\">        outputType: &#x27;jpeg&#x27;, // 裁剪生成图片的格式</span><br><span class=\"line\">        canScale: true, // 图片是否允许滚轮缩放</span><br><span class=\"line\">        autoCrop: true, // 是否默认生成截图框</span><br><span class=\"line\">        fixedBox: true, // 固定截图框大小 不允许改变</span><br><span class=\"line\">        fixed: true, // 是否开启截图框宽高固定比例</span><br><span class=\"line\">        fixedNumber: [1, 1], // 截图框的宽高比例</span><br><span class=\"line\">        full: true, // 是否输出原图比例的截图</span><br><span class=\"line\">        canMoveBox: false, // 截图框能否拖动</span><br><span class=\"line\">        original: false, // 上传图片按照原始比例渲染</span><br><span class=\"line\">        centerBox: true, // 截图框是否被限制在图片里面</span><br><span class=\"line\">        infoTrue: true, // true 为展示真实输出图片宽高 false 展示看到的截图框宽高</span><br><span class=\"line\">        mode: &#x27;contain&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getSliceImg () &#123;</span><br><span class=\"line\">      this.$refs.cropper.getCropBlob(async (data) =&gt; &#123;</span><br><span class=\"line\">        const imgSize = await this.getImgSize(data)</span><br><span class=\"line\">        /* 把blob对象和最终图像的size传给父组件 */</span><br><span class=\"line\">        this.$emit(&#x27;upload&#x27;, &#123; file: data, imgSize &#125;)</span><br><span class=\"line\">        this.ImgdialogVisible = false</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 处理element upload组件change事件 */</span><br><span class=\"line\">    handleChange (file) &#123;</span><br><span class=\"line\">      this.openImgDialog(file.raw)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 打开裁剪页面 */</span><br><span class=\"line\">    openImgDialog (file) &#123;</span><br><span class=\"line\">      let reader = new FileReader()</span><br><span class=\"line\">      reader.onload = (theFile) =&gt; &#123;</span><br><span class=\"line\">        this.option.img = theFile.target.result</span><br><span class=\"line\">        this.ImgdialogVisible = true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (file) &#123;</span><br><span class=\"line\">        reader.readAsDataURL(file)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /* 计算图片大小 */</span><br><span class=\"line\">    getImgSize (file) &#123;</span><br><span class=\"line\">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        let reader = new FileReader()</span><br><span class=\"line\">        reader.onload = function (theFile) &#123;</span><br><span class=\"line\">          let image = new Image()</span><br><span class=\"line\">          image.src = theFile.target.result</span><br><span class=\"line\">          image.onload = function () &#123;</span><br><span class=\"line\">            resolve(&#123;</span><br><span class=\"line\">              width: this.width,</span><br><span class=\"line\">              height: this.height</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (file) &#123;</span><br><span class=\"line\">          reader.readAsDataURL(file)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          reject(&#x27;出错了&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题总结\"><a href=\"#问题总结\" class=\"headerlink\" title=\"问题总结\"></a>问题总结</h1><p>问题一、如何阻止upload上传完之后就上传？　　<br>将el-upload 的 auto-upload 设置为 false即可<br>问题二、如何将获取到文件传给vue-cropper?　　<br>vue-cropper 可以接受一个 blob，此时需要 new FileReader()，参考 MDN<br>问题三、el-upload 选择完文件后不能更改，如何上传裁剪之后的图片？<br>使用自定义上传，点击上传时直接调用submit 方法，这时会自动触发http-request中的自定义方法，可以拿到file中的所有属性，在函数里面使用 axios 自定义上传参数和文件。此方法比较好控制。</p>\n"},{"title":"vue3-hooks使用","date":"2022-10-25T15:21:17.000Z","_content":"# 我们来说一下vue3 项目中的 hooks 的使用\nhooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。\n一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n这两者主要的区别，主要是 hooks 是函数。\n\n# 我们先看一下hooks优点有哪些？\nhooks 特点：\n1. vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。\n2. vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。\n3. hooks 函数可以与 mixin 连用，但是不建议。\n\n# hooks 基本使用\n![](案例1.png)\n我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。\n如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。\n但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。\n\n# 我们针对上面的案例，我们使用 hooks 简单的实现一下。\n首先，我们在 src 文件夹下创建一个 hooks 文件夹。\n在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件\n接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。\n![](案例2.png)\n然后在需要使用 hooks 的文件引入就可以使用了。\n![](案例3.png)\n","source":"_posts/vue3-hooks使用.md","raw":"---\ntitle: vue3-hooks使用\ndate: 2022-10-25 23:21:17\ntags: vue3\ncategories: vue3\n---\n# 我们来说一下vue3 项目中的 hooks 的使用\nhooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。\n一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n这两者主要的区别，主要是 hooks 是函数。\n\n# 我们先看一下hooks优点有哪些？\nhooks 特点：\n1. vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。\n2. vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。\n3. hooks 函数可以与 mixin 连用，但是不建议。\n\n# hooks 基本使用\n![](案例1.png)\n我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。\n如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。\n但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。\n\n# 我们针对上面的案例，我们使用 hooks 简单的实现一下。\n首先，我们在 src 文件夹下创建一个 hooks 文件夹。\n在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件\n接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。\n![](案例2.png)\n然后在需要使用 hooks 的文件引入就可以使用了。\n![](案例3.png)\n","slug":"vue3-hooks使用","published":1,"updated":"2023-03-22T06:18:54.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml7001ltit830etb747","content":"<h1 id=\"我们来说一下vue3-项目中的-hooks-的使用\"><a href=\"#我们来说一下vue3-项目中的-hooks-的使用\" class=\"headerlink\" title=\"我们来说一下vue3 项目中的 hooks 的使用\"></a>我们来说一下vue3 项目中的 hooks 的使用</h1><p>hooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。<br>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>这两者主要的区别，主要是 hooks 是函数。</p>\n<h1 id=\"我们先看一下hooks优点有哪些？\"><a href=\"#我们先看一下hooks优点有哪些？\" class=\"headerlink\" title=\"我们先看一下hooks优点有哪些？\"></a>我们先看一下hooks优点有哪些？</h1><p>hooks 特点：</p>\n<ol>\n<li>vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。</li>\n<li>vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。</li>\n<li>hooks 函数可以与 mixin 连用，但是不建议。</li>\n</ol>\n<h1 id=\"hooks-基本使用\"><a href=\"#hooks-基本使用\" class=\"headerlink\" title=\"hooks 基本使用\"></a>hooks 基本使用</h1><p><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。<br>如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。<br>但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。</p>\n<h1 id=\"我们针对上面的案例，我们使用-hooks-简单的实现一下。\"><a href=\"#我们针对上面的案例，我们使用-hooks-简单的实现一下。\" class=\"headerlink\" title=\"我们针对上面的案例，我们使用 hooks 简单的实现一下。\"></a>我们针对上面的案例，我们使用 hooks 简单的实现一下。</h1><p>首先，我们在 src 文件夹下创建一个 hooks 文件夹。<br>在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件<br>接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。<br><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>然后在需要使用 hooks 的文件引入就可以使用了。<br><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B3.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"我们来说一下vue3-项目中的-hooks-的使用\"><a href=\"#我们来说一下vue3-项目中的-hooks-的使用\" class=\"headerlink\" title=\"我们来说一下vue3 项目中的 hooks 的使用\"></a>我们来说一下vue3 项目中的 hooks 的使用</h1><p>hooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。<br>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>这两者主要的区别，主要是 hooks 是函数。</p>\n<h1 id=\"我们先看一下hooks优点有哪些？\"><a href=\"#我们先看一下hooks优点有哪些？\" class=\"headerlink\" title=\"我们先看一下hooks优点有哪些？\"></a>我们先看一下hooks优点有哪些？</h1><p>hooks 特点：</p>\n<ol>\n<li>vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。</li>\n<li>vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。</li>\n<li>hooks 函数可以与 mixin 连用，但是不建议。</li>\n</ol>\n<h1 id=\"hooks-基本使用\"><a href=\"#hooks-基本使用\" class=\"headerlink\" title=\"hooks 基本使用\"></a>hooks 基本使用</h1><p><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B1.png\"><br>我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。<br>如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。<br>但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。</p>\n<h1 id=\"我们针对上面的案例，我们使用-hooks-简单的实现一下。\"><a href=\"#我们针对上面的案例，我们使用-hooks-简单的实现一下。\" class=\"headerlink\" title=\"我们针对上面的案例，我们使用 hooks 简单的实现一下。\"></a>我们针对上面的案例，我们使用 hooks 简单的实现一下。</h1><p>首先，我们在 src 文件夹下创建一个 hooks 文件夹。<br>在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件<br>接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。<br><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B2.png\"><br>然后在需要使用 hooks 的文件引入就可以使用了。<br><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B3.png\"></p>\n"},{"title":"vue3","date":"2022-10-10T12:17:33.000Z","_content":"# vue3 简介\n1. vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。\n2. 3.0版本的vue，开发周期长达两年多。\n3. 3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。\n# Vue3 的优势\n1. 3比2要快将近两倍。\n2. 3加入了TS以及对PWA的支持。\n3. 3没有beforeCreate、created，用setup代替。\n4. 单独功能可以抽离，比如watch、component。\n5. 没有眼花缭乱的this。\n6. 强大的proxy实现响应式。\n7. 响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。\n8. 3的组合式API可以和2的 optionAPI同时存在。\n9. 代码更利于维护和封装。","source":"_posts/vue3.md","raw":"---\ntitle: vue3\ndate: 2022-10-10 20:17:33\ntags: vue3\ncategories: vue3\n---\n# vue3 简介\n1. vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。\n2. 3.0版本的vue，开发周期长达两年多。\n3. 3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。\n# Vue3 的优势\n1. 3比2要快将近两倍。\n2. 3加入了TS以及对PWA的支持。\n3. 3没有beforeCreate、created，用setup代替。\n4. 单独功能可以抽离，比如watch、component。\n5. 没有眼花缭乱的this。\n6. 强大的proxy实现响应式。\n7. 响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。\n8. 3的组合式API可以和2的 optionAPI同时存在。\n9. 代码更利于维护和封装。","slug":"vue3","published":1,"updated":"2023-03-22T06:24:35.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml7001ptit8gy1ec892","content":"<h1 id=\"vue3-简介\"><a href=\"#vue3-简介\" class=\"headerlink\" title=\"vue3 简介\"></a>vue3 简介</h1><ol>\n<li>vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。</li>\n<li>3.0版本的vue，开发周期长达两年多。</li>\n<li>3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。<h1 id=\"Vue3-的优势\"><a href=\"#Vue3-的优势\" class=\"headerlink\" title=\"Vue3 的优势\"></a>Vue3 的优势</h1></li>\n<li>3比2要快将近两倍。</li>\n<li>3加入了TS以及对PWA的支持。</li>\n<li>3没有beforeCreate、created，用setup代替。</li>\n<li>单独功能可以抽离，比如watch、component。</li>\n<li>没有眼花缭乱的this。</li>\n<li>强大的proxy实现响应式。</li>\n<li>响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。</li>\n<li>3的组合式API可以和2的 optionAPI同时存在。</li>\n<li>代码更利于维护和封装。</li>\n</ol>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"vue3-简介\"><a href=\"#vue3-简介\" class=\"headerlink\" title=\"vue3 简介\"></a>vue3 简介</h1><ol>\n<li>vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。</li>\n<li>3.0版本的vue，开发周期长达两年多。</li>\n<li>3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。<h1 id=\"Vue3-的优势\"><a href=\"#Vue3-的优势\" class=\"headerlink\" title=\"Vue3 的优势\"></a>Vue3 的优势</h1></li>\n<li>3比2要快将近两倍。</li>\n<li>3加入了TS以及对PWA的支持。</li>\n<li>3没有beforeCreate、created，用setup代替。</li>\n<li>单独功能可以抽离，比如watch、component。</li>\n<li>没有眼花缭乱的this。</li>\n<li>强大的proxy实现响应式。</li>\n<li>响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。</li>\n<li>3的组合式API可以和2的 optionAPI同时存在。</li>\n<li>代码更利于维护和封装。</li>\n</ol>\n"},{"title":"vue3API","date":"2022-12-13T13:10:12.000Z","_content":"为什么要使用setup组合?\nVue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。\n\nVue3中使用 setup 是如何解决这一问题的呢？\n第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；\n第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。\n\n1、ref\n作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。\n背后：ref 的背后是使用 reactive 来实现的响应式.\n语法：const x = ref(100)\n访问：在 setup 中使用 .value 来访问。\n![](案例1.png)\n\n2、isRef\n作用：判断一个变量是否为一个ref对象。\n语法：const bol = isRef(x)\n![](案例2.png)\n\n3、unref\n作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。\n语法：const x = unref(y)\n![](案例3.png)\n\n4、customRef\n作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。\n![](案例4.png)\n\n5、toRef\n作用：把一个 reactive对象中的某个属性变成 ref 变量。\n语法：const x = toRef(reactive(obj), 'key') // x.value\n![](案例5.png)\n\n6、toRefs\n作用：把一个reactive响应式对象变成ref变量。\n语法：const obj1 = toRefs(reactive(obj))\n应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。\n![](案例6.png)\n\n7、shallowRef\n作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)\n语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。\n![](案例7.png)\n\n8、triggerRef\n作用：强制更新一个 shallowRef对象的渲染。\n语法：triggerRef(shallowRef对象)\n参考代码：见shallowRef示例。\n\n9、reactive\n作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。\n语法：const info = reactive([] | {})\n![](案例9.png)\n\n10、readonly\n作用：把一个对象，变成只读的。\n语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)\n![](案例10.png)\n\n11、isReadonly\n作用: 判断一个变量是不是只读的。\n语法：const bol = isReadonly(变量)\n![](案例11.png)\n\n12、isReactive\n作用：判断一变量是不是 reactive的。\n注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。\n![](案例12.png)\n\n13、isProxy\n作用：判断一个变量是不是 readonly 或 reactive的。\n![](案例13.png)\n\n14、toRaw\n作用：得到返回 reactive变量或 readonly变量的\"原始对象\"。\n语法:：const raw = toRaw(reactive变量或readonly变量)\n说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。\n![](案例14.png)\n\n15、markRaw\n作用：把一个普通对象标记成\"永久原始\"，从此将无法再变成proxy了。\n语法：const raw = markRaw({a,b})\n![](案例15.png)\n\n16、shallowReactive\n作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。\n语法：const obj = shallowReactive({a:{b:9}})\n![](案例16.png)\n\n17、shallowReadonly\n作用：定义一个reactive变量，只有第一层是只读的。\n语法：const obj = shallowReadonly({a:{b:9}})\n![](案例17.png)\n\n18、computed\n作用：对响应式变量进行缓存计算。\n语法：const c = computed(fn / {get,set})\n![](案例18.png)\n\n19、watch\n作用：用于监听响应式变量的变化，组件初始化时，它不执行。\n语法：const stop = watch(x, (new,old)=>{})，调用stop() 可以停止监听。\n语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=>{})，调用stop()可以停止监听。\n![](案例19.png)\n\n20、watchEffect\n作用：相当于是 react中的 useEffect()，用于执行各种副作用。\n语法：const stop = watchEffect(fn)，默认其 flush:'pre'，前置执行的副作用。\nwatchPostEffect，等价于 watchEffect(fn, {flush:'post'})，后置执行的副作用。\nwatchSyncEffect，等价于 watchEffect(fn, {flush:'sync'})，同步执行的副作用。\n特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。\n![](案例20.png)\n\n21、生命周期钩子\n选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。\n选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。\n新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。\n在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。\n![](案例21.png)\n\n22、provide / inject\n作用：在组件树中自上而下地传递数据.\n语法：provide('key', value)\n语法：const value = inject('key', '默认值')\n![](案例22.png)\n\n23、getCurrentInstance\n作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。\n语法：const app = getCurrentInstance()\n场景：常用于访问 app.config.globalProperties 上的全局数据。\n![](案例23.png)\n\n24、关于setup代码范式\n只使用 setup 及组合API，不要再使用vue选项了。\n有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。\n能用 vite就尽量使用vite，能用ts 就尽量使用ts。\n\n","source":"_posts/vue3API.md","raw":"---\ntitle: vue3API\ndate: 2022-12-13 21:10:12\ntags: vue3\ncategories: vue3\n---\n为什么要使用setup组合?\nVue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。\n\nVue3中使用 setup 是如何解决这一问题的呢？\n第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；\n第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。\n\n1、ref\n作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。\n背后：ref 的背后是使用 reactive 来实现的响应式.\n语法：const x = ref(100)\n访问：在 setup 中使用 .value 来访问。\n![](案例1.png)\n\n2、isRef\n作用：判断一个变量是否为一个ref对象。\n语法：const bol = isRef(x)\n![](案例2.png)\n\n3、unref\n作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。\n语法：const x = unref(y)\n![](案例3.png)\n\n4、customRef\n作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。\n![](案例4.png)\n\n5、toRef\n作用：把一个 reactive对象中的某个属性变成 ref 变量。\n语法：const x = toRef(reactive(obj), 'key') // x.value\n![](案例5.png)\n\n6、toRefs\n作用：把一个reactive响应式对象变成ref变量。\n语法：const obj1 = toRefs(reactive(obj))\n应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。\n![](案例6.png)\n\n7、shallowRef\n作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)\n语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。\n![](案例7.png)\n\n8、triggerRef\n作用：强制更新一个 shallowRef对象的渲染。\n语法：triggerRef(shallowRef对象)\n参考代码：见shallowRef示例。\n\n9、reactive\n作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。\n语法：const info = reactive([] | {})\n![](案例9.png)\n\n10、readonly\n作用：把一个对象，变成只读的。\n语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)\n![](案例10.png)\n\n11、isReadonly\n作用: 判断一个变量是不是只读的。\n语法：const bol = isReadonly(变量)\n![](案例11.png)\n\n12、isReactive\n作用：判断一变量是不是 reactive的。\n注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。\n![](案例12.png)\n\n13、isProxy\n作用：判断一个变量是不是 readonly 或 reactive的。\n![](案例13.png)\n\n14、toRaw\n作用：得到返回 reactive变量或 readonly变量的\"原始对象\"。\n语法:：const raw = toRaw(reactive变量或readonly变量)\n说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。\n![](案例14.png)\n\n15、markRaw\n作用：把一个普通对象标记成\"永久原始\"，从此将无法再变成proxy了。\n语法：const raw = markRaw({a,b})\n![](案例15.png)\n\n16、shallowReactive\n作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。\n语法：const obj = shallowReactive({a:{b:9}})\n![](案例16.png)\n\n17、shallowReadonly\n作用：定义一个reactive变量，只有第一层是只读的。\n语法：const obj = shallowReadonly({a:{b:9}})\n![](案例17.png)\n\n18、computed\n作用：对响应式变量进行缓存计算。\n语法：const c = computed(fn / {get,set})\n![](案例18.png)\n\n19、watch\n作用：用于监听响应式变量的变化，组件初始化时，它不执行。\n语法：const stop = watch(x, (new,old)=>{})，调用stop() 可以停止监听。\n语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=>{})，调用stop()可以停止监听。\n![](案例19.png)\n\n20、watchEffect\n作用：相当于是 react中的 useEffect()，用于执行各种副作用。\n语法：const stop = watchEffect(fn)，默认其 flush:'pre'，前置执行的副作用。\nwatchPostEffect，等价于 watchEffect(fn, {flush:'post'})，后置执行的副作用。\nwatchSyncEffect，等价于 watchEffect(fn, {flush:'sync'})，同步执行的副作用。\n特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。\n![](案例20.png)\n\n21、生命周期钩子\n选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。\n选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。\n新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。\n在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。\n![](案例21.png)\n\n22、provide / inject\n作用：在组件树中自上而下地传递数据.\n语法：provide('key', value)\n语法：const value = inject('key', '默认值')\n![](案例22.png)\n\n23、getCurrentInstance\n作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。\n语法：const app = getCurrentInstance()\n场景：常用于访问 app.config.globalProperties 上的全局数据。\n![](案例23.png)\n\n24、关于setup代码范式\n只使用 setup 及组合API，不要再使用vue选项了。\n有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。\n能用 vite就尽量使用vite，能用ts 就尽量使用ts。\n\n","slug":"vue3API","published":1,"updated":"2022-12-19T08:43:34.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml7001stit8ej7d5f4w","content":"<p>为什么要使用setup组合?<br>Vue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。</p>\n<p>Vue3中使用 setup 是如何解决这一问题的呢？<br>第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；<br>第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。</p>\n<p>1、ref<br>作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。<br>背后：ref 的背后是使用 reactive 来实现的响应式.<br>语法：const x = ref(100)<br>访问：在 setup 中使用 .value 来访问。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>2、isRef<br>作用：判断一个变量是否为一个ref对象。<br>语法：const bol = isRef(x)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>3、unref<br>作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。<br>语法：const x = unref(y)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B3.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>4、customRef<br>作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B4.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>5、toRef<br>作用：把一个 reactive对象中的某个属性变成 ref 变量。<br>语法：const x = toRef(reactive(obj), ‘key’) // x.value<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B5.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>6、toRefs<br>作用：把一个reactive响应式对象变成ref变量。<br>语法：const obj1 = toRefs(reactive(obj))<br>应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B6.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>7、shallowRef<br>作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)<br>语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B7.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>8、triggerRef<br>作用：强制更新一个 shallowRef对象的渲染。<br>语法：triggerRef(shallowRef对象)<br>参考代码：见shallowRef示例。</p>\n<p>9、reactive<br>作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。<br>语法：const info = reactive([] | {})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B9.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>10、readonly<br>作用：把一个对象，变成只读的。<br>语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B10.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>11、isReadonly<br>作用: 判断一个变量是不是只读的。<br>语法：const bol = isReadonly(变量)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B11.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>12、isReactive<br>作用：判断一变量是不是 reactive的。<br>注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B12.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>13、isProxy<br>作用：判断一个变量是不是 readonly 或 reactive的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B13.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>14、toRaw<br>作用：得到返回 reactive变量或 readonly变量的”原始对象”。<br>语法:：const raw = toRaw(reactive变量或readonly变量)<br>说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B14.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>15、markRaw<br>作用：把一个普通对象标记成”永久原始”，从此将无法再变成proxy了。<br>语法：const raw = markRaw({a,b})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B15.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>16、shallowReactive<br>作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。<br>语法：const obj = shallowReactive({a:{b:9}})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B16.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>17、shallowReadonly<br>作用：定义一个reactive变量，只有第一层是只读的。<br>语法：const obj = shallowReadonly({a:{b:9}})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B17.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>18、computed<br>作用：对响应式变量进行缓存计算。<br>语法：const c = computed(fn / {get,set})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B18.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>19、watch<br>作用：用于监听响应式变量的变化，组件初始化时，它不执行。<br>语法：const stop = watch(x, (new,old)=&gt;{})，调用stop() 可以停止监听。<br>语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=&gt;{})，调用stop()可以停止监听。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B19.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>20、watchEffect<br>作用：相当于是 react中的 useEffect()，用于执行各种副作用。<br>语法：const stop = watchEffect(fn)，默认其 flush:’pre’，前置执行的副作用。<br>watchPostEffect，等价于 watchEffect(fn, {flush:’post’})，后置执行的副作用。<br>watchSyncEffect，等价于 watchEffect(fn, {flush:’sync’})，同步执行的副作用。<br>特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B20.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>21、生命周期钩子<br>选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。<br>选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。<br>新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。<br>在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B21.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>22、provide / inject<br>作用：在组件树中自上而下地传递数据.<br>语法：provide(‘key’, value)<br>语法：const value = inject(‘key’, ‘默认值’)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B22.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>23、getCurrentInstance<br>作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。<br>语法：const app = getCurrentInstance()<br>场景：常用于访问 app.config.globalProperties 上的全局数据。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B23.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<p>24、关于setup代码范式<br>只使用 setup 及组合API，不要再使用vue选项了。<br>有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。<br>能用 vite就尽量使用vite，能用ts 就尽量使用ts。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>为什么要使用setup组合?<br>Vue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。</p>\n<p>Vue3中使用 setup 是如何解决这一问题的呢？<br>第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；<br>第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。</p>\n<p>1、ref<br>作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。<br>背后：ref 的背后是使用 reactive 来实现的响应式.<br>语法：const x = ref(100)<br>访问：在 setup 中使用 .value 来访问。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B1.png\"></p>\n<p>2、isRef<br>作用：判断一个变量是否为一个ref对象。<br>语法：const bol = isRef(x)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B2.png\"></p>\n<p>3、unref<br>作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。<br>语法：const x = unref(y)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B3.png\"></p>\n<p>4、customRef<br>作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B4.png\"></p>\n<p>5、toRef<br>作用：把一个 reactive对象中的某个属性变成 ref 变量。<br>语法：const x = toRef(reactive(obj), ‘key’) // x.value<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B5.png\"></p>\n<p>6、toRefs<br>作用：把一个reactive响应式对象变成ref变量。<br>语法：const obj1 = toRefs(reactive(obj))<br>应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B6.png\"></p>\n<p>7、shallowRef<br>作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)<br>语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B7.png\"></p>\n<p>8、triggerRef<br>作用：强制更新一个 shallowRef对象的渲染。<br>语法：triggerRef(shallowRef对象)<br>参考代码：见shallowRef示例。</p>\n<p>9、reactive<br>作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。<br>语法：const info = reactive([] | {})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B9.png\"></p>\n<p>10、readonly<br>作用：把一个对象，变成只读的。<br>语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B10.png\"></p>\n<p>11、isReadonly<br>作用: 判断一个变量是不是只读的。<br>语法：const bol = isReadonly(变量)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B11.png\"></p>\n<p>12、isReactive<br>作用：判断一变量是不是 reactive的。<br>注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B12.png\"></p>\n<p>13、isProxy<br>作用：判断一个变量是不是 readonly 或 reactive的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B13.png\"></p>\n<p>14、toRaw<br>作用：得到返回 reactive变量或 readonly变量的”原始对象”。<br>语法:：const raw = toRaw(reactive变量或readonly变量)<br>说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B14.png\"></p>\n<p>15、markRaw<br>作用：把一个普通对象标记成”永久原始”，从此将无法再变成proxy了。<br>语法：const raw = markRaw({a,b})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B15.png\"></p>\n<p>16、shallowReactive<br>作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。<br>语法：const obj = shallowReactive({a:{b:9}})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B16.png\"></p>\n<p>17、shallowReadonly<br>作用：定义一个reactive变量，只有第一层是只读的。<br>语法：const obj = shallowReadonly({a:{b:9}})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B17.png\"></p>\n<p>18、computed<br>作用：对响应式变量进行缓存计算。<br>语法：const c = computed(fn / {get,set})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B18.png\"></p>\n<p>19、watch<br>作用：用于监听响应式变量的变化，组件初始化时，它不执行。<br>语法：const stop = watch(x, (new,old)=&gt;{})，调用stop() 可以停止监听。<br>语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=&gt;{})，调用stop()可以停止监听。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B19.png\"></p>\n<p>20、watchEffect<br>作用：相当于是 react中的 useEffect()，用于执行各种副作用。<br>语法：const stop = watchEffect(fn)，默认其 flush:’pre’，前置执行的副作用。<br>watchPostEffect，等价于 watchEffect(fn, {flush:’post’})，后置执行的副作用。<br>watchSyncEffect，等价于 watchEffect(fn, {flush:’sync’})，同步执行的副作用。<br>特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B20.png\"></p>\n<p>21、生命周期钩子<br>选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。<br>选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。<br>新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。<br>在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B21.png\"></p>\n<p>22、provide / inject<br>作用：在组件树中自上而下地传递数据.<br>语法：provide(‘key’, value)<br>语法：const value = inject(‘key’, ‘默认值’)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B22.png\"></p>\n<p>23、getCurrentInstance<br>作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。<br>语法：const app = getCurrentInstance()<br>场景：常用于访问 app.config.globalProperties 上的全局数据。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B23.png\"></p>\n<p>24、关于setup代码范式<br>只使用 setup 及组合API，不要再使用vue选项了。<br>有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。<br>能用 vite就尽量使用vite，能用ts 就尽量使用ts。</p>\n"},{"title":"vue3ref和reactive函数","date":"2022-10-13T09:11:20.000Z","_content":"# ref 函数介绍\n1. ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。\n2. 通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。\n3. 在vue2当中，通过给元素添加 ref='xxx'然后使用refs.xxx的方式来获取元素，vue3也可以。\n4. 当 ref 里面的值发生变化的时候，视图会自动更新数据。\n5. ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。\n\n## ref 函数使用\n使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。\n\n## ref 函数处理基本数据类型\n首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。\n![](ref基本数据类型代码.png)\n刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！\n![](ref基本出错.png)\n![](ref基本控制台.png)\n为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。\n![](ref结构.png)\n修改代码：\n![](ref修改代码.png)\n码刷新页面查看效果\n![](ref基本修改成功.png)\n有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。\n\n## ref 函数处理复杂数据类型\n不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。\n例如我们写一个案例，创建一个个人信息，放到对象里面展示\n![](ref复杂数据代码.png)\n我们先看一下对象被 ref 函数包裹后的数据结构。\n![](ref复杂结构.png)\n我们修改也通过 value 进行操作\n![](ref复杂修改代码.png)\n刷新页面，查看效果\n![](ref复杂修改代码成功.png)\n\n## ref 函数获取单个DOM元素\n和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。\n页面上有一个标签，点击按钮，获取标签的相关数据。\n![](refdom代码.png)\n运行效果\n![](ref成功.png)\n![](ref打印.png)\n\n# reactive 函数介绍\n上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。\n\n## reactive 函数使用\nreactive 函数处理对象\nreactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息\n![](reactive对象代码.png)\n![](reactive对象结果.png)\n有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。\n![](reactive修改代码.png)\n![](reactive对象修改结果.png)\n\n## reactive 函数处理数组\n处理数组的方式和处理对象的方式是一样一样的\n![](reactive数组代码.png)\n![](reactive数组处理结果.png)\n\n\n","source":"_posts/vue3ref和reactive函数.md","raw":"---\ntitle: vue3ref和reactive函数\ndate: 2022-10-13 17:11:20\ntags: vue3\ncategories: vue3\n---\n# ref 函数介绍\n1. ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。\n2. 通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。\n3. 在vue2当中，通过给元素添加 ref='xxx'然后使用refs.xxx的方式来获取元素，vue3也可以。\n4. 当 ref 里面的值发生变化的时候，视图会自动更新数据。\n5. ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。\n\n## ref 函数使用\n使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。\n\n## ref 函数处理基本数据类型\n首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。\n![](ref基本数据类型代码.png)\n刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！\n![](ref基本出错.png)\n![](ref基本控制台.png)\n为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。\n![](ref结构.png)\n修改代码：\n![](ref修改代码.png)\n码刷新页面查看效果\n![](ref基本修改成功.png)\n有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。\n\n## ref 函数处理复杂数据类型\n不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。\n例如我们写一个案例，创建一个个人信息，放到对象里面展示\n![](ref复杂数据代码.png)\n我们先看一下对象被 ref 函数包裹后的数据结构。\n![](ref复杂结构.png)\n我们修改也通过 value 进行操作\n![](ref复杂修改代码.png)\n刷新页面，查看效果\n![](ref复杂修改代码成功.png)\n\n## ref 函数获取单个DOM元素\n和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。\n页面上有一个标签，点击按钮，获取标签的相关数据。\n![](refdom代码.png)\n运行效果\n![](ref成功.png)\n![](ref打印.png)\n\n# reactive 函数介绍\n上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。\n\n## reactive 函数使用\nreactive 函数处理对象\nreactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息\n![](reactive对象代码.png)\n![](reactive对象结果.png)\n有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。\n![](reactive修改代码.png)\n![](reactive对象修改结果.png)\n\n## reactive 函数处理数组\n处理数组的方式和处理对象的方式是一样一样的\n![](reactive数组代码.png)\n![](reactive数组处理结果.png)\n\n\n","slug":"vue3ref和reactive函数","published":1,"updated":"2023-03-22T06:26:35.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml8001vtit85nz2hhka","content":"<h1 id=\"ref-函数介绍\"><a href=\"#ref-函数介绍\" class=\"headerlink\" title=\"ref 函数介绍\"></a>ref 函数介绍</h1><ol>\n<li>ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。</li>\n<li>通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。</li>\n<li>在vue2当中，通过给元素添加 ref=’xxx’然后使用refs.xxx的方式来获取元素，vue3也可以。</li>\n<li>当 ref 里面的值发生变化的时候，视图会自动更新数据。</li>\n<li>ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。</li>\n</ol>\n<h2 id=\"ref-函数使用\"><a href=\"#ref-函数使用\" class=\"headerlink\" title=\"ref 函数使用\"></a>ref 函数使用</h2><p>使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。</p>\n<h2 id=\"ref-函数处理基本数据类型\"><a href=\"#ref-函数处理基本数据类型\" class=\"headerlink\" title=\"ref 函数处理基本数据类型\"></a>ref 函数处理基本数据类型</h2><p>首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E5%87%BA%E9%94%99.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8F%B0.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E7%BB%93%E6%9E%84.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>修改代码：<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>码刷新页面查看效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。</p>\n<h2 id=\"ref-函数处理复杂数据类型\"><a href=\"#ref-函数处理复杂数据类型\" class=\"headerlink\" title=\"ref 函数处理复杂数据类型\"></a>ref 函数处理复杂数据类型</h2><p>不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。<br>例如我们写一个案例，创建一个个人信息，放到对象里面展示<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们先看一下对象被 ref 函数包裹后的数据结构。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>我们修改也通过 value 进行操作<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>刷新页面，查看效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%88%90%E5%8A%9F.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h2 id=\"ref-函数获取单个DOM元素\"><a href=\"#ref-函数获取单个DOM元素\" class=\"headerlink\" title=\"ref 函数获取单个DOM元素\"></a>ref 函数获取单个DOM元素</h2><p>和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。<br>页面上有一个标签，点击按钮，获取标签的相关数据。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/refdom%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>运行效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%88%90%E5%8A%9F.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%89%93%E5%8D%B0.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"reactive-函数介绍\"><a href=\"#reactive-函数介绍\" class=\"headerlink\" title=\"reactive 函数介绍\"></a>reactive 函数介绍</h1><p>上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。</p>\n<h2 id=\"reactive-函数使用\"><a href=\"#reactive-函数使用\" class=\"headerlink\" title=\"reactive 函数使用\"></a>reactive 函数使用</h2><p>reactive 函数处理对象<br>reactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h2 id=\"reactive-函数处理数组\"><a href=\"#reactive-函数处理数组\" class=\"headerlink\" title=\"reactive 函数处理数组\"></a>reactive 函数处理数组</h2><p>处理数组的方式和处理对象的方式是一样一样的<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"ref-函数介绍\"><a href=\"#ref-函数介绍\" class=\"headerlink\" title=\"ref 函数介绍\"></a>ref 函数介绍</h1><ol>\n<li>ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。</li>\n<li>通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。</li>\n<li>在vue2当中，通过给元素添加 ref=’xxx’然后使用refs.xxx的方式来获取元素，vue3也可以。</li>\n<li>当 ref 里面的值发生变化的时候，视图会自动更新数据。</li>\n<li>ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。</li>\n</ol>\n<h2 id=\"ref-函数使用\"><a href=\"#ref-函数使用\" class=\"headerlink\" title=\"ref 函数使用\"></a>ref 函数使用</h2><p>使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。</p>\n<h2 id=\"ref-函数处理基本数据类型\"><a href=\"#ref-函数处理基本数据类型\" class=\"headerlink\" title=\"ref 函数处理基本数据类型\"></a>ref 函数处理基本数据类型</h2><p>首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81.png\"><br>刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E5%87%BA%E9%94%99.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8F%B0.png\"><br>为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E7%BB%93%E6%9E%84.png\"><br>修改代码：<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>码刷新页面查看效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png\"><br>有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。</p>\n<h2 id=\"ref-函数处理复杂数据类型\"><a href=\"#ref-函数处理复杂数据类型\" class=\"headerlink\" title=\"ref 函数处理复杂数据类型\"></a>ref 函数处理复杂数据类型</h2><p>不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。<br>例如我们写一个案例，创建一个个人信息，放到对象里面展示<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>我们先看一下对象被 ref 函数包裹后的数据结构。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84.png\"><br>我们修改也通过 value 进行操作<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，查看效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%88%90%E5%8A%9F.png\"></p>\n<h2 id=\"ref-函数获取单个DOM元素\"><a href=\"#ref-函数获取单个DOM元素\" class=\"headerlink\" title=\"ref 函数获取单个DOM元素\"></a>ref 函数获取单个DOM元素</h2><p>和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。<br>页面上有一个标签，点击按钮，获取标签的相关数据。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/refdom%E4%BB%A3%E7%A0%81.png\"><br>运行效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%88%90%E5%8A%9F.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%89%93%E5%8D%B0.png\"></p>\n<h1 id=\"reactive-函数介绍\"><a href=\"#reactive-函数介绍\" class=\"headerlink\" title=\"reactive 函数介绍\"></a>reactive 函数介绍</h1><p>上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。</p>\n<h2 id=\"reactive-函数使用\"><a href=\"#reactive-函数使用\" class=\"headerlink\" title=\"reactive 函数使用\"></a>reactive 函数使用</h2><p>reactive 函数处理对象<br>reactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%9C.png\"><br>有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"></p>\n<h2 id=\"reactive-函数处理数组\"><a href=\"#reactive-函数处理数组\" class=\"headerlink\" title=\"reactive 函数处理数组\"></a>reactive 函数处理数组</h2><p>处理数组的方式和处理对象的方式是一样一样的<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"vue3组件传值","date":"2022-10-20T14:39:21.000Z","_content":"# 父子组件传值 props\n父组件\n![](父组件代码.png)\n子组件\n![](子组件代码.png)\n![](子传父结果.png)\n\n# 祖孙组件传值 provide 和 inject\n父组件\n![](父组件二代码.png)\n子组件\n![](子组件二代码.png)\n![](祖孙结果.png)\n\n# 父组件中点击按钮向子组件传值\n父组件\n![](父组件三代码.png)\n子组件\n![](子组件三代码.png)\n![](传值前结果.png)\n![](传值后结果.png)\n\n","source":"_posts/vue3组件传值.md","raw":"---\ntitle: vue3组件传值\ndate: 2022-10-20 22:39:21\ntags: vue3\ncategories: vue3\n---\n# 父子组件传值 props\n父组件\n![](父组件代码.png)\n子组件\n![](子组件代码.png)\n![](子传父结果.png)\n\n# 祖孙组件传值 provide 和 inject\n父组件\n![](父组件二代码.png)\n子组件\n![](子组件二代码.png)\n![](祖孙结果.png)\n\n# 父组件中点击按钮向子组件传值\n父组件\n![](父组件三代码.png)\n子组件\n![](子组件三代码.png)\n![](传值前结果.png)\n![](传值后结果.png)\n\n","slug":"vue3组件传值","published":1,"updated":"2023-03-22T06:25:44.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml8001ytit8fjii9lvf","content":"<h1 id=\"父子组件传值-props\"><a href=\"#父子组件传值-props\" class=\"headerlink\" title=\"父子组件传值 props\"></a>父子组件传值 props</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E4%BC%A0%E7%88%B6%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"祖孙组件传值-provide-和-inject\"><a href=\"#祖孙组件传值-provide-和-inject\" class=\"headerlink\" title=\"祖孙组件传值 provide 和 inject\"></a>祖孙组件传值 provide 和 inject</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%A5%96%E5%AD%99%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n<h1 id=\"父组件中点击按钮向子组件传值\"><a href=\"#父组件中点击按钮向子组件传值\" class=\"headerlink\" title=\"父组件中点击按钮向子组件传值\"></a>父组件中点击按钮向子组件传值</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%89%8D%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%90%8E%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"父子组件传值-props\"><a href=\"#父子组件传值-props\" class=\"headerlink\" title=\"父子组件传值 props\"></a>父子组件传值 props</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E4%BC%A0%E7%88%B6%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"祖孙组件传值-provide-和-inject\"><a href=\"#祖孙组件传值-provide-和-inject\" class=\"headerlink\" title=\"祖孙组件传值 provide 和 inject\"></a>祖孙组件传值 provide 和 inject</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%A5%96%E5%AD%99%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"父组件中点击按钮向子组件传值\"><a href=\"#父组件中点击按钮向子组件传值\" class=\"headerlink\" title=\"父组件中点击按钮向子组件传值\"></a>父组件中点击按钮向子组件传值</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%89%8D%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%90%8E%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"vue3新语法细节","date":"2023-01-10T10:40:55.000Z","_content":"1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。\n\n2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。\n\n3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。\n\n4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。\n\n5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。\n\n6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。\n\n7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。\n\n8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。\n\n9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。\n\n10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。\n\n11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 `@vitejs/plugin-vue-jsx` 插件来支持 JSX语法，那么定义函数式组件就更加方便了。\n\n12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。\n\n13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。\n\n14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。\n\n15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。\n\n","source":"_posts/vue3新语法细节.md","raw":"---\ntitle: vue3新语法细节\ndate: 2023-01-10 18:40:55\ntags: vue3\ncategories: vue3\n---\n1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。\n\n2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。\n\n3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。\n\n4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。\n\n5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。\n\n6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。\n\n7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。\n\n8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。\n\n9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。\n\n10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。\n\n11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 `@vitejs/plugin-vue-jsx` 插件来支持 JSX语法，那么定义函数式组件就更加方便了。\n\n12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。\n\n13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。\n\n14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。\n\n15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。\n\n","slug":"vue3新语法细节","published":1,"updated":"2023-01-10T10:43:16.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml80021tit8e1ymconk","content":"<p>1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。</p>\n<p>2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。</p>\n<p>3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。</p>\n<p>4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。</p>\n<p>5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。</p>\n<p>6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。</p>\n<p>7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。</p>\n<p>8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。</p>\n<p>9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。</p>\n<p>10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。</p>\n<p>11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 <code>@vitejs/plugin-vue-jsx</code> 插件来支持 JSX语法，那么定义函数式组件就更加方便了。</p>\n<p>12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。</p>\n<p>13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。</p>\n<p>14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。</p>\n<p>15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。</p>\n<p>2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。</p>\n<p>3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。</p>\n<p>4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。</p>\n<p>5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。</p>\n<p>6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。</p>\n<p>7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。</p>\n<p>8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。</p>\n<p>9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。</p>\n<p>10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。</p>\n<p>11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 <code>@vitejs/plugin-vue-jsx</code> 插件来支持 JSX语法，那么定义函数式组件就更加方便了。</p>\n<p>12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。</p>\n<p>13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。</p>\n<p>14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。</p>\n<p>15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。</p>\n"},{"title":"webpack","date":"2022-08-30T06:25:44.000Z","_content":"# webpack 打包原理是什么？\n## 打包原理\nwebpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。\n## webpack构建流程：\n初始化参数—>开始编译---->确定入口---->编译模块—>完成编译---->输出数据---->输出完成\n## 优势：\n代码层面：\n1. 体积更小，加载更快\n2. 编译高级语言和语法\n3. 兼容性和错误检查\n## 研发流程层面：\n1.统一高效的开发环境\n2.统一的构建流程和产出标准\n3.集成公司构建规范（提测、上线）\n## 核心概念：\nentry：入口，webpack的执行从entry开始，\noutput：出口，输出结果，webpack的输出位置，\nloader：模块转换器，用于把webpack不能直接打包的文件类型转换\nplugins：插件，用于把模块原内容按需求转换成新内容,mode：通过选择development或者production来设置mode参数\nchunk：代码块，即打包后输出的文件\n## 基本功能和工作原理\n当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括\n1.代码转换：将无法直接运行的文件代码编译成可以执行的代码\n2.文件优化：压缩文件代码、压缩合并图片等\n3.代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载\n4.模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件\n5.自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器\n6.代码校验：在代码被提交前需要校验代码格式等是否符合规范\n7.自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统\n# 常见问题\n### 1、loader和plugin的区别：\n### 不同的作用：\nloader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具\nplugins：插件，可以扩展fwebpack的功能，让其更具有灵活性\n### 不同的用法：\nloader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，\nplugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入\n### 2、什么事模块化，为什么要用模块化\n模块化是指把一个复杂的系统分解到多个模块以方便编码\n不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码\n### 3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。\n```\ndevServer: {\n    contentBase: resolve(__dirname, 'build'),\n    compress: true,\n    port: 3000,\n    open: true,\n    // 开启HMR功能\n    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务\n    hot: true\n  }\n```\n### 4、什么是HMR功能\nHMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览\n优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式\n### 5、什么是Tree-sharking?\n指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等\n### 6、babel和webpack的区别\nbabel JS新语法编译工具，只关心语法，不关心模块化\nwebpack -打包构建工具，是多个Loader plugin的集合\n### 7、类似webpack的工具还有哪些\n(1)、webpack适用于大型复杂的前端站点构建\n(2)、rollup适用于基础库的打包，如vue、react\n(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel\n### 8、常见loader\nfile-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去\nbabel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。\n### 9、常见的plugins\ndefine-plugin：定义环境变量\ncommons-chunk-plugin：提取公共代码\nuglifyjs-webpack-plugin：通过UglifyES压缩ES6代码","source":"_posts/webpack.md","raw":"---\ntitle: webpack\ndate: 2022-08-30 14:25:44\ntags: webpack\ncategories: 知识点\n---\n# webpack 打包原理是什么？\n## 打包原理\nwebpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。\n## webpack构建流程：\n初始化参数—>开始编译---->确定入口---->编译模块—>完成编译---->输出数据---->输出完成\n## 优势：\n代码层面：\n1. 体积更小，加载更快\n2. 编译高级语言和语法\n3. 兼容性和错误检查\n## 研发流程层面：\n1.统一高效的开发环境\n2.统一的构建流程和产出标准\n3.集成公司构建规范（提测、上线）\n## 核心概念：\nentry：入口，webpack的执行从entry开始，\noutput：出口，输出结果，webpack的输出位置，\nloader：模块转换器，用于把webpack不能直接打包的文件类型转换\nplugins：插件，用于把模块原内容按需求转换成新内容,mode：通过选择development或者production来设置mode参数\nchunk：代码块，即打包后输出的文件\n## 基本功能和工作原理\n当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括\n1.代码转换：将无法直接运行的文件代码编译成可以执行的代码\n2.文件优化：压缩文件代码、压缩合并图片等\n3.代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载\n4.模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件\n5.自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器\n6.代码校验：在代码被提交前需要校验代码格式等是否符合规范\n7.自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统\n# 常见问题\n### 1、loader和plugin的区别：\n### 不同的作用：\nloader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具\nplugins：插件，可以扩展fwebpack的功能，让其更具有灵活性\n### 不同的用法：\nloader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，\nplugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入\n### 2、什么事模块化，为什么要用模块化\n模块化是指把一个复杂的系统分解到多个模块以方便编码\n不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码\n### 3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。\n```\ndevServer: {\n    contentBase: resolve(__dirname, 'build'),\n    compress: true,\n    port: 3000,\n    open: true,\n    // 开启HMR功能\n    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务\n    hot: true\n  }\n```\n### 4、什么是HMR功能\nHMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览\n优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式\n### 5、什么是Tree-sharking?\n指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等\n### 6、babel和webpack的区别\nbabel JS新语法编译工具，只关心语法，不关心模块化\nwebpack -打包构建工具，是多个Loader plugin的集合\n### 7、类似webpack的工具还有哪些\n(1)、webpack适用于大型复杂的前端站点构建\n(2)、rollup适用于基础库的打包，如vue、react\n(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel\n### 8、常见loader\nfile-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去\nbabel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。\n### 9、常见的plugins\ndefine-plugin：定义环境变量\ncommons-chunk-plugin：提取公共代码\nuglifyjs-webpack-plugin：通过UglifyES压缩ES6代码","slug":"webpack","published":1,"updated":"2023-04-10T02:38:22.245Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml80024tit85jgf3iq2","content":"<h1 id=\"webpack-打包原理是什么？\"><a href=\"#webpack-打包原理是什么？\" class=\"headerlink\" title=\"webpack 打包原理是什么？\"></a>webpack 打包原理是什么？</h1><h2 id=\"打包原理\"><a href=\"#打包原理\" class=\"headerlink\" title=\"打包原理\"></a>打包原理</h2><p>webpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。</p>\n<h2 id=\"webpack构建流程：\"><a href=\"#webpack构建流程：\" class=\"headerlink\" title=\"webpack构建流程：\"></a>webpack构建流程：</h2><p>初始化参数—&gt;开始编译—-&gt;确定入口—-&gt;编译模块—&gt;完成编译—-&gt;输出数据—-&gt;输出完成</p>\n<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><p>代码层面：</p>\n<ol>\n<li>体积更小，加载更快</li>\n<li>编译高级语言和语法</li>\n<li>兼容性和错误检查<h2 id=\"研发流程层面：\"><a href=\"#研发流程层面：\" class=\"headerlink\" title=\"研发流程层面：\"></a>研发流程层面：</h2></li>\n<li>统一高效的开发环境</li>\n<li>统一的构建流程和产出标准</li>\n<li>集成公司构建规范（提测、上线）<h2 id=\"核心概念：\"><a href=\"#核心概念：\" class=\"headerlink\" title=\"核心概念：\"></a>核心概念：</h2>entry：入口，webpack的执行从entry开始，<br>output：出口，输出结果，webpack的输出位置，<br>loader：模块转换器，用于把webpack不能直接打包的文件类型转换<br>plugins：插件，用于把模块原内容按需求转换成新内容,mode：通过选择development或者production来设置mode参数<br>chunk：代码块，即打包后输出的文件<h2 id=\"基本功能和工作原理\"><a href=\"#基本功能和工作原理\" class=\"headerlink\" title=\"基本功能和工作原理\"></a>基本功能和工作原理</h2>当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括</li>\n<li>代码转换：将无法直接运行的文件代码编译成可以执行的代码</li>\n<li>文件优化：压缩文件代码、压缩合并图片等</li>\n<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载</li>\n<li>模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件</li>\n<li>自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器</li>\n<li>代码校验：在代码被提交前需要校验代码格式等是否符合规范</li>\n<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h3 id=\"1、loader和plugin的区别：\"><a href=\"#1、loader和plugin的区别：\" class=\"headerlink\" title=\"1、loader和plugin的区别：\"></a>1、loader和plugin的区别：</h3><h3 id=\"不同的作用：\"><a href=\"#不同的作用：\" class=\"headerlink\" title=\"不同的作用：\"></a>不同的作用：</h3>loader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具<br>plugins：插件，可以扩展fwebpack的功能，让其更具有灵活性<h3 id=\"不同的用法：\"><a href=\"#不同的用法：\" class=\"headerlink\" title=\"不同的用法：\"></a>不同的用法：</h3>loader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，<br>plugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入<h3 id=\"2、什么事模块化，为什么要用模块化\"><a href=\"#2、什么事模块化，为什么要用模块化\" class=\"headerlink\" title=\"2、什么事模块化，为什么要用模块化\"></a>2、什么事模块化，为什么要用模块化</h3>模块化是指把一个复杂的系统分解到多个模块以方便编码<br>不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码<h3 id=\"3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。\"><a href=\"#3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。\" class=\"headerlink\" title=\"3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。\"></a>3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    contentBase: resolve(__dirname, &#x27;build&#x27;),</span><br><span class=\"line\">    compress: true,</span><br><span class=\"line\">    port: 3000,</span><br><span class=\"line\">    open: true,</span><br><span class=\"line\">    // 开启HMR功能</span><br><span class=\"line\">    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务</span><br><span class=\"line\">    hot: true</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、什么是HMR功能\"><a href=\"#4、什么是HMR功能\" class=\"headerlink\" title=\"4、什么是HMR功能\"></a>4、什么是HMR功能</h3>HMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览<br>优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式<h3 id=\"5、什么是Tree-sharking\"><a href=\"#5、什么是Tree-sharking\" class=\"headerlink\" title=\"5、什么是Tree-sharking?\"></a>5、什么是Tree-sharking?</h3>指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等<h3 id=\"6、babel和webpack的区别\"><a href=\"#6、babel和webpack的区别\" class=\"headerlink\" title=\"6、babel和webpack的区别\"></a>6、babel和webpack的区别</h3>babel JS新语法编译工具，只关心语法，不关心模块化<br>webpack -打包构建工具，是多个Loader plugin的集合<h3 id=\"7、类似webpack的工具还有哪些\"><a href=\"#7、类似webpack的工具还有哪些\" class=\"headerlink\" title=\"7、类似webpack的工具还有哪些\"></a>7、类似webpack的工具还有哪些</h3>(1)、webpack适用于大型复杂的前端站点构建<br>(2)、rollup适用于基础库的打包，如vue、react<br>(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel<h3 id=\"8、常见loader\"><a href=\"#8、常见loader\" class=\"headerlink\" title=\"8、常见loader\"></a>8、常见loader</h3>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<h3 id=\"9、常见的plugins\"><a href=\"#9、常见的plugins\" class=\"headerlink\" title=\"9、常见的plugins\"></a>9、常见的plugins</h3>define-plugin：定义环境变量<br>commons-chunk-plugin：提取公共代码<br>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li>\n</ol>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"webpack-打包原理是什么？\"><a href=\"#webpack-打包原理是什么？\" class=\"headerlink\" title=\"webpack 打包原理是什么？\"></a>webpack 打包原理是什么？</h1><h2 id=\"打包原理\"><a href=\"#打包原理\" class=\"headerlink\" title=\"打包原理\"></a>打包原理</h2><p>webpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。</p>\n<h2 id=\"webpack构建流程：\"><a href=\"#webpack构建流程：\" class=\"headerlink\" title=\"webpack构建流程：\"></a>webpack构建流程：</h2><p>初始化参数—&gt;开始编译—-&gt;确定入口—-&gt;编译模块—&gt;完成编译—-&gt;输出数据—-&gt;输出完成</p>\n<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><p>代码层面：</p>\n<ol>\n<li>体积更小，加载更快</li>\n<li>编译高级语言和语法</li>\n<li>兼容性和错误检查<h2 id=\"研发流程层面：\"><a href=\"#研发流程层面：\" class=\"headerlink\" title=\"研发流程层面：\"></a>研发流程层面：</h2></li>\n<li>统一高效的开发环境</li>\n<li>统一的构建流程和产出标准</li>\n<li>集成公司构建规范（提测、上线）<h2 id=\"核心概念：\"><a href=\"#核心概念：\" class=\"headerlink\" title=\"核心概念：\"></a>核心概念：</h2>entry：入口，webpack的执行从entry开始，<br>output：出口，输出结果，webpack的输出位置，<br>loader：模块转换器，用于把webpack不能直接打包的文件类型转换<br>plugins：插件，用于把模块原内容按需求转换成新内容,mode：通过选择development或者production来设置mode参数<br>chunk：代码块，即打包后输出的文件<h2 id=\"基本功能和工作原理\"><a href=\"#基本功能和工作原理\" class=\"headerlink\" title=\"基本功能和工作原理\"></a>基本功能和工作原理</h2>当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括</li>\n<li>代码转换：将无法直接运行的文件代码编译成可以执行的代码</li>\n<li>文件优化：压缩文件代码、压缩合并图片等</li>\n<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载</li>\n<li>模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件</li>\n<li>自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器</li>\n<li>代码校验：在代码被提交前需要校验代码格式等是否符合规范</li>\n<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h3 id=\"1、loader和plugin的区别：\"><a href=\"#1、loader和plugin的区别：\" class=\"headerlink\" title=\"1、loader和plugin的区别：\"></a>1、loader和plugin的区别：</h3><h3 id=\"不同的作用：\"><a href=\"#不同的作用：\" class=\"headerlink\" title=\"不同的作用：\"></a>不同的作用：</h3>loader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具<br>plugins：插件，可以扩展fwebpack的功能，让其更具有灵活性<h3 id=\"不同的用法：\"><a href=\"#不同的用法：\" class=\"headerlink\" title=\"不同的用法：\"></a>不同的用法：</h3>loader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，<br>plugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入<h3 id=\"2、什么事模块化，为什么要用模块化\"><a href=\"#2、什么事模块化，为什么要用模块化\" class=\"headerlink\" title=\"2、什么事模块化，为什么要用模块化\"></a>2、什么事模块化，为什么要用模块化</h3>模块化是指把一个复杂的系统分解到多个模块以方便编码<br>不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码<h3 id=\"3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。\"><a href=\"#3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。\" class=\"headerlink\" title=\"3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。\"></a>3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    contentBase: resolve(__dirname, &#x27;build&#x27;),</span><br><span class=\"line\">    compress: true,</span><br><span class=\"line\">    port: 3000,</span><br><span class=\"line\">    open: true,</span><br><span class=\"line\">    // 开启HMR功能</span><br><span class=\"line\">    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务</span><br><span class=\"line\">    hot: true</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、什么是HMR功能\"><a href=\"#4、什么是HMR功能\" class=\"headerlink\" title=\"4、什么是HMR功能\"></a>4、什么是HMR功能</h3>HMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览<br>优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式<h3 id=\"5、什么是Tree-sharking\"><a href=\"#5、什么是Tree-sharking\" class=\"headerlink\" title=\"5、什么是Tree-sharking?\"></a>5、什么是Tree-sharking?</h3>指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等<h3 id=\"6、babel和webpack的区别\"><a href=\"#6、babel和webpack的区别\" class=\"headerlink\" title=\"6、babel和webpack的区别\"></a>6、babel和webpack的区别</h3>babel JS新语法编译工具，只关心语法，不关心模块化<br>webpack -打包构建工具，是多个Loader plugin的集合<h3 id=\"7、类似webpack的工具还有哪些\"><a href=\"#7、类似webpack的工具还有哪些\" class=\"headerlink\" title=\"7、类似webpack的工具还有哪些\"></a>7、类似webpack的工具还有哪些</h3>(1)、webpack适用于大型复杂的前端站点构建<br>(2)、rollup适用于基础库的打包，如vue、react<br>(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel<h3 id=\"8、常见loader\"><a href=\"#8、常见loader\" class=\"headerlink\" title=\"8、常见loader\"></a>8、常见loader</h3>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<h3 id=\"9、常见的plugins\"><a href=\"#9、常见的plugins\" class=\"headerlink\" title=\"9、常见的plugins\"></a>9、常见的plugins</h3>define-plugin：定义环境变量<br>commons-chunk-plugin：提取公共代码<br>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li>\n</ol>\n"},{"title":"webpack升级","date":"2023-04-05T08:15:20.000Z","cover":["/images/webpackcover.png"],"banner":{"type":"img","bgurl":["/images/webpackcover.png"]},"_content":"# 一、背景\n由于项目越来越庞大复杂，打包时间也非常长，本地开发环境每次重启都要打包好久，正好借此契机对webpack做了一个升级。\n# 二、webpack5 和 webpack4 的区别有哪些 ？\n## Tree Shaking\n### 作用：\n如果我们的项目中引入了lodash包，但是我只用了其中的一个方法。其他没有用到的方法是不是冗余的？此时tree-shaking就可以把没有用的那些东西剔除掉，来减少最终的bundle体积。\nusedExports : true, 标记没有用的叶子\nminimize: true, 摇掉那些没有用的叶子\n```\n// webpack.config.js中\n  module.exports = {\n     optimization: {\n       usedExports: true, //只导出被使用的模块\n       minimize : true // 启动压缩\n     }\n  }\n```\n由于tree shaking只支持esmodule ，如果你打包出来的是commonjs，此时tree-shaking就失效了。不过当前大家都用的是vue，react等框架，他们都是用babel-loader编译，以下配置就能够保证他一定是esmodule。\n![](webpack4.png)\nwebpack5的 mode=“production” 自动开启 tree-shaking。\n## 压缩代码\n+ webpack4\nwebpack4需要下载安装terser-webpack-plugin 插件，并且需要以下配置\n```\nconst TerserPlugin = require('terser-webpack-plugin')\nmodule.exports = { \n// ...other config\noptimization: {\n  minimize: !isDev,\n  minimizer: [\n    new TerserPlugin({\n      extractComments: false, \n      terserOptions: { \n        compress: { \n          pure_funcs: ['console.log'] \n        }\n      }\n    }) \n   ]\n }\n}\n```\n+ webpack5\n内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。\n如果你要在开发环境使用，就用下面：\n```\n// webpack.config.js中\n  module.exports = {\n     optimization: {\n       usedExports: true, //只导出被使用的模块\n       minimize : true // 启动压缩\n     }\n  }\n```\n+ js 压缩失效问题\n当你下载 optimize-css-assets-webpack-plugin ，执行 css 压缩以后，你会发现 webpack5 默认的 js 压缩功能失效了。先说 optimize-css-assets-webpack-plugin 的配置：\n```\nnpm install optimize-css-assets-webpack-plugin -D\n```\n```\nmodule.exports = { \n  optimization: { \n    minimizer: [ \n      new OptimizeCssAssetsPlugin() \n    ]\n  },\n}\n```\n此时的压缩插件optimize-css-assets-webpack-plugin可以配置到plugins里面去，也可以如图配置到到 optimization里面。区别如下：\n配置到plugins中，那么这个插件在任何情况下都会工作。而配置在optimization表示只有minimize为 true 的时候才能工作。\n当安装 optimize-css-assets-webpack-plugin 以后你去打包会发现原来可以压缩的 js 文件，现在不能压缩了。原因是你指定的压缩器是optimize-css-assets-webpack-plugin\n导致默认的terser-webpack-plugin就会失效。解决办法如下：\n```\nnpm install terser-webpack-plugin -D\n```\n```\noptimization: {\n    minimizer: [\n      new TerserPlugin({\n        extractComments: false,\n        terserOptions: {\n          compress: { pure_funcs: ['console.log'] },\n        },\n      }),\n      new OptimiazeCssAssetPlugin(),\n    ]\n  }\n```\n即便在webpack5中，你也要像webpack4中一样使用js压缩。\n+ 注意事项\n在webpack5里面使用optimize-css-assets-webpack-plugin会报错，因为官方已经打算要废除了，请使用替换方案：\n```\nnpm i css-assets-webpack-plugin -D\n```\n## 合并模块\n普通打包只是将一个模块最终放到一个单独的立即执行函数中，如果你有很多模块，那么就有很多立即执行函数。concatenateModules可以要所有的模块都合并到一个函数里面去。\noptimization.concatenateModules = true\n配置如下：\n```\nmodule.exports = {\n  optimization: {\n    usedExports: true,\n    concatenateModules: true,\n    minimize: true\n  }\n}\n```\n此时配合 tree-shaking 你会发现打包的体积会减小很多。\n## 副作用sideEffects\n+ webpack4 新增了一个sideEffects的功能，允许我们通过配置来标识我们的代码是否有副作用。这个特性只有在开发npm包的时候用到。\n+ 副作用的解释： 在utils文件夹下面有index.js文件，用于系统导出utils里面其他文件，作用就是写的少，不管utils里面有多少方法，我都只需要引入utils即可。\n```\n// utils/index.js\n  export * from './getXXX.js';\n  export * from './getAAA.js';\n  export * from './getBBB.js';\n  export * from './getCCC.js';\n```\n```\n // 在其他文件使用 getXXX 引入\n  import {getXX} from '../utils'\n```\n+ 此时，如果文件getAAA在外界没有用到，而tree-shaking又不能把它摇掉怎么办？\n+ 这个getAAA就是副作用。你或许要问tree-shaking为什么不能把它摇掉？\n+ 原因就是：他在utils/index.js 里面使用了。只能开启副作用特性。如下：\n```\n// package.json中\n{\n  name：“项目名称”,\n  ....\n  sideEffects: false\n}\n```\n```\n// webpack.config.js\nmodule.exports = {\n  mode: 'none',\n  ....\n  optimization: {\n    sideEffects: true\n  }\n}\n```\n+ 副作用开启：\n(1)optimization.sideEffects = true 开启副作用功能\n(2)package.json 中设置 sideEffects : false 标记所有模块无副作用\n+ 说明： \nwebpack打包前都会检查项目所属的package.json文件中的sideEffects标识，如果没有副作用，那些没有用到的模块就不需要打包，反之亦然。此时，在webpack.config.js里面开启sideEffects。\n## webpack 缓存\n+ webpack4缓存配置\n支持缓存在内存中\n```\nnpm install hard-source-webpack-plugin -D\n```\n```\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin') \nmodule.exports = { \nplugins: [\n  // 其它 plugin... \n  new HardSourceWebpackPlugin(), \n] }\n```\n+ webpack5缓存配置\nwebpack5内部内置了cache缓存机制，直接配置即可。\ncache会在开发模式下被设置成type：memory而且会在生产模式把cache给禁用掉。\n```\n// webpack.config.js\nmodule.exports= {\n  // 使用持久化缓存\n  cache: {\n    type: 'filesystem'，\n    cacheDirectory: path.join(__dirname, 'node_modules/.cac/webpack')\n  }\n}\n```\n+ type的可选值为：memory使用内容缓存，filesystem使用文件缓存。\n+ 当type=filesystem的时候设置cacheDirectory才生效。用于设置你需要的东西缓存放在哪里。\n## 对loader的优化\nwebpack4加载资源需要用不同的loader\n+ raw-loader将文件导入为字符串\n+ url-loader将文件作为data url内联到bundle文件中\n+ file-loader将文件发送到输出目录中\n![](webpack4-1.png)\nwebpack5 的资源模块类型替换 loader\n资源模块类型(asset module type)，通过添加4种新的模块类型，来替换所有这些 loader：\n+ asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\n+ asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。\n+ asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。\n+ asset 在导出一个data URI和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\n![](webpack4-2.png)\n## 启动服务的差别\n+ webpack4 启动服务\n通过webpack-dev-server启动服务\n+ webpack5 启动服务\n内置使用webpack serve启动，但是它的日志不是很好，所以一般都加都喜欢用webpack-dev-server优化。\n## devtool的差别\nsourceMap需要在webpack.config.js里面直接配置devtool就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。\n一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。\ndevtool在webpack4和webpack5上也是有区别的\nv4: devtool: 'cheap-eval-module-source-map'\nv5: devtool: 'eval-cheap-module-source-map'\n## 热更新差别\n+ webpack4设置\n![](webpack4-3.png)\n+ webpack5设置\n如果你使用的是bable6，按照上述设置，你会发现热更新无效，需要添加配置：\n```\n module.hot.accept('需要热启动的文件',(source)=>{\n     //自定义热启动\n  })\n```\n当前最新版的babel里面的 babel-loader已经帮我们处理的热更新失效的问题。所以不必担心，直接使用即可。\n如果你引入 mini-css-extract-plugin 以后你会发现 样式的热更新也会失效。\n只能在开发环境使用style-loader，而在生产环境用MinicssExtractPlugin.loader。 如下：\n![](webpack5-1.png)\n## 使用 webpack-merge 的差别\n+ webpack4 导入\n```\nconst merge = require('webpack-merge);\n```\n+ webpack 5 导入\n```\nconst {merge} = require('webpack-merge');\n```\n## 使用 copy-webpack-plugin 的差别\n```\n//webpack.config.js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nmodule.exports = {\n  plugins: [\n    // webpack 4\n    new CopyWebpackPlugin(['public']),   \n    // webpack 5\n    new CopyWebpackPlugin({\n      patterns: [{\n        from: './public',\n        to: './dist/public'\n      }]\n    })\n  ]\n}\n```\nwebpack5支持的新版本里面需要配置的更加清楚。\n# 三、升级过程\nWebpack5对Node.js的版本要求至少是10.13.0\n## 先升级 webpack 和 webpack-cli\n```scss\nnpm install --save-dev webpack@latest webpack-cli@latest  webpack-dev-server@latest webpack-merge@latest\n```\nwebpack-merge升级以后，使用方式改为如下：\n```js\nconst webpackMerge = require(\"webpack-merge\");\n```\n```js\nconst { merge } = require('webpack-merge');\n```\n升级所有使用到的plugin和loader为最新的可用版本。\n部分plugin和loader可能会有一个beta版本，必须使用它们才能与webpack 5兼容。\n## 执行npm start\n在 package.json中scripts的start命令如下：\n```json\n\"scripts\": {\n    \"start\": \"cross-env NODE_ENV=dev webpack-dev-server --hot --progress --colors  --config ./webpack.dev.js\",\n}\n```\n### --colors 报错\n在v4版本中，我们可以使用 --colors或者 --color，但是在v5版本中只能使用 --color\n调整命令：\n```json\n\"scripts\": {\n    \"start\": \"cross-env NODE_ENV=dev webpack-dev-server --hot --progress --color  --config ./webpack.dev.js\",\n}\n```\n### devServer 中 disableHostCheck报错\n```\ndevServer: {\n    ... \n    disableHostCheck: true, \n    ... \n},\n```\n修改为：\n```\ndevServer: {\n    ... \n    allowedHosts: \"all\", \n    ... \n},\n```\n当设置为 'all' 时会跳过host检查。并不推荐这样做，因为不检查host的应用程序容易受到DNS重绑定攻击。\n### vue-loader问题\n注意 vue-loader不同的版本是对应VUE不同版本的，这里一定要注意，如果你的VUE版本是2.x那么你要使用vue-loader@15.x，如果是vue@3.x那么要使用vue-loader@16.x\n```js\n// vue-loader@16.x\n// 对应vue@3.x\nconst { VueLoaderPlugin } = require('vue-loader/dist/index');\nmodule.exports = {\n    plugins: [\n        new VueLoaderPlugin(),\n    ]\n}\n// vue-loader@15.x\n// 对应vue@2.x\nconst { VueLoaderPlugin } = require('vue-loader');\nmodule.exports = {\n    plugins: [\n        new VueLoaderPlugin(),\n    ]\n}\n```\n### webpack@5.x与vue-loader@16.x版本中间的一个报错问题,DescriptionDataMatcherRulePlugin | webpack5 报错问题\n解决方案\n1. DescriptionDataMatcherRulePlugin是出现在vue-loader里面的\n2. webpack@5里面为啥不见了，我去webpack源码里找，竟然把文件名给改了，然后vue-loader那边没有同步修改\n3. 解决方案：npm i webpack@5.44.0 -D 或者等vue-loader 更新\n### postcss-loader 问题\n```\nnpm install --save-dev autoprefixer\n```\n```js\n// 新的配置\nmodule.exports = {\n    module: {\n        rules: [\n            {\n                test: /\\.(c|sa|sc)ss$/,\n                use: [\n                     'vue-style-loader', // <style></style> 插入页面,development下使用\n                     'css-loader',\n                     {\n                        loader: 'postcss-loader',\n                        options: {\n                            postcssOptions: {\n                                plugins: [\n                                    [\n                                        // \"postcss-preset-env\", // postcss-preset-env 包含autoprefixer （npm install postcss-preset-env --save-dev）\n                                        // \"postcss-nested\",\n                                        \"autoprefixer\", // css 加前缀\n                                    ],\n                                ],\n                            },\n                        }\n                    },\n                    'sass-loader'\n                     \n                ]\n            }\n        ]\n    }\n}\n```\n### optimization 配置\nproduction\n```js\nmodule.exports = {\n    optimization: {\n        // 告知 webpack 当选择模块 id 时需要使用哪种算法\n        moduleIds: 'deterministic' // 被哈希转化成的小位数值模块名。\n    },\n}\n```\n### webpack-manifest-plugin\n```js\nconst { WebpackManifestPlugin } = require('webpack-manifest-plugin');\nnew WebpackManifestPlugin({\n    publicPath: '',\n    filter: function (FileDescriptor) {\n        return FileDescriptor.isChunk;\n    }\n})\n```","source":"_posts/webpack升级.md","raw":"---\ntitle: webpack升级\ndate: 2023-04-05 16:15:20\ntags: webpack\ncategories: webpack\ncover: [/images/webpackcover.png]\nbanner: \n  type: img\n  bgurl: [/images/webpackcover.png]\n---\n# 一、背景\n由于项目越来越庞大复杂，打包时间也非常长，本地开发环境每次重启都要打包好久，正好借此契机对webpack做了一个升级。\n# 二、webpack5 和 webpack4 的区别有哪些 ？\n## Tree Shaking\n### 作用：\n如果我们的项目中引入了lodash包，但是我只用了其中的一个方法。其他没有用到的方法是不是冗余的？此时tree-shaking就可以把没有用的那些东西剔除掉，来减少最终的bundle体积。\nusedExports : true, 标记没有用的叶子\nminimize: true, 摇掉那些没有用的叶子\n```\n// webpack.config.js中\n  module.exports = {\n     optimization: {\n       usedExports: true, //只导出被使用的模块\n       minimize : true // 启动压缩\n     }\n  }\n```\n由于tree shaking只支持esmodule ，如果你打包出来的是commonjs，此时tree-shaking就失效了。不过当前大家都用的是vue，react等框架，他们都是用babel-loader编译，以下配置就能够保证他一定是esmodule。\n![](webpack4.png)\nwebpack5的 mode=“production” 自动开启 tree-shaking。\n## 压缩代码\n+ webpack4\nwebpack4需要下载安装terser-webpack-plugin 插件，并且需要以下配置\n```\nconst TerserPlugin = require('terser-webpack-plugin')\nmodule.exports = { \n// ...other config\noptimization: {\n  minimize: !isDev,\n  minimizer: [\n    new TerserPlugin({\n      extractComments: false, \n      terserOptions: { \n        compress: { \n          pure_funcs: ['console.log'] \n        }\n      }\n    }) \n   ]\n }\n}\n```\n+ webpack5\n内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。\n如果你要在开发环境使用，就用下面：\n```\n// webpack.config.js中\n  module.exports = {\n     optimization: {\n       usedExports: true, //只导出被使用的模块\n       minimize : true // 启动压缩\n     }\n  }\n```\n+ js 压缩失效问题\n当你下载 optimize-css-assets-webpack-plugin ，执行 css 压缩以后，你会发现 webpack5 默认的 js 压缩功能失效了。先说 optimize-css-assets-webpack-plugin 的配置：\n```\nnpm install optimize-css-assets-webpack-plugin -D\n```\n```\nmodule.exports = { \n  optimization: { \n    minimizer: [ \n      new OptimizeCssAssetsPlugin() \n    ]\n  },\n}\n```\n此时的压缩插件optimize-css-assets-webpack-plugin可以配置到plugins里面去，也可以如图配置到到 optimization里面。区别如下：\n配置到plugins中，那么这个插件在任何情况下都会工作。而配置在optimization表示只有minimize为 true 的时候才能工作。\n当安装 optimize-css-assets-webpack-plugin 以后你去打包会发现原来可以压缩的 js 文件，现在不能压缩了。原因是你指定的压缩器是optimize-css-assets-webpack-plugin\n导致默认的terser-webpack-plugin就会失效。解决办法如下：\n```\nnpm install terser-webpack-plugin -D\n```\n```\noptimization: {\n    minimizer: [\n      new TerserPlugin({\n        extractComments: false,\n        terserOptions: {\n          compress: { pure_funcs: ['console.log'] },\n        },\n      }),\n      new OptimiazeCssAssetPlugin(),\n    ]\n  }\n```\n即便在webpack5中，你也要像webpack4中一样使用js压缩。\n+ 注意事项\n在webpack5里面使用optimize-css-assets-webpack-plugin会报错，因为官方已经打算要废除了，请使用替换方案：\n```\nnpm i css-assets-webpack-plugin -D\n```\n## 合并模块\n普通打包只是将一个模块最终放到一个单独的立即执行函数中，如果你有很多模块，那么就有很多立即执行函数。concatenateModules可以要所有的模块都合并到一个函数里面去。\noptimization.concatenateModules = true\n配置如下：\n```\nmodule.exports = {\n  optimization: {\n    usedExports: true,\n    concatenateModules: true,\n    minimize: true\n  }\n}\n```\n此时配合 tree-shaking 你会发现打包的体积会减小很多。\n## 副作用sideEffects\n+ webpack4 新增了一个sideEffects的功能，允许我们通过配置来标识我们的代码是否有副作用。这个特性只有在开发npm包的时候用到。\n+ 副作用的解释： 在utils文件夹下面有index.js文件，用于系统导出utils里面其他文件，作用就是写的少，不管utils里面有多少方法，我都只需要引入utils即可。\n```\n// utils/index.js\n  export * from './getXXX.js';\n  export * from './getAAA.js';\n  export * from './getBBB.js';\n  export * from './getCCC.js';\n```\n```\n // 在其他文件使用 getXXX 引入\n  import {getXX} from '../utils'\n```\n+ 此时，如果文件getAAA在外界没有用到，而tree-shaking又不能把它摇掉怎么办？\n+ 这个getAAA就是副作用。你或许要问tree-shaking为什么不能把它摇掉？\n+ 原因就是：他在utils/index.js 里面使用了。只能开启副作用特性。如下：\n```\n// package.json中\n{\n  name：“项目名称”,\n  ....\n  sideEffects: false\n}\n```\n```\n// webpack.config.js\nmodule.exports = {\n  mode: 'none',\n  ....\n  optimization: {\n    sideEffects: true\n  }\n}\n```\n+ 副作用开启：\n(1)optimization.sideEffects = true 开启副作用功能\n(2)package.json 中设置 sideEffects : false 标记所有模块无副作用\n+ 说明： \nwebpack打包前都会检查项目所属的package.json文件中的sideEffects标识，如果没有副作用，那些没有用到的模块就不需要打包，反之亦然。此时，在webpack.config.js里面开启sideEffects。\n## webpack 缓存\n+ webpack4缓存配置\n支持缓存在内存中\n```\nnpm install hard-source-webpack-plugin -D\n```\n```\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin') \nmodule.exports = { \nplugins: [\n  // 其它 plugin... \n  new HardSourceWebpackPlugin(), \n] }\n```\n+ webpack5缓存配置\nwebpack5内部内置了cache缓存机制，直接配置即可。\ncache会在开发模式下被设置成type：memory而且会在生产模式把cache给禁用掉。\n```\n// webpack.config.js\nmodule.exports= {\n  // 使用持久化缓存\n  cache: {\n    type: 'filesystem'，\n    cacheDirectory: path.join(__dirname, 'node_modules/.cac/webpack')\n  }\n}\n```\n+ type的可选值为：memory使用内容缓存，filesystem使用文件缓存。\n+ 当type=filesystem的时候设置cacheDirectory才生效。用于设置你需要的东西缓存放在哪里。\n## 对loader的优化\nwebpack4加载资源需要用不同的loader\n+ raw-loader将文件导入为字符串\n+ url-loader将文件作为data url内联到bundle文件中\n+ file-loader将文件发送到输出目录中\n![](webpack4-1.png)\nwebpack5 的资源模块类型替换 loader\n资源模块类型(asset module type)，通过添加4种新的模块类型，来替换所有这些 loader：\n+ asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\n+ asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。\n+ asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。\n+ asset 在导出一个data URI和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\n![](webpack4-2.png)\n## 启动服务的差别\n+ webpack4 启动服务\n通过webpack-dev-server启动服务\n+ webpack5 启动服务\n内置使用webpack serve启动，但是它的日志不是很好，所以一般都加都喜欢用webpack-dev-server优化。\n## devtool的差别\nsourceMap需要在webpack.config.js里面直接配置devtool就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。\n一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。\ndevtool在webpack4和webpack5上也是有区别的\nv4: devtool: 'cheap-eval-module-source-map'\nv5: devtool: 'eval-cheap-module-source-map'\n## 热更新差别\n+ webpack4设置\n![](webpack4-3.png)\n+ webpack5设置\n如果你使用的是bable6，按照上述设置，你会发现热更新无效，需要添加配置：\n```\n module.hot.accept('需要热启动的文件',(source)=>{\n     //自定义热启动\n  })\n```\n当前最新版的babel里面的 babel-loader已经帮我们处理的热更新失效的问题。所以不必担心，直接使用即可。\n如果你引入 mini-css-extract-plugin 以后你会发现 样式的热更新也会失效。\n只能在开发环境使用style-loader，而在生产环境用MinicssExtractPlugin.loader。 如下：\n![](webpack5-1.png)\n## 使用 webpack-merge 的差别\n+ webpack4 导入\n```\nconst merge = require('webpack-merge);\n```\n+ webpack 5 导入\n```\nconst {merge} = require('webpack-merge');\n```\n## 使用 copy-webpack-plugin 的差别\n```\n//webpack.config.js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nmodule.exports = {\n  plugins: [\n    // webpack 4\n    new CopyWebpackPlugin(['public']),   \n    // webpack 5\n    new CopyWebpackPlugin({\n      patterns: [{\n        from: './public',\n        to: './dist/public'\n      }]\n    })\n  ]\n}\n```\nwebpack5支持的新版本里面需要配置的更加清楚。\n# 三、升级过程\nWebpack5对Node.js的版本要求至少是10.13.0\n## 先升级 webpack 和 webpack-cli\n```scss\nnpm install --save-dev webpack@latest webpack-cli@latest  webpack-dev-server@latest webpack-merge@latest\n```\nwebpack-merge升级以后，使用方式改为如下：\n```js\nconst webpackMerge = require(\"webpack-merge\");\n```\n```js\nconst { merge } = require('webpack-merge');\n```\n升级所有使用到的plugin和loader为最新的可用版本。\n部分plugin和loader可能会有一个beta版本，必须使用它们才能与webpack 5兼容。\n## 执行npm start\n在 package.json中scripts的start命令如下：\n```json\n\"scripts\": {\n    \"start\": \"cross-env NODE_ENV=dev webpack-dev-server --hot --progress --colors  --config ./webpack.dev.js\",\n}\n```\n### --colors 报错\n在v4版本中，我们可以使用 --colors或者 --color，但是在v5版本中只能使用 --color\n调整命令：\n```json\n\"scripts\": {\n    \"start\": \"cross-env NODE_ENV=dev webpack-dev-server --hot --progress --color  --config ./webpack.dev.js\",\n}\n```\n### devServer 中 disableHostCheck报错\n```\ndevServer: {\n    ... \n    disableHostCheck: true, \n    ... \n},\n```\n修改为：\n```\ndevServer: {\n    ... \n    allowedHosts: \"all\", \n    ... \n},\n```\n当设置为 'all' 时会跳过host检查。并不推荐这样做，因为不检查host的应用程序容易受到DNS重绑定攻击。\n### vue-loader问题\n注意 vue-loader不同的版本是对应VUE不同版本的，这里一定要注意，如果你的VUE版本是2.x那么你要使用vue-loader@15.x，如果是vue@3.x那么要使用vue-loader@16.x\n```js\n// vue-loader@16.x\n// 对应vue@3.x\nconst { VueLoaderPlugin } = require('vue-loader/dist/index');\nmodule.exports = {\n    plugins: [\n        new VueLoaderPlugin(),\n    ]\n}\n// vue-loader@15.x\n// 对应vue@2.x\nconst { VueLoaderPlugin } = require('vue-loader');\nmodule.exports = {\n    plugins: [\n        new VueLoaderPlugin(),\n    ]\n}\n```\n### webpack@5.x与vue-loader@16.x版本中间的一个报错问题,DescriptionDataMatcherRulePlugin | webpack5 报错问题\n解决方案\n1. DescriptionDataMatcherRulePlugin是出现在vue-loader里面的\n2. webpack@5里面为啥不见了，我去webpack源码里找，竟然把文件名给改了，然后vue-loader那边没有同步修改\n3. 解决方案：npm i webpack@5.44.0 -D 或者等vue-loader 更新\n### postcss-loader 问题\n```\nnpm install --save-dev autoprefixer\n```\n```js\n// 新的配置\nmodule.exports = {\n    module: {\n        rules: [\n            {\n                test: /\\.(c|sa|sc)ss$/,\n                use: [\n                     'vue-style-loader', // <style></style> 插入页面,development下使用\n                     'css-loader',\n                     {\n                        loader: 'postcss-loader',\n                        options: {\n                            postcssOptions: {\n                                plugins: [\n                                    [\n                                        // \"postcss-preset-env\", // postcss-preset-env 包含autoprefixer （npm install postcss-preset-env --save-dev）\n                                        // \"postcss-nested\",\n                                        \"autoprefixer\", // css 加前缀\n                                    ],\n                                ],\n                            },\n                        }\n                    },\n                    'sass-loader'\n                     \n                ]\n            }\n        ]\n    }\n}\n```\n### optimization 配置\nproduction\n```js\nmodule.exports = {\n    optimization: {\n        // 告知 webpack 当选择模块 id 时需要使用哪种算法\n        moduleIds: 'deterministic' // 被哈希转化成的小位数值模块名。\n    },\n}\n```\n### webpack-manifest-plugin\n```js\nconst { WebpackManifestPlugin } = require('webpack-manifest-plugin');\nnew WebpackManifestPlugin({\n    publicPath: '',\n    filter: function (FileDescriptor) {\n        return FileDescriptor.isChunk;\n    }\n})\n```","slug":"webpack升级","published":1,"updated":"2023-04-11T06:23:28.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml80027tit8hikmhjqy","content":"<h1 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h1><p>由于项目越来越庞大复杂，打包时间也非常长，本地开发环境每次重启都要打包好久，正好借此契机对webpack做了一个升级。</p>\n<h1 id=\"二、webpack5-和-webpack4-的区别有哪些-？\"><a href=\"#二、webpack5-和-webpack4-的区别有哪些-？\" class=\"headerlink\" title=\"二、webpack5 和 webpack4 的区别有哪些 ？\"></a>二、webpack5 和 webpack4 的区别有哪些 ？</h1><h2 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h2><h3 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><p>如果我们的项目中引入了lodash包，但是我只用了其中的一个方法。其他没有用到的方法是不是冗余的？此时tree-shaking就可以把没有用的那些东西剔除掉，来减少最终的bundle体积。<br>usedExports : true, 标记没有用的叶子<br>minimize: true, 摇掉那些没有用的叶子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.config.js中</span><br><span class=\"line\">  module.exports = &#123;</span><br><span class=\"line\">     optimization: &#123;</span><br><span class=\"line\">       usedExports: true, //只导出被使用的模块</span><br><span class=\"line\">       minimize : true // 启动压缩</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>由于tree shaking只支持esmodule ，如果你打包出来的是commonjs，此时tree-shaking就失效了。不过当前大家都用的是vue，react等框架，他们都是用babel-loader编译，以下配置就能够保证他一定是esmodule。<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>webpack5的 mode=“production” 自动开启 tree-shaking。</p>\n<h2 id=\"压缩代码\"><a href=\"#压缩代码\" class=\"headerlink\" title=\"压缩代码\"></a>压缩代码</h2><ul>\n<li>webpack4<br>webpack4需要下载安装terser-webpack-plugin 插件，并且需要以下配置<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)</span><br><span class=\"line\">module.exports = &#123; </span><br><span class=\"line\">// ...other config</span><br><span class=\"line\">optimization: &#123;</span><br><span class=\"line\">  minimize: !isDev,</span><br><span class=\"line\">  minimizer: [</span><br><span class=\"line\">    new TerserPlugin(&#123;</span><br><span class=\"line\">      extractComments: false, </span><br><span class=\"line\">      terserOptions: &#123; </span><br><span class=\"line\">        compress: &#123; </span><br><span class=\"line\">          pure_funcs: [&#x27;console.log&#x27;] </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;) </span><br><span class=\"line\">   ]</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>webpack5<br>内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。<br>如果你要在开发环境使用，就用下面：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.config.js中</span><br><span class=\"line\">  module.exports = &#123;</span><br><span class=\"line\">     optimization: &#123;</span><br><span class=\"line\">       usedExports: true, //只导出被使用的模块</span><br><span class=\"line\">       minimize : true // 启动压缩</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n<li>js 压缩失效问题<br>当你下载 optimize-css-assets-webpack-plugin ，执行 css 压缩以后，你会发现 webpack5 默认的 js 压缩功能失效了。先说 optimize-css-assets-webpack-plugin 的配置：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123; </span><br><span class=\"line\">  optimization: &#123; </span><br><span class=\"line\">    minimizer: [ </span><br><span class=\"line\">      new OptimizeCssAssetsPlugin() </span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n此时的压缩插件optimize-css-assets-webpack-plugin可以配置到plugins里面去，也可以如图配置到到 optimization里面。区别如下：<br>配置到plugins中，那么这个插件在任何情况下都会工作。而配置在optimization表示只有minimize为 true 的时候才能工作。<br>当安装 optimize-css-assets-webpack-plugin 以后你去打包会发现原来可以压缩的 js 文件，现在不能压缩了。原因是你指定的压缩器是optimize-css-assets-webpack-plugin<br>导致默认的terser-webpack-plugin就会失效。解决办法如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install terser-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">optimization: &#123;</span><br><span class=\"line\">    minimizer: [</span><br><span class=\"line\">      new TerserPlugin(&#123;</span><br><span class=\"line\">        extractComments: false,</span><br><span class=\"line\">        terserOptions: &#123;</span><br><span class=\"line\">          compress: &#123; pure_funcs: [&#x27;console.log&#x27;] &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;),</span><br><span class=\"line\">      new OptimiazeCssAssetPlugin(),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n即便在webpack5中，你也要像webpack4中一样使用js压缩。</li>\n<li>注意事项<br>在webpack5里面使用optimize-css-assets-webpack-plugin会报错，因为官方已经打算要废除了，请使用替换方案：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<h2 id=\"合并模块\"><a href=\"#合并模块\" class=\"headerlink\" title=\"合并模块\"></a>合并模块</h2>普通打包只是将一个模块最终放到一个单独的立即执行函数中，如果你有很多模块，那么就有很多立即执行函数。concatenateModules可以要所有的模块都合并到一个函数里面去。<br>optimization.concatenateModules = true<br>配置如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    usedExports: true,</span><br><span class=\"line\">    concatenateModules: true,</span><br><span class=\"line\">    minimize: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n此时配合 tree-shaking 你会发现打包的体积会减小很多。<h2 id=\"副作用sideEffects\"><a href=\"#副作用sideEffects\" class=\"headerlink\" title=\"副作用sideEffects\"></a>副作用sideEffects</h2></li>\n<li>webpack4 新增了一个sideEffects的功能，允许我们通过配置来标识我们的代码是否有副作用。这个特性只有在开发npm包的时候用到。</li>\n<li>副作用的解释： 在utils文件夹下面有index.js文件，用于系统导出utils里面其他文件，作用就是写的少，不管utils里面有多少方法，我都只需要引入utils即可。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// utils/index.js</span><br><span class=\"line\">  export * from &#x27;./getXXX.js&#x27;;</span><br><span class=\"line\">  export * from &#x27;./getAAA.js&#x27;;</span><br><span class=\"line\">  export * from &#x27;./getBBB.js&#x27;;</span><br><span class=\"line\">  export * from &#x27;./getCCC.js&#x27;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 在其他文件使用 getXXX 引入</span><br><span class=\"line\"> import &#123;getXX&#125; from &#x27;../utils&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>此时，如果文件getAAA在外界没有用到，而tree-shaking又不能把它摇掉怎么办？</li>\n<li>这个getAAA就是副作用。你或许要问tree-shaking为什么不能把它摇掉？</li>\n<li>原因就是：他在utils/index.js 里面使用了。只能开启副作用特性。如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// package.json中</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  name：“项目名称”,</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  sideEffects: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  mode: &#x27;none&#x27;,</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    sideEffects: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>副作用开启：<br>(1)optimization.sideEffects = true 开启副作用功能<br>(2)package.json 中设置 sideEffects : false 标记所有模块无副作用</li>\n<li>说明：<br>webpack打包前都会检查项目所属的package.json文件中的sideEffects标识，如果没有副作用，那些没有用到的模块就不需要打包，反之亦然。此时，在webpack.config.js里面开启sideEffects。<h2 id=\"webpack-缓存\"><a href=\"#webpack-缓存\" class=\"headerlink\" title=\"webpack 缓存\"></a>webpack 缓存</h2></li>\n<li>webpack4缓存配置<br>支持缓存在内存中<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hard-source-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const HardSourceWebpackPlugin = require(&#x27;hard-source-webpack-plugin&#x27;) </span><br><span class=\"line\">module.exports = &#123; </span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  // 其它 plugin... </span><br><span class=\"line\">  new HardSourceWebpackPlugin(), </span><br><span class=\"line\">] &#125;</span><br></pre></td></tr></table></figure></li>\n<li>webpack5缓存配置<br>webpack5内部内置了cache缓存机制，直接配置即可。<br>cache会在开发模式下被设置成type：memory而且会在生产模式把cache给禁用掉。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.config.js</span><br><span class=\"line\">module.exports= &#123;</span><br><span class=\"line\">  // 使用持久化缓存</span><br><span class=\"line\">  cache: &#123;</span><br><span class=\"line\">    type: &#x27;filesystem&#x27;，</span><br><span class=\"line\">    cacheDirectory: path.join(__dirname, &#x27;node_modules/.cac/webpack&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>type的可选值为：memory使用内容缓存，filesystem使用文件缓存。</li>\n<li>当type=filesystem的时候设置cacheDirectory才生效。用于设置你需要的东西缓存放在哪里。<h2 id=\"对loader的优化\"><a href=\"#对loader的优化\" class=\"headerlink\" title=\"对loader的优化\"></a>对loader的优化</h2>webpack4加载资源需要用不同的loader</li>\n<li>raw-loader将文件导入为字符串</li>\n<li>url-loader将文件作为data url内联到bundle文件中</li>\n<li>file-loader将文件发送到输出目录中<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><br>webpack5 的资源模块类型替换 loader<br>资源模块类型(asset module type)，通过添加4种新的模块类型，来替换所有这些 loader：</li>\n<li>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。</li>\n<li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。</li>\n<li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。</li>\n<li>asset 在导出一个data URI和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-2.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><h2 id=\"启动服务的差别\"><a href=\"#启动服务的差别\" class=\"headerlink\" title=\"启动服务的差别\"></a>启动服务的差别</h2></li>\n<li>webpack4 启动服务<br>通过webpack-dev-server启动服务</li>\n<li>webpack5 启动服务<br>内置使用webpack serve启动，但是它的日志不是很好，所以一般都加都喜欢用webpack-dev-server优化。<h2 id=\"devtool的差别\"><a href=\"#devtool的差别\" class=\"headerlink\" title=\"devtool的差别\"></a>devtool的差别</h2>sourceMap需要在webpack.config.js里面直接配置devtool就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。<br>一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。<br>devtool在webpack4和webpack5上也是有区别的<br>v4: devtool: ‘cheap-eval-module-source-map’<br>v5: devtool: ‘eval-cheap-module-source-map’<h2 id=\"热更新差别\"><a href=\"#热更新差别\" class=\"headerlink\" title=\"热更新差别\"></a>热更新差别</h2></li>\n<li>webpack4设置<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-3.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></li>\n<li>webpack5设置<br>如果你使用的是bable6，按照上述设置，你会发现热更新无效，需要添加配置：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.hot.accept(&#x27;需要热启动的文件&#x27;,(source)=&gt;&#123;</span><br><span class=\"line\">    //自定义热启动</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n当前最新版的babel里面的 babel-loader已经帮我们处理的热更新失效的问题。所以不必担心，直接使用即可。<br>如果你引入 mini-css-extract-plugin 以后你会发现 样式的热更新也会失效。<br>只能在开发环境使用style-loader，而在生产环境用MinicssExtractPlugin.loader。 如下：<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack5-1.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'><h2 id=\"使用-webpack-merge-的差别\"><a href=\"#使用-webpack-merge-的差别\" class=\"headerlink\" title=\"使用 webpack-merge 的差别\"></a>使用 webpack-merge 的差别</h2></li>\n<li>webpack4 导入<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const merge = require(&#x27;webpack-merge);</span><br></pre></td></tr></table></figure></li>\n<li>webpack 5 导入<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;merge&#125; = require(&#x27;webpack-merge&#x27;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-copy-webpack-plugin-的差别\"><a href=\"#使用-copy-webpack-plugin-的差别\" class=\"headerlink\" title=\"使用 copy-webpack-plugin 的差别\"></a>使用 copy-webpack-plugin 的差别</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//webpack.config.js</span><br><span class=\"line\">const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // webpack 4</span><br><span class=\"line\">    new CopyWebpackPlugin([&#x27;public&#x27;]),   </span><br><span class=\"line\">    // webpack 5</span><br><span class=\"line\">    new CopyWebpackPlugin(&#123;</span><br><span class=\"line\">      patterns: [&#123;</span><br><span class=\"line\">        from: &#x27;./public&#x27;,</span><br><span class=\"line\">        to: &#x27;./dist/public&#x27;</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nwebpack5支持的新版本里面需要配置的更加清楚。<h1 id=\"三、升级过程\"><a href=\"#三、升级过程\" class=\"headerlink\" title=\"三、升级过程\"></a>三、升级过程</h1>Webpack5对Node.js的版本要求至少是10.13.0<h2 id=\"先升级-webpack-和-webpack-cli\"><a href=\"#先升级-webpack-和-webpack-cli\" class=\"headerlink\" title=\"先升级 webpack 和 webpack-cli\"></a>先升级 webpack 和 webpack-cli</h2><figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install <span class=\"attr\">--save-dev</span> webpack<span class=\"keyword\">@latest</span> webpack-cli<span class=\"keyword\">@latest</span>  webpack-dev-server<span class=\"keyword\">@latest</span> webpack-merge<span class=\"keyword\">@latest</span></span><br></pre></td></tr></table></figure>\nwebpack-merge升级以后，使用方式改为如下：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpackMerge = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;webpack-merge&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; merge &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack-merge&#x27;</span>);</span><br></pre></td></tr></table></figure>\n升级所有使用到的plugin和loader为最新的可用版本。<br>部分plugin和loader可能会有一个beta版本，必须使用它们才能与webpack 5兼容。<h2 id=\"执行npm-start\"><a href=\"#执行npm-start\" class=\"headerlink\" title=\"执行npm start\"></a>执行npm start</h2>在 package.json中scripts的start命令如下：<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;start&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cross-env NODE_ENV=dev webpack-dev-server --hot --progress --colors  --config ./webpack.dev.js&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"–colors-报错\"><a href=\"#–colors-报错\" class=\"headerlink\" title=\"–colors 报错\"></a>–colors 报错</h3>在v4版本中，我们可以使用 –colors或者 –color，但是在v5版本中只能使用 –color<br>调整命令：<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;start&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cross-env NODE_ENV=dev webpack-dev-server --hot --progress --color  --config ./webpack.dev.js&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"devServer-中-disableHostCheck报错\"><a href=\"#devServer-中-disableHostCheck报错\" class=\"headerlink\" title=\"devServer 中 disableHostCheck报错\"></a>devServer 中 disableHostCheck报错</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    ... </span><br><span class=\"line\">    disableHostCheck: true, </span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n修改为：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    ... </span><br><span class=\"line\">    allowedHosts: &quot;all&quot;, </span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n当设置为 ‘all’ 时会跳过host检查。并不推荐这样做，因为不检查host的应用程序容易受到DNS重绑定攻击。<h3 id=\"vue-loader问题\"><a href=\"#vue-loader问题\" class=\"headerlink\" title=\"vue-loader问题\"></a>vue-loader问题</h3>注意 vue-loader不同的版本是对应VUE不同版本的，这里一定要注意，如果你的VUE版本是2.x那么你要使用<a href=\"mailto:&#118;&#117;&#101;&#45;&#x6c;&#111;&#x61;&#100;&#x65;&#114;&#64;&#x31;&#53;&#46;&#x78;\">&#118;&#117;&#101;&#45;&#x6c;&#111;&#x61;&#100;&#x65;&#114;&#64;&#x31;&#53;&#46;&#x78;</a>，如果是<a href=\"mailto:&#118;&#x75;&#101;&#x40;&#51;&#x2e;&#120;\">&#118;&#x75;&#101;&#x40;&#51;&#x2e;&#120;</a>那么要使用<a href=\"mailto:&#118;&#x75;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#49;&#x36;&#x2e;&#120;\">&#118;&#x75;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#49;&#x36;&#x2e;&#120;</a><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue-loader@16.x</span></span><br><span class=\"line\"><span class=\"comment\">// 对应vue@3.x</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">VueLoaderPlugin</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;vue-loader/dist/index&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">VueLoaderPlugin</span>(),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// vue-loader@15.x</span></span><br><span class=\"line\"><span class=\"comment\">// 对应vue@2.x</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">VueLoaderPlugin</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;vue-loader&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">VueLoaderPlugin</span>(),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"119-x65-98-112-97-x63-x6b-x40-x35-x2e-120-与-118-117-x65-x2d-108-x6f-x61-x64-101-x72-x40-49-54-x2e-x78-版本中间的一个报错问题-DescriptionDataMatcherRulePlugin-webpack5-报错问题\"><a href=\"#119-x65-98-112-97-x63-x6b-x40-x35-x2e-120-与-118-117-x65-x2d-108-x6f-x61-x64-101-x72-x40-49-54-x2e-x78-版本中间的一个报错问题-DescriptionDataMatcherRulePlugin-webpack5-报错问题\" class=\"headerlink\" title=\"&#119;&#x65;&#98;&#112;&#97;&#x63;&#x6b;&#x40;&#x35;&#x2e;&#120;与&#118;&#117;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#49;&#54;&#x2e;&#x78;版本中间的一个报错问题,DescriptionDataMatcherRulePlugin | webpack5 报错问题\"></a><a href=\"mailto:&#119;&#x65;&#98;&#112;&#97;&#x63;&#x6b;&#x40;&#x35;&#x2e;&#120;\">&#119;&#x65;&#98;&#112;&#97;&#x63;&#x6b;&#x40;&#x35;&#x2e;&#120;</a>与<a href=\"mailto:&#118;&#117;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#49;&#54;&#x2e;&#x78;\">&#118;&#117;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#49;&#54;&#x2e;&#x78;</a>版本中间的一个报错问题,DescriptionDataMatcherRulePlugin | webpack5 报错问题</h3>解决方案</li>\n</ul>\n<ol>\n<li>DescriptionDataMatcherRulePlugin是出现在vue-loader里面的</li>\n<li>webpack@5里面为啥不见了，我去webpack源码里找，竟然把文件名给改了，然后vue-loader那边没有同步修改</li>\n<li>解决方案：npm i <a href=\"mailto:&#x77;&#101;&#98;&#112;&#x61;&#99;&#107;&#64;&#53;&#x2e;&#52;&#x34;&#x2e;&#48;\">&#x77;&#101;&#98;&#112;&#x61;&#99;&#107;&#64;&#53;&#x2e;&#52;&#x34;&#x2e;&#48;</a> -D 或者等vue-loader 更新<h3 id=\"postcss-loader-问题\"><a href=\"#postcss-loader-问题\" class=\"headerlink\" title=\"postcss-loader 问题\"></a>postcss-loader 问题</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev autoprefixer</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新的配置</span></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(c|sa|sc)ss$/</span>,</span><br><span class=\"line\">                <span class=\"attr\">use</span>: [</span><br><span class=\"line\">                     <span class=\"string\">&#x27;vue-style-loader&#x27;</span>, <span class=\"comment\">// &lt;style&gt;&lt;/style&gt; 插入页面,development下使用</span></span><br><span class=\"line\">                     <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">                     &#123;</span><br><span class=\"line\">                        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;postcss-loader&#x27;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">                            <span class=\"attr\">postcssOptions</span>: &#123;</span><br><span class=\"line\">                                <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">                                    [</span><br><span class=\"line\">                                        <span class=\"comment\">// &quot;postcss-preset-env&quot;, // postcss-preset-env 包含autoprefixer （npm install postcss-preset-env --save-dev）</span></span><br><span class=\"line\">                                        <span class=\"comment\">// &quot;postcss-nested&quot;,</span></span><br><span class=\"line\">                                        <span class=\"string\">&quot;autoprefixer&quot;</span>, <span class=\"comment\">// css 加前缀</span></span><br><span class=\"line\">                                    ],</span><br><span class=\"line\">                                ],</span><br><span class=\"line\">                            &#125;,</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;sass-loader&#x27;</span></span><br><span class=\"line\">                     </span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"optimization-配置\"><a href=\"#optimization-配置\" class=\"headerlink\" title=\"optimization 配置\"></a>optimization 配置</h3>production<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">optimization</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 告知 webpack 当选择模块 id 时需要使用哪种算法</span></span><br><span class=\"line\">        <span class=\"attr\">moduleIds</span>: <span class=\"string\">&#x27;deterministic&#x27;</span> <span class=\"comment\">// 被哈希转化成的小位数值模块名。</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"webpack-manifest-plugin\"><a href=\"#webpack-manifest-plugin\" class=\"headerlink\" title=\"webpack-manifest-plugin\"></a>webpack-manifest-plugin</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">WebpackManifestPlugin</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack-manifest-plugin&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">WebpackManifestPlugin</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">publicPath</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">filter</span>: <span class=\"keyword\">function</span> (<span class=\"params\">FileDescriptor</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">FileDescriptor</span>.<span class=\"property\">isChunk</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h1><p>由于项目越来越庞大复杂，打包时间也非常长，本地开发环境每次重启都要打包好久，正好借此契机对webpack做了一个升级。</p>\n<h1 id=\"二、webpack5-和-webpack4-的区别有哪些-？\"><a href=\"#二、webpack5-和-webpack4-的区别有哪些-？\" class=\"headerlink\" title=\"二、webpack5 和 webpack4 的区别有哪些 ？\"></a>二、webpack5 和 webpack4 的区别有哪些 ？</h1><h2 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h2><h3 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><p>如果我们的项目中引入了lodash包，但是我只用了其中的一个方法。其他没有用到的方法是不是冗余的？此时tree-shaking就可以把没有用的那些东西剔除掉，来减少最终的bundle体积。<br>usedExports : true, 标记没有用的叶子<br>minimize: true, 摇掉那些没有用的叶子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.config.js中</span><br><span class=\"line\">  module.exports = &#123;</span><br><span class=\"line\">     optimization: &#123;</span><br><span class=\"line\">       usedExports: true, //只导出被使用的模块</span><br><span class=\"line\">       minimize : true // 启动压缩</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>由于tree shaking只支持esmodule ，如果你打包出来的是commonjs，此时tree-shaking就失效了。不过当前大家都用的是vue，react等框架，他们都是用babel-loader编译，以下配置就能够保证他一定是esmodule。<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4.png\"><br>webpack5的 mode=“production” 自动开启 tree-shaking。</p>\n<h2 id=\"压缩代码\"><a href=\"#压缩代码\" class=\"headerlink\" title=\"压缩代码\"></a>压缩代码</h2><ul>\n<li>webpack4<br>webpack4需要下载安装terser-webpack-plugin 插件，并且需要以下配置<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)</span><br><span class=\"line\">module.exports = &#123; </span><br><span class=\"line\">// ...other config</span><br><span class=\"line\">optimization: &#123;</span><br><span class=\"line\">  minimize: !isDev,</span><br><span class=\"line\">  minimizer: [</span><br><span class=\"line\">    new TerserPlugin(&#123;</span><br><span class=\"line\">      extractComments: false, </span><br><span class=\"line\">      terserOptions: &#123; </span><br><span class=\"line\">        compress: &#123; </span><br><span class=\"line\">          pure_funcs: [&#x27;console.log&#x27;] </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;) </span><br><span class=\"line\">   ]</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>webpack5<br>内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。<br>如果你要在开发环境使用，就用下面：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.config.js中</span><br><span class=\"line\">  module.exports = &#123;</span><br><span class=\"line\">     optimization: &#123;</span><br><span class=\"line\">       usedExports: true, //只导出被使用的模块</span><br><span class=\"line\">       minimize : true // 启动压缩</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n<li>js 压缩失效问题<br>当你下载 optimize-css-assets-webpack-plugin ，执行 css 压缩以后，你会发现 webpack5 默认的 js 压缩功能失效了。先说 optimize-css-assets-webpack-plugin 的配置：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123; </span><br><span class=\"line\">  optimization: &#123; </span><br><span class=\"line\">    minimizer: [ </span><br><span class=\"line\">      new OptimizeCssAssetsPlugin() </span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n此时的压缩插件optimize-css-assets-webpack-plugin可以配置到plugins里面去，也可以如图配置到到 optimization里面。区别如下：<br>配置到plugins中，那么这个插件在任何情况下都会工作。而配置在optimization表示只有minimize为 true 的时候才能工作。<br>当安装 optimize-css-assets-webpack-plugin 以后你去打包会发现原来可以压缩的 js 文件，现在不能压缩了。原因是你指定的压缩器是optimize-css-assets-webpack-plugin<br>导致默认的terser-webpack-plugin就会失效。解决办法如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install terser-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">optimization: &#123;</span><br><span class=\"line\">    minimizer: [</span><br><span class=\"line\">      new TerserPlugin(&#123;</span><br><span class=\"line\">        extractComments: false,</span><br><span class=\"line\">        terserOptions: &#123;</span><br><span class=\"line\">          compress: &#123; pure_funcs: [&#x27;console.log&#x27;] &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;),</span><br><span class=\"line\">      new OptimiazeCssAssetPlugin(),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n即便在webpack5中，你也要像webpack4中一样使用js压缩。</li>\n<li>注意事项<br>在webpack5里面使用optimize-css-assets-webpack-plugin会报错，因为官方已经打算要废除了，请使用替换方案：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<h2 id=\"合并模块\"><a href=\"#合并模块\" class=\"headerlink\" title=\"合并模块\"></a>合并模块</h2>普通打包只是将一个模块最终放到一个单独的立即执行函数中，如果你有很多模块，那么就有很多立即执行函数。concatenateModules可以要所有的模块都合并到一个函数里面去。<br>optimization.concatenateModules = true<br>配置如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    usedExports: true,</span><br><span class=\"line\">    concatenateModules: true,</span><br><span class=\"line\">    minimize: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n此时配合 tree-shaking 你会发现打包的体积会减小很多。<h2 id=\"副作用sideEffects\"><a href=\"#副作用sideEffects\" class=\"headerlink\" title=\"副作用sideEffects\"></a>副作用sideEffects</h2></li>\n<li>webpack4 新增了一个sideEffects的功能，允许我们通过配置来标识我们的代码是否有副作用。这个特性只有在开发npm包的时候用到。</li>\n<li>副作用的解释： 在utils文件夹下面有index.js文件，用于系统导出utils里面其他文件，作用就是写的少，不管utils里面有多少方法，我都只需要引入utils即可。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// utils/index.js</span><br><span class=\"line\">  export * from &#x27;./getXXX.js&#x27;;</span><br><span class=\"line\">  export * from &#x27;./getAAA.js&#x27;;</span><br><span class=\"line\">  export * from &#x27;./getBBB.js&#x27;;</span><br><span class=\"line\">  export * from &#x27;./getCCC.js&#x27;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 在其他文件使用 getXXX 引入</span><br><span class=\"line\"> import &#123;getXX&#125; from &#x27;../utils&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>此时，如果文件getAAA在外界没有用到，而tree-shaking又不能把它摇掉怎么办？</li>\n<li>这个getAAA就是副作用。你或许要问tree-shaking为什么不能把它摇掉？</li>\n<li>原因就是：他在utils/index.js 里面使用了。只能开启副作用特性。如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// package.json中</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  name：“项目名称”,</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  sideEffects: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  mode: &#x27;none&#x27;,</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    sideEffects: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>副作用开启：<br>(1)optimization.sideEffects = true 开启副作用功能<br>(2)package.json 中设置 sideEffects : false 标记所有模块无副作用</li>\n<li>说明：<br>webpack打包前都会检查项目所属的package.json文件中的sideEffects标识，如果没有副作用，那些没有用到的模块就不需要打包，反之亦然。此时，在webpack.config.js里面开启sideEffects。<h2 id=\"webpack-缓存\"><a href=\"#webpack-缓存\" class=\"headerlink\" title=\"webpack 缓存\"></a>webpack 缓存</h2></li>\n<li>webpack4缓存配置<br>支持缓存在内存中<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hard-source-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const HardSourceWebpackPlugin = require(&#x27;hard-source-webpack-plugin&#x27;) </span><br><span class=\"line\">module.exports = &#123; </span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  // 其它 plugin... </span><br><span class=\"line\">  new HardSourceWebpackPlugin(), </span><br><span class=\"line\">] &#125;</span><br></pre></td></tr></table></figure></li>\n<li>webpack5缓存配置<br>webpack5内部内置了cache缓存机制，直接配置即可。<br>cache会在开发模式下被设置成type：memory而且会在生产模式把cache给禁用掉。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webpack.config.js</span><br><span class=\"line\">module.exports= &#123;</span><br><span class=\"line\">  // 使用持久化缓存</span><br><span class=\"line\">  cache: &#123;</span><br><span class=\"line\">    type: &#x27;filesystem&#x27;，</span><br><span class=\"line\">    cacheDirectory: path.join(__dirname, &#x27;node_modules/.cac/webpack&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>type的可选值为：memory使用内容缓存，filesystem使用文件缓存。</li>\n<li>当type=filesystem的时候设置cacheDirectory才生效。用于设置你需要的东西缓存放在哪里。<h2 id=\"对loader的优化\"><a href=\"#对loader的优化\" class=\"headerlink\" title=\"对loader的优化\"></a>对loader的优化</h2>webpack4加载资源需要用不同的loader</li>\n<li>raw-loader将文件导入为字符串</li>\n<li>url-loader将文件作为data url内联到bundle文件中</li>\n<li>file-loader将文件发送到输出目录中<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-1.png\"><br>webpack5 的资源模块类型替换 loader<br>资源模块类型(asset module type)，通过添加4种新的模块类型，来替换所有这些 loader：</li>\n<li>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。</li>\n<li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。</li>\n<li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。</li>\n<li>asset 在导出一个data URI和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-2.png\"><h2 id=\"启动服务的差别\"><a href=\"#启动服务的差别\" class=\"headerlink\" title=\"启动服务的差别\"></a>启动服务的差别</h2></li>\n<li>webpack4 启动服务<br>通过webpack-dev-server启动服务</li>\n<li>webpack5 启动服务<br>内置使用webpack serve启动，但是它的日志不是很好，所以一般都加都喜欢用webpack-dev-server优化。<h2 id=\"devtool的差别\"><a href=\"#devtool的差别\" class=\"headerlink\" title=\"devtool的差别\"></a>devtool的差别</h2>sourceMap需要在webpack.config.js里面直接配置devtool就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。<br>一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。<br>devtool在webpack4和webpack5上也是有区别的<br>v4: devtool: ‘cheap-eval-module-source-map’<br>v5: devtool: ‘eval-cheap-module-source-map’<h2 id=\"热更新差别\"><a href=\"#热更新差别\" class=\"headerlink\" title=\"热更新差别\"></a>热更新差别</h2></li>\n<li>webpack4设置<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack4-3.png\"></li>\n<li>webpack5设置<br>如果你使用的是bable6，按照上述设置，你会发现热更新无效，需要添加配置：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.hot.accept(&#x27;需要热启动的文件&#x27;,(source)=&gt;&#123;</span><br><span class=\"line\">    //自定义热启动</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n当前最新版的babel里面的 babel-loader已经帮我们处理的热更新失效的问题。所以不必担心，直接使用即可。<br>如果你引入 mini-css-extract-plugin 以后你会发现 样式的热更新也会失效。<br>只能在开发环境使用style-loader，而在生产环境用MinicssExtractPlugin.loader。 如下：<br><img src=\"/2023/04/05/webpack%E5%8D%87%E7%BA%A7/webpack5-1.png\"><h2 id=\"使用-webpack-merge-的差别\"><a href=\"#使用-webpack-merge-的差别\" class=\"headerlink\" title=\"使用 webpack-merge 的差别\"></a>使用 webpack-merge 的差别</h2></li>\n<li>webpack4 导入<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const merge = require(&#x27;webpack-merge);</span><br></pre></td></tr></table></figure></li>\n<li>webpack 5 导入<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;merge&#125; = require(&#x27;webpack-merge&#x27;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-copy-webpack-plugin-的差别\"><a href=\"#使用-copy-webpack-plugin-的差别\" class=\"headerlink\" title=\"使用 copy-webpack-plugin 的差别\"></a>使用 copy-webpack-plugin 的差别</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//webpack.config.js</span><br><span class=\"line\">const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // webpack 4</span><br><span class=\"line\">    new CopyWebpackPlugin([&#x27;public&#x27;]),   </span><br><span class=\"line\">    // webpack 5</span><br><span class=\"line\">    new CopyWebpackPlugin(&#123;</span><br><span class=\"line\">      patterns: [&#123;</span><br><span class=\"line\">        from: &#x27;./public&#x27;,</span><br><span class=\"line\">        to: &#x27;./dist/public&#x27;</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nwebpack5支持的新版本里面需要配置的更加清楚。<h1 id=\"三、升级过程\"><a href=\"#三、升级过程\" class=\"headerlink\" title=\"三、升级过程\"></a>三、升级过程</h1>Webpack5对Node.js的版本要求至少是10.13.0<h2 id=\"先升级-webpack-和-webpack-cli\"><a href=\"#先升级-webpack-和-webpack-cli\" class=\"headerlink\" title=\"先升级 webpack 和 webpack-cli\"></a>先升级 webpack 和 webpack-cli</h2><figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install <span class=\"attr\">--save-dev</span> webpack<span class=\"keyword\">@latest</span> webpack-cli<span class=\"keyword\">@latest</span>  webpack-dev-server<span class=\"keyword\">@latest</span> webpack-merge<span class=\"keyword\">@latest</span></span><br></pre></td></tr></table></figure>\nwebpack-merge升级以后，使用方式改为如下：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpackMerge = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;webpack-merge&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; merge &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack-merge&#x27;</span>);</span><br></pre></td></tr></table></figure>\n升级所有使用到的plugin和loader为最新的可用版本。<br>部分plugin和loader可能会有一个beta版本，必须使用它们才能与webpack 5兼容。<h2 id=\"执行npm-start\"><a href=\"#执行npm-start\" class=\"headerlink\" title=\"执行npm start\"></a>执行npm start</h2>在 package.json中scripts的start命令如下：<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;start&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cross-env NODE_ENV=dev webpack-dev-server --hot --progress --colors  --config ./webpack.dev.js&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"–colors-报错\"><a href=\"#–colors-报错\" class=\"headerlink\" title=\"–colors 报错\"></a>–colors 报错</h3>在v4版本中，我们可以使用 –colors或者 –color，但是在v5版本中只能使用 –color<br>调整命令：<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;start&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cross-env NODE_ENV=dev webpack-dev-server --hot --progress --color  --config ./webpack.dev.js&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"devServer-中-disableHostCheck报错\"><a href=\"#devServer-中-disableHostCheck报错\" class=\"headerlink\" title=\"devServer 中 disableHostCheck报错\"></a>devServer 中 disableHostCheck报错</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    ... </span><br><span class=\"line\">    disableHostCheck: true, </span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n修改为：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    ... </span><br><span class=\"line\">    allowedHosts: &quot;all&quot;, </span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n当设置为 ‘all’ 时会跳过host检查。并不推荐这样做，因为不检查host的应用程序容易受到DNS重绑定攻击。<h3 id=\"vue-loader问题\"><a href=\"#vue-loader问题\" class=\"headerlink\" title=\"vue-loader问题\"></a>vue-loader问题</h3>注意 vue-loader不同的版本是对应VUE不同版本的，这里一定要注意，如果你的VUE版本是2.x那么你要使用<a href=\"mailto:&#118;&#117;&#101;&#45;&#x6c;&#111;&#x61;&#100;&#x65;&#114;&#64;&#x31;&#53;&#46;&#x78;\">&#118;&#117;&#101;&#45;&#x6c;&#111;&#x61;&#100;&#x65;&#114;&#64;&#x31;&#53;&#46;&#x78;</a>，如果是<a href=\"mailto:&#118;&#x75;&#101;&#x40;&#51;&#x2e;&#120;\">&#118;&#x75;&#101;&#x40;&#51;&#x2e;&#120;</a>那么要使用<a href=\"mailto:&#118;&#x75;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#49;&#x36;&#x2e;&#120;\">&#118;&#x75;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#49;&#x36;&#x2e;&#120;</a><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue-loader@16.x</span></span><br><span class=\"line\"><span class=\"comment\">// 对应vue@3.x</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">VueLoaderPlugin</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;vue-loader/dist/index&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">VueLoaderPlugin</span>(),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// vue-loader@15.x</span></span><br><span class=\"line\"><span class=\"comment\">// 对应vue@2.x</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">VueLoaderPlugin</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;vue-loader&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">VueLoaderPlugin</span>(),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"119-x65-98-112-97-x63-x6b-x40-x35-x2e-120-与-118-117-x65-x2d-108-x6f-x61-x64-101-x72-x40-49-54-x2e-x78-版本中间的一个报错问题-DescriptionDataMatcherRulePlugin-webpack5-报错问题\"><a href=\"#119-x65-98-112-97-x63-x6b-x40-x35-x2e-120-与-118-117-x65-x2d-108-x6f-x61-x64-101-x72-x40-49-54-x2e-x78-版本中间的一个报错问题-DescriptionDataMatcherRulePlugin-webpack5-报错问题\" class=\"headerlink\" title=\"&#119;&#x65;&#98;&#112;&#97;&#x63;&#x6b;&#x40;&#x35;&#x2e;&#120;与&#118;&#117;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#49;&#54;&#x2e;&#x78;版本中间的一个报错问题,DescriptionDataMatcherRulePlugin | webpack5 报错问题\"></a><a href=\"mailto:&#119;&#x65;&#98;&#112;&#97;&#x63;&#x6b;&#x40;&#x35;&#x2e;&#120;\">&#119;&#x65;&#98;&#112;&#97;&#x63;&#x6b;&#x40;&#x35;&#x2e;&#120;</a>与<a href=\"mailto:&#118;&#117;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#49;&#54;&#x2e;&#x78;\">&#118;&#117;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#49;&#54;&#x2e;&#x78;</a>版本中间的一个报错问题,DescriptionDataMatcherRulePlugin | webpack5 报错问题</h3>解决方案</li>\n</ul>\n<ol>\n<li>DescriptionDataMatcherRulePlugin是出现在vue-loader里面的</li>\n<li>webpack@5里面为啥不见了，我去webpack源码里找，竟然把文件名给改了，然后vue-loader那边没有同步修改</li>\n<li>解决方案：npm i <a href=\"mailto:&#x77;&#101;&#98;&#112;&#x61;&#99;&#107;&#64;&#53;&#x2e;&#52;&#x34;&#x2e;&#48;\">&#x77;&#101;&#98;&#112;&#x61;&#99;&#107;&#64;&#53;&#x2e;&#52;&#x34;&#x2e;&#48;</a> -D 或者等vue-loader 更新<h3 id=\"postcss-loader-问题\"><a href=\"#postcss-loader-问题\" class=\"headerlink\" title=\"postcss-loader 问题\"></a>postcss-loader 问题</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev autoprefixer</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新的配置</span></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(c|sa|sc)ss$/</span>,</span><br><span class=\"line\">                <span class=\"attr\">use</span>: [</span><br><span class=\"line\">                     <span class=\"string\">&#x27;vue-style-loader&#x27;</span>, <span class=\"comment\">// &lt;style&gt;&lt;/style&gt; 插入页面,development下使用</span></span><br><span class=\"line\">                     <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">                     &#123;</span><br><span class=\"line\">                        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;postcss-loader&#x27;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">                            <span class=\"attr\">postcssOptions</span>: &#123;</span><br><span class=\"line\">                                <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">                                    [</span><br><span class=\"line\">                                        <span class=\"comment\">// &quot;postcss-preset-env&quot;, // postcss-preset-env 包含autoprefixer （npm install postcss-preset-env --save-dev）</span></span><br><span class=\"line\">                                        <span class=\"comment\">// &quot;postcss-nested&quot;,</span></span><br><span class=\"line\">                                        <span class=\"string\">&quot;autoprefixer&quot;</span>, <span class=\"comment\">// css 加前缀</span></span><br><span class=\"line\">                                    ],</span><br><span class=\"line\">                                ],</span><br><span class=\"line\">                            &#125;,</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;sass-loader&#x27;</span></span><br><span class=\"line\">                     </span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"optimization-配置\"><a href=\"#optimization-配置\" class=\"headerlink\" title=\"optimization 配置\"></a>optimization 配置</h3>production<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">optimization</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 告知 webpack 当选择模块 id 时需要使用哪种算法</span></span><br><span class=\"line\">        <span class=\"attr\">moduleIds</span>: <span class=\"string\">&#x27;deterministic&#x27;</span> <span class=\"comment\">// 被哈希转化成的小位数值模块名。</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"webpack-manifest-plugin\"><a href=\"#webpack-manifest-plugin\" class=\"headerlink\" title=\"webpack-manifest-plugin\"></a>webpack-manifest-plugin</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">WebpackManifestPlugin</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack-manifest-plugin&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">WebpackManifestPlugin</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">publicPath</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">filter</span>: <span class=\"keyword\">function</span> (<span class=\"params\">FileDescriptor</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">FileDescriptor</span>.<span class=\"property\">isChunk</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"webpack迁移vite","date":"2023-03-29T13:41:53.000Z","cover":["/images/迁移vitecover.png"],"banner":{"type":"img","bgurl":["/images/迁移vitecover.png"]},"_content":"# 一、迁移流程\n1.先创建新的vite项目\n2.新版vite项目默认是支持vue3的，需要把vue改成vue2版本后配置vite-plugin-vue2插件来支持vue2\n3.把项目代码改成vue2写法，确保新vite项目可以正常运行vue2\n4.把原webpack项目生产环境依赖复制到vite项目，剔除掉webpack相关的插件依赖\n5.复制原项目src文件代码和其他业务相关代码到新vite项目。\n6.新vite项目配置开发环境启动命令，根据报错信息来进行调整。\n7.在测试开发和打包环境都没问题后，替换原先的项目。\n# 二、迁移业务代码到vite项目\n## 2.1创建新的vite项目\n由于原先项目没有用ts，所以创建项目不选ts版本，包管理工具也依然选择是npm。\nnpm init vite@latest my-vue-app -- --template vue\n创建完成后，使用vs code打开，打开命令行，执行npm i安装依赖\nnpm i\n安装依赖完成后，使用npm run dev启动项目\n此时基本的vite2+vue3项目已经启动成功了，但此时vite支持的还是vue3版本的，我们需要让vite支持vue2版本。\n## 2.2配置vite支持vue2\n此时打开vite.config.js,里面的代码为\n```\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()]\n})\n```\n@vitejs/plugin-vue插件是对vue3语法做支持，如果要支持vue2，需要用vite-plugin-vue2\n第一步，从vite中删除 @vitejs/plugin-vue配置，从package.json文件中也删除。\nnpm uninstall @vitejs/plugin-vue -D\n第二步,安装vite-plugin-vue2依赖\nnpm install vite-plugin-vue2 -D\n第三步,在vite.config.js文件配置vite-plugin-vue2\n```\nimport { defineConfig } from 'vite'\nimport { createVuePlugin } from \"vite-plugin-vue2\";\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [createVuePlugin()]\n})\n```\n第四步，修改vue版本由3改为2版本\nnpm install vue@2 -S\n第五步, 修改main.js，创建根vue实例写法改为vue2写法\n```\nimport Vue from 'vue'\nimport App from './App.vue'\nnew Vue({\n  render: h => h(App),\n}).$mount('#app')\n```\n第六步，修改main.js完成后，修改App.vue文件代码为vue2格式代码\n执行npm run dev，即可看到启动成功,代表此时vite已经支持vue2语法了，可以开始项目迁移工作了。\n## 2.3复制原项目业务代码\n第一步，复制原项目静态目录static下文件到vite项目public文件夹下\n第二步，复制原项目index.html文件内容替换vite项目的index.html内容(注意本地静态资源引入的路径)替换后需要在body结束标签前添加 <script type=\"module\" src=\"/src/main.js\"></script>\n第三步, 复制package.json中生产环境依赖到新vite项目,去除webpack相关配置依赖\n第四步，复制原项目src业务文件代码，直接替换vite项目src文件\n# 三、项目开发阶段报错处理","source":"_posts/webpack迁移vite.md","raw":"---\ntitle: webpack迁移vite\ndate: 2023-03-29 21:41:53\ntags: webpack\ncategories: 知识点\ncover: [/images/迁移vitecover.png]\nbanner: \n  type: img\n  bgurl: [/images/迁移vitecover.png]\n---\n# 一、迁移流程\n1.先创建新的vite项目\n2.新版vite项目默认是支持vue3的，需要把vue改成vue2版本后配置vite-plugin-vue2插件来支持vue2\n3.把项目代码改成vue2写法，确保新vite项目可以正常运行vue2\n4.把原webpack项目生产环境依赖复制到vite项目，剔除掉webpack相关的插件依赖\n5.复制原项目src文件代码和其他业务相关代码到新vite项目。\n6.新vite项目配置开发环境启动命令，根据报错信息来进行调整。\n7.在测试开发和打包环境都没问题后，替换原先的项目。\n# 二、迁移业务代码到vite项目\n## 2.1创建新的vite项目\n由于原先项目没有用ts，所以创建项目不选ts版本，包管理工具也依然选择是npm。\nnpm init vite@latest my-vue-app -- --template vue\n创建完成后，使用vs code打开，打开命令行，执行npm i安装依赖\nnpm i\n安装依赖完成后，使用npm run dev启动项目\n此时基本的vite2+vue3项目已经启动成功了，但此时vite支持的还是vue3版本的，我们需要让vite支持vue2版本。\n## 2.2配置vite支持vue2\n此时打开vite.config.js,里面的代码为\n```\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()]\n})\n```\n@vitejs/plugin-vue插件是对vue3语法做支持，如果要支持vue2，需要用vite-plugin-vue2\n第一步，从vite中删除 @vitejs/plugin-vue配置，从package.json文件中也删除。\nnpm uninstall @vitejs/plugin-vue -D\n第二步,安装vite-plugin-vue2依赖\nnpm install vite-plugin-vue2 -D\n第三步,在vite.config.js文件配置vite-plugin-vue2\n```\nimport { defineConfig } from 'vite'\nimport { createVuePlugin } from \"vite-plugin-vue2\";\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [createVuePlugin()]\n})\n```\n第四步，修改vue版本由3改为2版本\nnpm install vue@2 -S\n第五步, 修改main.js，创建根vue实例写法改为vue2写法\n```\nimport Vue from 'vue'\nimport App from './App.vue'\nnew Vue({\n  render: h => h(App),\n}).$mount('#app')\n```\n第六步，修改main.js完成后，修改App.vue文件代码为vue2格式代码\n执行npm run dev，即可看到启动成功,代表此时vite已经支持vue2语法了，可以开始项目迁移工作了。\n## 2.3复制原项目业务代码\n第一步，复制原项目静态目录static下文件到vite项目public文件夹下\n第二步，复制原项目index.html文件内容替换vite项目的index.html内容(注意本地静态资源引入的路径)替换后需要在body结束标签前添加 <script type=\"module\" src=\"/src/main.js\"></script>\n第三步, 复制package.json中生产环境依赖到新vite项目,去除webpack相关配置依赖\n第四步，复制原项目src业务文件代码，直接替换vite项目src文件\n# 三、项目开发阶段报错处理","slug":"webpack迁移vite","published":1,"updated":"2023-04-11T06:49:17.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml9002btit82yicexo1","content":"<h1 id=\"一、迁移流程\"><a href=\"#一、迁移流程\" class=\"headerlink\" title=\"一、迁移流程\"></a>一、迁移流程</h1><p>1.先创建新的vite项目<br>2.新版vite项目默认是支持vue3的，需要把vue改成vue2版本后配置vite-plugin-vue2插件来支持vue2<br>3.把项目代码改成vue2写法，确保新vite项目可以正常运行vue2<br>4.把原webpack项目生产环境依赖复制到vite项目，剔除掉webpack相关的插件依赖<br>5.复制原项目src文件代码和其他业务相关代码到新vite项目。<br>6.新vite项目配置开发环境启动命令，根据报错信息来进行调整。<br>7.在测试开发和打包环境都没问题后，替换原先的项目。</p>\n<h1 id=\"二、迁移业务代码到vite项目\"><a href=\"#二、迁移业务代码到vite项目\" class=\"headerlink\" title=\"二、迁移业务代码到vite项目\"></a>二、迁移业务代码到vite项目</h1><h2 id=\"2-1创建新的vite项目\"><a href=\"#2-1创建新的vite项目\" class=\"headerlink\" title=\"2.1创建新的vite项目\"></a>2.1创建新的vite项目</h2><p>由于原先项目没有用ts，所以创建项目不选ts版本，包管理工具也依然选择是npm。<br>npm init vite@latest my-vue-app – –template vue<br>创建完成后，使用vs code打开，打开命令行，执行npm i安装依赖<br>npm i<br>安装依赖完成后，使用npm run dev启动项目<br>此时基本的vite2+vue3项目已经启动成功了，但此时vite支持的还是vue3版本的，我们需要让vite支持vue2版本。</p>\n<h2 id=\"2-2配置vite支持vue2\"><a href=\"#2-2配置vite支持vue2\" class=\"headerlink\" title=\"2.2配置vite支持vue2\"></a>2.2配置vite支持vue2</h2><p>此时打开vite.config.js,里面的代码为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class=\"line\">import vue from &#x27;@vitejs/plugin-vue&#x27;</span><br><span class=\"line\">// https://vitejs.dev/config/</span><br><span class=\"line\">export default defineConfig(&#123;</span><br><span class=\"line\">  plugins: [vue()]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>@vitejs/plugin-vue插件是对vue3语法做支持，如果要支持vue2，需要用vite-plugin-vue2<br>第一步，从vite中删除 @vitejs/plugin-vue配置，从package.json文件中也删除。<br>npm uninstall @vitejs/plugin-vue -D<br>第二步,安装vite-plugin-vue2依赖<br>npm install vite-plugin-vue2 -D<br>第三步,在vite.config.js文件配置vite-plugin-vue2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class=\"line\">import &#123; createVuePlugin &#125; from &quot;vite-plugin-vue2&quot;;</span><br><span class=\"line\">// https://vitejs.dev/config/</span><br><span class=\"line\">export default defineConfig(&#123;</span><br><span class=\"line\">  plugins: [createVuePlugin()]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>第四步，修改vue版本由3改为2版本<br>npm install vue@2 -S<br>第五步, 修改main.js，创建根vue实例写法改为vue2写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  render: h =&gt; h(App),</span><br><span class=\"line\">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>\n<p>第六步，修改main.js完成后，修改App.vue文件代码为vue2格式代码<br>执行npm run dev，即可看到启动成功,代表此时vite已经支持vue2语法了，可以开始项目迁移工作了。</p>\n<h2 id=\"2-3复制原项目业务代码\"><a href=\"#2-3复制原项目业务代码\" class=\"headerlink\" title=\"2.3复制原项目业务代码\"></a>2.3复制原项目业务代码</h2><p>第一步，复制原项目静态目录static下文件到vite项目public文件夹下<br>第二步，复制原项目index.html文件内容替换vite项目的index.html内容(注意本地静态资源引入的路径)替换后需要在body结束标签前添加 <script type=\"module\" src=\"/src/main.js\"></script><br>第三步, 复制package.json中生产环境依赖到新vite项目,去除webpack相关配置依赖<br>第四步，复制原项目src业务文件代码，直接替换vite项目src文件</p>\n<h1 id=\"三、项目开发阶段报错处理\"><a href=\"#三、项目开发阶段报错处理\" class=\"headerlink\" title=\"三、项目开发阶段报错处理\"></a>三、项目开发阶段报错处理</h1>","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"一、迁移流程\"><a href=\"#一、迁移流程\" class=\"headerlink\" title=\"一、迁移流程\"></a>一、迁移流程</h1><p>1.先创建新的vite项目<br>2.新版vite项目默认是支持vue3的，需要把vue改成vue2版本后配置vite-plugin-vue2插件来支持vue2<br>3.把项目代码改成vue2写法，确保新vite项目可以正常运行vue2<br>4.把原webpack项目生产环境依赖复制到vite项目，剔除掉webpack相关的插件依赖<br>5.复制原项目src文件代码和其他业务相关代码到新vite项目。<br>6.新vite项目配置开发环境启动命令，根据报错信息来进行调整。<br>7.在测试开发和打包环境都没问题后，替换原先的项目。</p>\n<h1 id=\"二、迁移业务代码到vite项目\"><a href=\"#二、迁移业务代码到vite项目\" class=\"headerlink\" title=\"二、迁移业务代码到vite项目\"></a>二、迁移业务代码到vite项目</h1><h2 id=\"2-1创建新的vite项目\"><a href=\"#2-1创建新的vite项目\" class=\"headerlink\" title=\"2.1创建新的vite项目\"></a>2.1创建新的vite项目</h2><p>由于原先项目没有用ts，所以创建项目不选ts版本，包管理工具也依然选择是npm。<br>npm init vite@latest my-vue-app – –template vue<br>创建完成后，使用vs code打开，打开命令行，执行npm i安装依赖<br>npm i<br>安装依赖完成后，使用npm run dev启动项目<br>此时基本的vite2+vue3项目已经启动成功了，但此时vite支持的还是vue3版本的，我们需要让vite支持vue2版本。</p>\n<h2 id=\"2-2配置vite支持vue2\"><a href=\"#2-2配置vite支持vue2\" class=\"headerlink\" title=\"2.2配置vite支持vue2\"></a>2.2配置vite支持vue2</h2><p>此时打开vite.config.js,里面的代码为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class=\"line\">import vue from &#x27;@vitejs/plugin-vue&#x27;</span><br><span class=\"line\">// https://vitejs.dev/config/</span><br><span class=\"line\">export default defineConfig(&#123;</span><br><span class=\"line\">  plugins: [vue()]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>@vitejs/plugin-vue插件是对vue3语法做支持，如果要支持vue2，需要用vite-plugin-vue2<br>第一步，从vite中删除 @vitejs/plugin-vue配置，从package.json文件中也删除。<br>npm uninstall @vitejs/plugin-vue -D<br>第二步,安装vite-plugin-vue2依赖<br>npm install vite-plugin-vue2 -D<br>第三步,在vite.config.js文件配置vite-plugin-vue2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class=\"line\">import &#123; createVuePlugin &#125; from &quot;vite-plugin-vue2&quot;;</span><br><span class=\"line\">// https://vitejs.dev/config/</span><br><span class=\"line\">export default defineConfig(&#123;</span><br><span class=\"line\">  plugins: [createVuePlugin()]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>第四步，修改vue版本由3改为2版本<br>npm install vue@2 -S<br>第五步, 修改main.js，创建根vue实例写法改为vue2写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  render: h =&gt; h(App),</span><br><span class=\"line\">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>\n<p>第六步，修改main.js完成后，修改App.vue文件代码为vue2格式代码<br>执行npm run dev，即可看到启动成功,代表此时vite已经支持vue2语法了，可以开始项目迁移工作了。</p>\n<h2 id=\"2-3复制原项目业务代码\"><a href=\"#2-3复制原项目业务代码\" class=\"headerlink\" title=\"2.3复制原项目业务代码\"></a>2.3复制原项目业务代码</h2><p>第一步，复制原项目静态目录static下文件到vite项目public文件夹下<br>第二步，复制原项目index.html文件内容替换vite项目的index.html内容(注意本地静态资源引入的路径)替换后需要在body结束标签前添加 <script type=\"module\" src=\"/src/main.js\"></script><br>第三步, 复制package.json中生产环境依赖到新vite项目,去除webpack相关配置依赖<br>第四步，复制原项目src业务文件代码，直接替换vite项目src文件</p>\n<h1 id=\"三、项目开发阶段报错处理\"><a href=\"#三、项目开发阶段报错处理\" class=\"headerlink\" title=\"三、项目开发阶段报错处理\"></a>三、项目开发阶段报错处理</h1>"},{"title":"博客搭建","date":"2022-08-16T13:45:54.000Z","_content":"# 1.安装hexo\n# 2.初始化项目\n## 现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\n## // 初始化生成blog项目\nhexo init blog\n# 3.配置主题\n## hexo默认的主题是_landscape，现在我们将主题配置为 keep。\n## // 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\ncd blog\n## // 安装keep主题\nnpm install hexo-theme-keep\n## // 修改_config.yml配置文件\ntheme: keep\n##// 预览网站\nhexo server\n在浏览器中打开http://localhost:4000\n# 4.添加文章\n## 现在，让我们新建一篇博客\n## // 在blog项目中，执行如下命令：新建文章\nhexo new post xxxx\n## 新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。\n## 编辑\n## 添加正文\n## 现在我们打开【xxxx.md】，写下我们的xxxxx。\n## 然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\n\n##  添加分类和标签\n接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下\ntags:xxxx\ncategories: xxxx\n## 然后，打开终端分别执行如下命令。\nhexo new page categories\nhexo new page tags\n\n## hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片\n\n## 为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:\nmenu:\n  主页: /\n  归档: /archives\n  分类: /categories\n  标签: /tags\n再次刷新http://localhost:4000\n# 5.发布草稿\n## 如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\nhexo new draft xxxx\n图片刷新http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令\n\n## // 发布草稿\nhexo publish draft xxxx\n## 现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片\n\n# 6.部署博客\n## 现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\n## 新建仓库\n1.我们打开 github，然后点击New repository按钮\n2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址\n## 部署\n// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\ncd blog\n// 安装部署插件\nnpm install hexo-deployer-git --save\n// 修改_config.yml配置文件\n// 将复制的地址，黏贴到如下repo字段中\ndeploy:\n type: git\n  repo: https://github.com/xxxx/xxxx.github.io.git\n branch: master\n// 部署网站到创建的仓库\nhexo deploy\n部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。","source":"_posts/博客搭建.md","raw":"---\ntitle: 博客搭建\ndate: 2022-08-16 21:45:54\ntags: 搭建博客\ncategories: 工具\n---\n# 1.安装hexo\n# 2.初始化项目\n## 现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\n## // 初始化生成blog项目\nhexo init blog\n# 3.配置主题\n## hexo默认的主题是_landscape，现在我们将主题配置为 keep。\n## // 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\ncd blog\n## // 安装keep主题\nnpm install hexo-theme-keep\n## // 修改_config.yml配置文件\ntheme: keep\n##// 预览网站\nhexo server\n在浏览器中打开http://localhost:4000\n# 4.添加文章\n## 现在，让我们新建一篇博客\n## // 在blog项目中，执行如下命令：新建文章\nhexo new post xxxx\n## 新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。\n## 编辑\n## 添加正文\n## 现在我们打开【xxxx.md】，写下我们的xxxxx。\n## 然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\n\n##  添加分类和标签\n接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下\ntags:xxxx\ncategories: xxxx\n## 然后，打开终端分别执行如下命令。\nhexo new page categories\nhexo new page tags\n\n## hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片\n\n## 为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:\nmenu:\n  主页: /\n  归档: /archives\n  分类: /categories\n  标签: /tags\n再次刷新http://localhost:4000\n# 5.发布草稿\n## 如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\nhexo new draft xxxx\n图片刷新http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令\n\n## // 发布草稿\nhexo publish draft xxxx\n## 现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片\n\n# 6.部署博客\n## 现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\n## 新建仓库\n1.我们打开 github，然后点击New repository按钮\n2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址\n## 部署\n// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\ncd blog\n// 安装部署插件\nnpm install hexo-deployer-git --save\n// 修改_config.yml配置文件\n// 将复制的地址，黏贴到如下repo字段中\ndeploy:\n type: git\n  repo: https://github.com/xxxx/xxxx.github.io.git\n branch: master\n// 部署网站到创建的仓库\nhexo deploy\n部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。","slug":"博客搭建","published":1,"updated":"2023-03-22T06:08:23.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml9002ftit8fr4nfqt5","content":"<h1 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h1><h1 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2.初始化项目\"></a>2.初始化项目</h1><h2 id=\"现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\"><a href=\"#现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\" class=\"headerlink\" title=\"现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\"></a>现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。</h2><h2 id=\"初始化生成blog项目\"><a href=\"#初始化生成blog项目\" class=\"headerlink\" title=\"// 初始化生成blog项目\"></a>// 初始化生成blog项目</h2><p>hexo init blog</p>\n<h1 id=\"3-配置主题\"><a href=\"#3-配置主题\" class=\"headerlink\" title=\"3.配置主题\"></a>3.配置主题</h1><h2 id=\"hexo默认的主题是-landscape，现在我们将主题配置为-keep。\"><a href=\"#hexo默认的主题是-landscape，现在我们将主题配置为-keep。\" class=\"headerlink\" title=\"hexo默认的主题是_landscape，现在我们将主题配置为 keep。\"></a>hexo默认的主题是_landscape，现在我们将主题配置为 keep。</h2><h2 id=\"确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\"><a href=\"#确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\" class=\"headerlink\" title=\"// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\"></a>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中</h2><p>cd blog</p>\n<h2 id=\"安装keep主题\"><a href=\"#安装keep主题\" class=\"headerlink\" title=\"// 安装keep主题\"></a>// 安装keep主题</h2><p>npm install hexo-theme-keep</p>\n<h2 id=\"修改-config-yml配置文件\"><a href=\"#修改-config-yml配置文件\" class=\"headerlink\" title=\"// 修改_config.yml配置文件\"></a>// 修改_config.yml配置文件</h2><p>theme: keep<br>##// 预览网站<br>hexo server<br>在浏览器中打开<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h1 id=\"4-添加文章\"><a href=\"#4-添加文章\" class=\"headerlink\" title=\"4.添加文章\"></a>4.添加文章</h1><h2 id=\"现在，让我们新建一篇博客\"><a href=\"#现在，让我们新建一篇博客\" class=\"headerlink\" title=\"现在，让我们新建一篇博客\"></a>现在，让我们新建一篇博客</h2><h2 id=\"在blog项目中，执行如下命令：新建文章\"><a href=\"#在blog项目中，执行如下命令：新建文章\" class=\"headerlink\" title=\"// 在blog项目中，执行如下命令：新建文章\"></a>// 在blog项目中，执行如下命令：新建文章</h2><p>hexo new post xxxx</p>\n<h2 id=\"新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。\"><a href=\"#新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。\" class=\"headerlink\" title=\"新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。\"></a>新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。</h2><h2 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h2><h2 id=\"添加正文\"><a href=\"#添加正文\" class=\"headerlink\" title=\"添加正文\"></a>添加正文</h2><h2 id=\"现在我们打开【xxxx-md】，写下我们的xxxxx。\"><a href=\"#现在我们打开【xxxx-md】，写下我们的xxxxx。\" class=\"headerlink\" title=\"现在我们打开【xxxx.md】，写下我们的xxxxx。\"></a>现在我们打开【xxxx.md】，写下我们的xxxxx。</h2><h2 id=\"然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了\"><a href=\"#然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了\" class=\"headerlink\" title=\"然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\"></a>然后保存。刷新<a href=\"http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\">http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了</a></h2><h2 id=\"添加分类和标签\"><a href=\"#添加分类和标签\" class=\"headerlink\" title=\"添加分类和标签\"></a>添加分类和标签</h2><p>接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下<br>tags:xxxx<br>categories: xxxx</p>\n<h2 id=\"然后，打开终端分别执行如下命令。\"><a href=\"#然后，打开终端分别执行如下命令。\" class=\"headerlink\" title=\"然后，打开终端分别执行如下命令。\"></a>然后，打开终端分别执行如下命令。</h2><p>hexo new page categories<br>hexo new page tags</p>\n<h2 id=\"hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片\"><a href=\"#hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片\" class=\"headerlink\" title=\"hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片\"></a>hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。<a href=\"http://localhost:4000/categories/%E5%9B%BE%E7%89%87\">http://localhost:4000/categories/图片</a>, <a href=\"http://localhost:4000/tags/%E5%9B%BE%E7%89%87\">http://localhost:4000/tags/图片</a></h2><h2 id=\"为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改\"><a href=\"#为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改\" class=\"headerlink\" title=\"为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:\"></a>为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:</h2><p>menu:<br>  主页: /<br>  归档: /archives<br>  分类: /categories<br>  标签: /tags<br>再次刷新<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h1 id=\"5-发布草稿\"><a href=\"#5-发布草稿\" class=\"headerlink\" title=\"5.发布草稿\"></a>5.发布草稿</h1><h2 id=\"如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\"><a href=\"#如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\" class=\"headerlink\" title=\"如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\"></a>如果你暂时还不想要文章被公开访问，可以先创建草稿。如下</h2><p>hexo new draft xxxx<br>图片刷新<a href=\"http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令\">http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令</a></p>\n<h2 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"// 发布草稿\"></a>// 发布草稿</h2><p>hexo publish draft xxxx</p>\n<h2 id=\"现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片\"><a href=\"#现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片\" class=\"headerlink\" title=\"现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片\"></a>现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新<a href=\"http://localhost:4000，便可以看到这篇文章了图片\">http://localhost:4000，便可以看到这篇文章了图片</a></h2><h1 id=\"6-部署博客\"><a href=\"#6-部署博客\" class=\"headerlink\" title=\"6.部署博客\"></a>6.部署博客</h1><h2 id=\"现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\"><a href=\"#现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\" class=\"headerlink\" title=\"现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\"></a>现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。</h2><h2 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h2><p>1.我们打开 github，然后点击New repository按钮<br>2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中<br>cd blog<br>// 安装部署插件<br>npm install hexo-deployer-git –save<br>// 修改_config.yml配置文件<br>// 将复制的地址，黏贴到如下repo字段中<br>deploy:<br> type: git<br>  repo: <a href=\"https://github.com/xxxx/xxxx.github.io.git\">https://github.com/xxxx/xxxx.github.io.git</a><br> branch: master<br>// 部署网站到创建的仓库<br>hexo deploy<br>部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h1><h1 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2.初始化项目\"></a>2.初始化项目</h1><h2 id=\"现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\"><a href=\"#现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\" class=\"headerlink\" title=\"现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\"></a>现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。</h2><h2 id=\"初始化生成blog项目\"><a href=\"#初始化生成blog项目\" class=\"headerlink\" title=\"// 初始化生成blog项目\"></a>// 初始化生成blog项目</h2><p>hexo init blog</p>\n<h1 id=\"3-配置主题\"><a href=\"#3-配置主题\" class=\"headerlink\" title=\"3.配置主题\"></a>3.配置主题</h1><h2 id=\"hexo默认的主题是-landscape，现在我们将主题配置为-keep。\"><a href=\"#hexo默认的主题是-landscape，现在我们将主题配置为-keep。\" class=\"headerlink\" title=\"hexo默认的主题是_landscape，现在我们将主题配置为 keep。\"></a>hexo默认的主题是_landscape，现在我们将主题配置为 keep。</h2><h2 id=\"确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\"><a href=\"#确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\" class=\"headerlink\" title=\"// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\"></a>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中</h2><p>cd blog</p>\n<h2 id=\"安装keep主题\"><a href=\"#安装keep主题\" class=\"headerlink\" title=\"// 安装keep主题\"></a>// 安装keep主题</h2><p>npm install hexo-theme-keep</p>\n<h2 id=\"修改-config-yml配置文件\"><a href=\"#修改-config-yml配置文件\" class=\"headerlink\" title=\"// 修改_config.yml配置文件\"></a>// 修改_config.yml配置文件</h2><p>theme: keep<br>##// 预览网站<br>hexo server<br>在浏览器中打开<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h1 id=\"4-添加文章\"><a href=\"#4-添加文章\" class=\"headerlink\" title=\"4.添加文章\"></a>4.添加文章</h1><h2 id=\"现在，让我们新建一篇博客\"><a href=\"#现在，让我们新建一篇博客\" class=\"headerlink\" title=\"现在，让我们新建一篇博客\"></a>现在，让我们新建一篇博客</h2><h2 id=\"在blog项目中，执行如下命令：新建文章\"><a href=\"#在blog项目中，执行如下命令：新建文章\" class=\"headerlink\" title=\"// 在blog项目中，执行如下命令：新建文章\"></a>// 在blog项目中，执行如下命令：新建文章</h2><p>hexo new post xxxx</p>\n<h2 id=\"新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。\"><a href=\"#新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。\" class=\"headerlink\" title=\"新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。\"></a>新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。</h2><h2 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h2><h2 id=\"添加正文\"><a href=\"#添加正文\" class=\"headerlink\" title=\"添加正文\"></a>添加正文</h2><h2 id=\"现在我们打开【xxxx-md】，写下我们的xxxxx。\"><a href=\"#现在我们打开【xxxx-md】，写下我们的xxxxx。\" class=\"headerlink\" title=\"现在我们打开【xxxx.md】，写下我们的xxxxx。\"></a>现在我们打开【xxxx.md】，写下我们的xxxxx。</h2><h2 id=\"然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了\"><a href=\"#然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了\" class=\"headerlink\" title=\"然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\"></a>然后保存。刷新<a href=\"http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\">http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了</a></h2><h2 id=\"添加分类和标签\"><a href=\"#添加分类和标签\" class=\"headerlink\" title=\"添加分类和标签\"></a>添加分类和标签</h2><p>接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下<br>tags:xxxx<br>categories: xxxx</p>\n<h2 id=\"然后，打开终端分别执行如下命令。\"><a href=\"#然后，打开终端分别执行如下命令。\" class=\"headerlink\" title=\"然后，打开终端分别执行如下命令。\"></a>然后，打开终端分别执行如下命令。</h2><p>hexo new page categories<br>hexo new page tags</p>\n<h2 id=\"hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片\"><a href=\"#hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片\" class=\"headerlink\" title=\"hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片\"></a>hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。<a href=\"http://localhost:4000/categories/%E5%9B%BE%E7%89%87\">http://localhost:4000/categories/图片</a>, <a href=\"http://localhost:4000/tags/%E5%9B%BE%E7%89%87\">http://localhost:4000/tags/图片</a></h2><h2 id=\"为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改\"><a href=\"#为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改\" class=\"headerlink\" title=\"为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:\"></a>为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:</h2><p>menu:<br>  主页: /<br>  归档: /archives<br>  分类: /categories<br>  标签: /tags<br>再次刷新<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h1 id=\"5-发布草稿\"><a href=\"#5-发布草稿\" class=\"headerlink\" title=\"5.发布草稿\"></a>5.发布草稿</h1><h2 id=\"如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\"><a href=\"#如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\" class=\"headerlink\" title=\"如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\"></a>如果你暂时还不想要文章被公开访问，可以先创建草稿。如下</h2><p>hexo new draft xxxx<br>图片刷新<a href=\"http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令\">http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令</a></p>\n<h2 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"// 发布草稿\"></a>// 发布草稿</h2><p>hexo publish draft xxxx</p>\n<h2 id=\"现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片\"><a href=\"#现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片\" class=\"headerlink\" title=\"现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片\"></a>现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新<a href=\"http://localhost:4000，便可以看到这篇文章了图片\">http://localhost:4000，便可以看到这篇文章了图片</a></h2><h1 id=\"6-部署博客\"><a href=\"#6-部署博客\" class=\"headerlink\" title=\"6.部署博客\"></a>6.部署博客</h1><h2 id=\"现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\"><a href=\"#现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\" class=\"headerlink\" title=\"现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\"></a>现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。</h2><h2 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h2><p>1.我们打开 github，然后点击New repository按钮<br>2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中<br>cd blog<br>// 安装部署插件<br>npm install hexo-deployer-git –save<br>// 修改_config.yml配置文件<br>// 将复制的地址，黏贴到如下repo字段中<br>deploy:<br> type: git<br>  repo: <a href=\"https://github.com/xxxx/xxxx.github.io.git\">https://github.com/xxxx/xxxx.github.io.git</a><br> branch: master<br>// 部署网站到创建的仓库<br>hexo deploy<br>部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。</p>\n"},{"title":"开发hexo主题记录","date":"2023-04-13T02:13:55.000Z","_content":"# 关于Hexo及其工作原理\n## 什么是Hexo\nHexo.js 官网的概述是：快速、简洁且高效的博客框架。准确而具体地概述应该是 Hexo.js 是一个基于 Node.js ，可以将 markdown 文件转换为html静态界面的博客框架。\n\n换句话说，hexo.js 可以使用 hexo serve 的命令运行提供网站功能，但其最主要的作用应当是生成静态文件，然后交给 nginx / tomcat 等服务器软件进行维护，对外提供网页服务。\n## Hexo 工作原理\n应该把 Hexo.js 看作一个工具，一个根据配置文件与markdown文件以及html/css/js代码转换为前端界面的工具。\n默认情况下 Hexo.js 运行后，将会默认生成多个页面，并具有相应的路径。\n因此，Hexo 主题的作用就是将每个页面进行特定样式的渲染。\n## Hexo 快速开始\n按照教程进行初始化项目：\nhexo init 'xxxx'\ncd 'xxxx'\nnpm install\nhexo serve\n访问 4000 端口\n## 总体分析默认的 landscape 主题\nlanguages 国际化\n即对于同一个变量对应的语言表达方法，比如 英文 home 简体中文 主页。\n\nlayout 主题布局文件\n在启动hexo的时候，博客渲染的入口为其中的 layout.ejs 文件，其他的内容将对应其他 ejs 文件，比如分类对应的是 category.ejs ，标签对应的是 tag.ejs。\n\n这里详细展开layout中所有的文件：\n\n_partial: 将整个网页拆成若干个局部模块，这些子模块存储于这个文件夹。\n_partial/post：查看博客时的所有组件；\n_partial/post/category.ejs: 查看博客详情时显示博客的类别；\n_partial/post/date.ejs: 查看博客详情时显示博客的日期；\n_partial/post/gallery.ejs: 查看博客详情时显示博客的图片；\n_partial/post/nav.ejs: 查看博客详情时显示博客的上一篇下一篇的导航；\n_partial/post/tag.ejs: 查看博客详情时显示博客的标签；\n_partial/post/title.ejs: 查看博客详情时显示博客的标题；\n_partial/after-footer.ejs：所有页面html的最后面应用 js 部分；\n_partial/archive-post.ejs：对所有博客的归档；\n_partital/archive.ejs：包括分类，标签以及博客的归档；\n_partial/article.ejs：展示每篇博客的内容；\n_partial/footer.ejs：每页内容的最下面展示的内容，比如copyright等；\n_partial/gauges_analytics：对每篇博客的字数统计分析；\n_partial/google_analytics：对每篇博客的谷歌统计分析；\n_partial/head.ejs：html的头部内容；\n_partial/mobile-nav.ejs：移动端时的导航；\n_partial/sidebar.ejs：侧边栏；\n_widget：小工具类，也就是侧边导航栏的组件；\n_widget/archive.ejs：侧边栏的归档；\n_widget/category.ejs：侧边栏的分类；\n_widget/recent_posts.ejs：侧边栏的最近博客；\n_widget/tag.ejs：侧边栏的标签；\n_widget/tagcloud.ejs：侧边栏的标签云（使用自带的函数）；\narchive.ejs ：博客的归档，是直接绑定 archives/ 的入口，根据归档的不同会在这里进行分岔。比如博客的归档，分类的归档，标签的归档。\ncategory.ejs：博客的分类，是直接绑定 categories/某类名称 的入口，根据某类名 的不同进行渲染。\nindex.ejs：直接绑定博客的主页，在访问根目录时，对应的 <%- body %> 输出的内容。\nlayout.ejs：整个主题的入口，包括 html 的 <head> 标签等所有内容。一般而言不同页面渲染结果不同是因为 <%- body %> 输出的内容不同。<%-body %> 是自带的内容，会根据访问的是主页还是分类或者标签或者归档进行渲染。\npage.ejs：特殊页的渲染，除了分类、标签、主页和归档，用户可以自己定义页面，自己定义的页面对应的 markdown 文件的渲染方法与 page.ejs 对应。\npost.ejs：博客的详细内容渲染，也就是对应markdown文件转换出的 html 界面。\ntag.ejs：标签的分类，直接绑定某个标签的内容，比如访问 tags/某标签 则返回这个标签的所有内容，就是在这里进行控制的。\n\nscripts 主题自带脚本文件夹\n接下来查看 scripts 文件夹：\n\nfancybox.js：在启动 hexo 时候会运行这个脚本。\n1.4.4 source 主题自带的资源文件夹\n主题的渲染过程样式非常重要，主题对应的 css 样式存储于这个文件夹，以及用得到的 js 脚本，也存储于此（与scripts不同，那个会启动时自动执行，只执行一次）。\n\ncss ：所有的样式文件夹。\nfancybox：fancybox 对应的样式与js文件；\njs：所有的js 文件。\n1.4.5 _config.yml 主题配置文件\n编写主题的时候必须考虑到不同的人审美、需求是不一样的，为了让用户用起来简单，把尽可能可以通过配置文件配置的内容均放在这个文件中比较合适。比如，主题默认情况下侧边栏的顺序是：\nwidgets:\n- category\n- tag\n- archive\n## hexo 主题工作整体流程\nHexo 启动后，\n1. 读 scripts 下所有脚本并执行这些脚本；\n2. 读取 layout 目录下 layout.ejs 文件；\n3. 根据 <%-body%> 在 layout.ejs 的位置进行渲染，包括主页的渲染、分类的渲染、归档的渲染以及自定义页面的渲染。\n\n# Hexo主题编写\n## 新建主题并配置\n在 themes 目录下新建一个文件夹，我们的主题对应的就是这个文件夹，给自己的主题起个名字，我们暂时起名为 base 吧。\n目前 base 还是为空的文件夹，我们修改根目录的 _config.yml 也就是Hexo的配置文件，将主题修改为我们的主题名字 base。\n并且在 base 目录下新建 layout 文件夹，并在 layout 下新建 layout.ejs 文件与 index.ejs 文件，前面第一章节介绍过，layout.ejs 是整个主题的入口，而 index.ejs 是必需文件，暂时为空白即可。\n编辑 layout.ejs 内容如下：\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>wnxx</title>\n</head>\n<body>\n    这是入口\n</body>\n</html>\n```\n重启 hexo ，可以看到效果为：\n## 新建所有功能性文件\n先理清楚所有功能对应的功能性文件，概述一下如表格所示。\n意博客详情页时默认是 posts/年/月/日/博客标题，也可以自行修改，这里统称为 博客路径。\n我们根据这个表格新建相应的文件。\n## 熟悉hexo内置的变量\n官网文档地址为：中文 https://hexo.io/zh-cn/docs/variables | 英文 https://hexo.io/docs/variables 建议两个都看一下。\n## layout.ejs\nlayout.ejs 是主题的入口，因此整个博客网站不同页面都可以认为是由 layout.ejs “派生” 得到的。换句话说，layout.ejs 中 <%- body %> 具体输出什么是由用户访问的页面决定的，其他部分可以根据具体访问的页面而决定是否展示（比如访问archive可以考虑隐藏侧边栏等）。\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>wnxx</title>\n</head>\n \n<body>\n    <!-- 网站名 -->\n    <h1>\n        <a href=\"/\"><%= config.title  %></a>\n        <a href=\"/\">Home</a>\n        <a href=\"<%-url_for(config.archive_dir)%>\">Archive</a>\n    </h1>\n    <%- body %> \n\n    <h3>categories</h3>\n    <ul>\n        <% site.categories.each(category=>{ %>\n            <li>\n                <a href=\"<%- url_for(category.path) %>\">\n                    <%- category.name  %> \n                </a>\n            </li>\n        <% }) %>\n    </ul>\n\n    <h3>tags</h3>\n    <ul>\n        <% site.tags.each(tag=>{ %>\n            <li>\n                <a href=\"<%- url_for(tag.path) %>\">\n                    <%- tag.name  %> \n                </a>\n            </li>\n        <% }) %>\n    </ul>\n</body>\n</html>\n```\n## index.ejs\n主页的内容展示带有分页效果的博客，具体的方法与前面的类似，读取page变量的所有 posts然后遍历，渲染。\n```\n<!-- 主页 -->\n<ul>\n<% page.posts.each(post=>{ %>\n    <li>\n        <a href=\"<%=url_for(post.path)%>\">\n            <%= post.title %>\n        </a>\n        | <%- date( post.date , 'YYYY/MM/DD HH:mm') %> \n    </li>\n<% }) %>\n</ul>\n\n<%- paginator({\n    prev_text: '<',\n    next_text: '>'\n}) %>\n```","source":"_posts/开发hexo主题记录.md","raw":"---\ntitle: 开发hexo主题记录\ndate: 2023-04-13 10:13:55\ntags: hexo\ncategories: 工具\n---\n# 关于Hexo及其工作原理\n## 什么是Hexo\nHexo.js 官网的概述是：快速、简洁且高效的博客框架。准确而具体地概述应该是 Hexo.js 是一个基于 Node.js ，可以将 markdown 文件转换为html静态界面的博客框架。\n\n换句话说，hexo.js 可以使用 hexo serve 的命令运行提供网站功能，但其最主要的作用应当是生成静态文件，然后交给 nginx / tomcat 等服务器软件进行维护，对外提供网页服务。\n## Hexo 工作原理\n应该把 Hexo.js 看作一个工具，一个根据配置文件与markdown文件以及html/css/js代码转换为前端界面的工具。\n默认情况下 Hexo.js 运行后，将会默认生成多个页面，并具有相应的路径。\n因此，Hexo 主题的作用就是将每个页面进行特定样式的渲染。\n## Hexo 快速开始\n按照教程进行初始化项目：\nhexo init 'xxxx'\ncd 'xxxx'\nnpm install\nhexo serve\n访问 4000 端口\n## 总体分析默认的 landscape 主题\nlanguages 国际化\n即对于同一个变量对应的语言表达方法，比如 英文 home 简体中文 主页。\n\nlayout 主题布局文件\n在启动hexo的时候，博客渲染的入口为其中的 layout.ejs 文件，其他的内容将对应其他 ejs 文件，比如分类对应的是 category.ejs ，标签对应的是 tag.ejs。\n\n这里详细展开layout中所有的文件：\n\n_partial: 将整个网页拆成若干个局部模块，这些子模块存储于这个文件夹。\n_partial/post：查看博客时的所有组件；\n_partial/post/category.ejs: 查看博客详情时显示博客的类别；\n_partial/post/date.ejs: 查看博客详情时显示博客的日期；\n_partial/post/gallery.ejs: 查看博客详情时显示博客的图片；\n_partial/post/nav.ejs: 查看博客详情时显示博客的上一篇下一篇的导航；\n_partial/post/tag.ejs: 查看博客详情时显示博客的标签；\n_partial/post/title.ejs: 查看博客详情时显示博客的标题；\n_partial/after-footer.ejs：所有页面html的最后面应用 js 部分；\n_partial/archive-post.ejs：对所有博客的归档；\n_partital/archive.ejs：包括分类，标签以及博客的归档；\n_partial/article.ejs：展示每篇博客的内容；\n_partial/footer.ejs：每页内容的最下面展示的内容，比如copyright等；\n_partial/gauges_analytics：对每篇博客的字数统计分析；\n_partial/google_analytics：对每篇博客的谷歌统计分析；\n_partial/head.ejs：html的头部内容；\n_partial/mobile-nav.ejs：移动端时的导航；\n_partial/sidebar.ejs：侧边栏；\n_widget：小工具类，也就是侧边导航栏的组件；\n_widget/archive.ejs：侧边栏的归档；\n_widget/category.ejs：侧边栏的分类；\n_widget/recent_posts.ejs：侧边栏的最近博客；\n_widget/tag.ejs：侧边栏的标签；\n_widget/tagcloud.ejs：侧边栏的标签云（使用自带的函数）；\narchive.ejs ：博客的归档，是直接绑定 archives/ 的入口，根据归档的不同会在这里进行分岔。比如博客的归档，分类的归档，标签的归档。\ncategory.ejs：博客的分类，是直接绑定 categories/某类名称 的入口，根据某类名 的不同进行渲染。\nindex.ejs：直接绑定博客的主页，在访问根目录时，对应的 <%- body %> 输出的内容。\nlayout.ejs：整个主题的入口，包括 html 的 <head> 标签等所有内容。一般而言不同页面渲染结果不同是因为 <%- body %> 输出的内容不同。<%-body %> 是自带的内容，会根据访问的是主页还是分类或者标签或者归档进行渲染。\npage.ejs：特殊页的渲染，除了分类、标签、主页和归档，用户可以自己定义页面，自己定义的页面对应的 markdown 文件的渲染方法与 page.ejs 对应。\npost.ejs：博客的详细内容渲染，也就是对应markdown文件转换出的 html 界面。\ntag.ejs：标签的分类，直接绑定某个标签的内容，比如访问 tags/某标签 则返回这个标签的所有内容，就是在这里进行控制的。\n\nscripts 主题自带脚本文件夹\n接下来查看 scripts 文件夹：\n\nfancybox.js：在启动 hexo 时候会运行这个脚本。\n1.4.4 source 主题自带的资源文件夹\n主题的渲染过程样式非常重要，主题对应的 css 样式存储于这个文件夹，以及用得到的 js 脚本，也存储于此（与scripts不同，那个会启动时自动执行，只执行一次）。\n\ncss ：所有的样式文件夹。\nfancybox：fancybox 对应的样式与js文件；\njs：所有的js 文件。\n1.4.5 _config.yml 主题配置文件\n编写主题的时候必须考虑到不同的人审美、需求是不一样的，为了让用户用起来简单，把尽可能可以通过配置文件配置的内容均放在这个文件中比较合适。比如，主题默认情况下侧边栏的顺序是：\nwidgets:\n- category\n- tag\n- archive\n## hexo 主题工作整体流程\nHexo 启动后，\n1. 读 scripts 下所有脚本并执行这些脚本；\n2. 读取 layout 目录下 layout.ejs 文件；\n3. 根据 <%-body%> 在 layout.ejs 的位置进行渲染，包括主页的渲染、分类的渲染、归档的渲染以及自定义页面的渲染。\n\n# Hexo主题编写\n## 新建主题并配置\n在 themes 目录下新建一个文件夹，我们的主题对应的就是这个文件夹，给自己的主题起个名字，我们暂时起名为 base 吧。\n目前 base 还是为空的文件夹，我们修改根目录的 _config.yml 也就是Hexo的配置文件，将主题修改为我们的主题名字 base。\n并且在 base 目录下新建 layout 文件夹，并在 layout 下新建 layout.ejs 文件与 index.ejs 文件，前面第一章节介绍过，layout.ejs 是整个主题的入口，而 index.ejs 是必需文件，暂时为空白即可。\n编辑 layout.ejs 内容如下：\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>wnxx</title>\n</head>\n<body>\n    这是入口\n</body>\n</html>\n```\n重启 hexo ，可以看到效果为：\n## 新建所有功能性文件\n先理清楚所有功能对应的功能性文件，概述一下如表格所示。\n意博客详情页时默认是 posts/年/月/日/博客标题，也可以自行修改，这里统称为 博客路径。\n我们根据这个表格新建相应的文件。\n## 熟悉hexo内置的变量\n官网文档地址为：中文 https://hexo.io/zh-cn/docs/variables | 英文 https://hexo.io/docs/variables 建议两个都看一下。\n## layout.ejs\nlayout.ejs 是主题的入口，因此整个博客网站不同页面都可以认为是由 layout.ejs “派生” 得到的。换句话说，layout.ejs 中 <%- body %> 具体输出什么是由用户访问的页面决定的，其他部分可以根据具体访问的页面而决定是否展示（比如访问archive可以考虑隐藏侧边栏等）。\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>wnxx</title>\n</head>\n \n<body>\n    <!-- 网站名 -->\n    <h1>\n        <a href=\"/\"><%= config.title  %></a>\n        <a href=\"/\">Home</a>\n        <a href=\"<%-url_for(config.archive_dir)%>\">Archive</a>\n    </h1>\n    <%- body %> \n\n    <h3>categories</h3>\n    <ul>\n        <% site.categories.each(category=>{ %>\n            <li>\n                <a href=\"<%- url_for(category.path) %>\">\n                    <%- category.name  %> \n                </a>\n            </li>\n        <% }) %>\n    </ul>\n\n    <h3>tags</h3>\n    <ul>\n        <% site.tags.each(tag=>{ %>\n            <li>\n                <a href=\"<%- url_for(tag.path) %>\">\n                    <%- tag.name  %> \n                </a>\n            </li>\n        <% }) %>\n    </ul>\n</body>\n</html>\n```\n## index.ejs\n主页的内容展示带有分页效果的博客，具体的方法与前面的类似，读取page变量的所有 posts然后遍历，渲染。\n```\n<!-- 主页 -->\n<ul>\n<% page.posts.each(post=>{ %>\n    <li>\n        <a href=\"<%=url_for(post.path)%>\">\n            <%= post.title %>\n        </a>\n        | <%- date( post.date , 'YYYY/MM/DD HH:mm') %> \n    </li>\n<% }) %>\n</ul>\n\n<%- paginator({\n    prev_text: '<',\n    next_text: '>'\n}) %>\n```","slug":"开发hexo主题记录","published":1,"updated":"2023-04-13T08:19:27.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13ml9002itit8cbi9gu66","content":"<h1 id=\"关于Hexo及其工作原理\"><a href=\"#关于Hexo及其工作原理\" class=\"headerlink\" title=\"关于Hexo及其工作原理\"></a>关于Hexo及其工作原理</h1><h2 id=\"什么是Hexo\"><a href=\"#什么是Hexo\" class=\"headerlink\" title=\"什么是Hexo\"></a>什么是Hexo</h2><p>Hexo.js 官网的概述是：快速、简洁且高效的博客框架。准确而具体地概述应该是 Hexo.js 是一个基于 Node.js ，可以将 markdown 文件转换为html静态界面的博客框架。</p>\n<p>换句话说，hexo.js 可以使用 hexo serve 的命令运行提供网站功能，但其最主要的作用应当是生成静态文件，然后交给 nginx / tomcat 等服务器软件进行维护，对外提供网页服务。</p>\n<h2 id=\"Hexo-工作原理\"><a href=\"#Hexo-工作原理\" class=\"headerlink\" title=\"Hexo 工作原理\"></a>Hexo 工作原理</h2><p>应该把 Hexo.js 看作一个工具，一个根据配置文件与markdown文件以及html/css/js代码转换为前端界面的工具。<br>默认情况下 Hexo.js 运行后，将会默认生成多个页面，并具有相应的路径。<br>因此，Hexo 主题的作用就是将每个页面进行特定样式的渲染。</p>\n<h2 id=\"Hexo-快速开始\"><a href=\"#Hexo-快速开始\" class=\"headerlink\" title=\"Hexo 快速开始\"></a>Hexo 快速开始</h2><p>按照教程进行初始化项目：<br>hexo init ‘xxxx’<br>cd ‘xxxx’<br>npm install<br>hexo serve<br>访问 4000 端口</p>\n<h2 id=\"总体分析默认的-landscape-主题\"><a href=\"#总体分析默认的-landscape-主题\" class=\"headerlink\" title=\"总体分析默认的 landscape 主题\"></a>总体分析默认的 landscape 主题</h2><p>languages 国际化<br>即对于同一个变量对应的语言表达方法，比如 英文 home 简体中文 主页。</p>\n<p>layout 主题布局文件<br>在启动hexo的时候，博客渲染的入口为其中的 layout.ejs 文件，其他的内容将对应其他 ejs 文件，比如分类对应的是 category.ejs ，标签对应的是 tag.ejs。</p>\n<p>这里详细展开layout中所有的文件：</p>\n<p>_partial: 将整个网页拆成若干个局部模块，这些子模块存储于这个文件夹。<br>_partial/post：查看博客时的所有组件；<br>_partial/post/category.ejs: 查看博客详情时显示博客的类别；<br>_partial/post/date.ejs: 查看博客详情时显示博客的日期；<br>_partial/post/gallery.ejs: 查看博客详情时显示博客的图片；<br>_partial/post/nav.ejs: 查看博客详情时显示博客的上一篇下一篇的导航；<br>_partial/post/tag.ejs: 查看博客详情时显示博客的标签；<br>_partial/post/title.ejs: 查看博客详情时显示博客的标题；<br>_partial/after-footer.ejs：所有页面html的最后面应用 js 部分；<br>_partial/archive-post.ejs：对所有博客的归档；<br>_partital/archive.ejs：包括分类，标签以及博客的归档；<br>_partial/article.ejs：展示每篇博客的内容；<br>_partial/footer.ejs：每页内容的最下面展示的内容，比如copyright等；<br>_partial/gauges_analytics：对每篇博客的字数统计分析；<br>_partial/google_analytics：对每篇博客的谷歌统计分析；<br>_partial/head.ejs：html的头部内容；<br>_partial/mobile-nav.ejs：移动端时的导航；<br>_partial/sidebar.ejs：侧边栏；<br>_widget：小工具类，也就是侧边导航栏的组件；<br>_widget/archive.ejs：侧边栏的归档；<br>_widget/category.ejs：侧边栏的分类；<br>_widget/recent_posts.ejs：侧边栏的最近博客；<br>_widget/tag.ejs：侧边栏的标签；<br>_widget/tagcloud.ejs：侧边栏的标签云（使用自带的函数）；<br>archive.ejs ：博客的归档，是直接绑定 archives/ 的入口，根据归档的不同会在这里进行分岔。比如博客的归档，分类的归档，标签的归档。<br>category.ejs：博客的分类，是直接绑定 categories/某类名称 的入口，根据某类名 的不同进行渲染。<br>index.ejs：直接绑定博客的主页，在访问根目录时，对应的 &lt;%- body %&gt; 输出的内容。<br>layout.ejs：整个主题的入口，包括 html 的 <head> 标签等所有内容。一般而言不同页面渲染结果不同是因为 &lt;%- body %&gt; 输出的内容不同。&lt;%-body %&gt; 是自带的内容，会根据访问的是主页还是分类或者标签或者归档进行渲染。<br>page.ejs：特殊页的渲染，除了分类、标签、主页和归档，用户可以自己定义页面，自己定义的页面对应的 markdown 文件的渲染方法与 page.ejs 对应。<br>post.ejs：博客的详细内容渲染，也就是对应markdown文件转换出的 html 界面。<br>tag.ejs：标签的分类，直接绑定某个标签的内容，比如访问 tags/某标签 则返回这个标签的所有内容，就是在这里进行控制的。</p>\n<p>scripts 主题自带脚本文件夹<br>接下来查看 scripts 文件夹：</p>\n<p>fancybox.js：在启动 hexo 时候会运行这个脚本。<br>1.4.4 source 主题自带的资源文件夹<br>主题的渲染过程样式非常重要，主题对应的 css 样式存储于这个文件夹，以及用得到的 js 脚本，也存储于此（与scripts不同，那个会启动时自动执行，只执行一次）。</p>\n<p>css ：所有的样式文件夹。<br>fancybox：fancybox 对应的样式与js文件；<br>js：所有的js 文件。<br>1.4.5 _config.yml 主题配置文件<br>编写主题的时候必须考虑到不同的人审美、需求是不一样的，为了让用户用起来简单，把尽可能可以通过配置文件配置的内容均放在这个文件中比较合适。比如，主题默认情况下侧边栏的顺序是：<br>widgets:</p>\n<ul>\n<li>category</li>\n<li>tag</li>\n<li>archive<h2 id=\"hexo-主题工作整体流程\"><a href=\"#hexo-主题工作整体流程\" class=\"headerlink\" title=\"hexo 主题工作整体流程\"></a>hexo 主题工作整体流程</h2>Hexo 启动后，</li>\n</ul>\n<ol>\n<li>读 scripts 下所有脚本并执行这些脚本；</li>\n<li>读取 layout 目录下 layout.ejs 文件；</li>\n<li>根据 &lt;%-body%&gt; 在 layout.ejs 的位置进行渲染，包括主页的渲染、分类的渲染、归档的渲染以及自定义页面的渲染。</li>\n</ol>\n<h1 id=\"Hexo主题编写\"><a href=\"#Hexo主题编写\" class=\"headerlink\" title=\"Hexo主题编写\"></a>Hexo主题编写</h1><h2 id=\"新建主题并配置\"><a href=\"#新建主题并配置\" class=\"headerlink\" title=\"新建主题并配置\"></a>新建主题并配置</h2><p>在 themes 目录下新建一个文件夹，我们的主题对应的就是这个文件夹，给自己的主题起个名字，我们暂时起名为 base 吧。<br>目前 base 还是为空的文件夹，我们修改根目录的 _config.yml 也就是Hexo的配置文件，将主题修改为我们的主题名字 base。<br>并且在 base 目录下新建 layout 文件夹，并在 layout 下新建 layout.ejs 文件与 index.ejs 文件，前面第一章节介绍过，layout.ejs 是整个主题的入口，而 index.ejs 是必需文件，暂时为空白即可。<br>编辑 layout.ejs 内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;wnxx&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    这是入口</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>重启 hexo ，可以看到效果为：</p>\n<h2 id=\"新建所有功能性文件\"><a href=\"#新建所有功能性文件\" class=\"headerlink\" title=\"新建所有功能性文件\"></a>新建所有功能性文件</h2><p>先理清楚所有功能对应的功能性文件，概述一下如表格所示。<br>意博客详情页时默认是 posts/年/月/日/博客标题，也可以自行修改，这里统称为 博客路径。<br>我们根据这个表格新建相应的文件。</p>\n<h2 id=\"熟悉hexo内置的变量\"><a href=\"#熟悉hexo内置的变量\" class=\"headerlink\" title=\"熟悉hexo内置的变量\"></a>熟悉hexo内置的变量</h2><p>官网文档地址为：中文 <a href=\"https://hexo.io/zh-cn/docs/variables\">https://hexo.io/zh-cn/docs/variables</a> | 英文 <a href=\"https://hexo.io/docs/variables\">https://hexo.io/docs/variables</a> 建议两个都看一下。</p>\n<h2 id=\"layout-ejs\"><a href=\"#layout-ejs\" class=\"headerlink\" title=\"layout.ejs\"></a>layout.ejs</h2><p>layout.ejs 是主题的入口，因此整个博客网站不同页面都可以认为是由 layout.ejs “派生” 得到的。换句话说，layout.ejs 中 &lt;%- body %&gt; 具体输出什么是由用户访问的页面决定的，其他部分可以根据具体访问的页面而决定是否展示（比如访问archive可以考虑隐藏侧边栏等）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;wnxx&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;!-- 网站名 --&gt;</span><br><span class=\"line\">    &lt;h1&gt;</span><br><span class=\"line\">        &lt;a href=&quot;/&quot;&gt;&lt;%= config.title  %&gt;&lt;/a&gt;</span><br><span class=\"line\">        &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;</span><br><span class=\"line\">        &lt;a href=&quot;&lt;%-url_for(config.archive_dir)%&gt;&quot;&gt;Archive&lt;/a&gt;</span><br><span class=\"line\">    &lt;/h1&gt;</span><br><span class=\"line\">    &lt;%- body %&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;h3&gt;categories&lt;/h3&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &lt;% site.categories.each(category=&gt;&#123; %&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">                &lt;a href=&quot;&lt;%- url_for(category.path) %&gt;&quot;&gt;</span><br><span class=\"line\">                    &lt;%- category.name  %&gt; </span><br><span class=\"line\">                &lt;/a&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">        &lt;% &#125;) %&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;h3&gt;tags&lt;/h3&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &lt;% site.tags.each(tag=&gt;&#123; %&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">                &lt;a href=&quot;&lt;%- url_for(tag.path) %&gt;&quot;&gt;</span><br><span class=\"line\">                    &lt;%- tag.name  %&gt; </span><br><span class=\"line\">                &lt;/a&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">        &lt;% &#125;) %&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"index-ejs\"><a href=\"#index-ejs\" class=\"headerlink\" title=\"index.ejs\"></a>index.ejs</h2><p>主页的内容展示带有分页效果的博客，具体的方法与前面的类似，读取page变量的所有 posts然后遍历，渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 主页 --&gt;</span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">&lt;% page.posts.each(post=&gt;&#123; %&gt;</span><br><span class=\"line\">    &lt;li&gt;</span><br><span class=\"line\">        &lt;a href=&quot;&lt;%=url_for(post.path)%&gt;&quot;&gt;</span><br><span class=\"line\">            &lt;%= post.title %&gt;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">        | &lt;%- date( post.date , &#x27;YYYY/MM/DD HH:mm&#x27;) %&gt; </span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;% &#125;) %&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;%- paginator(&#123;</span><br><span class=\"line\">    prev_text: &#x27;&lt;&#x27;,</span><br><span class=\"line\">    next_text: &#x27;&gt;&#x27;</span><br><span class=\"line\">&#125;) %&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"关于Hexo及其工作原理\"><a href=\"#关于Hexo及其工作原理\" class=\"headerlink\" title=\"关于Hexo及其工作原理\"></a>关于Hexo及其工作原理</h1><h2 id=\"什么是Hexo\"><a href=\"#什么是Hexo\" class=\"headerlink\" title=\"什么是Hexo\"></a>什么是Hexo</h2><p>Hexo.js 官网的概述是：快速、简洁且高效的博客框架。准确而具体地概述应该是 Hexo.js 是一个基于 Node.js ，可以将 markdown 文件转换为html静态界面的博客框架。</p>\n<p>换句话说，hexo.js 可以使用 hexo serve 的命令运行提供网站功能，但其最主要的作用应当是生成静态文件，然后交给 nginx / tomcat 等服务器软件进行维护，对外提供网页服务。</p>\n<h2 id=\"Hexo-工作原理\"><a href=\"#Hexo-工作原理\" class=\"headerlink\" title=\"Hexo 工作原理\"></a>Hexo 工作原理</h2><p>应该把 Hexo.js 看作一个工具，一个根据配置文件与markdown文件以及html/css/js代码转换为前端界面的工具。<br>默认情况下 Hexo.js 运行后，将会默认生成多个页面，并具有相应的路径。<br>因此，Hexo 主题的作用就是将每个页面进行特定样式的渲染。</p>\n<h2 id=\"Hexo-快速开始\"><a href=\"#Hexo-快速开始\" class=\"headerlink\" title=\"Hexo 快速开始\"></a>Hexo 快速开始</h2><p>按照教程进行初始化项目：<br>hexo init ‘xxxx’<br>cd ‘xxxx’<br>npm install<br>hexo serve<br>访问 4000 端口</p>\n<h2 id=\"总体分析默认的-landscape-主题\"><a href=\"#总体分析默认的-landscape-主题\" class=\"headerlink\" title=\"总体分析默认的 landscape 主题\"></a>总体分析默认的 landscape 主题</h2><p>languages 国际化<br>即对于同一个变量对应的语言表达方法，比如 英文 home 简体中文 主页。</p>\n<p>layout 主题布局文件<br>在启动hexo的时候，博客渲染的入口为其中的 layout.ejs 文件，其他的内容将对应其他 ejs 文件，比如分类对应的是 category.ejs ，标签对应的是 tag.ejs。</p>\n<p>这里详细展开layout中所有的文件：</p>\n<p>_partial: 将整个网页拆成若干个局部模块，这些子模块存储于这个文件夹。<br>_partial/post：查看博客时的所有组件；<br>_partial/post/category.ejs: 查看博客详情时显示博客的类别；<br>_partial/post/date.ejs: 查看博客详情时显示博客的日期；<br>_partial/post/gallery.ejs: 查看博客详情时显示博客的图片；<br>_partial/post/nav.ejs: 查看博客详情时显示博客的上一篇下一篇的导航；<br>_partial/post/tag.ejs: 查看博客详情时显示博客的标签；<br>_partial/post/title.ejs: 查看博客详情时显示博客的标题；<br>_partial/after-footer.ejs：所有页面html的最后面应用 js 部分；<br>_partial/archive-post.ejs：对所有博客的归档；<br>_partital/archive.ejs：包括分类，标签以及博客的归档；<br>_partial/article.ejs：展示每篇博客的内容；<br>_partial/footer.ejs：每页内容的最下面展示的内容，比如copyright等；<br>_partial/gauges_analytics：对每篇博客的字数统计分析；<br>_partial/google_analytics：对每篇博客的谷歌统计分析；<br>_partial/head.ejs：html的头部内容；<br>_partial/mobile-nav.ejs：移动端时的导航；<br>_partial/sidebar.ejs：侧边栏；<br>_widget：小工具类，也就是侧边导航栏的组件；<br>_widget/archive.ejs：侧边栏的归档；<br>_widget/category.ejs：侧边栏的分类；<br>_widget/recent_posts.ejs：侧边栏的最近博客；<br>_widget/tag.ejs：侧边栏的标签；<br>_widget/tagcloud.ejs：侧边栏的标签云（使用自带的函数）；<br>archive.ejs ：博客的归档，是直接绑定 archives/ 的入口，根据归档的不同会在这里进行分岔。比如博客的归档，分类的归档，标签的归档。<br>category.ejs：博客的分类，是直接绑定 categories/某类名称 的入口，根据某类名 的不同进行渲染。<br>index.ejs：直接绑定博客的主页，在访问根目录时，对应的 &lt;%- body %&gt; 输出的内容。<br>layout.ejs：整个主题的入口，包括 html 的 <head> 标签等所有内容。一般而言不同页面渲染结果不同是因为 &lt;%- body %&gt; 输出的内容不同。&lt;%-body %&gt; 是自带的内容，会根据访问的是主页还是分类或者标签或者归档进行渲染。<br>page.ejs：特殊页的渲染，除了分类、标签、主页和归档，用户可以自己定义页面，自己定义的页面对应的 markdown 文件的渲染方法与 page.ejs 对应。<br>post.ejs：博客的详细内容渲染，也就是对应markdown文件转换出的 html 界面。<br>tag.ejs：标签的分类，直接绑定某个标签的内容，比如访问 tags/某标签 则返回这个标签的所有内容，就是在这里进行控制的。</p>\n<p>scripts 主题自带脚本文件夹<br>接下来查看 scripts 文件夹：</p>\n<p>fancybox.js：在启动 hexo 时候会运行这个脚本。<br>1.4.4 source 主题自带的资源文件夹<br>主题的渲染过程样式非常重要，主题对应的 css 样式存储于这个文件夹，以及用得到的 js 脚本，也存储于此（与scripts不同，那个会启动时自动执行，只执行一次）。</p>\n<p>css ：所有的样式文件夹。<br>fancybox：fancybox 对应的样式与js文件；<br>js：所有的js 文件。<br>1.4.5 _config.yml 主题配置文件<br>编写主题的时候必须考虑到不同的人审美、需求是不一样的，为了让用户用起来简单，把尽可能可以通过配置文件配置的内容均放在这个文件中比较合适。比如，主题默认情况下侧边栏的顺序是：<br>widgets:</p>\n<ul>\n<li>category</li>\n<li>tag</li>\n<li>archive<h2 id=\"hexo-主题工作整体流程\"><a href=\"#hexo-主题工作整体流程\" class=\"headerlink\" title=\"hexo 主题工作整体流程\"></a>hexo 主题工作整体流程</h2>Hexo 启动后，</li>\n</ul>\n<ol>\n<li>读 scripts 下所有脚本并执行这些脚本；</li>\n<li>读取 layout 目录下 layout.ejs 文件；</li>\n<li>根据 &lt;%-body%&gt; 在 layout.ejs 的位置进行渲染，包括主页的渲染、分类的渲染、归档的渲染以及自定义页面的渲染。</li>\n</ol>\n<h1 id=\"Hexo主题编写\"><a href=\"#Hexo主题编写\" class=\"headerlink\" title=\"Hexo主题编写\"></a>Hexo主题编写</h1><h2 id=\"新建主题并配置\"><a href=\"#新建主题并配置\" class=\"headerlink\" title=\"新建主题并配置\"></a>新建主题并配置</h2><p>在 themes 目录下新建一个文件夹，我们的主题对应的就是这个文件夹，给自己的主题起个名字，我们暂时起名为 base 吧。<br>目前 base 还是为空的文件夹，我们修改根目录的 _config.yml 也就是Hexo的配置文件，将主题修改为我们的主题名字 base。<br>并且在 base 目录下新建 layout 文件夹，并在 layout 下新建 layout.ejs 文件与 index.ejs 文件，前面第一章节介绍过，layout.ejs 是整个主题的入口，而 index.ejs 是必需文件，暂时为空白即可。<br>编辑 layout.ejs 内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;wnxx&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    这是入口</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>重启 hexo ，可以看到效果为：</p>\n<h2 id=\"新建所有功能性文件\"><a href=\"#新建所有功能性文件\" class=\"headerlink\" title=\"新建所有功能性文件\"></a>新建所有功能性文件</h2><p>先理清楚所有功能对应的功能性文件，概述一下如表格所示。<br>意博客详情页时默认是 posts/年/月/日/博客标题，也可以自行修改，这里统称为 博客路径。<br>我们根据这个表格新建相应的文件。</p>\n<h2 id=\"熟悉hexo内置的变量\"><a href=\"#熟悉hexo内置的变量\" class=\"headerlink\" title=\"熟悉hexo内置的变量\"></a>熟悉hexo内置的变量</h2><p>官网文档地址为：中文 <a href=\"https://hexo.io/zh-cn/docs/variables\">https://hexo.io/zh-cn/docs/variables</a> | 英文 <a href=\"https://hexo.io/docs/variables\">https://hexo.io/docs/variables</a> 建议两个都看一下。</p>\n<h2 id=\"layout-ejs\"><a href=\"#layout-ejs\" class=\"headerlink\" title=\"layout.ejs\"></a>layout.ejs</h2><p>layout.ejs 是主题的入口，因此整个博客网站不同页面都可以认为是由 layout.ejs “派生” 得到的。换句话说，layout.ejs 中 &lt;%- body %&gt; 具体输出什么是由用户访问的页面决定的，其他部分可以根据具体访问的页面而决定是否展示（比如访问archive可以考虑隐藏侧边栏等）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;wnxx&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;!-- 网站名 --&gt;</span><br><span class=\"line\">    &lt;h1&gt;</span><br><span class=\"line\">        &lt;a href=&quot;/&quot;&gt;&lt;%= config.title  %&gt;&lt;/a&gt;</span><br><span class=\"line\">        &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;</span><br><span class=\"line\">        &lt;a href=&quot;&lt;%-url_for(config.archive_dir)%&gt;&quot;&gt;Archive&lt;/a&gt;</span><br><span class=\"line\">    &lt;/h1&gt;</span><br><span class=\"line\">    &lt;%- body %&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;h3&gt;categories&lt;/h3&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &lt;% site.categories.each(category=&gt;&#123; %&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">                &lt;a href=&quot;&lt;%- url_for(category.path) %&gt;&quot;&gt;</span><br><span class=\"line\">                    &lt;%- category.name  %&gt; </span><br><span class=\"line\">                &lt;/a&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">        &lt;% &#125;) %&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;h3&gt;tags&lt;/h3&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &lt;% site.tags.each(tag=&gt;&#123; %&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">                &lt;a href=&quot;&lt;%- url_for(tag.path) %&gt;&quot;&gt;</span><br><span class=\"line\">                    &lt;%- tag.name  %&gt; </span><br><span class=\"line\">                &lt;/a&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">        &lt;% &#125;) %&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"index-ejs\"><a href=\"#index-ejs\" class=\"headerlink\" title=\"index.ejs\"></a>index.ejs</h2><p>主页的内容展示带有分页效果的博客，具体的方法与前面的类似，读取page变量的所有 posts然后遍历，渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 主页 --&gt;</span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">&lt;% page.posts.each(post=&gt;&#123; %&gt;</span><br><span class=\"line\">    &lt;li&gt;</span><br><span class=\"line\">        &lt;a href=&quot;&lt;%=url_for(post.path)%&gt;&quot;&gt;</span><br><span class=\"line\">            &lt;%= post.title %&gt;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">        | &lt;%- date( post.date , &#x27;YYYY/MM/DD HH:mm&#x27;) %&gt; </span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;% &#125;) %&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;%- paginator(&#123;</span><br><span class=\"line\">    prev_text: &#x27;&lt;&#x27;,</span><br><span class=\"line\">    next_text: &#x27;&gt;&#x27;</span><br><span class=\"line\">&#125;) %&gt;</span><br></pre></td></tr></table></figure>"},{"title":"微前端-qiankun","date":"2023-03-29T04:18:39.000Z","aubot":"ljylwnxx","comments":0,"toc":true,"cover":["/images/qiankuncover.png"],"banner":{"type":"img","bgurl":["/images/qiankuncover.png"]},"_content":"qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。\n# qiankun 的核心设计理念\n1. 简单\n由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。\n2. 解耦/技术栈无关\n微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。\n\n# 为什么不是 iframe\n一. 为什么不用 iframe，这几乎是所有微前端方案第一个会被 challenge 的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 \"炫技\" 或者刻意追求 \"特立独行\"。\n如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。\n二. iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。\n1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。\n2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..\n3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。\n4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。\n其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。\n\n# 特性\n1. 基于 single-spa 封装，提供了更加开箱即用的 API。\n2. 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。\n3. HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。\n4. 样式隔离，确保微应用之间样式互相不干扰。\n5. JS 沙箱，确保微应用之间 全局变量/事件 不冲突。\n6. 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。\n7. umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。\n\n# 快速构建一个qiankun微前端应用\n## 主应用的配置\n1. 首先需要创建一个主应用和至少一个微应用\n2. 然后在主应用中安装微前端库：qiankun，yarn add qiankun # 或者 npm i qiankun -S\n3. 在主应用的入口处导入qiankun中的两个方法registerMicroApps和start方法\n4. 调用registerMicroApps方法注册各个微应用，最后调用start方法来启动qiankun\n\n## 微应用配置\n1. 微应用不需要安装qiankun，但必须要在自己的入口处导出三个方法：\nbootstrap：在微应用启动（初始化）的时候调用一次（只会调用一次）\nmount：微应用渲染函数，每次微应用进入时都会调用\nunmount：每次微应用切出或卸载时都会调用\n**注意：**以上三个方法即使不做任何事也必须要导出，否则会报错\n2. 为了保证每个微应用还能独立运行，还需要在入口处根据全局属性window.__ POWERED_BY_QIANKUN __ 来判断当前应用是由主应用启动还是自己独立运行，从而做出相应的逻辑处理。\n+ 如果是独立运行则不需额外处理，只是按照原有逻辑进行渲染即可\n+ 如果是由主应用启动的，则需将全局变量window.__ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋给变量 __ webpack_public_path __\n3. 如果是webpack等工具构建的应用（如vue或react等）则还需要给微应用的打包工具（webpack）增加一些相应的配置，一般需要配置output的library和libraryTarget。\n4. 最后因为不同应用会部署在不同的域下，所以肯定还会有个跨域问题，一般会在服务器端再进行一个允许跨域的配置。\n\n# 实践\n## 主应用\n1. 利用vue脚手架创建一个vue2.0项目：main-app（vue create main-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式。\n2. 打开项目main-app，安装qiankun（npm install qiankun --save）\n3. 修改App.vue，新增一个subapp的router-link，to值为“/subapp”，并在router-view的下方新增一个id为vueContainer的div盒子（用于承载子应用）。\n4. 修改views/Home.vue，将默认内容删除，并改为： This is a home page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）\n5. 修改views/About.vue，将内容改为：This is an about page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）\n6. 修改main.js，导入qiankun中的registerMicroApps和start两个方法，注册子应用并启动qiankun\n下面看下修改后的完整代码（创建项目和安装qiankun的步骤就省略了）\n```\n<!-- App.vue -->\n<template>\n\t<div id=\"app\">\n\t\t<div id=\"nav\">\n\t\t\t<router-link to=\"/\">Home</router-link>\n\t\t\t<router-link to=\"/about\">About</router-link>\n\t\t\t<router-link to=\"/subapp\">sub-app</router-link> <!--新增部分-->\n\t\t</div>\n\t\t<router-view />\n\t\t<div id=\"vueContainer\"></div><!--新增部分，用于承载子应用-->\n\t</div>\n</template>\n```\n```\n<!-- views/Home.vue -->\n<template>\n\t<div class=\"home\">This is a home page in qiankun-main</div>\n</template>\n```\n```\n<!-- views/About.vue -->\n<template>\n\t<div class=\"home\">This is an about page in qiankun-main</div>\n</template>\n```\n```\n<!-- main.js -->\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\n<!-- ======================新增内容开始=============================== -->\nimport {registerMicroApps, start} from 'qiankun' //新增部分，导入qiankun中的两个方法\nconst apps = [\n{\n\tname:'subApp', //子应用的名称\n\tentry:'//localhost:8081',//子应用的域名\n\tcontainer:'#vueContainer',//承载子应用的容器，在上面App.vue中定义\n\tactiveRule:'/subapp', // 被激活的子应用的路由\n}\n]\nregisterMicroApps(apps);//注册子应用\nstart();//启动qiankun\n<!-- ======================新增内容结束=============================== -->\nnew Vue({\n\trouter,\n\trender: h => h(App)\n}).$mount('#app');\n```\n```\n<!-- router/index.js -->\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport Home from \"../views/Home\";\nimport About from \"../views/About\";\nVue.use(VueRouter)\nconst routes = [{\n        path: '/',\n        name: 'Home',\n        // redirect: '/home',\n        component: Home,\n    },\n    {\n        path: '/about',\n        name: 'About',\n        component: About,\n    },\n]\n<!-- 以下是修改后的代码 -->\nconst router = new VueRouter({\n\tmode:'history',\n\tbase: '',\n\troutes\n})\nexport default router;\n```\n\n## 微应用\n微应用中主要需要修改的地方有：main.js、vue.config.js和router/index.js，其余页面部分根据自己喜好可改可不改，本文为了便于区分主子应用的内容将对Home.vue和About.vue页面进行微小的改动\n\n1. 利用vue脚手架创建一个vue2.0项目：sub-app（vue create sub-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式\n2. 修改views/Home.vue，在原有内容的基础上新增语句：“This is a home page in sub-app”（根据个人喜好，可改可不改）\n修改views/About.vue，将内容改为：“This is an about page in sub-app”（根据个人喜好，可改可不改）\n3. 修改main.js（必需）\n+ 将创建Vue实例的代码部分提取到一个函数render中，render函数接收一个参数props\n+ 判断window.__ POWERED_BY_QIANKUN __，如果是从qiankun启动则将window. __ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋值给 __ webpack_public_path __ ，否则直接调用render方法表示子应用是独立运行\n+ 导出3个必需的方法bootstrap，mount和unmount；bootstrap函数体内容可为空但函数必须要导出。mount函数中调用render方法进行子应用渲染。unmount函数中将render方法中创建的vue实例销毁。\n4. 修改router/index.js，指定base值为：“/vueChild”\n5. 创建vue.config.js，在该文件中配置允许跨域：“ Access-Control-Allow-Origin：'*' ”，并配置webpack的output.library和output.libraryTarget\n\n各部分完整代码如下：\n```\n<!--======================== views/Home.vue ====================-->\n<template>\n\t<div class=\"home\">\n\t\t<img alt=\"Vue logo\" src=\"../assets/logo.png\" />\n\t\t<h1 style=\"color:red;\">This is a home page in sub-app</h1>\n\t</div>\n</template>\n```\n```\n<!--======================== views/About.vue ====================-->\n<template>\n\t<div class=\"About\">\t\t\n\t\tThis is an about page in sub-app\n\t</div>\n</template>\n```\n```\n<!--  main.js -->\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nlet instance = null; //设置全局变量，用于保存或销毁Vue实例\nfunction render(props = {}){\n\tconst { container } = props\n\tinstance = new Vue({\n\t\trouter,\n\t\trender: h => h(App)\n\t}).$mount(container ? container.querySelector(\"#app\") : \"#app\");//用于限定当前上下文下的#app，防止与主应用中的#app冲突\n}\nif(window.__POWERED_BY_QIANKUN__){\n\t__webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__\n}else{\n\trender();\n\tconsole.log('子应用独立运行')\n}\nexport async function bootstrap(props){\n\tconsole.log('这里暂时可以什么都不用做，但方法必须要导出')\n}\nexport async function mount(props){\n\trender(props);//从qiankun启动\n}\nexport async function unmount(props){\n\tinstance.$destroy();//销毁子应用实例\n}\n```\n```\n<!-- vue.config.js -->\nmodule.exports = {\n\tlintOnSave: false,\n\tdevServer:{\n\t\tport:8081,\n\t\theaders:{\n\t\t\t\"Access-Control-Allow-Origin\": \"*\"\n\t\t}\n\t},\n\tconfigureWebpack:{\n\t\toutput:{\n\t\t\tlibrary:'subApp',\n\t\t\tlibraryTarget:'umd'\n\t\t}\n\t}\n}\n```\n```\n<!-- router/index.js -->\n// ...原有代码省略\n//修改后的代码\nconst router = new VueRouter({\n\tmode:'history',\n\tbase:'/subapp',\n\troutes\n})\n```","source":"_posts/微前端-qiankun.md","raw":"---\ntitle: 微前端-qiankun\ndate: 2023-03-29 12:18:39\ntags: 微前端\ncategories: 知识点\naubot: ljylwnxx\ncomments: false\ntoc: true\ncover: [/images/qiankuncover.png]\nbanner: \n  type: img\n  bgurl: [/images/qiankuncover.png]\n---\nqiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。\n# qiankun 的核心设计理念\n1. 简单\n由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。\n2. 解耦/技术栈无关\n微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。\n\n# 为什么不是 iframe\n一. 为什么不用 iframe，这几乎是所有微前端方案第一个会被 challenge 的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 \"炫技\" 或者刻意追求 \"特立独行\"。\n如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。\n二. iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。\n1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。\n2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..\n3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。\n4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。\n其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。\n\n# 特性\n1. 基于 single-spa 封装，提供了更加开箱即用的 API。\n2. 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。\n3. HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。\n4. 样式隔离，确保微应用之间样式互相不干扰。\n5. JS 沙箱，确保微应用之间 全局变量/事件 不冲突。\n6. 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。\n7. umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。\n\n# 快速构建一个qiankun微前端应用\n## 主应用的配置\n1. 首先需要创建一个主应用和至少一个微应用\n2. 然后在主应用中安装微前端库：qiankun，yarn add qiankun # 或者 npm i qiankun -S\n3. 在主应用的入口处导入qiankun中的两个方法registerMicroApps和start方法\n4. 调用registerMicroApps方法注册各个微应用，最后调用start方法来启动qiankun\n\n## 微应用配置\n1. 微应用不需要安装qiankun，但必须要在自己的入口处导出三个方法：\nbootstrap：在微应用启动（初始化）的时候调用一次（只会调用一次）\nmount：微应用渲染函数，每次微应用进入时都会调用\nunmount：每次微应用切出或卸载时都会调用\n**注意：**以上三个方法即使不做任何事也必须要导出，否则会报错\n2. 为了保证每个微应用还能独立运行，还需要在入口处根据全局属性window.__ POWERED_BY_QIANKUN __ 来判断当前应用是由主应用启动还是自己独立运行，从而做出相应的逻辑处理。\n+ 如果是独立运行则不需额外处理，只是按照原有逻辑进行渲染即可\n+ 如果是由主应用启动的，则需将全局变量window.__ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋给变量 __ webpack_public_path __\n3. 如果是webpack等工具构建的应用（如vue或react等）则还需要给微应用的打包工具（webpack）增加一些相应的配置，一般需要配置output的library和libraryTarget。\n4. 最后因为不同应用会部署在不同的域下，所以肯定还会有个跨域问题，一般会在服务器端再进行一个允许跨域的配置。\n\n# 实践\n## 主应用\n1. 利用vue脚手架创建一个vue2.0项目：main-app（vue create main-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式。\n2. 打开项目main-app，安装qiankun（npm install qiankun --save）\n3. 修改App.vue，新增一个subapp的router-link，to值为“/subapp”，并在router-view的下方新增一个id为vueContainer的div盒子（用于承载子应用）。\n4. 修改views/Home.vue，将默认内容删除，并改为： This is a home page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）\n5. 修改views/About.vue，将内容改为：This is an about page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）\n6. 修改main.js，导入qiankun中的registerMicroApps和start两个方法，注册子应用并启动qiankun\n下面看下修改后的完整代码（创建项目和安装qiankun的步骤就省略了）\n```\n<!-- App.vue -->\n<template>\n\t<div id=\"app\">\n\t\t<div id=\"nav\">\n\t\t\t<router-link to=\"/\">Home</router-link>\n\t\t\t<router-link to=\"/about\">About</router-link>\n\t\t\t<router-link to=\"/subapp\">sub-app</router-link> <!--新增部分-->\n\t\t</div>\n\t\t<router-view />\n\t\t<div id=\"vueContainer\"></div><!--新增部分，用于承载子应用-->\n\t</div>\n</template>\n```\n```\n<!-- views/Home.vue -->\n<template>\n\t<div class=\"home\">This is a home page in qiankun-main</div>\n</template>\n```\n```\n<!-- views/About.vue -->\n<template>\n\t<div class=\"home\">This is an about page in qiankun-main</div>\n</template>\n```\n```\n<!-- main.js -->\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\n<!-- ======================新增内容开始=============================== -->\nimport {registerMicroApps, start} from 'qiankun' //新增部分，导入qiankun中的两个方法\nconst apps = [\n{\n\tname:'subApp', //子应用的名称\n\tentry:'//localhost:8081',//子应用的域名\n\tcontainer:'#vueContainer',//承载子应用的容器，在上面App.vue中定义\n\tactiveRule:'/subapp', // 被激活的子应用的路由\n}\n]\nregisterMicroApps(apps);//注册子应用\nstart();//启动qiankun\n<!-- ======================新增内容结束=============================== -->\nnew Vue({\n\trouter,\n\trender: h => h(App)\n}).$mount('#app');\n```\n```\n<!-- router/index.js -->\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport Home from \"../views/Home\";\nimport About from \"../views/About\";\nVue.use(VueRouter)\nconst routes = [{\n        path: '/',\n        name: 'Home',\n        // redirect: '/home',\n        component: Home,\n    },\n    {\n        path: '/about',\n        name: 'About',\n        component: About,\n    },\n]\n<!-- 以下是修改后的代码 -->\nconst router = new VueRouter({\n\tmode:'history',\n\tbase: '',\n\troutes\n})\nexport default router;\n```\n\n## 微应用\n微应用中主要需要修改的地方有：main.js、vue.config.js和router/index.js，其余页面部分根据自己喜好可改可不改，本文为了便于区分主子应用的内容将对Home.vue和About.vue页面进行微小的改动\n\n1. 利用vue脚手架创建一个vue2.0项目：sub-app（vue create sub-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式\n2. 修改views/Home.vue，在原有内容的基础上新增语句：“This is a home page in sub-app”（根据个人喜好，可改可不改）\n修改views/About.vue，将内容改为：“This is an about page in sub-app”（根据个人喜好，可改可不改）\n3. 修改main.js（必需）\n+ 将创建Vue实例的代码部分提取到一个函数render中，render函数接收一个参数props\n+ 判断window.__ POWERED_BY_QIANKUN __，如果是从qiankun启动则将window. __ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋值给 __ webpack_public_path __ ，否则直接调用render方法表示子应用是独立运行\n+ 导出3个必需的方法bootstrap，mount和unmount；bootstrap函数体内容可为空但函数必须要导出。mount函数中调用render方法进行子应用渲染。unmount函数中将render方法中创建的vue实例销毁。\n4. 修改router/index.js，指定base值为：“/vueChild”\n5. 创建vue.config.js，在该文件中配置允许跨域：“ Access-Control-Allow-Origin：'*' ”，并配置webpack的output.library和output.libraryTarget\n\n各部分完整代码如下：\n```\n<!--======================== views/Home.vue ====================-->\n<template>\n\t<div class=\"home\">\n\t\t<img alt=\"Vue logo\" src=\"../assets/logo.png\" />\n\t\t<h1 style=\"color:red;\">This is a home page in sub-app</h1>\n\t</div>\n</template>\n```\n```\n<!--======================== views/About.vue ====================-->\n<template>\n\t<div class=\"About\">\t\t\n\t\tThis is an about page in sub-app\n\t</div>\n</template>\n```\n```\n<!--  main.js -->\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nlet instance = null; //设置全局变量，用于保存或销毁Vue实例\nfunction render(props = {}){\n\tconst { container } = props\n\tinstance = new Vue({\n\t\trouter,\n\t\trender: h => h(App)\n\t}).$mount(container ? container.querySelector(\"#app\") : \"#app\");//用于限定当前上下文下的#app，防止与主应用中的#app冲突\n}\nif(window.__POWERED_BY_QIANKUN__){\n\t__webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__\n}else{\n\trender();\n\tconsole.log('子应用独立运行')\n}\nexport async function bootstrap(props){\n\tconsole.log('这里暂时可以什么都不用做，但方法必须要导出')\n}\nexport async function mount(props){\n\trender(props);//从qiankun启动\n}\nexport async function unmount(props){\n\tinstance.$destroy();//销毁子应用实例\n}\n```\n```\n<!-- vue.config.js -->\nmodule.exports = {\n\tlintOnSave: false,\n\tdevServer:{\n\t\tport:8081,\n\t\theaders:{\n\t\t\t\"Access-Control-Allow-Origin\": \"*\"\n\t\t}\n\t},\n\tconfigureWebpack:{\n\t\toutput:{\n\t\t\tlibrary:'subApp',\n\t\t\tlibraryTarget:'umd'\n\t\t}\n\t}\n}\n```\n```\n<!-- router/index.js -->\n// ...原有代码省略\n//修改后的代码\nconst router = new VueRouter({\n\tmode:'history',\n\tbase:'/subapp',\n\troutes\n})\n```","slug":"微前端-qiankun","published":1,"updated":"2023-04-11T06:54:40.195Z","layout":"post","photos":[],"link":"","_id":"clgq13ml9002mtit88w63abak","content":"<p>qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p>\n<h1 id=\"qiankun-的核心设计理念\"><a href=\"#qiankun-的核心设计理念\" class=\"headerlink\" title=\"qiankun 的核心设计理念\"></a>qiankun 的核心设计理念</h1><ol>\n<li>简单<br>由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。</li>\n<li>解耦/技术栈无关<br>微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。</li>\n</ol>\n<h1 id=\"为什么不是-iframe\"><a href=\"#为什么不是-iframe\" class=\"headerlink\" title=\"为什么不是 iframe\"></a>为什么不是 iframe</h1><p>一. 为什么不用 iframe，这几乎是所有微前端方案第一个会被 challenge 的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 “炫技” 或者刻意追求 “特立独行”。<br>如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。<br>二. iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。</p>\n<ol>\n<li>url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。</li>\n<li>UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..</li>\n<li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。</li>\n<li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。<br>其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。</li>\n</ol>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><ol>\n<li>基于 single-spa 封装，提供了更加开箱即用的 API。</li>\n<li>技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。</li>\n<li>HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。</li>\n<li>样式隔离，确保微应用之间样式互相不干扰。</li>\n<li>JS 沙箱，确保微应用之间 全局变量/事件 不冲突。</li>\n<li>资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。</li>\n<li>umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。</li>\n</ol>\n<h1 id=\"快速构建一个qiankun微前端应用\"><a href=\"#快速构建一个qiankun微前端应用\" class=\"headerlink\" title=\"快速构建一个qiankun微前端应用\"></a>快速构建一个qiankun微前端应用</h1><h2 id=\"主应用的配置\"><a href=\"#主应用的配置\" class=\"headerlink\" title=\"主应用的配置\"></a>主应用的配置</h2><ol>\n<li>首先需要创建一个主应用和至少一个微应用</li>\n<li>然后在主应用中安装微前端库：qiankun，yarn add qiankun # 或者 npm i qiankun -S</li>\n<li>在主应用的入口处导入qiankun中的两个方法registerMicroApps和start方法</li>\n<li>调用registerMicroApps方法注册各个微应用，最后调用start方法来启动qiankun</li>\n</ol>\n<h2 id=\"微应用配置\"><a href=\"#微应用配置\" class=\"headerlink\" title=\"微应用配置\"></a>微应用配置</h2><ol>\n<li>微应用不需要安装qiankun，但必须要在自己的入口处导出三个方法：<br>bootstrap：在微应用启动（初始化）的时候调用一次（只会调用一次）<br>mount：微应用渲染函数，每次微应用进入时都会调用<br>unmount：每次微应用切出或卸载时都会调用</li>\n</ol>\n<p><strong>注意：</strong>以上三个方法即使不做任何事也必须要导出，否则会报错<br>2. 为了保证每个微应用还能独立运行，还需要在入口处根据全局属性window.__ POWERED_BY_QIANKUN __ 来判断当前应用是由主应用启动还是自己独立运行，从而做出相应的逻辑处理。</p>\n<ul>\n<li>如果是独立运行则不需额外处理，只是按照原有逻辑进行渲染即可</li>\n<li>如果是由主应用启动的，则需将全局变量window.__ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋给变量 __ webpack_public_path __</li>\n</ul>\n<ol start=\"3\">\n<li>如果是webpack等工具构建的应用（如vue或react等）则还需要给微应用的打包工具（webpack）增加一些相应的配置，一般需要配置output的library和libraryTarget。</li>\n<li>最后因为不同应用会部署在不同的域下，所以肯定还会有个跨域问题，一般会在服务器端再进行一个允许跨域的配置。</li>\n</ol>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><h2 id=\"主应用\"><a href=\"#主应用\" class=\"headerlink\" title=\"主应用\"></a>主应用</h2><ol>\n<li>利用vue脚手架创建一个vue2.0项目：main-app（vue create main-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式。</li>\n<li>打开项目main-app，安装qiankun（npm install qiankun –save）</li>\n<li>修改App.vue，新增一个subapp的router-link，to值为“/subapp”，并在router-view的下方新增一个id为vueContainer的div盒子（用于承载子应用）。</li>\n<li>修改views/Home.vue，将默认内容删除，并改为： This is a home page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）</li>\n<li>修改views/About.vue，将内容改为：This is an about page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）</li>\n<li>修改main.js，导入qiankun中的registerMicroApps和start两个方法，注册子应用并启动qiankun<br>下面看下修改后的完整代码（创建项目和安装qiankun的步骤就省略了）<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- App.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">\t\t&lt;div id=&quot;nav&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;</span><br><span class=\"line\">\t\t\t&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class=\"line\">\t\t\t&lt;router-link to=&quot;/subapp&quot;&gt;sub-app&lt;/router-link&gt; &lt;!--新增部分--&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;router-view /&gt;</span><br><span class=\"line\">\t\t&lt;div id=&quot;vueContainer&quot;&gt;&lt;/div&gt;&lt;!--新增部分，用于承载子应用--&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- views/Home.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;home&quot;&gt;This is a home page in qiankun-main&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- views/About.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;home&quot;&gt;This is an about page in qiankun-main&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- main.js --&gt;</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\">import router from &#x27;./router&#x27;</span><br><span class=\"line\">&lt;!-- ======================新增内容开始=============================== --&gt;</span><br><span class=\"line\">import &#123;registerMicroApps, start&#125; from &#x27;qiankun&#x27; //新增部分，导入qiankun中的两个方法</span><br><span class=\"line\">const apps = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tname:&#x27;subApp&#x27;, //子应用的名称</span><br><span class=\"line\">\tentry:&#x27;//localhost:8081&#x27;,//子应用的域名</span><br><span class=\"line\">\tcontainer:&#x27;#vueContainer&#x27;,//承载子应用的容器，在上面App.vue中定义</span><br><span class=\"line\">\tactiveRule:&#x27;/subapp&#x27;, // 被激活的子应用的路由</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">registerMicroApps(apps);//注册子应用</span><br><span class=\"line\">start();//启动qiankun</span><br><span class=\"line\">&lt;!-- ======================新增内容结束=============================== --&gt;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">\trouter,</span><br><span class=\"line\">\trender: h =&gt; h(App)</span><br><span class=\"line\">&#125;).$mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- router/index.js --&gt;</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import VueRouter from &#x27;vue-router&#x27;</span><br><span class=\"line\">import Home from &quot;../views/Home&quot;;</span><br><span class=\"line\">import About from &quot;../views/About&quot;;</span><br><span class=\"line\">Vue.use(VueRouter)</span><br><span class=\"line\">const routes = [&#123;</span><br><span class=\"line\">        path: &#x27;/&#x27;,</span><br><span class=\"line\">        name: &#x27;Home&#x27;,</span><br><span class=\"line\">        // redirect: &#x27;/home&#x27;,</span><br><span class=\"line\">        component: Home,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        path: &#x27;/about&#x27;,</span><br><span class=\"line\">        name: &#x27;About&#x27;,</span><br><span class=\"line\">        component: About,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\">&lt;!-- 以下是修改后的代码 --&gt;</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">\tmode:&#x27;history&#x27;,</span><br><span class=\"line\">\tbase: &#x27;&#x27;,</span><br><span class=\"line\">\troutes</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export default router;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"微应用\"><a href=\"#微应用\" class=\"headerlink\" title=\"微应用\"></a>微应用</h2><p>微应用中主要需要修改的地方有：main.js、vue.config.js和router/index.js，其余页面部分根据自己喜好可改可不改，本文为了便于区分主子应用的内容将对Home.vue和About.vue页面进行微小的改动</p>\n<ol>\n<li>利用vue脚手架创建一个vue2.0项目：sub-app（vue create sub-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式</li>\n<li>修改views/Home.vue，在原有内容的基础上新增语句：“This is a home page in sub-app”（根据个人喜好，可改可不改）<br>修改views/About.vue，将内容改为：“This is an about page in sub-app”（根据个人喜好，可改可不改）</li>\n<li>修改main.js（必需）</li>\n</ol>\n<ul>\n<li>将创建Vue实例的代码部分提取到一个函数render中，render函数接收一个参数props</li>\n<li>判断window.__ POWERED_BY_QIANKUN __，如果是从qiankun启动则将window. __ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋值给 __ webpack_public_path __ ，否则直接调用render方法表示子应用是独立运行</li>\n<li>导出3个必需的方法bootstrap，mount和unmount；bootstrap函数体内容可为空但函数必须要导出。mount函数中调用render方法进行子应用渲染。unmount函数中将render方法中创建的vue实例销毁。</li>\n</ul>\n<ol start=\"4\">\n<li>修改router/index.js，指定base值为：“/vueChild”</li>\n<li>创建vue.config.js，在该文件中配置允许跨域：“ Access-Control-Allow-Origin：’*’ ”，并配置webpack的output.library和output.libraryTarget</li>\n</ol>\n<p>各部分完整代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--======================== views/Home.vue ====================--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;home&quot;&gt;</span><br><span class=\"line\">\t\t&lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;h1 style=&quot;color:red;&quot;&gt;This is a home page in sub-app&lt;/h1&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--======================== views/About.vue ====================--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;About&quot;&gt;\t\t</span><br><span class=\"line\">\t\tThis is an about page in sub-app</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--  main.js --&gt;</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\">import router from &#x27;./router&#x27;</span><br><span class=\"line\">let instance = null; //设置全局变量，用于保存或销毁Vue实例</span><br><span class=\"line\">function render(props = &#123;&#125;)&#123;</span><br><span class=\"line\">\tconst &#123; container &#125; = props</span><br><span class=\"line\">\tinstance = new Vue(&#123;</span><br><span class=\"line\">\t\trouter,</span><br><span class=\"line\">\t\trender: h =&gt; h(App)</span><br><span class=\"line\">\t&#125;).$mount(container ? container.querySelector(&quot;#app&quot;) : &quot;#app&quot;);//用于限定当前上下文下的#app，防止与主应用中的#app冲突</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if(window.__POWERED_BY_QIANKUN__)&#123;</span><br><span class=\"line\">\t__webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">\trender();</span><br><span class=\"line\">\tconsole.log(&#x27;子应用独立运行&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export async function bootstrap(props)&#123;</span><br><span class=\"line\">\tconsole.log(&#x27;这里暂时可以什么都不用做，但方法必须要导出&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export async function mount(props)&#123;</span><br><span class=\"line\">\trender(props);//从qiankun启动</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export async function unmount(props)&#123;</span><br><span class=\"line\">\tinstance.$destroy();//销毁子应用实例</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- vue.config.js --&gt;</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">\tlintOnSave: false,</span><br><span class=\"line\">\tdevServer:&#123;</span><br><span class=\"line\">\t\tport:8081,</span><br><span class=\"line\">\t\theaders:&#123;</span><br><span class=\"line\">\t\t\t&quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tconfigureWebpack:&#123;</span><br><span class=\"line\">\t\toutput:&#123;</span><br><span class=\"line\">\t\t\tlibrary:&#x27;subApp&#x27;,</span><br><span class=\"line\">\t\t\tlibraryTarget:&#x27;umd&#x27;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- router/index.js --&gt;</span><br><span class=\"line\">// ...原有代码省略</span><br><span class=\"line\">//修改后的代码</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">\tmode:&#x27;history&#x27;,</span><br><span class=\"line\">\tbase:&#x27;/subapp&#x27;,</span><br><span class=\"line\">\troutes</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p>\n<h1 id=\"qiankun-的核心设计理念\"><a href=\"#qiankun-的核心设计理念\" class=\"headerlink\" title=\"qiankun 的核心设计理念\"></a>qiankun 的核心设计理念</h1><ol>\n<li>简单<br>由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。</li>\n<li>解耦/技术栈无关<br>微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。</li>\n</ol>\n<h1 id=\"为什么不是-iframe\"><a href=\"#为什么不是-iframe\" class=\"headerlink\" title=\"为什么不是 iframe\"></a>为什么不是 iframe</h1><p>一. 为什么不用 iframe，这几乎是所有微前端方案第一个会被 challenge 的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 “炫技” 或者刻意追求 “特立独行”。<br>如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。<br>二. iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。</p>\n<ol>\n<li>url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。</li>\n<li>UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..</li>\n<li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。</li>\n<li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。<br>其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。</li>\n</ol>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><ol>\n<li>基于 single-spa 封装，提供了更加开箱即用的 API。</li>\n<li>技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。</li>\n<li>HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。</li>\n<li>样式隔离，确保微应用之间样式互相不干扰。</li>\n<li>JS 沙箱，确保微应用之间 全局变量/事件 不冲突。</li>\n<li>资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。</li>\n<li>umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。</li>\n</ol>\n<h1 id=\"快速构建一个qiankun微前端应用\"><a href=\"#快速构建一个qiankun微前端应用\" class=\"headerlink\" title=\"快速构建一个qiankun微前端应用\"></a>快速构建一个qiankun微前端应用</h1><h2 id=\"主应用的配置\"><a href=\"#主应用的配置\" class=\"headerlink\" title=\"主应用的配置\"></a>主应用的配置</h2><ol>\n<li>首先需要创建一个主应用和至少一个微应用</li>\n<li>然后在主应用中安装微前端库：qiankun，yarn add qiankun # 或者 npm i qiankun -S</li>\n<li>在主应用的入口处导入qiankun中的两个方法registerMicroApps和start方法</li>\n<li>调用registerMicroApps方法注册各个微应用，最后调用start方法来启动qiankun</li>\n</ol>\n<h2 id=\"微应用配置\"><a href=\"#微应用配置\" class=\"headerlink\" title=\"微应用配置\"></a>微应用配置</h2><ol>\n<li>微应用不需要安装qiankun，但必须要在自己的入口处导出三个方法：<br>bootstrap：在微应用启动（初始化）的时候调用一次（只会调用一次）<br>mount：微应用渲染函数，每次微应用进入时都会调用<br>unmount：每次微应用切出或卸载时都会调用</li>\n</ol>\n<p><strong>注意：</strong>以上三个方法即使不做任何事也必须要导出，否则会报错<br>2. 为了保证每个微应用还能独立运行，还需要在入口处根据全局属性window.__ POWERED_BY_QIANKUN __ 来判断当前应用是由主应用启动还是自己独立运行，从而做出相应的逻辑处理。</p>\n<ul>\n<li>如果是独立运行则不需额外处理，只是按照原有逻辑进行渲染即可</li>\n<li>如果是由主应用启动的，则需将全局变量window.__ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋给变量 __ webpack_public_path __</li>\n</ul>\n<ol start=\"3\">\n<li>如果是webpack等工具构建的应用（如vue或react等）则还需要给微应用的打包工具（webpack）增加一些相应的配置，一般需要配置output的library和libraryTarget。</li>\n<li>最后因为不同应用会部署在不同的域下，所以肯定还会有个跨域问题，一般会在服务器端再进行一个允许跨域的配置。</li>\n</ol>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><h2 id=\"主应用\"><a href=\"#主应用\" class=\"headerlink\" title=\"主应用\"></a>主应用</h2><ol>\n<li>利用vue脚手架创建一个vue2.0项目：main-app（vue create main-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式。</li>\n<li>打开项目main-app，安装qiankun（npm install qiankun –save）</li>\n<li>修改App.vue，新增一个subapp的router-link，to值为“/subapp”，并在router-view的下方新增一个id为vueContainer的div盒子（用于承载子应用）。</li>\n<li>修改views/Home.vue，将默认内容删除，并改为： This is a home page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）</li>\n<li>修改views/About.vue，将内容改为：This is an about page in qiankun-main（非必须，可根据自己喜好随便改动，也可使用默认内容）</li>\n<li>修改main.js，导入qiankun中的registerMicroApps和start两个方法，注册子应用并启动qiankun<br>下面看下修改后的完整代码（创建项目和安装qiankun的步骤就省略了）<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- App.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">\t\t&lt;div id=&quot;nav&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;</span><br><span class=\"line\">\t\t\t&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class=\"line\">\t\t\t&lt;router-link to=&quot;/subapp&quot;&gt;sub-app&lt;/router-link&gt; &lt;!--新增部分--&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;router-view /&gt;</span><br><span class=\"line\">\t\t&lt;div id=&quot;vueContainer&quot;&gt;&lt;/div&gt;&lt;!--新增部分，用于承载子应用--&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- views/Home.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;home&quot;&gt;This is a home page in qiankun-main&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- views/About.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;home&quot;&gt;This is an about page in qiankun-main&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- main.js --&gt;</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\">import router from &#x27;./router&#x27;</span><br><span class=\"line\">&lt;!-- ======================新增内容开始=============================== --&gt;</span><br><span class=\"line\">import &#123;registerMicroApps, start&#125; from &#x27;qiankun&#x27; //新增部分，导入qiankun中的两个方法</span><br><span class=\"line\">const apps = [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tname:&#x27;subApp&#x27;, //子应用的名称</span><br><span class=\"line\">\tentry:&#x27;//localhost:8081&#x27;,//子应用的域名</span><br><span class=\"line\">\tcontainer:&#x27;#vueContainer&#x27;,//承载子应用的容器，在上面App.vue中定义</span><br><span class=\"line\">\tactiveRule:&#x27;/subapp&#x27;, // 被激活的子应用的路由</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">registerMicroApps(apps);//注册子应用</span><br><span class=\"line\">start();//启动qiankun</span><br><span class=\"line\">&lt;!-- ======================新增内容结束=============================== --&gt;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">\trouter,</span><br><span class=\"line\">\trender: h =&gt; h(App)</span><br><span class=\"line\">&#125;).$mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- router/index.js --&gt;</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import VueRouter from &#x27;vue-router&#x27;</span><br><span class=\"line\">import Home from &quot;../views/Home&quot;;</span><br><span class=\"line\">import About from &quot;../views/About&quot;;</span><br><span class=\"line\">Vue.use(VueRouter)</span><br><span class=\"line\">const routes = [&#123;</span><br><span class=\"line\">        path: &#x27;/&#x27;,</span><br><span class=\"line\">        name: &#x27;Home&#x27;,</span><br><span class=\"line\">        // redirect: &#x27;/home&#x27;,</span><br><span class=\"line\">        component: Home,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        path: &#x27;/about&#x27;,</span><br><span class=\"line\">        name: &#x27;About&#x27;,</span><br><span class=\"line\">        component: About,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\">&lt;!-- 以下是修改后的代码 --&gt;</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">\tmode:&#x27;history&#x27;,</span><br><span class=\"line\">\tbase: &#x27;&#x27;,</span><br><span class=\"line\">\troutes</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export default router;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"微应用\"><a href=\"#微应用\" class=\"headerlink\" title=\"微应用\"></a>微应用</h2><p>微应用中主要需要修改的地方有：main.js、vue.config.js和router/index.js，其余页面部分根据自己喜好可改可不改，本文为了便于区分主子应用的内容将对Home.vue和About.vue页面进行微小的改动</p>\n<ol>\n<li>利用vue脚手架创建一个vue2.0项目：sub-app（vue create sub-app），建议选择手动模式可以将Router勾选上，并且需要使用history路由模式</li>\n<li>修改views/Home.vue，在原有内容的基础上新增语句：“This is a home page in sub-app”（根据个人喜好，可改可不改）<br>修改views/About.vue，将内容改为：“This is an about page in sub-app”（根据个人喜好，可改可不改）</li>\n<li>修改main.js（必需）</li>\n</ol>\n<ul>\n<li>将创建Vue实例的代码部分提取到一个函数render中，render函数接收一个参数props</li>\n<li>判断window.__ POWERED_BY_QIANKUN __，如果是从qiankun启动则将window. __ INJECTED_PUBLIC_PATH_BY_QIANKUN __ 的值赋值给 __ webpack_public_path __ ，否则直接调用render方法表示子应用是独立运行</li>\n<li>导出3个必需的方法bootstrap，mount和unmount；bootstrap函数体内容可为空但函数必须要导出。mount函数中调用render方法进行子应用渲染。unmount函数中将render方法中创建的vue实例销毁。</li>\n</ul>\n<ol start=\"4\">\n<li>修改router/index.js，指定base值为：“/vueChild”</li>\n<li>创建vue.config.js，在该文件中配置允许跨域：“ Access-Control-Allow-Origin：’*’ ”，并配置webpack的output.library和output.libraryTarget</li>\n</ol>\n<p>各部分完整代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--======================== views/Home.vue ====================--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;home&quot;&gt;</span><br><span class=\"line\">\t\t&lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;h1 style=&quot;color:red;&quot;&gt;This is a home page in sub-app&lt;/h1&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--======================== views/About.vue ====================--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;About&quot;&gt;\t\t</span><br><span class=\"line\">\t\tThis is an about page in sub-app</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--  main.js --&gt;</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\">import router from &#x27;./router&#x27;</span><br><span class=\"line\">let instance = null; //设置全局变量，用于保存或销毁Vue实例</span><br><span class=\"line\">function render(props = &#123;&#125;)&#123;</span><br><span class=\"line\">\tconst &#123; container &#125; = props</span><br><span class=\"line\">\tinstance = new Vue(&#123;</span><br><span class=\"line\">\t\trouter,</span><br><span class=\"line\">\t\trender: h =&gt; h(App)</span><br><span class=\"line\">\t&#125;).$mount(container ? container.querySelector(&quot;#app&quot;) : &quot;#app&quot;);//用于限定当前上下文下的#app，防止与主应用中的#app冲突</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if(window.__POWERED_BY_QIANKUN__)&#123;</span><br><span class=\"line\">\t__webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">\trender();</span><br><span class=\"line\">\tconsole.log(&#x27;子应用独立运行&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export async function bootstrap(props)&#123;</span><br><span class=\"line\">\tconsole.log(&#x27;这里暂时可以什么都不用做，但方法必须要导出&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export async function mount(props)&#123;</span><br><span class=\"line\">\trender(props);//从qiankun启动</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export async function unmount(props)&#123;</span><br><span class=\"line\">\tinstance.$destroy();//销毁子应用实例</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- vue.config.js --&gt;</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">\tlintOnSave: false,</span><br><span class=\"line\">\tdevServer:&#123;</span><br><span class=\"line\">\t\tport:8081,</span><br><span class=\"line\">\t\theaders:&#123;</span><br><span class=\"line\">\t\t\t&quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tconfigureWebpack:&#123;</span><br><span class=\"line\">\t\toutput:&#123;</span><br><span class=\"line\">\t\t\tlibrary:&#x27;subApp&#x27;,</span><br><span class=\"line\">\t\t\tlibraryTarget:&#x27;umd&#x27;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- router/index.js --&gt;</span><br><span class=\"line\">// ...原有代码省略</span><br><span class=\"line\">//修改后的代码</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">\tmode:&#x27;history&#x27;,</span><br><span class=\"line\">\tbase:&#x27;/subapp&#x27;,</span><br><span class=\"line\">\troutes</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"微前端","date":"2023-03-27T13:29:13.000Z","_content":"# 什么是微前端\n微前端是一种多个团队通过独立发布功能的方式来共同构建现代化web应用的技术手段及方法策略。\n微前端可以将多个小型应用整合成一个完整的应用。每个小型应用都是独立开发、独立运行、独立部署的，这就意味着可以多团队并行开发 且有无冲突、无阻塞等特点。\n# 微前端架构具备以下几个核心价值：\n1.技术栈无关\n主框架不限制接入应用的技术栈，微应用具备完全自主权\n2.独立开发、独立部署\n微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n3.增量升级\n在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n4.独立运行时\n每个微应用之间状态隔离，运行时状态不共享\n# 常见的微前端实现方式\n1.路由分发\n简单来说，其实就是通过网关/代理对路由进行监听，对不同的路由路径导向不同的前端资源入口。\n例如：\n使用 Nginx 代理了 localhost:80；\n然后访问路径为 /app1 的时候，返回 html/app1/index.html 的文件；\n访问路径为 /app2 的时候，返回 html/app2/index.html 的文件。\n这种方式由于是多页面应用，所以用户体验不好，而且比较依赖于后端，应用之间存在着耦合问题。\n## 优点：\n开发成本低\n配置简单\n## 缺点：\n多应用之间切换时，每个应用都会重新加载，影响体验（可以思考 传统页面 和 SPA 区别）\n多应用间不能共享数据\n多应用间通信困难\n多应用公共依赖重复加载\n\n## 2.iframe\n它的作用就是在网页中嵌套另一个网页，那么通过这种特性就可以实现微前端了。\n但实际上个大微前端框架，就没有一个是用iframe去做的，因为iframe有着很多的问题，其中一些甚至是无法解决的。\n## 优点：完美支持js隔离，样式隔离\n## 缺点：\nurl 不同步， 浏览器刷新时，iframe中的url 状态会丢失\niframe局部弹框\n内外通信效率低下，变量不能共享\n每次进入，资源都会被重新加载，速度较慢\n## 3.Web Components\nWeb Components 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。\n(1)Custom elements（自定义元素） 一组 JavaScript API，允许您定义custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。\n(2)Shadow DOM（影子 DOM） ：一组JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\n(3)HTML templates（HTML 模板）： <template> 和 <slot> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\n## 优点：\n每个服务拥有独立的脚本和样式\n## 缺点：\n改造成本大\n各个浏览器兼容不友好\n多应用公共依赖重复加载\n## 4.single-SPA\nsingle-spa 提供了一种基于路由的基座化的微前端方案，它将应用分为两类：基座应用和子应用。其中，子应用对应前面我们讲到的需要聚合的应用，基座应用是另外一个单独的应用，用于聚合子应用。在基座应用中，我们会维护一个路由注册表 - 每个路由对应一个子应用。基座应用启动以后，当我们切换路由时，如果是一个新的子应用，会动态获取子应用的 js 脚本，然后执行脚本并渲染出相应的页面；如果是一个已经访问过的子应用，那么就会从基座应用的缓存中获取已经缓存的子应用，激活子应用并渲染出对应的页面。\n## 优点：\n良好的体验，多服务切换如同单体SPA\n具备服务的生命周期\n共享数据\n兼容不同技术栈运行\n## 缺点：\n多应用间，无多应用沙箱机制\n多应用间，样式命名不慎会导致冲突\njs entry 导致子服务和基座强耦合\n## 5.qiankun\n乾坤是 @kuitos 大佬开发的，阿里出品。目前来说，是最完美的微前端解决方案，也是start最多的。\n其代码写的很漂亮，建议大家去阅读，学习。\n## 优点：\n基于single-SPA封装，开箱即用\n技术无关，多技术栈可以共存\nhtml entry接入，解耦基座和子服务\n样式隔离\njs沙箱机制\n资源预加载\n提供全局错误机制\n提供跨服务通信机制\n提供服务的生命周期\n脱离基座，单个服务降级运行策略处理\n## 缺点：\n共享运行时缓存支持\n不兼容ie系列 \n# 现有市面框架\n1.single-spa 将多个单页面应用聚合为一个整体应用的JavaScript 微前端框架\n2.qiankun 蚂蚁金服，在 single-spa 的基础上封装\n3.MicroApp 京东，一款基于WebComponent的思想，轻量、高效、功能强大的微前端框架\n4.无界 腾讯无界微前端方案基于 WebComponent 容器 + iframe 沙箱\n5.EMP YY语音，基于Webpack5 Module Federation 除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力\n6.icestark 阿里出品，是一个面向大型系统的微前端解决方案\n7.garfish 字节跳动\n8.magic-microservices 一款基于 Web Components 的轻量级的微前端工厂函数\n# 相关\n微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n更多关于微前端的相关介绍，推荐大家可以去看这几篇文章：\nMicro Frontends [https://micro-frontends.org/]\nMicro Frontends from martinfowler.com [https://martinfowler.com/articles/micro-frontends.html]","source":"_posts/微前端.md","raw":"---\ntitle: 微前端\ndate: 2023-03-27 21:29:13\ntags: 微前端\ncategories: 知识点\n---\n# 什么是微前端\n微前端是一种多个团队通过独立发布功能的方式来共同构建现代化web应用的技术手段及方法策略。\n微前端可以将多个小型应用整合成一个完整的应用。每个小型应用都是独立开发、独立运行、独立部署的，这就意味着可以多团队并行开发 且有无冲突、无阻塞等特点。\n# 微前端架构具备以下几个核心价值：\n1.技术栈无关\n主框架不限制接入应用的技术栈，微应用具备完全自主权\n2.独立开发、独立部署\n微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n3.增量升级\n在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n4.独立运行时\n每个微应用之间状态隔离，运行时状态不共享\n# 常见的微前端实现方式\n1.路由分发\n简单来说，其实就是通过网关/代理对路由进行监听，对不同的路由路径导向不同的前端资源入口。\n例如：\n使用 Nginx 代理了 localhost:80；\n然后访问路径为 /app1 的时候，返回 html/app1/index.html 的文件；\n访问路径为 /app2 的时候，返回 html/app2/index.html 的文件。\n这种方式由于是多页面应用，所以用户体验不好，而且比较依赖于后端，应用之间存在着耦合问题。\n## 优点：\n开发成本低\n配置简单\n## 缺点：\n多应用之间切换时，每个应用都会重新加载，影响体验（可以思考 传统页面 和 SPA 区别）\n多应用间不能共享数据\n多应用间通信困难\n多应用公共依赖重复加载\n\n## 2.iframe\n它的作用就是在网页中嵌套另一个网页，那么通过这种特性就可以实现微前端了。\n但实际上个大微前端框架，就没有一个是用iframe去做的，因为iframe有着很多的问题，其中一些甚至是无法解决的。\n## 优点：完美支持js隔离，样式隔离\n## 缺点：\nurl 不同步， 浏览器刷新时，iframe中的url 状态会丢失\niframe局部弹框\n内外通信效率低下，变量不能共享\n每次进入，资源都会被重新加载，速度较慢\n## 3.Web Components\nWeb Components 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。\n(1)Custom elements（自定义元素） 一组 JavaScript API，允许您定义custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。\n(2)Shadow DOM（影子 DOM） ：一组JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\n(3)HTML templates（HTML 模板）： <template> 和 <slot> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\n## 优点：\n每个服务拥有独立的脚本和样式\n## 缺点：\n改造成本大\n各个浏览器兼容不友好\n多应用公共依赖重复加载\n## 4.single-SPA\nsingle-spa 提供了一种基于路由的基座化的微前端方案，它将应用分为两类：基座应用和子应用。其中，子应用对应前面我们讲到的需要聚合的应用，基座应用是另外一个单独的应用，用于聚合子应用。在基座应用中，我们会维护一个路由注册表 - 每个路由对应一个子应用。基座应用启动以后，当我们切换路由时，如果是一个新的子应用，会动态获取子应用的 js 脚本，然后执行脚本并渲染出相应的页面；如果是一个已经访问过的子应用，那么就会从基座应用的缓存中获取已经缓存的子应用，激活子应用并渲染出对应的页面。\n## 优点：\n良好的体验，多服务切换如同单体SPA\n具备服务的生命周期\n共享数据\n兼容不同技术栈运行\n## 缺点：\n多应用间，无多应用沙箱机制\n多应用间，样式命名不慎会导致冲突\njs entry 导致子服务和基座强耦合\n## 5.qiankun\n乾坤是 @kuitos 大佬开发的，阿里出品。目前来说，是最完美的微前端解决方案，也是start最多的。\n其代码写的很漂亮，建议大家去阅读，学习。\n## 优点：\n基于single-SPA封装，开箱即用\n技术无关，多技术栈可以共存\nhtml entry接入，解耦基座和子服务\n样式隔离\njs沙箱机制\n资源预加载\n提供全局错误机制\n提供跨服务通信机制\n提供服务的生命周期\n脱离基座，单个服务降级运行策略处理\n## 缺点：\n共享运行时缓存支持\n不兼容ie系列 \n# 现有市面框架\n1.single-spa 将多个单页面应用聚合为一个整体应用的JavaScript 微前端框架\n2.qiankun 蚂蚁金服，在 single-spa 的基础上封装\n3.MicroApp 京东，一款基于WebComponent的思想，轻量、高效、功能强大的微前端框架\n4.无界 腾讯无界微前端方案基于 WebComponent 容器 + iframe 沙箱\n5.EMP YY语音，基于Webpack5 Module Federation 除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力\n6.icestark 阿里出品，是一个面向大型系统的微前端解决方案\n7.garfish 字节跳动\n8.magic-microservices 一款基于 Web Components 的轻量级的微前端工厂函数\n# 相关\n微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n更多关于微前端的相关介绍，推荐大家可以去看这几篇文章：\nMicro Frontends [https://micro-frontends.org/]\nMicro Frontends from martinfowler.com [https://martinfowler.com/articles/micro-frontends.html]","slug":"微前端","published":1,"updated":"2023-03-30T04:22:45.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13mla002qtit8g6ye10wp","content":"<h1 id=\"什么是微前端\"><a href=\"#什么是微前端\" class=\"headerlink\" title=\"什么是微前端\"></a>什么是微前端</h1><p>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化web应用的技术手段及方法策略。<br>微前端可以将多个小型应用整合成一个完整的应用。每个小型应用都是独立开发、独立运行、独立部署的，这就意味着可以多团队并行开发 且有无冲突、无阻塞等特点。</p>\n<h1 id=\"微前端架构具备以下几个核心价值：\"><a href=\"#微前端架构具备以下几个核心价值：\" class=\"headerlink\" title=\"微前端架构具备以下几个核心价值：\"></a>微前端架构具备以下几个核心价值：</h1><p>1.技术栈无关<br>主框架不限制接入应用的技术栈，微应用具备完全自主权<br>2.独立开发、独立部署<br>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新<br>3.增量升级<br>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略<br>4.独立运行时<br>每个微应用之间状态隔离，运行时状态不共享</p>\n<h1 id=\"常见的微前端实现方式\"><a href=\"#常见的微前端实现方式\" class=\"headerlink\" title=\"常见的微前端实现方式\"></a>常见的微前端实现方式</h1><p>1.路由分发<br>简单来说，其实就是通过网关/代理对路由进行监听，对不同的路由路径导向不同的前端资源入口。<br>例如：<br>使用 Nginx 代理了 localhost:80；<br>然后访问路径为 /app1 的时候，返回 html/app1/index.html 的文件；<br>访问路径为 /app2 的时候，返回 html/app2/index.html 的文件。<br>这种方式由于是多页面应用，所以用户体验不好，而且比较依赖于后端，应用之间存在着耦合问题。</p>\n<h2 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>开发成本低<br>配置简单</p>\n<h2 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>多应用之间切换时，每个应用都会重新加载，影响体验（可以思考 传统页面 和 SPA 区别）<br>多应用间不能共享数据<br>多应用间通信困难<br>多应用公共依赖重复加载</p>\n<h2 id=\"2-iframe\"><a href=\"#2-iframe\" class=\"headerlink\" title=\"2.iframe\"></a>2.iframe</h2><p>它的作用就是在网页中嵌套另一个网页，那么通过这种特性就可以实现微前端了。<br>但实际上个大微前端框架，就没有一个是用iframe去做的，因为iframe有着很多的问题，其中一些甚至是无法解决的。</p>\n<h2 id=\"优点：完美支持js隔离，样式隔离\"><a href=\"#优点：完美支持js隔离，样式隔离\" class=\"headerlink\" title=\"优点：完美支持js隔离，样式隔离\"></a>优点：完美支持js隔离，样式隔离</h2><h2 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>url 不同步， 浏览器刷新时，iframe中的url 状态会丢失<br>iframe局部弹框<br>内外通信效率低下，变量不能共享<br>每次进入，资源都会被重新加载，速度较慢</p>\n<h2 id=\"3-Web-Components\"><a href=\"#3-Web-Components\" class=\"headerlink\" title=\"3.Web Components\"></a>3.Web Components</h2><p>Web Components 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。<br>(1)Custom elements（自定义元素） 一组 JavaScript API，允许您定义custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。<br>(2)Shadow DOM（影子 DOM） ：一组JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。<br>(3)HTML templates（HTML 模板）： <template> 和 <slot> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</p>\n<h2 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>每个服务拥有独立的脚本和样式</p>\n<h2 id=\"缺点：-2\"><a href=\"#缺点：-2\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>改造成本大<br>各个浏览器兼容不友好<br>多应用公共依赖重复加载</p>\n<h2 id=\"4-single-SPA\"><a href=\"#4-single-SPA\" class=\"headerlink\" title=\"4.single-SPA\"></a>4.single-SPA</h2><p>single-spa 提供了一种基于路由的基座化的微前端方案，它将应用分为两类：基座应用和子应用。其中，子应用对应前面我们讲到的需要聚合的应用，基座应用是另外一个单独的应用，用于聚合子应用。在基座应用中，我们会维护一个路由注册表 - 每个路由对应一个子应用。基座应用启动以后，当我们切换路由时，如果是一个新的子应用，会动态获取子应用的 js 脚本，然后执行脚本并渲染出相应的页面；如果是一个已经访问过的子应用，那么就会从基座应用的缓存中获取已经缓存的子应用，激活子应用并渲染出对应的页面。</p>\n<h2 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>良好的体验，多服务切换如同单体SPA<br>具备服务的生命周期<br>共享数据<br>兼容不同技术栈运行</p>\n<h2 id=\"缺点：-3\"><a href=\"#缺点：-3\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>多应用间，无多应用沙箱机制<br>多应用间，样式命名不慎会导致冲突<br>js entry 导致子服务和基座强耦合</p>\n<h2 id=\"5-qiankun\"><a href=\"#5-qiankun\" class=\"headerlink\" title=\"5.qiankun\"></a>5.qiankun</h2><p>乾坤是 @kuitos 大佬开发的，阿里出品。目前来说，是最完美的微前端解决方案，也是start最多的。<br>其代码写的很漂亮，建议大家去阅读，学习。</p>\n<h2 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>基于single-SPA封装，开箱即用<br>技术无关，多技术栈可以共存<br>html entry接入，解耦基座和子服务<br>样式隔离<br>js沙箱机制<br>资源预加载<br>提供全局错误机制<br>提供跨服务通信机制<br>提供服务的生命周期<br>脱离基座，单个服务降级运行策略处理</p>\n<h2 id=\"缺点：-4\"><a href=\"#缺点：-4\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>共享运行时缓存支持<br>不兼容ie系列 </p>\n<h1 id=\"现有市面框架\"><a href=\"#现有市面框架\" class=\"headerlink\" title=\"现有市面框架\"></a>现有市面框架</h1><p>1.single-spa 将多个单页面应用聚合为一个整体应用的JavaScript 微前端框架<br>2.qiankun 蚂蚁金服，在 single-spa 的基础上封装<br>3.MicroApp 京东，一款基于WebComponent的思想，轻量、高效、功能强大的微前端框架<br>4.无界 腾讯无界微前端方案基于 WebComponent 容器 + iframe 沙箱<br>5.EMP YY语音，基于Webpack5 Module Federation 除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力<br>6.icestark 阿里出品，是一个面向大型系统的微前端解决方案<br>7.garfish 字节跳动<br>8.magic-microservices 一款基于 Web Components 的轻量级的微前端工厂函数</p>\n<h1 id=\"相关\"><a href=\"#相关\" class=\"headerlink\" title=\"相关\"></a>相关</h1><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。<br>更多关于微前端的相关介绍，推荐大家可以去看这几篇文章：<br>Micro Frontends [<a href=\"https://micro-frontends.org/]\">https://micro-frontends.org/]</a><br>Micro Frontends from martinfowler.com [<a href=\"https://martinfowler.com/articles/micro-frontends.html]\">https://martinfowler.com/articles/micro-frontends.html]</a></p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"什么是微前端\"><a href=\"#什么是微前端\" class=\"headerlink\" title=\"什么是微前端\"></a>什么是微前端</h1><p>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化web应用的技术手段及方法策略。<br>微前端可以将多个小型应用整合成一个完整的应用。每个小型应用都是独立开发、独立运行、独立部署的，这就意味着可以多团队并行开发 且有无冲突、无阻塞等特点。</p>\n<h1 id=\"微前端架构具备以下几个核心价值：\"><a href=\"#微前端架构具备以下几个核心价值：\" class=\"headerlink\" title=\"微前端架构具备以下几个核心价值：\"></a>微前端架构具备以下几个核心价值：</h1><p>1.技术栈无关<br>主框架不限制接入应用的技术栈，微应用具备完全自主权<br>2.独立开发、独立部署<br>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新<br>3.增量升级<br>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略<br>4.独立运行时<br>每个微应用之间状态隔离，运行时状态不共享</p>\n<h1 id=\"常见的微前端实现方式\"><a href=\"#常见的微前端实现方式\" class=\"headerlink\" title=\"常见的微前端实现方式\"></a>常见的微前端实现方式</h1><p>1.路由分发<br>简单来说，其实就是通过网关/代理对路由进行监听，对不同的路由路径导向不同的前端资源入口。<br>例如：<br>使用 Nginx 代理了 localhost:80；<br>然后访问路径为 /app1 的时候，返回 html/app1/index.html 的文件；<br>访问路径为 /app2 的时候，返回 html/app2/index.html 的文件。<br>这种方式由于是多页面应用，所以用户体验不好，而且比较依赖于后端，应用之间存在着耦合问题。</p>\n<h2 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>开发成本低<br>配置简单</p>\n<h2 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>多应用之间切换时，每个应用都会重新加载，影响体验（可以思考 传统页面 和 SPA 区别）<br>多应用间不能共享数据<br>多应用间通信困难<br>多应用公共依赖重复加载</p>\n<h2 id=\"2-iframe\"><a href=\"#2-iframe\" class=\"headerlink\" title=\"2.iframe\"></a>2.iframe</h2><p>它的作用就是在网页中嵌套另一个网页，那么通过这种特性就可以实现微前端了。<br>但实际上个大微前端框架，就没有一个是用iframe去做的，因为iframe有着很多的问题，其中一些甚至是无法解决的。</p>\n<h2 id=\"优点：完美支持js隔离，样式隔离\"><a href=\"#优点：完美支持js隔离，样式隔离\" class=\"headerlink\" title=\"优点：完美支持js隔离，样式隔离\"></a>优点：完美支持js隔离，样式隔离</h2><h2 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>url 不同步， 浏览器刷新时，iframe中的url 状态会丢失<br>iframe局部弹框<br>内外通信效率低下，变量不能共享<br>每次进入，资源都会被重新加载，速度较慢</p>\n<h2 id=\"3-Web-Components\"><a href=\"#3-Web-Components\" class=\"headerlink\" title=\"3.Web Components\"></a>3.Web Components</h2><p>Web Components 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。<br>(1)Custom elements（自定义元素） 一组 JavaScript API，允许您定义custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。<br>(2)Shadow DOM（影子 DOM） ：一组JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。<br>(3)HTML templates（HTML 模板）： <template> 和 <slot> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</p>\n<h2 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>每个服务拥有独立的脚本和样式</p>\n<h2 id=\"缺点：-2\"><a href=\"#缺点：-2\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>改造成本大<br>各个浏览器兼容不友好<br>多应用公共依赖重复加载</p>\n<h2 id=\"4-single-SPA\"><a href=\"#4-single-SPA\" class=\"headerlink\" title=\"4.single-SPA\"></a>4.single-SPA</h2><p>single-spa 提供了一种基于路由的基座化的微前端方案，它将应用分为两类：基座应用和子应用。其中，子应用对应前面我们讲到的需要聚合的应用，基座应用是另外一个单独的应用，用于聚合子应用。在基座应用中，我们会维护一个路由注册表 - 每个路由对应一个子应用。基座应用启动以后，当我们切换路由时，如果是一个新的子应用，会动态获取子应用的 js 脚本，然后执行脚本并渲染出相应的页面；如果是一个已经访问过的子应用，那么就会从基座应用的缓存中获取已经缓存的子应用，激活子应用并渲染出对应的页面。</p>\n<h2 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>良好的体验，多服务切换如同单体SPA<br>具备服务的生命周期<br>共享数据<br>兼容不同技术栈运行</p>\n<h2 id=\"缺点：-3\"><a href=\"#缺点：-3\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>多应用间，无多应用沙箱机制<br>多应用间，样式命名不慎会导致冲突<br>js entry 导致子服务和基座强耦合</p>\n<h2 id=\"5-qiankun\"><a href=\"#5-qiankun\" class=\"headerlink\" title=\"5.qiankun\"></a>5.qiankun</h2><p>乾坤是 @kuitos 大佬开发的，阿里出品。目前来说，是最完美的微前端解决方案，也是start最多的。<br>其代码写的很漂亮，建议大家去阅读，学习。</p>\n<h2 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>基于single-SPA封装，开箱即用<br>技术无关，多技术栈可以共存<br>html entry接入，解耦基座和子服务<br>样式隔离<br>js沙箱机制<br>资源预加载<br>提供全局错误机制<br>提供跨服务通信机制<br>提供服务的生命周期<br>脱离基座，单个服务降级运行策略处理</p>\n<h2 id=\"缺点：-4\"><a href=\"#缺点：-4\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>共享运行时缓存支持<br>不兼容ie系列 </p>\n<h1 id=\"现有市面框架\"><a href=\"#现有市面框架\" class=\"headerlink\" title=\"现有市面框架\"></a>现有市面框架</h1><p>1.single-spa 将多个单页面应用聚合为一个整体应用的JavaScript 微前端框架<br>2.qiankun 蚂蚁金服，在 single-spa 的基础上封装<br>3.MicroApp 京东，一款基于WebComponent的思想，轻量、高效、功能强大的微前端框架<br>4.无界 腾讯无界微前端方案基于 WebComponent 容器 + iframe 沙箱<br>5.EMP YY语音，基于Webpack5 Module Federation 除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力<br>6.icestark 阿里出品，是一个面向大型系统的微前端解决方案<br>7.garfish 字节跳动<br>8.magic-microservices 一款基于 Web Components 的轻量级的微前端工厂函数</p>\n<h1 id=\"相关\"><a href=\"#相关\" class=\"headerlink\" title=\"相关\"></a>相关</h1><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。<br>更多关于微前端的相关介绍，推荐大家可以去看这几篇文章：<br>Micro Frontends [<a href=\"https://micro-frontends.org/]\">https://micro-frontends.org/]</a><br>Micro Frontends from martinfowler.com [<a href=\"https://martinfowler.com/articles/micro-frontends.html]\">https://martinfowler.com/articles/micro-frontends.html]</a></p>\n"},{"title":"性能优化","date":"2023-04-03T13:52:16.000Z","cover":["/images/性能优化cover.png"],"banner":{"type":"img","bgurl":["/images/性能优化cover.png"]},"_content":"# 一、代码层面的优化\n## 1.1、 v-if 和 v-show 区分使用场景\nv-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\nv-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。\n所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。\n## 1.2、computed 和 watch 区分使用场景\ncomputed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；\nwatch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\n运用场景：\n当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n## 1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-\n（1）v-for 遍历必须为 item 添加 key\n在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。\n（2）v-for 遍历避免同时使用 v-if\nv-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。\n推荐：\n```\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\">\n    {{ user.name }}\n  </li>\n</ul>\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n\t return user.isActive\n    })\n  }\n}\n```\n不推荐：\n```\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\">\n    {{ user.name }}\n  </li>\n</ul>\n```\n## 1.4、长列表性能优化\nVue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。\n```\nexport default {\n  data: () => ({\n    users: {}\n  }),\n  async created() {\n    const users = await axios.get(\"/api/users\");\n    this.users = Object.freeze(users);\n  }\n}\n```\n## 1.5、事件的销毁\nVue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：\n```\ncreated() {\n  addEventListener('click', this.click, false)\n},\nbeforeDestroy() {\n  removeEventListener('click', this.click, false)\n}\n```\n## 1.6、图片资源懒加载\n对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：\n（1）安装插件\nnpm install vue-lazyload --save-dev\n（2）在入口文件 man.js 中引入并使用\nimport VueLazyload from 'vue-lazyload'\n然后再 vue 中直接使用\nVue.use(VueLazyload)\n或者添加自定义选项\n```\nVue.use(VueLazyload, {\n  preLoad: 1.3,\n  error: 'dist/error.png',\n  loading: 'dist/loading.gif',\n  attempt: 1\n})\n```\n3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：\n```\n<img v-lazy=\"/static/img/1.png\">\n```\n## 1.7、路由懒加载\nVue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。\n路由懒加载：\n```\nconst Foo = () => import('./Foo.vue')\nconst router = new VueRouter({\n  routes: [\n    { path: '/foo', component: Foo }\n  ]\n})\n```\n## 1.8、第三方插件的按需引入\n我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：\n（1）首先，安装 babel-plugin-component ：\n```\nnpm install babel-plugin-component -D\n```\n（2）然后，将 .babelrc 修改为：\n```\n{\n  \"presets\": [[\"es2015\", { \"modules\": false }]],\n  \"plugins\": [\n    [\n      \"component\",\n      {\n        \"libraryName\": \"element-ui\",\n        \"styleLibraryName\": \"theme-chalk\"\n      }\n    ]\n  ]\n}\n```\n（3）在 main.js 中引入部分组件：\n```\nimport Vue from 'vue';\nimport { Button, Select } from 'element-ui';\nVue.use(Button)\nVue.use(Select)\n```\n## 1.9、优化无限列表性能\n如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口化的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。 你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller来优化这种无限列表的场景的。\n## 1.10、服务端渲染 SSR or 预渲染\n服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。\n（1）服务端渲染的优点：\n+ 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；\n+ 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；\n（2）服务端渲染的缺点：\n+ 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；\n+ 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。\n如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。\n\n# 二、Webpack 层面的优化\n## 2.1、Webpack 对图片进行压缩\n在vue项目中除了可以在webpack.base.conf.js中url-loader中设置limit大小来对图片处理，对小limit 的图片转化为base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：\n（1）首先，安装 image-webpack-loader ：\n```\nnpm install image-webpack-loader --save-dev\n```\n（2）然后，在 webpack.base.conf.js 中进行配置：\n```\n{\n  test: /.(png|jpe?g|gif|svg)(?.*)?$/,\n  use:[\n    {\n    loader: 'url-loader',\n    options: {\n      limit: 10000,\n      name: utils.assetsPath('img/[name].[hash:7].[ext]')\n      }\n    },\n    {\n      loader: 'image-webpack-loader',\n      options: {\n        bypassOnDebug: true,\n      }\n    }\n  ]\n}\n```\n## 2.2、减少 ES6 转为 ES5 的冗余代码\nBabel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：\n```\nclass HelloWebpack extends Component{...}\n```\n这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：\n```\nbabel-runtime/helpers/createClass  // 用于实现 class 语法\nbabel-runtime/helpers/inherits  // 用于实现 extends 语法  \n```\n在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require('babel-runtime/helpers/createClass') 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。\n（1）首先，安装 babel-plugin-transform-runtime ：\n```\nnpm install babel-plugin-transform-runtime --save-dev\n```\n（2）然后，修改 .babelrc 配置文件为：\n```\n\"plugins\": [\n    \"transform-runtime\"\n]\n```\n如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime的详细介绍。\n## 2.3、提取公共代码\n如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：\n+ 相同的资源被重复加载，浪费用户的流量和服务器的成本。\n+ 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。\n所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk中的公共部分的插件CommonsChunkPlugin，我们在项目中CommonsChunkPlugin 的配置如下：\n```\n// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。\nnew webpack.optimize.CommonsChunkPlugin({\n  name: 'vendor',\n  minChunks: function(module, count) {\n    return (\n      module.resource &&\n      /.js$/.test(module.resource) &&\n      module.resource.indexOf(\n        path.join(__dirname, '../node_modules')\n      ) === 0\n    );\n  }\n}),\n// 抽取出代码模块的映射关系\nnew webpack.optimize.CommonsChunkPlugin({\n  name: 'manifest',\n  chunks: ['vendor']\n})\n```\n如果要看插件的更多详细内容，可以查看CommonsChunkPlugin的详细介绍。\n## 2.4、模板预编译\n当使用DOM内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。\n预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。\n如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。\n## 2.5、提取组件的 CSS\n当使用单文件组件时，组件内的CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。\n查阅这个构建工具各自的文档来了解更多：\nwebpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)\nBrowserify + vueify\nRollup + rollup-plugin-vue\n## 2.6、优化 SourceMap\n我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。\n开发环境推荐： cheap-module-eval-source-map\n生产环境推荐： cheap-module-source-map\n原因如下：\n+ cheap： 源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；\n+ module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；\n+ soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；\n+ eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。\n## 2.7、构建结果输出分析\nWebpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。\n我们在项目中 webpack.prod.conf.js 进行配置：\nif (config.build.bundleAnalyzerReport) { var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin()); } \n## 2.8、Vue 项目的编译优化\n如果你的Vue项目使用Webpack编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的Webpack配置进行优化，提高 Webpack 的构建效率。具体如何进行Vue项目的Webpack构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》\n","source":"_posts/性能优化.md","raw":"---\ntitle: 性能优化\ndate: 2023-04-03 21:52:16\ntags: Vue\ncategories: 性能优化\ncover: [/images/性能优化cover.png]\nbanner: \n  type: img\n  bgurl: [/images/性能优化cover.png]\n---\n# 一、代码层面的优化\n## 1.1、 v-if 和 v-show 区分使用场景\nv-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\nv-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。\n所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。\n## 1.2、computed 和 watch 区分使用场景\ncomputed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；\nwatch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\n运用场景：\n当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n## 1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-\n（1）v-for 遍历必须为 item 添加 key\n在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。\n（2）v-for 遍历避免同时使用 v-if\nv-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。\n推荐：\n```\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\">\n    {{ user.name }}\n  </li>\n</ul>\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n\t return user.isActive\n    })\n  }\n}\n```\n不推荐：\n```\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\">\n    {{ user.name }}\n  </li>\n</ul>\n```\n## 1.4、长列表性能优化\nVue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。\n```\nexport default {\n  data: () => ({\n    users: {}\n  }),\n  async created() {\n    const users = await axios.get(\"/api/users\");\n    this.users = Object.freeze(users);\n  }\n}\n```\n## 1.5、事件的销毁\nVue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：\n```\ncreated() {\n  addEventListener('click', this.click, false)\n},\nbeforeDestroy() {\n  removeEventListener('click', this.click, false)\n}\n```\n## 1.6、图片资源懒加载\n对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：\n（1）安装插件\nnpm install vue-lazyload --save-dev\n（2）在入口文件 man.js 中引入并使用\nimport VueLazyload from 'vue-lazyload'\n然后再 vue 中直接使用\nVue.use(VueLazyload)\n或者添加自定义选项\n```\nVue.use(VueLazyload, {\n  preLoad: 1.3,\n  error: 'dist/error.png',\n  loading: 'dist/loading.gif',\n  attempt: 1\n})\n```\n3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：\n```\n<img v-lazy=\"/static/img/1.png\">\n```\n## 1.7、路由懒加载\nVue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。\n路由懒加载：\n```\nconst Foo = () => import('./Foo.vue')\nconst router = new VueRouter({\n  routes: [\n    { path: '/foo', component: Foo }\n  ]\n})\n```\n## 1.8、第三方插件的按需引入\n我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：\n（1）首先，安装 babel-plugin-component ：\n```\nnpm install babel-plugin-component -D\n```\n（2）然后，将 .babelrc 修改为：\n```\n{\n  \"presets\": [[\"es2015\", { \"modules\": false }]],\n  \"plugins\": [\n    [\n      \"component\",\n      {\n        \"libraryName\": \"element-ui\",\n        \"styleLibraryName\": \"theme-chalk\"\n      }\n    ]\n  ]\n}\n```\n（3）在 main.js 中引入部分组件：\n```\nimport Vue from 'vue';\nimport { Button, Select } from 'element-ui';\nVue.use(Button)\nVue.use(Select)\n```\n## 1.9、优化无限列表性能\n如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口化的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。 你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller来优化这种无限列表的场景的。\n## 1.10、服务端渲染 SSR or 预渲染\n服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。\n（1）服务端渲染的优点：\n+ 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；\n+ 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；\n（2）服务端渲染的缺点：\n+ 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；\n+ 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。\n如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。\n\n# 二、Webpack 层面的优化\n## 2.1、Webpack 对图片进行压缩\n在vue项目中除了可以在webpack.base.conf.js中url-loader中设置limit大小来对图片处理，对小limit 的图片转化为base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：\n（1）首先，安装 image-webpack-loader ：\n```\nnpm install image-webpack-loader --save-dev\n```\n（2）然后，在 webpack.base.conf.js 中进行配置：\n```\n{\n  test: /.(png|jpe?g|gif|svg)(?.*)?$/,\n  use:[\n    {\n    loader: 'url-loader',\n    options: {\n      limit: 10000,\n      name: utils.assetsPath('img/[name].[hash:7].[ext]')\n      }\n    },\n    {\n      loader: 'image-webpack-loader',\n      options: {\n        bypassOnDebug: true,\n      }\n    }\n  ]\n}\n```\n## 2.2、减少 ES6 转为 ES5 的冗余代码\nBabel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：\n```\nclass HelloWebpack extends Component{...}\n```\n这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：\n```\nbabel-runtime/helpers/createClass  // 用于实现 class 语法\nbabel-runtime/helpers/inherits  // 用于实现 extends 语法  \n```\n在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require('babel-runtime/helpers/createClass') 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。\n（1）首先，安装 babel-plugin-transform-runtime ：\n```\nnpm install babel-plugin-transform-runtime --save-dev\n```\n（2）然后，修改 .babelrc 配置文件为：\n```\n\"plugins\": [\n    \"transform-runtime\"\n]\n```\n如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime的详细介绍。\n## 2.3、提取公共代码\n如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：\n+ 相同的资源被重复加载，浪费用户的流量和服务器的成本。\n+ 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。\n所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk中的公共部分的插件CommonsChunkPlugin，我们在项目中CommonsChunkPlugin 的配置如下：\n```\n// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。\nnew webpack.optimize.CommonsChunkPlugin({\n  name: 'vendor',\n  minChunks: function(module, count) {\n    return (\n      module.resource &&\n      /.js$/.test(module.resource) &&\n      module.resource.indexOf(\n        path.join(__dirname, '../node_modules')\n      ) === 0\n    );\n  }\n}),\n// 抽取出代码模块的映射关系\nnew webpack.optimize.CommonsChunkPlugin({\n  name: 'manifest',\n  chunks: ['vendor']\n})\n```\n如果要看插件的更多详细内容，可以查看CommonsChunkPlugin的详细介绍。\n## 2.4、模板预编译\n当使用DOM内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。\n预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。\n如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。\n## 2.5、提取组件的 CSS\n当使用单文件组件时，组件内的CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。\n查阅这个构建工具各自的文档来了解更多：\nwebpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)\nBrowserify + vueify\nRollup + rollup-plugin-vue\n## 2.6、优化 SourceMap\n我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。\n开发环境推荐： cheap-module-eval-source-map\n生产环境推荐： cheap-module-source-map\n原因如下：\n+ cheap： 源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；\n+ module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；\n+ soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；\n+ eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。\n## 2.7、构建结果输出分析\nWebpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。\n我们在项目中 webpack.prod.conf.js 进行配置：\nif (config.build.bundleAnalyzerReport) { var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin()); } \n## 2.8、Vue 项目的编译优化\n如果你的Vue项目使用Webpack编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的Webpack配置进行优化，提高 Webpack 的构建效率。具体如何进行Vue项目的Webpack构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》\n","slug":"性能优化","published":1,"updated":"2023-04-11T06:44:39.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13mla002utit8b87d0p8i","content":"<h1 id=\"一、代码层面的优化\"><a href=\"#一、代码层面的优化\" class=\"headerlink\" title=\"一、代码层面的优化\"></a>一、代码层面的优化</h1><h2 id=\"1-1、-v-if-和-v-show-区分使用场景\"><a href=\"#1-1、-v-if-和-v-show-区分使用场景\" class=\"headerlink\" title=\"1.1、 v-if 和 v-show 区分使用场景\"></a>1.1、 v-if 和 v-show 区分使用场景</h2><p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。<br>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>\n<h2 id=\"1-2、computed-和-watch-区分使用场景\"><a href=\"#1-2、computed-和-watch-区分使用场景\" class=\"headerlink\" title=\"1.2、computed 和 watch 区分使用场景\"></a>1.2、computed 和 watch 区分使用场景</h2><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>运用场景：<br>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<h2 id=\"1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v\"><a href=\"#1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v\" class=\"headerlink\" title=\"1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-\"></a>1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-</h2><p>（1）v-for 遍历必须为 item 添加 key<br>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。<br>（2）v-for 遍历避免同时使用 v-if<br>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。<br>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li</span><br><span class=\"line\">    v-for=&quot;user in activeUsers&quot;</span><br><span class=\"line\">    :key=&quot;user.id&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; user.name &#125;&#125;</span><br><span class=\"line\">  &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  activeUsers: function () &#123;</span><br><span class=\"line\">    return this.users.filter(function (user) &#123;</span><br><span class=\"line\">\t return user.isActive</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li</span><br><span class=\"line\">    v-for=&quot;user in users&quot;</span><br><span class=\"line\">    v-if=&quot;user.isActive&quot;</span><br><span class=\"line\">    :key=&quot;user.id&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; user.name &#125;&#125;</span><br><span class=\"line\">  &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-4、长列表性能优化\"><a href=\"#1-4、长列表性能优化\" class=\"headerlink\" title=\"1.4、长列表性能优化\"></a>1.4、长列表性能优化</h2><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data: () =&gt; (&#123;</span><br><span class=\"line\">    users: &#123;&#125;</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  async created() &#123;</span><br><span class=\"line\">    const users = await axios.get(&quot;/api/users&quot;);</span><br><span class=\"line\">    this.users = Object.freeze(users);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-5、事件的销毁\"><a href=\"#1-5、事件的销毁\" class=\"headerlink\" title=\"1.5、事件的销毁\"></a>1.5、事件的销毁</h2><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">  addEventListener(&#x27;click&#x27;, this.click, false)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">  removeEventListener(&#x27;click&#x27;, this.click, false)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-6、图片资源懒加载\"><a href=\"#1-6、图片资源懒加载\" class=\"headerlink\" title=\"1.6、图片资源懒加载\"></a>1.6、图片资源懒加载</h2><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：<br>（1）安装插件<br>npm install vue-lazyload –save-dev<br>（2）在入口文件 man.js 中引入并使用<br>import VueLazyload from ‘vue-lazyload’<br>然后再 vue 中直接使用<br>Vue.use(VueLazyload)<br>或者添加自定义选项</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.use(VueLazyload, &#123;</span><br><span class=\"line\">  preLoad: 1.3,</span><br><span class=\"line\">  error: &#x27;dist/error.png&#x27;,</span><br><span class=\"line\">  loading: &#x27;dist/loading.gif&#x27;,</span><br><span class=\"line\">  attempt: 1</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-7、路由懒加载\"><a href=\"#1-7、路由懒加载\" class=\"headerlink\" title=\"1.7、路由懒加载\"></a>1.7、路由懒加载</h2><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。<br>路由懒加载：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Foo = () =&gt; import(&#x27;./Foo.vue&#x27;)</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123; path: &#x27;/foo&#x27;, component: Foo &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-8、第三方插件的按需引入\"><a href=\"#1-8、第三方插件的按需引入\" class=\"headerlink\" title=\"1.8、第三方插件的按需引入\"></a>1.8、第三方插件的按需引入</h2><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：<br>（1）首先，安装 babel-plugin-component ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>\n<p>（2）然后，将 .babelrc 修改为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]],</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;component&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class=\"line\">        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）在 main.js 中引入部分组件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;;</span><br><span class=\"line\">import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;</span><br><span class=\"line\">Vue.use(Button)</span><br><span class=\"line\">Vue.use(Select)</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-9、优化无限列表性能\"><a href=\"#1-9、优化无限列表性能\" class=\"headerlink\" title=\"1.9、优化无限列表性能\"></a>1.9、优化无限列表性能</h2><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口化的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。 你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller来优化这种无限列表的场景的。</p>\n<h2 id=\"1-10、服务端渲染-SSR-or-预渲染\"><a href=\"#1-10、服务端渲染-SSR-or-预渲染\" class=\"headerlink\" title=\"1.10、服务端渲染 SSR or 预渲染\"></a>1.10、服务端渲染 SSR or 预渲染</h2><p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。<br>（1）服务端渲染的优点：</p>\n<ul>\n<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>\n<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；<br>（2）服务端渲染的缺点：</li>\n<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>\n<li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。<br>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</li>\n</ul>\n<h1 id=\"二、Webpack-层面的优化\"><a href=\"#二、Webpack-层面的优化\" class=\"headerlink\" title=\"二、Webpack 层面的优化\"></a>二、Webpack 层面的优化</h1><h2 id=\"2-1、Webpack-对图片进行压缩\"><a href=\"#2-1、Webpack-对图片进行压缩\" class=\"headerlink\" title=\"2.1、Webpack 对图片进行压缩\"></a>2.1、Webpack 对图片进行压缩</h2><p>在vue项目中除了可以在webpack.base.conf.js中url-loader中设置limit大小来对图片处理，对小limit 的图片转化为base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：<br>（1）首先，安装 image-webpack-loader ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure>\n<p>（2）然后，在 webpack.base.conf.js 中进行配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: /.(png|jpe?g|gif|svg)(?.*)?$/,</span><br><span class=\"line\">  use:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    loader: &#x27;url-loader&#x27;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">      limit: 10000,</span><br><span class=\"line\">      name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      loader: &#x27;image-webpack-loader&#x27;,</span><br><span class=\"line\">      options: &#123;</span><br><span class=\"line\">        bypassOnDebug: true,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、减少-ES6-转为-ES5-的冗余代码\"><a href=\"#2-2、减少-ES6-转为-ES5-的冗余代码\" class=\"headerlink\" title=\"2.2、减少 ES6 转为 ES5 的冗余代码\"></a>2.2、减少 ES6 转为 ES5 的冗余代码</h2><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class HelloWebpack extends Component&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">babel-runtime/helpers/createClass  // 用于实现 class 语法</span><br><span class=\"line\">babel-runtime/helpers/inherits  // 用于实现 extends 语法  </span><br></pre></td></tr></table></figure>\n<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。<br>（1）首先，安装 babel-plugin-transform-runtime ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-runtime --save-dev</span><br></pre></td></tr></table></figure>\n<p>（2）然后，修改 .babelrc 配置文件为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;plugins&quot;: [</span><br><span class=\"line\">    &quot;transform-runtime&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime的详细介绍。</p>\n<h2 id=\"2-3、提取公共代码\"><a href=\"#2-3、提取公共代码\" class=\"headerlink\" title=\"2.3、提取公共代码\"></a>2.3、提取公共代码</h2><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p>\n<ul>\n<li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li>\n<li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。<br>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk中的公共部分的插件CommonsChunkPlugin，我们在项目中CommonsChunkPlugin 的配置如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">  name: &#x27;vendor&#x27;,</span><br><span class=\"line\">  minChunks: function(module, count) &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      module.resource &amp;&amp;</span><br><span class=\"line\">      /.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">      module.resource.indexOf(</span><br><span class=\"line\">        path.join(__dirname, &#x27;../node_modules&#x27;)</span><br><span class=\"line\">      ) === 0</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">// 抽取出代码模块的映射关系</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">  name: &#x27;manifest&#x27;,</span><br><span class=\"line\">  chunks: [&#x27;vendor&#x27;]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n如果要看插件的更多详细内容，可以查看CommonsChunkPlugin的详细介绍。<h2 id=\"2-4、模板预编译\"><a href=\"#2-4、模板预编译\" class=\"headerlink\" title=\"2.4、模板预编译\"></a>2.4、模板预编译</h2>当使用DOM内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。<br>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。<br>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。<h2 id=\"2-5、提取组件的-CSS\"><a href=\"#2-5、提取组件的-CSS\" class=\"headerlink\" title=\"2.5、提取组件的 CSS\"></a>2.5、提取组件的 CSS</h2>当使用单文件组件时，组件内的CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。<br>查阅这个构建工具各自的文档来了解更多：<br>webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)<br>Browserify + vueify<br>Rollup + rollup-plugin-vue<h2 id=\"2-6、优化-SourceMap\"><a href=\"#2-6、优化-SourceMap\" class=\"headerlink\" title=\"2.6、优化 SourceMap\"></a>2.6、优化 SourceMap</h2>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。<br>开发环境推荐： cheap-module-eval-source-map<br>生产环境推荐： cheap-module-source-map<br>原因如下：</li>\n<li>cheap： 源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</li>\n<li>module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</li>\n<li>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</li>\n<li>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。<h2 id=\"2-7、构建结果输出分析\"><a href=\"#2-7、构建结果输出分析\" class=\"headerlink\" title=\"2.7、构建结果输出分析\"></a>2.7、构建结果输出分析</h2>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。<br>我们在项目中 webpack.prod.conf.js 进行配置：<br>if (config.build.bundleAnalyzerReport) { var BundleAnalyzerPlugin = require(‘webpack-bundle-analyzer’).BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin()); } <h2 id=\"2-8、Vue-项目的编译优化\"><a href=\"#2-8、Vue-项目的编译优化\" class=\"headerlink\" title=\"2.8、Vue 项目的编译优化\"></a>2.8、Vue 项目的编译优化</h2>如果你的Vue项目使用Webpack编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的Webpack配置进行优化，提高 Webpack 的构建效率。具体如何进行Vue项目的Webpack构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》</li>\n</ul>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"一、代码层面的优化\"><a href=\"#一、代码层面的优化\" class=\"headerlink\" title=\"一、代码层面的优化\"></a>一、代码层面的优化</h1><h2 id=\"1-1、-v-if-和-v-show-区分使用场景\"><a href=\"#1-1、-v-if-和-v-show-区分使用场景\" class=\"headerlink\" title=\"1.1、 v-if 和 v-show 区分使用场景\"></a>1.1、 v-if 和 v-show 区分使用场景</h2><p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。<br>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>\n<h2 id=\"1-2、computed-和-watch-区分使用场景\"><a href=\"#1-2、computed-和-watch-区分使用场景\" class=\"headerlink\" title=\"1.2、computed 和 watch 区分使用场景\"></a>1.2、computed 和 watch 区分使用场景</h2><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>运用场景：<br>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<h2 id=\"1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v\"><a href=\"#1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v\" class=\"headerlink\" title=\"1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-\"></a>1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-</h2><p>（1）v-for 遍历必须为 item 添加 key<br>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。<br>（2）v-for 遍历避免同时使用 v-if<br>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。<br>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li</span><br><span class=\"line\">    v-for=&quot;user in activeUsers&quot;</span><br><span class=\"line\">    :key=&quot;user.id&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; user.name &#125;&#125;</span><br><span class=\"line\">  &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  activeUsers: function () &#123;</span><br><span class=\"line\">    return this.users.filter(function (user) &#123;</span><br><span class=\"line\">\t return user.isActive</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li</span><br><span class=\"line\">    v-for=&quot;user in users&quot;</span><br><span class=\"line\">    v-if=&quot;user.isActive&quot;</span><br><span class=\"line\">    :key=&quot;user.id&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; user.name &#125;&#125;</span><br><span class=\"line\">  &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-4、长列表性能优化\"><a href=\"#1-4、长列表性能优化\" class=\"headerlink\" title=\"1.4、长列表性能优化\"></a>1.4、长列表性能优化</h2><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data: () =&gt; (&#123;</span><br><span class=\"line\">    users: &#123;&#125;</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  async created() &#123;</span><br><span class=\"line\">    const users = await axios.get(&quot;/api/users&quot;);</span><br><span class=\"line\">    this.users = Object.freeze(users);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-5、事件的销毁\"><a href=\"#1-5、事件的销毁\" class=\"headerlink\" title=\"1.5、事件的销毁\"></a>1.5、事件的销毁</h2><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">  addEventListener(&#x27;click&#x27;, this.click, false)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">  removeEventListener(&#x27;click&#x27;, this.click, false)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-6、图片资源懒加载\"><a href=\"#1-6、图片资源懒加载\" class=\"headerlink\" title=\"1.6、图片资源懒加载\"></a>1.6、图片资源懒加载</h2><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：<br>（1）安装插件<br>npm install vue-lazyload –save-dev<br>（2）在入口文件 man.js 中引入并使用<br>import VueLazyload from ‘vue-lazyload’<br>然后再 vue 中直接使用<br>Vue.use(VueLazyload)<br>或者添加自定义选项</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.use(VueLazyload, &#123;</span><br><span class=\"line\">  preLoad: 1.3,</span><br><span class=\"line\">  error: &#x27;dist/error.png&#x27;,</span><br><span class=\"line\">  loading: &#x27;dist/loading.gif&#x27;,</span><br><span class=\"line\">  attempt: 1</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-7、路由懒加载\"><a href=\"#1-7、路由懒加载\" class=\"headerlink\" title=\"1.7、路由懒加载\"></a>1.7、路由懒加载</h2><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。<br>路由懒加载：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Foo = () =&gt; import(&#x27;./Foo.vue&#x27;)</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123; path: &#x27;/foo&#x27;, component: Foo &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-8、第三方插件的按需引入\"><a href=\"#1-8、第三方插件的按需引入\" class=\"headerlink\" title=\"1.8、第三方插件的按需引入\"></a>1.8、第三方插件的按需引入</h2><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：<br>（1）首先，安装 babel-plugin-component ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>\n<p>（2）然后，将 .babelrc 修改为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]],</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;component&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class=\"line\">        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）在 main.js 中引入部分组件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;;</span><br><span class=\"line\">import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;</span><br><span class=\"line\">Vue.use(Button)</span><br><span class=\"line\">Vue.use(Select)</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-9、优化无限列表性能\"><a href=\"#1-9、优化无限列表性能\" class=\"headerlink\" title=\"1.9、优化无限列表性能\"></a>1.9、优化无限列表性能</h2><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口化的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。 你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller来优化这种无限列表的场景的。</p>\n<h2 id=\"1-10、服务端渲染-SSR-or-预渲染\"><a href=\"#1-10、服务端渲染-SSR-or-预渲染\" class=\"headerlink\" title=\"1.10、服务端渲染 SSR or 预渲染\"></a>1.10、服务端渲染 SSR or 预渲染</h2><p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。<br>（1）服务端渲染的优点：</p>\n<ul>\n<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>\n<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；<br>（2）服务端渲染的缺点：</li>\n<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>\n<li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。<br>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</li>\n</ul>\n<h1 id=\"二、Webpack-层面的优化\"><a href=\"#二、Webpack-层面的优化\" class=\"headerlink\" title=\"二、Webpack 层面的优化\"></a>二、Webpack 层面的优化</h1><h2 id=\"2-1、Webpack-对图片进行压缩\"><a href=\"#2-1、Webpack-对图片进行压缩\" class=\"headerlink\" title=\"2.1、Webpack 对图片进行压缩\"></a>2.1、Webpack 对图片进行压缩</h2><p>在vue项目中除了可以在webpack.base.conf.js中url-loader中设置limit大小来对图片处理，对小limit 的图片转化为base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：<br>（1）首先，安装 image-webpack-loader ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure>\n<p>（2）然后，在 webpack.base.conf.js 中进行配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: /.(png|jpe?g|gif|svg)(?.*)?$/,</span><br><span class=\"line\">  use:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    loader: &#x27;url-loader&#x27;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">      limit: 10000,</span><br><span class=\"line\">      name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      loader: &#x27;image-webpack-loader&#x27;,</span><br><span class=\"line\">      options: &#123;</span><br><span class=\"line\">        bypassOnDebug: true,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、减少-ES6-转为-ES5-的冗余代码\"><a href=\"#2-2、减少-ES6-转为-ES5-的冗余代码\" class=\"headerlink\" title=\"2.2、减少 ES6 转为 ES5 的冗余代码\"></a>2.2、减少 ES6 转为 ES5 的冗余代码</h2><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class HelloWebpack extends Component&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">babel-runtime/helpers/createClass  // 用于实现 class 语法</span><br><span class=\"line\">babel-runtime/helpers/inherits  // 用于实现 extends 语法  </span><br></pre></td></tr></table></figure>\n<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。<br>（1）首先，安装 babel-plugin-transform-runtime ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-runtime --save-dev</span><br></pre></td></tr></table></figure>\n<p>（2）然后，修改 .babelrc 配置文件为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;plugins&quot;: [</span><br><span class=\"line\">    &quot;transform-runtime&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime的详细介绍。</p>\n<h2 id=\"2-3、提取公共代码\"><a href=\"#2-3、提取公共代码\" class=\"headerlink\" title=\"2.3、提取公共代码\"></a>2.3、提取公共代码</h2><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p>\n<ul>\n<li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li>\n<li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。<br>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk中的公共部分的插件CommonsChunkPlugin，我们在项目中CommonsChunkPlugin 的配置如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">  name: &#x27;vendor&#x27;,</span><br><span class=\"line\">  minChunks: function(module, count) &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      module.resource &amp;&amp;</span><br><span class=\"line\">      /.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">      module.resource.indexOf(</span><br><span class=\"line\">        path.join(__dirname, &#x27;../node_modules&#x27;)</span><br><span class=\"line\">      ) === 0</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">// 抽取出代码模块的映射关系</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">  name: &#x27;manifest&#x27;,</span><br><span class=\"line\">  chunks: [&#x27;vendor&#x27;]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n如果要看插件的更多详细内容，可以查看CommonsChunkPlugin的详细介绍。<h2 id=\"2-4、模板预编译\"><a href=\"#2-4、模板预编译\" class=\"headerlink\" title=\"2.4、模板预编译\"></a>2.4、模板预编译</h2>当使用DOM内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。<br>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。<br>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。<h2 id=\"2-5、提取组件的-CSS\"><a href=\"#2-5、提取组件的-CSS\" class=\"headerlink\" title=\"2.5、提取组件的 CSS\"></a>2.5、提取组件的 CSS</h2>当使用单文件组件时，组件内的CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。<br>查阅这个构建工具各自的文档来了解更多：<br>webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)<br>Browserify + vueify<br>Rollup + rollup-plugin-vue<h2 id=\"2-6、优化-SourceMap\"><a href=\"#2-6、优化-SourceMap\" class=\"headerlink\" title=\"2.6、优化 SourceMap\"></a>2.6、优化 SourceMap</h2>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。<br>开发环境推荐： cheap-module-eval-source-map<br>生产环境推荐： cheap-module-source-map<br>原因如下：</li>\n<li>cheap： 源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</li>\n<li>module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</li>\n<li>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</li>\n<li>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。<h2 id=\"2-7、构建结果输出分析\"><a href=\"#2-7、构建结果输出分析\" class=\"headerlink\" title=\"2.7、构建结果输出分析\"></a>2.7、构建结果输出分析</h2>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。<br>我们在项目中 webpack.prod.conf.js 进行配置：<br>if (config.build.bundleAnalyzerReport) { var BundleAnalyzerPlugin = require(‘webpack-bundle-analyzer’).BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin()); } <h2 id=\"2-8、Vue-项目的编译优化\"><a href=\"#2-8、Vue-项目的编译优化\" class=\"headerlink\" title=\"2.8、Vue 项目的编译优化\"></a>2.8、Vue 项目的编译优化</h2>如果你的Vue项目使用Webpack编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的Webpack配置进行优化，提高 Webpack 的构建效率。具体如何进行Vue项目的Webpack构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》</li>\n</ul>\n"},{"title":"数组，对象遍历的用法总结","date":"2023-03-21T03:06:45.000Z","_content":"作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。\n前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。\n\n# 一、遍历数组\n## 方法一：for循环\n### for 循环是使用最多，也是性能优化最好的一种遍历方式。\n```\nvar arr = [\"a\", \"b\", \"c\"]\nfor (var i = 0; i < arr.length; i++) {\n  console.log(arr[i])\n}\n// Expected output:a b c\n```\n## 方法二：for-of 遍历\n```\nvar arr = [\"a\", \"b\", \"c\"]\nfor (let item of arr) {\n  console.log(item)\n}\n// Expected output:a b c\n```\n## 方法三：数组方法\n### 1.forEach()方法，对原数组没有影响\n```\nvar arr = [\"a\", \"b\", \"c\"]\narr.forEach((index, item) => {\n  console.log(index, item)\n})\n//Expected output:\n// a 0\n// b 1\n// c 2\n```\n### 2.map()方法\n```\nvar arr = [1, 2, 3]\nvar newArr = arr.map(item => {\n  return item * 2\n});\nconsole.log(newArr); \n// Expected output:[2, 4, 6]\n```\n### 3.filter()方法，不改变原始数组\n```\nvar arr = [1, 2, 3]\nvar newArr = arr.filter(item => {\n  return item > 1\n});\nconsole.log(newArr)\n// Expected output:[2, 3]\n```\n### 4.reduce()方法\n```\nvar arr = [1, 2, 3]\nvar sum = arr.reduce((pre, cur) => {\n  return pre + cur\n});\nconsole.log(sum)\n// Expected output:6\n```\n### 5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\n```\nvar arr = [1, 2, 3]\nvar bool = arr.every(item => {\n  return item < 5\n});\nconsole.log(bool)\n// Expected output:true\n```\n### 6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。\n#### 下面的例子是检测数组元素是否存在 Number 类型。\n```\nvar arr = [\"a\", 1, \"b\"]\nvar bool = arr.some(item => {\n  return typeof item === \"number\"\n})\nconsole.log(bool)\n// Expected output:true\n```\n### 7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。\n```\nlet arr = [1, 2, 3, 4, 5]\nlet find = arr.find((item) => {\n  return item % 2 === 0\n})\n// Expected output:find =2\n```\n```\nvar arr = [1, 2, 3]\nvar ret = arr.find(ele => ele > 2)\nconsole.log(ret)\n// Expected output:3\nconsole.log(arr)\n// Expected output:[1, 2, 3]\n```\n### 8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。\n```\nlet arr = [1, 2, 3, 4, 5]\nlet findIndex = arr.findIndex((item) => {\n  return item % 2 === 0\n}) \n// Expected output:findIndex = 1\n```\n```\nvar arr = [1, 2, 3, 4 ,5]\nvar ret = arr.findIndex(ele => ele > 2) \nconsole.log(ret)\n// Expected output:2\n console.log(arr)\n// Expected output:[1, 2, 3, 4, 5]\n```\n\n# 二、遍历对象\n## 方法一：for-in 循环\n```\nvar obj = { a: 2, b: 4, c: 6 }\nfor (let key in obj) {\n  console.log(key)\n}\n// Expected output:a b c\n```\n## 方法二：Object.keys() 可理解为返回里面的key属性\n### 1.处理对象时：返回可枚举的属性数组\n```\nvar w_n = Object.keys({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:['name', 'address']\n```\n### 2.处理数组时：返回索引值数组\n```\nvar w_n = Object.keys([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:['0','1','2','3']\n```\n### 3.处理字符串数据时：返回索引值数组\n```\nvar str='hello';\nconsole.log(Object.keys(str))\n// Expected output:['0','1','2','3','4']\n```\n## 方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。\n### 1.处理对象数据时：返回可枚举的值组成的数组\n```\nvar w_n = Object.values({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:['wn', '中国']\n```\n### 2.处理数组数据时：返回原数组\n```\nvar w_n = Object.values([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:[11,22,33,44]\n```\n### 属性名为数值的属性，是按照数值大小，从小到大遍历的。\n```\nconst obj = {10 : \"a\", 6 : \"b\", 9 : \"c\"}\nconsole.log(Object.values(obj))\n// Expected output:['b', 'c', 'a']\n```\n### 3.处理字符串数据时：返回每个字符组成的数组\n```\nconsole.log(Object.values('hello'))\n// Expected output:['h', 'e', 'l', 'l', 'o']\n```\n### 4.Object.values会过滤属性名为 Symbol 值的属性\n```\nObject.values({ [Symbol()]: 123, foo: 'abc' })\n// Expected output:['abc']\n```\n## 方法四：Object.entries()方法\n### 1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。\n```\nvar w_n = Object.entries({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:[['name', 'wn'], ['address', '中国']]\n```\n### 2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。\n```\nvar w_n = Object.entries([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:[ ['0',11], ['1',22], ['2',33], ['3',44] ]\n```\n### 数组中包含对象：\n```\nvar w_n = Object.entries([{a:11},22,33,44]) \nconsole.log(w_n)\n// Expected output:[ ['0',{a:11}], ['1',22], ['2',33], ['3',44] ]\n```\n### 3.处理字符串数据时：返回也是一个二维数组。\n```\nvar str='hello'\nconsole.log(Object.entries(str)) \n// Expected output:[ ['0','h'], ['1','e'], ['2','l'], ['3','l'] ,['4','o'] ]\n```\n## 方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。\n### 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n```\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target);\n// Expected output: Object { a: 1, b: 4, c: 5 }\n```\n## 方法六：Object.getOwnPropertyNames()\n### Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for...in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\n```\nvar arr = [\"a\", \"b\", \"c\"]\nconsole.log(Object.getOwnPropertyNames(arr).sort()) \n// [\"0\", \"1\", \"2\", \"length\"]\n```\n### // 类数组对象\n```\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"}\nconsole.log(Object.getOwnPropertyNames(obj).sort())\n// Expected output:[\"0\", \"1\", \"2\"]\n```\n### // 使用 Array.forEach 输出属性名和属性值\n```\nObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n  console.log(val + \" -> \" + obj[val])\n})\n// Expected output:\n// 0 -> a\n// 1 -> b\n// 2 -> c\n```\n### //不可枚举属性\n```\nvar my_obj = Object.create({}, {\n  getFoo: {\n    value: function() { return this.foo; },\n    enumerable: false\n  }\n})\nmy_obj.foo = 1\nconsole.log(Object.getOwnPropertyNames(my_obj).sort())\n// Expected output:[\"foo\", \"getFoo\"]\n```\n","source":"_posts/数组，对象遍历的用法总结.md","raw":"---\ntitle: 数组，对象遍历的用法总结\ndate: 2023-03-21 11:06:45\ntags: JavaScript\ncategories: JavaScript\n---\n作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。\n前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。\n\n# 一、遍历数组\n## 方法一：for循环\n### for 循环是使用最多，也是性能优化最好的一种遍历方式。\n```\nvar arr = [\"a\", \"b\", \"c\"]\nfor (var i = 0; i < arr.length; i++) {\n  console.log(arr[i])\n}\n// Expected output:a b c\n```\n## 方法二：for-of 遍历\n```\nvar arr = [\"a\", \"b\", \"c\"]\nfor (let item of arr) {\n  console.log(item)\n}\n// Expected output:a b c\n```\n## 方法三：数组方法\n### 1.forEach()方法，对原数组没有影响\n```\nvar arr = [\"a\", \"b\", \"c\"]\narr.forEach((index, item) => {\n  console.log(index, item)\n})\n//Expected output:\n// a 0\n// b 1\n// c 2\n```\n### 2.map()方法\n```\nvar arr = [1, 2, 3]\nvar newArr = arr.map(item => {\n  return item * 2\n});\nconsole.log(newArr); \n// Expected output:[2, 4, 6]\n```\n### 3.filter()方法，不改变原始数组\n```\nvar arr = [1, 2, 3]\nvar newArr = arr.filter(item => {\n  return item > 1\n});\nconsole.log(newArr)\n// Expected output:[2, 3]\n```\n### 4.reduce()方法\n```\nvar arr = [1, 2, 3]\nvar sum = arr.reduce((pre, cur) => {\n  return pre + cur\n});\nconsole.log(sum)\n// Expected output:6\n```\n### 5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\n```\nvar arr = [1, 2, 3]\nvar bool = arr.every(item => {\n  return item < 5\n});\nconsole.log(bool)\n// Expected output:true\n```\n### 6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。\n#### 下面的例子是检测数组元素是否存在 Number 类型。\n```\nvar arr = [\"a\", 1, \"b\"]\nvar bool = arr.some(item => {\n  return typeof item === \"number\"\n})\nconsole.log(bool)\n// Expected output:true\n```\n### 7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。\n```\nlet arr = [1, 2, 3, 4, 5]\nlet find = arr.find((item) => {\n  return item % 2 === 0\n})\n// Expected output:find =2\n```\n```\nvar arr = [1, 2, 3]\nvar ret = arr.find(ele => ele > 2)\nconsole.log(ret)\n// Expected output:3\nconsole.log(arr)\n// Expected output:[1, 2, 3]\n```\n### 8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。\n```\nlet arr = [1, 2, 3, 4, 5]\nlet findIndex = arr.findIndex((item) => {\n  return item % 2 === 0\n}) \n// Expected output:findIndex = 1\n```\n```\nvar arr = [1, 2, 3, 4 ,5]\nvar ret = arr.findIndex(ele => ele > 2) \nconsole.log(ret)\n// Expected output:2\n console.log(arr)\n// Expected output:[1, 2, 3, 4, 5]\n```\n\n# 二、遍历对象\n## 方法一：for-in 循环\n```\nvar obj = { a: 2, b: 4, c: 6 }\nfor (let key in obj) {\n  console.log(key)\n}\n// Expected output:a b c\n```\n## 方法二：Object.keys() 可理解为返回里面的key属性\n### 1.处理对象时：返回可枚举的属性数组\n```\nvar w_n = Object.keys({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:['name', 'address']\n```\n### 2.处理数组时：返回索引值数组\n```\nvar w_n = Object.keys([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:['0','1','2','3']\n```\n### 3.处理字符串数据时：返回索引值数组\n```\nvar str='hello';\nconsole.log(Object.keys(str))\n// Expected output:['0','1','2','3','4']\n```\n## 方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。\n### 1.处理对象数据时：返回可枚举的值组成的数组\n```\nvar w_n = Object.values({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:['wn', '中国']\n```\n### 2.处理数组数据时：返回原数组\n```\nvar w_n = Object.values([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:[11,22,33,44]\n```\n### 属性名为数值的属性，是按照数值大小，从小到大遍历的。\n```\nconst obj = {10 : \"a\", 6 : \"b\", 9 : \"c\"}\nconsole.log(Object.values(obj))\n// Expected output:['b', 'c', 'a']\n```\n### 3.处理字符串数据时：返回每个字符组成的数组\n```\nconsole.log(Object.values('hello'))\n// Expected output:['h', 'e', 'l', 'l', 'o']\n```\n### 4.Object.values会过滤属性名为 Symbol 值的属性\n```\nObject.values({ [Symbol()]: 123, foo: 'abc' })\n// Expected output:['abc']\n```\n## 方法四：Object.entries()方法\n### 1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。\n```\nvar w_n = Object.entries({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:[['name', 'wn'], ['address', '中国']]\n```\n### 2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。\n```\nvar w_n = Object.entries([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:[ ['0',11], ['1',22], ['2',33], ['3',44] ]\n```\n### 数组中包含对象：\n```\nvar w_n = Object.entries([{a:11},22,33,44]) \nconsole.log(w_n)\n// Expected output:[ ['0',{a:11}], ['1',22], ['2',33], ['3',44] ]\n```\n### 3.处理字符串数据时：返回也是一个二维数组。\n```\nvar str='hello'\nconsole.log(Object.entries(str)) \n// Expected output:[ ['0','h'], ['1','e'], ['2','l'], ['3','l'] ,['4','o'] ]\n```\n## 方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。\n### 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n```\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target);\n// Expected output: Object { a: 1, b: 4, c: 5 }\n```\n## 方法六：Object.getOwnPropertyNames()\n### Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for...in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\n```\nvar arr = [\"a\", \"b\", \"c\"]\nconsole.log(Object.getOwnPropertyNames(arr).sort()) \n// [\"0\", \"1\", \"2\", \"length\"]\n```\n### // 类数组对象\n```\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"}\nconsole.log(Object.getOwnPropertyNames(obj).sort())\n// Expected output:[\"0\", \"1\", \"2\"]\n```\n### // 使用 Array.forEach 输出属性名和属性值\n```\nObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n  console.log(val + \" -> \" + obj[val])\n})\n// Expected output:\n// 0 -> a\n// 1 -> b\n// 2 -> c\n```\n### //不可枚举属性\n```\nvar my_obj = Object.create({}, {\n  getFoo: {\n    value: function() { return this.foo; },\n    enumerable: false\n  }\n})\nmy_obj.foo = 1\nconsole.log(Object.getOwnPropertyNames(my_obj).sort())\n// Expected output:[\"foo\", \"getFoo\"]\n```\n","slug":"数组，对象遍历的用法总结","published":1,"updated":"2023-04-03T04:42:28.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13mla002xtit8br6n2t07","content":"<p>作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。<br>前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。</p>\n<h1 id=\"一、遍历数组\"><a href=\"#一、遍历数组\" class=\"headerlink\" title=\"一、遍历数组\"></a>一、遍历数组</h1><h2 id=\"方法一：for循环\"><a href=\"#方法一：for循环\" class=\"headerlink\" title=\"方法一：for循环\"></a>方法一：for循环</h2><h3 id=\"for-循环是使用最多，也是性能优化最好的一种遍历方式。\"><a href=\"#for-循环是使用最多，也是性能优化最好的一种遍历方式。\" class=\"headerlink\" title=\"for 循环是使用最多，也是性能优化最好的一种遍历方式。\"></a>for 循环是使用最多，也是性能优化最好的一种遍历方式。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  console.log(arr[i])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Expected output:a b c</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法二：for-of-遍历\"><a href=\"#方法二：for-of-遍历\" class=\"headerlink\" title=\"方法二：for-of 遍历\"></a>方法二：for-of 遍历</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">for (let item of arr) &#123;</span><br><span class=\"line\">  console.log(item)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Expected output:a b c</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法三：数组方法\"><a href=\"#方法三：数组方法\" class=\"headerlink\" title=\"方法三：数组方法\"></a>方法三：数组方法</h2><h3 id=\"1-forEach-方法，对原数组没有影响\"><a href=\"#1-forEach-方法，对原数组没有影响\" class=\"headerlink\" title=\"1.forEach()方法，对原数组没有影响\"></a>1.forEach()方法，对原数组没有影响</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">arr.forEach((index, item) =&gt; &#123;</span><br><span class=\"line\">  console.log(index, item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//Expected output:</span><br><span class=\"line\">// a 0</span><br><span class=\"line\">// b 1</span><br><span class=\"line\">// c 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-map-方法\"><a href=\"#2-map-方法\" class=\"headerlink\" title=\"2.map()方法\"></a>2.map()方法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var newArr = arr.map(item =&gt; &#123;</span><br><span class=\"line\">  return item * 2</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(newArr); </span><br><span class=\"line\">// Expected output:[2, 4, 6]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-filter-方法，不改变原始数组\"><a href=\"#3-filter-方法，不改变原始数组\" class=\"headerlink\" title=\"3.filter()方法，不改变原始数组\"></a>3.filter()方法，不改变原始数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var newArr = arr.filter(item =&gt; &#123;</span><br><span class=\"line\">  return item &gt; 1</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(newArr)</span><br><span class=\"line\">// Expected output:[2, 3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-reduce-方法\"><a href=\"#4-reduce-方法\" class=\"headerlink\" title=\"4.reduce()方法\"></a>4.reduce()方法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var sum = arr.reduce((pre, cur) =&gt; &#123;</span><br><span class=\"line\">  return pre + cur</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(sum)</span><br><span class=\"line\">// Expected output:6</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\"><a href=\"#5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\" class=\"headerlink\" title=\"5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\"></a>5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var bool = arr.every(item =&gt; &#123;</span><br><span class=\"line\">  return item &lt; 5</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(bool)</span><br><span class=\"line\">// Expected output:true</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。\"><a href=\"#6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。\" class=\"headerlink\" title=\"6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。\"></a>6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。</h3><h4 id=\"下面的例子是检测数组元素是否存在-Number-类型。\"><a href=\"#下面的例子是检测数组元素是否存在-Number-类型。\" class=\"headerlink\" title=\"下面的例子是检测数组元素是否存在 Number 类型。\"></a>下面的例子是检测数组元素是否存在 Number 类型。</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, 1, &quot;b&quot;]</span><br><span class=\"line\">var bool = arr.some(item =&gt; &#123;</span><br><span class=\"line\">  return typeof item === &quot;number&quot;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(bool)</span><br><span class=\"line\">// Expected output:true</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。\"><a href=\"#7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。\" class=\"headerlink\" title=\"7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。\"></a>7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let arr = [1, 2, 3, 4, 5]</span><br><span class=\"line\">let find = arr.find((item) =&gt; &#123;</span><br><span class=\"line\">  return item % 2 === 0</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Expected output:find =2</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var ret = arr.find(ele =&gt; ele &gt; 2)</span><br><span class=\"line\">console.log(ret)</span><br><span class=\"line\">// Expected output:3</span><br><span class=\"line\">console.log(arr)</span><br><span class=\"line\">// Expected output:[1, 2, 3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。\"><a href=\"#8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。\" class=\"headerlink\" title=\"8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。\"></a>8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let arr = [1, 2, 3, 4, 5]</span><br><span class=\"line\">let findIndex = arr.findIndex((item) =&gt; &#123;</span><br><span class=\"line\">  return item % 2 === 0</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">// Expected output:findIndex = 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4 ,5]</span><br><span class=\"line\">var ret = arr.findIndex(ele =&gt; ele &gt; 2) </span><br><span class=\"line\">console.log(ret)</span><br><span class=\"line\">// Expected output:2</span><br><span class=\"line\"> console.log(arr)</span><br><span class=\"line\">// Expected output:[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、遍历对象\"><a href=\"#二、遍历对象\" class=\"headerlink\" title=\"二、遍历对象\"></a>二、遍历对象</h1><h2 id=\"方法一：for-in-循环\"><a href=\"#方法一：for-in-循环\" class=\"headerlink\" title=\"方法一：for-in 循环\"></a>方法一：for-in 循环</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123; a: 2, b: 4, c: 6 &#125;</span><br><span class=\"line\">for (let key in obj) &#123;</span><br><span class=\"line\">  console.log(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Expected output:a b c</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法二：Object-keys-可理解为返回里面的key属性\"><a href=\"#方法二：Object-keys-可理解为返回里面的key属性\" class=\"headerlink\" title=\"方法二：Object.keys() 可理解为返回里面的key属性\"></a>方法二：Object.keys() 可理解为返回里面的key属性</h2><h3 id=\"1-处理对象时：返回可枚举的属性数组\"><a href=\"#1-处理对象时：返回可枚举的属性数组\" class=\"headerlink\" title=\"1.处理对象时：返回可枚举的属性数组\"></a>1.处理对象时：返回可枚举的属性数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.keys(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[&#x27;name&#x27;, &#x27;address&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-处理数组时：返回索引值数组\"><a href=\"#2-处理数组时：返回索引值数组\" class=\"headerlink\" title=\"2.处理数组时：返回索引值数组\"></a>2.处理数组时：返回索引值数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.keys([11,22,33,44]) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-处理字符串数据时：返回索引值数组\"><a href=\"#3-处理字符串数据时：返回索引值数组\" class=\"headerlink\" title=\"3.处理字符串数据时：返回索引值数组\"></a>3.处理字符串数据时：返回索引值数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str=&#x27;hello&#x27;;</span><br><span class=\"line\">console.log(Object.keys(str))</span><br><span class=\"line\">// Expected output:[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。\"><a href=\"#方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。\" class=\"headerlink\" title=\"方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。\"></a>方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。</h2><h3 id=\"1-处理对象数据时：返回可枚举的值组成的数组\"><a href=\"#1-处理对象数据时：返回可枚举的值组成的数组\" class=\"headerlink\" title=\"1.处理对象数据时：返回可枚举的值组成的数组\"></a>1.处理对象数据时：返回可枚举的值组成的数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.values(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[&#x27;wn&#x27;, &#x27;中国&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-处理数组数据时：返回原数组\"><a href=\"#2-处理数组数据时：返回原数组\" class=\"headerlink\" title=\"2.处理数组数据时：返回原数组\"></a>2.处理数组数据时：返回原数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.values([11,22,33,44]) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[11,22,33,44]</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性名为数值的属性，是按照数值大小，从小到大遍历的。\"><a href=\"#属性名为数值的属性，是按照数值大小，从小到大遍历的。\" class=\"headerlink\" title=\"属性名为数值的属性，是按照数值大小，从小到大遍历的。\"></a>属性名为数值的属性，是按照数值大小，从小到大遍历的。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;10 : &quot;a&quot;, 6 : &quot;b&quot;, 9 : &quot;c&quot;&#125;</span><br><span class=\"line\">console.log(Object.values(obj))</span><br><span class=\"line\">// Expected output:[&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-处理字符串数据时：返回每个字符组成的数组\"><a href=\"#3-处理字符串数据时：返回每个字符组成的数组\" class=\"headerlink\" title=\"3.处理字符串数据时：返回每个字符组成的数组\"></a>3.处理字符串数据时：返回每个字符组成的数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(Object.values(&#x27;hello&#x27;))</span><br><span class=\"line\">// Expected output:[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-Object-values会过滤属性名为-Symbol-值的属性\"><a href=\"#4-Object-values会过滤属性名为-Symbol-值的属性\" class=\"headerlink\" title=\"4.Object.values会过滤属性名为 Symbol 值的属性\"></a>4.Object.values会过滤属性名为 Symbol 值的属性</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.values(&#123; [Symbol()]: 123, foo: &#x27;abc&#x27; &#125;)</span><br><span class=\"line\">// Expected output:[&#x27;abc&#x27;]</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法四：Object-entries-方法\"><a href=\"#方法四：Object-entries-方法\" class=\"headerlink\" title=\"方法四：Object.entries()方法\"></a>方法四：Object.entries()方法</h2><h3 id=\"1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。\"><a href=\"#1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。\" class=\"headerlink\" title=\"1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。\"></a>1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.entries(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[[&#x27;name&#x27;, &#x27;wn&#x27;], [&#x27;address&#x27;, &#x27;中国&#x27;]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。\"><a href=\"#2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。\" class=\"headerlink\" title=\"2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。\"></a>2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.entries([11,22,33,44]) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[ [&#x27;0&#x27;,11], [&#x27;1&#x27;,22], [&#x27;2&#x27;,33], [&#x27;3&#x27;,44] ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组中包含对象：\"><a href=\"#数组中包含对象：\" class=\"headerlink\" title=\"数组中包含对象：\"></a>数组中包含对象：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.entries([&#123;a:11&#125;,22,33,44]) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[ [&#x27;0&#x27;,&#123;a:11&#125;], [&#x27;1&#x27;,22], [&#x27;2&#x27;,33], [&#x27;3&#x27;,44] ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-处理字符串数据时：返回也是一个二维数组。\"><a href=\"#3-处理字符串数据时：返回也是一个二维数组。\" class=\"headerlink\" title=\"3.处理字符串数据时：返回也是一个二维数组。\"></a>3.处理字符串数据时：返回也是一个二维数组。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str=&#x27;hello&#x27;</span><br><span class=\"line\">console.log(Object.entries(str)) </span><br><span class=\"line\">// Expected output:[ [&#x27;0&#x27;,&#x27;h&#x27;], [&#x27;1&#x27;,&#x27;e&#x27;], [&#x27;2&#x27;,&#x27;l&#x27;], [&#x27;3&#x27;,&#x27;l&#x27;] ,[&#x27;4&#x27;,&#x27;o&#x27;] ]</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。\"><a href=\"#方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。\" class=\"headerlink\" title=\"方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。\"></a>方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</h2><h3 id=\"注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\"><a href=\"#注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\" class=\"headerlink\" title=\"注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\"></a>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const target = &#123; a: 1, b: 2 &#125;;</span><br><span class=\"line\">const source = &#123; b: 4, c: 5 &#125;;</span><br><span class=\"line\">const returnedTarget = Object.assign(target, source);</span><br><span class=\"line\">console.log(target);</span><br><span class=\"line\">// Expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法六：Object-getOwnPropertyNames\"><a href=\"#方法六：Object-getOwnPropertyNames\" class=\"headerlink\" title=\"方法六：Object.getOwnPropertyNames()\"></a>方法六：Object.getOwnPropertyNames()</h2><h3 id=\"Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\"><a href=\"#Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\" class=\"headerlink\" title=\"Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\"></a>Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">console.log(Object.getOwnPropertyNames(arr).sort()) </span><br><span class=\"line\">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;length&quot;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"类数组对象\"><a href=\"#类数组对象\" class=\"headerlink\" title=\"// 类数组对象\"></a>// 类数组对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\">console.log(Object.getOwnPropertyNames(obj).sort())</span><br><span class=\"line\">// Expected output:[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-Array-forEach-输出属性名和属性值\"><a href=\"#使用-Array-forEach-输出属性名和属性值\" class=\"headerlink\" title=\"// 使用 Array.forEach 输出属性名和属性值\"></a>// 使用 Array.forEach 输出属性名和属性值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) &#123;</span><br><span class=\"line\">  console.log(val + &quot; -&gt; &quot; + obj[val])</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Expected output:</span><br><span class=\"line\">// 0 -&gt; a</span><br><span class=\"line\">// 1 -&gt; b</span><br><span class=\"line\">// 2 -&gt; c</span><br></pre></td></tr></table></figure>\n<h3 id=\"不可枚举属性\"><a href=\"#不可枚举属性\" class=\"headerlink\" title=\"//不可枚举属性\"></a>//不可枚举属性</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var my_obj = Object.create(&#123;&#125;, &#123;</span><br><span class=\"line\">  getFoo: &#123;</span><br><span class=\"line\">    value: function() &#123; return this.foo; &#125;,</span><br><span class=\"line\">    enumerable: false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">my_obj.foo = 1</span><br><span class=\"line\">console.log(Object.getOwnPropertyNames(my_obj).sort())</span><br><span class=\"line\">// Expected output:[&quot;foo&quot;, &quot;getFoo&quot;]</span><br></pre></td></tr></table></figure>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。<br>前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。</p>\n<h1 id=\"一、遍历数组\"><a href=\"#一、遍历数组\" class=\"headerlink\" title=\"一、遍历数组\"></a>一、遍历数组</h1><h2 id=\"方法一：for循环\"><a href=\"#方法一：for循环\" class=\"headerlink\" title=\"方法一：for循环\"></a>方法一：for循环</h2><h3 id=\"for-循环是使用最多，也是性能优化最好的一种遍历方式。\"><a href=\"#for-循环是使用最多，也是性能优化最好的一种遍历方式。\" class=\"headerlink\" title=\"for 循环是使用最多，也是性能优化最好的一种遍历方式。\"></a>for 循环是使用最多，也是性能优化最好的一种遍历方式。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  console.log(arr[i])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Expected output:a b c</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法二：for-of-遍历\"><a href=\"#方法二：for-of-遍历\" class=\"headerlink\" title=\"方法二：for-of 遍历\"></a>方法二：for-of 遍历</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">for (let item of arr) &#123;</span><br><span class=\"line\">  console.log(item)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Expected output:a b c</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法三：数组方法\"><a href=\"#方法三：数组方法\" class=\"headerlink\" title=\"方法三：数组方法\"></a>方法三：数组方法</h2><h3 id=\"1-forEach-方法，对原数组没有影响\"><a href=\"#1-forEach-方法，对原数组没有影响\" class=\"headerlink\" title=\"1.forEach()方法，对原数组没有影响\"></a>1.forEach()方法，对原数组没有影响</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">arr.forEach((index, item) =&gt; &#123;</span><br><span class=\"line\">  console.log(index, item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//Expected output:</span><br><span class=\"line\">// a 0</span><br><span class=\"line\">// b 1</span><br><span class=\"line\">// c 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-map-方法\"><a href=\"#2-map-方法\" class=\"headerlink\" title=\"2.map()方法\"></a>2.map()方法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var newArr = arr.map(item =&gt; &#123;</span><br><span class=\"line\">  return item * 2</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(newArr); </span><br><span class=\"line\">// Expected output:[2, 4, 6]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-filter-方法，不改变原始数组\"><a href=\"#3-filter-方法，不改变原始数组\" class=\"headerlink\" title=\"3.filter()方法，不改变原始数组\"></a>3.filter()方法，不改变原始数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var newArr = arr.filter(item =&gt; &#123;</span><br><span class=\"line\">  return item &gt; 1</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(newArr)</span><br><span class=\"line\">// Expected output:[2, 3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-reduce-方法\"><a href=\"#4-reduce-方法\" class=\"headerlink\" title=\"4.reduce()方法\"></a>4.reduce()方法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var sum = arr.reduce((pre, cur) =&gt; &#123;</span><br><span class=\"line\">  return pre + cur</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(sum)</span><br><span class=\"line\">// Expected output:6</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\"><a href=\"#5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\" class=\"headerlink\" title=\"5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\"></a>5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var bool = arr.every(item =&gt; &#123;</span><br><span class=\"line\">  return item &lt; 5</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(bool)</span><br><span class=\"line\">// Expected output:true</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。\"><a href=\"#6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。\" class=\"headerlink\" title=\"6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。\"></a>6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。</h3><h4 id=\"下面的例子是检测数组元素是否存在-Number-类型。\"><a href=\"#下面的例子是检测数组元素是否存在-Number-类型。\" class=\"headerlink\" title=\"下面的例子是检测数组元素是否存在 Number 类型。\"></a>下面的例子是检测数组元素是否存在 Number 类型。</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, 1, &quot;b&quot;]</span><br><span class=\"line\">var bool = arr.some(item =&gt; &#123;</span><br><span class=\"line\">  return typeof item === &quot;number&quot;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(bool)</span><br><span class=\"line\">// Expected output:true</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。\"><a href=\"#7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。\" class=\"headerlink\" title=\"7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。\"></a>7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let arr = [1, 2, 3, 4, 5]</span><br><span class=\"line\">let find = arr.find((item) =&gt; &#123;</span><br><span class=\"line\">  return item % 2 === 0</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Expected output:find =2</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3]</span><br><span class=\"line\">var ret = arr.find(ele =&gt; ele &gt; 2)</span><br><span class=\"line\">console.log(ret)</span><br><span class=\"line\">// Expected output:3</span><br><span class=\"line\">console.log(arr)</span><br><span class=\"line\">// Expected output:[1, 2, 3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。\"><a href=\"#8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。\" class=\"headerlink\" title=\"8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。\"></a>8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let arr = [1, 2, 3, 4, 5]</span><br><span class=\"line\">let findIndex = arr.findIndex((item) =&gt; &#123;</span><br><span class=\"line\">  return item % 2 === 0</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">// Expected output:findIndex = 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4 ,5]</span><br><span class=\"line\">var ret = arr.findIndex(ele =&gt; ele &gt; 2) </span><br><span class=\"line\">console.log(ret)</span><br><span class=\"line\">// Expected output:2</span><br><span class=\"line\"> console.log(arr)</span><br><span class=\"line\">// Expected output:[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、遍历对象\"><a href=\"#二、遍历对象\" class=\"headerlink\" title=\"二、遍历对象\"></a>二、遍历对象</h1><h2 id=\"方法一：for-in-循环\"><a href=\"#方法一：for-in-循环\" class=\"headerlink\" title=\"方法一：for-in 循环\"></a>方法一：for-in 循环</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123; a: 2, b: 4, c: 6 &#125;</span><br><span class=\"line\">for (let key in obj) &#123;</span><br><span class=\"line\">  console.log(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Expected output:a b c</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法二：Object-keys-可理解为返回里面的key属性\"><a href=\"#方法二：Object-keys-可理解为返回里面的key属性\" class=\"headerlink\" title=\"方法二：Object.keys() 可理解为返回里面的key属性\"></a>方法二：Object.keys() 可理解为返回里面的key属性</h2><h3 id=\"1-处理对象时：返回可枚举的属性数组\"><a href=\"#1-处理对象时：返回可枚举的属性数组\" class=\"headerlink\" title=\"1.处理对象时：返回可枚举的属性数组\"></a>1.处理对象时：返回可枚举的属性数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.keys(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[&#x27;name&#x27;, &#x27;address&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-处理数组时：返回索引值数组\"><a href=\"#2-处理数组时：返回索引值数组\" class=\"headerlink\" title=\"2.处理数组时：返回索引值数组\"></a>2.处理数组时：返回索引值数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.keys([11,22,33,44]) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-处理字符串数据时：返回索引值数组\"><a href=\"#3-处理字符串数据时：返回索引值数组\" class=\"headerlink\" title=\"3.处理字符串数据时：返回索引值数组\"></a>3.处理字符串数据时：返回索引值数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str=&#x27;hello&#x27;;</span><br><span class=\"line\">console.log(Object.keys(str))</span><br><span class=\"line\">// Expected output:[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。\"><a href=\"#方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。\" class=\"headerlink\" title=\"方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。\"></a>方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。</h2><h3 id=\"1-处理对象数据时：返回可枚举的值组成的数组\"><a href=\"#1-处理对象数据时：返回可枚举的值组成的数组\" class=\"headerlink\" title=\"1.处理对象数据时：返回可枚举的值组成的数组\"></a>1.处理对象数据时：返回可枚举的值组成的数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.values(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[&#x27;wn&#x27;, &#x27;中国&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-处理数组数据时：返回原数组\"><a href=\"#2-处理数组数据时：返回原数组\" class=\"headerlink\" title=\"2.处理数组数据时：返回原数组\"></a>2.处理数组数据时：返回原数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.values([11,22,33,44]) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[11,22,33,44]</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性名为数值的属性，是按照数值大小，从小到大遍历的。\"><a href=\"#属性名为数值的属性，是按照数值大小，从小到大遍历的。\" class=\"headerlink\" title=\"属性名为数值的属性，是按照数值大小，从小到大遍历的。\"></a>属性名为数值的属性，是按照数值大小，从小到大遍历的。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;10 : &quot;a&quot;, 6 : &quot;b&quot;, 9 : &quot;c&quot;&#125;</span><br><span class=\"line\">console.log(Object.values(obj))</span><br><span class=\"line\">// Expected output:[&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-处理字符串数据时：返回每个字符组成的数组\"><a href=\"#3-处理字符串数据时：返回每个字符组成的数组\" class=\"headerlink\" title=\"3.处理字符串数据时：返回每个字符组成的数组\"></a>3.处理字符串数据时：返回每个字符组成的数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(Object.values(&#x27;hello&#x27;))</span><br><span class=\"line\">// Expected output:[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-Object-values会过滤属性名为-Symbol-值的属性\"><a href=\"#4-Object-values会过滤属性名为-Symbol-值的属性\" class=\"headerlink\" title=\"4.Object.values会过滤属性名为 Symbol 值的属性\"></a>4.Object.values会过滤属性名为 Symbol 值的属性</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.values(&#123; [Symbol()]: 123, foo: &#x27;abc&#x27; &#125;)</span><br><span class=\"line\">// Expected output:[&#x27;abc&#x27;]</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法四：Object-entries-方法\"><a href=\"#方法四：Object-entries-方法\" class=\"headerlink\" title=\"方法四：Object.entries()方法\"></a>方法四：Object.entries()方法</h2><h3 id=\"1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。\"><a href=\"#1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。\" class=\"headerlink\" title=\"1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。\"></a>1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.entries(&#123;name: &quot;wn&quot;, address: &quot;中国&quot;&#125;) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[[&#x27;name&#x27;, &#x27;wn&#x27;], [&#x27;address&#x27;, &#x27;中国&#x27;]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。\"><a href=\"#2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。\" class=\"headerlink\" title=\"2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。\"></a>2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.entries([11,22,33,44]) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[ [&#x27;0&#x27;,11], [&#x27;1&#x27;,22], [&#x27;2&#x27;,33], [&#x27;3&#x27;,44] ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组中包含对象：\"><a href=\"#数组中包含对象：\" class=\"headerlink\" title=\"数组中包含对象：\"></a>数组中包含对象：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var w_n = Object.entries([&#123;a:11&#125;,22,33,44]) </span><br><span class=\"line\">console.log(w_n)</span><br><span class=\"line\">// Expected output:[ [&#x27;0&#x27;,&#123;a:11&#125;], [&#x27;1&#x27;,22], [&#x27;2&#x27;,33], [&#x27;3&#x27;,44] ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-处理字符串数据时：返回也是一个二维数组。\"><a href=\"#3-处理字符串数据时：返回也是一个二维数组。\" class=\"headerlink\" title=\"3.处理字符串数据时：返回也是一个二维数组。\"></a>3.处理字符串数据时：返回也是一个二维数组。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str=&#x27;hello&#x27;</span><br><span class=\"line\">console.log(Object.entries(str)) </span><br><span class=\"line\">// Expected output:[ [&#x27;0&#x27;,&#x27;h&#x27;], [&#x27;1&#x27;,&#x27;e&#x27;], [&#x27;2&#x27;,&#x27;l&#x27;], [&#x27;3&#x27;,&#x27;l&#x27;] ,[&#x27;4&#x27;,&#x27;o&#x27;] ]</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。\"><a href=\"#方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。\" class=\"headerlink\" title=\"方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。\"></a>方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</h2><h3 id=\"注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\"><a href=\"#注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\" class=\"headerlink\" title=\"注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\"></a>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const target = &#123; a: 1, b: 2 &#125;;</span><br><span class=\"line\">const source = &#123; b: 4, c: 5 &#125;;</span><br><span class=\"line\">const returnedTarget = Object.assign(target, source);</span><br><span class=\"line\">console.log(target);</span><br><span class=\"line\">// Expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法六：Object-getOwnPropertyNames\"><a href=\"#方法六：Object-getOwnPropertyNames\" class=\"headerlink\" title=\"方法六：Object.getOwnPropertyNames()\"></a>方法六：Object.getOwnPropertyNames()</h2><h3 id=\"Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\"><a href=\"#Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\" class=\"headerlink\" title=\"Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\"></a>Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">console.log(Object.getOwnPropertyNames(arr).sort()) </span><br><span class=\"line\">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;length&quot;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"类数组对象\"><a href=\"#类数组对象\" class=\"headerlink\" title=\"// 类数组对象\"></a>// 类数组对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\">console.log(Object.getOwnPropertyNames(obj).sort())</span><br><span class=\"line\">// Expected output:[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-Array-forEach-输出属性名和属性值\"><a href=\"#使用-Array-forEach-输出属性名和属性值\" class=\"headerlink\" title=\"// 使用 Array.forEach 输出属性名和属性值\"></a>// 使用 Array.forEach 输出属性名和属性值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) &#123;</span><br><span class=\"line\">  console.log(val + &quot; -&gt; &quot; + obj[val])</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Expected output:</span><br><span class=\"line\">// 0 -&gt; a</span><br><span class=\"line\">// 1 -&gt; b</span><br><span class=\"line\">// 2 -&gt; c</span><br></pre></td></tr></table></figure>\n<h3 id=\"不可枚举属性\"><a href=\"#不可枚举属性\" class=\"headerlink\" title=\"//不可枚举属性\"></a>//不可枚举属性</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var my_obj = Object.create(&#123;&#125;, &#123;</span><br><span class=\"line\">  getFoo: &#123;</span><br><span class=\"line\">    value: function() &#123; return this.foo; &#125;,</span><br><span class=\"line\">    enumerable: false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">my_obj.foo = 1</span><br><span class=\"line\">console.log(Object.getOwnPropertyNames(my_obj).sort())</span><br><span class=\"line\">// Expected output:[&quot;foo&quot;, &quot;getFoo&quot;]</span><br></pre></td></tr></table></figure>\n"},{"title":"模块化","date":"2023-04-11T14:32:31.000Z","_content":"前言\n当你去面试的时候，被面试官问到前端模块化的问题，你的回答换来的是面试官的一句“你说了，但是好像又没说”。此时会感到备受打击，怀疑人生的问前端模块化到底是啥？说你好像知道，又好像说不出所以然来。\n\n1. 模块化简述\n把复杂代码按功能的不同划分成不同的模块单独维护，提高开发效率，降低维护成本 模块化只是思想、理论，不包含具体实现\n2. 模块化的诞生\n简单来说，就是一个人做不完的事，分成了多个人做，每人负责一个块内容（模块），最后把每个人做的东西组装一起成为整体\n前端模块化的演进道路上虽然有很多阶段，但是其实最终的目标，就是拆分模块，分工开发，每个人做好一个模块之后，暴露一些参数、方法给到调用者，演进的道路无非是秉行如何更加优雅，高解耦，高兼容等方向优化\n3. 模块化的演进\n第一阶段：仅仅基于文件的划分模块的方式\n具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）\n缺点：所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，而且模块一段多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系\n第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中\n具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。\n通过「命名空间」减小了命名冲突的可能，但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系。\n第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间\n具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现\n有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。\n第四阶段： 利用 IIFE 参数作为依赖声明使用\n具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。\n这使得每一个模块之间的关系变得更加明显。\n第五阶段： 模块化规范\nRequire.js 提供了 AMD 模块化规范，以及一个自动化模块加载器---模块化规范的出现，再之后便有了其他更多标准紧接而来，CommonJS、CMD。。。\n4. 模块化规范的出现\n需：模块化标准+模块加载器\nCommonJS规范(nodejs提出的一套标准)\n标准： 一个文件就是一个模块 每个模块都有单独的作用域 通过 module.exports 导出成员 通过 require 函数载入模块\n缺点：CommonJS是以同步模式加载模块，node执行机制是启动时加载模块，执行过程中不需要加载只需使用，在node中不会有问题；但是在浏览器端页面加载会导致大量同步请求出现，而效率低\nAMD(Asynchronous Module Definition) --- 异步模块定义规范\n模块通过define函数定义\n优势：目前绝大多数第三方库都支持AMD规范\n缺点： 使用复杂 模块划分细致，模块JS文件会出现请求频繁的情况\nSea.js(淘宝推出) + CMD(通用模块定义规范)\nCMD规范类似CommonJS规范 后期也被Require.js兼容了\nRequire.js\n提供了 AMD 模块化规范，以及一个自动化模块加载器 提供require函数加载模块\n5. 模块化默认规范\n浏览器环境使用ES Modules\nnodejs使用CommonJS\n6. 关于ES Modules\n通过给 script 添加 type = module 的属性使用 ES Modules\n\nESM 自动采用严格模式，忽略 'use strict'\n每个 ES Module 都是运行在单独的私有作用域中\nESM 是通过 CORS 的方式请求外部 JS 模块的\nESM 的 script 标签会延迟执行脚本\n对于我们前端平时开发，其实用得最多的是es modules，这里也简单介绍一下这种规范的一些常用写法\nES Modules 导出\n单个导出\n```\nexport const name = 'foo module'\nexport function hello () {\n    console.log('hello')\n}\n```\n合并导出\n```\nconst name = 'foo module'\nfunction hello () {\n    console.log('hello')\n}\nclass Person {}\nexport { name, hello, Person }\n```\n合并导出，且重命名\n```\nconst name = 'foo module'\nfunction hello () {\n    console.log('hello')\n}\nclass Person {}\nexport {\n    name1: name,\n    hello2: hello,\n    Person3: Person\n}\n```\n默认导出\n```\nconst name = 'foo module'\nfunction hello () {\n    console.log('hello')\n}\nclass Person {}\nexport default name;\n```\nES Modules 导入导出的注意事项\n导出字面量和导出模块的区别\n导出字面量(如:对象):export default { name, age }\n注意: import {name, age} from 'modulename'导入模块无法使用到name和age的值\n导出模块:\nexport { name, age }\nimport {name, age} from 'modulename' 导入模块可以使用到name和age的值\n原因：import导入的是对模块内部的使用\n导出模块的引用\n注意：export暴露的是模块的引用关系(地址)，并且只读不可修改(尝试修改会报错误---Uncaught TypeError:Assignment to constant variable)\n注意点\nCommonJS 中是先将模块整体导入为一个对象，然后从对象中结构出需要的成员 const { name, age } = require('./module.js')\nES Module 中 { } 是固定语法，就是直接提取模块导出成员 import { name, age } from './module.js'\n导入成员并不是复制一个副本，而是直接导入模块成员的引用地址，也就是说 import 得到的变量与 export 导入的变量在内存中是同一块空间。一旦模块中成员修改了，这里也会同时修改\n导入模块成员变量是只读的 name = 'tom' // 报错\n导入的是一个对象，对象的属性读写不受影响 name.xxx = 'xxx' // 正常","source":"_posts/模块化.md","raw":"---\ntitle: 模块化\ndate: 2023-04-11 22:32:31\ntags: 模块化\ncategories: 模块化\n---\n前言\n当你去面试的时候，被面试官问到前端模块化的问题，你的回答换来的是面试官的一句“你说了，但是好像又没说”。此时会感到备受打击，怀疑人生的问前端模块化到底是啥？说你好像知道，又好像说不出所以然来。\n\n1. 模块化简述\n把复杂代码按功能的不同划分成不同的模块单独维护，提高开发效率，降低维护成本 模块化只是思想、理论，不包含具体实现\n2. 模块化的诞生\n简单来说，就是一个人做不完的事，分成了多个人做，每人负责一个块内容（模块），最后把每个人做的东西组装一起成为整体\n前端模块化的演进道路上虽然有很多阶段，但是其实最终的目标，就是拆分模块，分工开发，每个人做好一个模块之后，暴露一些参数、方法给到调用者，演进的道路无非是秉行如何更加优雅，高解耦，高兼容等方向优化\n3. 模块化的演进\n第一阶段：仅仅基于文件的划分模块的方式\n具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）\n缺点：所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，而且模块一段多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系\n第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中\n具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。\n通过「命名空间」减小了命名冲突的可能，但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系。\n第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间\n具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现\n有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。\n第四阶段： 利用 IIFE 参数作为依赖声明使用\n具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。\n这使得每一个模块之间的关系变得更加明显。\n第五阶段： 模块化规范\nRequire.js 提供了 AMD 模块化规范，以及一个自动化模块加载器---模块化规范的出现，再之后便有了其他更多标准紧接而来，CommonJS、CMD。。。\n4. 模块化规范的出现\n需：模块化标准+模块加载器\nCommonJS规范(nodejs提出的一套标准)\n标准： 一个文件就是一个模块 每个模块都有单独的作用域 通过 module.exports 导出成员 通过 require 函数载入模块\n缺点：CommonJS是以同步模式加载模块，node执行机制是启动时加载模块，执行过程中不需要加载只需使用，在node中不会有问题；但是在浏览器端页面加载会导致大量同步请求出现，而效率低\nAMD(Asynchronous Module Definition) --- 异步模块定义规范\n模块通过define函数定义\n优势：目前绝大多数第三方库都支持AMD规范\n缺点： 使用复杂 模块划分细致，模块JS文件会出现请求频繁的情况\nSea.js(淘宝推出) + CMD(通用模块定义规范)\nCMD规范类似CommonJS规范 后期也被Require.js兼容了\nRequire.js\n提供了 AMD 模块化规范，以及一个自动化模块加载器 提供require函数加载模块\n5. 模块化默认规范\n浏览器环境使用ES Modules\nnodejs使用CommonJS\n6. 关于ES Modules\n通过给 script 添加 type = module 的属性使用 ES Modules\n\nESM 自动采用严格模式，忽略 'use strict'\n每个 ES Module 都是运行在单独的私有作用域中\nESM 是通过 CORS 的方式请求外部 JS 模块的\nESM 的 script 标签会延迟执行脚本\n对于我们前端平时开发，其实用得最多的是es modules，这里也简单介绍一下这种规范的一些常用写法\nES Modules 导出\n单个导出\n```\nexport const name = 'foo module'\nexport function hello () {\n    console.log('hello')\n}\n```\n合并导出\n```\nconst name = 'foo module'\nfunction hello () {\n    console.log('hello')\n}\nclass Person {}\nexport { name, hello, Person }\n```\n合并导出，且重命名\n```\nconst name = 'foo module'\nfunction hello () {\n    console.log('hello')\n}\nclass Person {}\nexport {\n    name1: name,\n    hello2: hello,\n    Person3: Person\n}\n```\n默认导出\n```\nconst name = 'foo module'\nfunction hello () {\n    console.log('hello')\n}\nclass Person {}\nexport default name;\n```\nES Modules 导入导出的注意事项\n导出字面量和导出模块的区别\n导出字面量(如:对象):export default { name, age }\n注意: import {name, age} from 'modulename'导入模块无法使用到name和age的值\n导出模块:\nexport { name, age }\nimport {name, age} from 'modulename' 导入模块可以使用到name和age的值\n原因：import导入的是对模块内部的使用\n导出模块的引用\n注意：export暴露的是模块的引用关系(地址)，并且只读不可修改(尝试修改会报错误---Uncaught TypeError:Assignment to constant variable)\n注意点\nCommonJS 中是先将模块整体导入为一个对象，然后从对象中结构出需要的成员 const { name, age } = require('./module.js')\nES Module 中 { } 是固定语法，就是直接提取模块导出成员 import { name, age } from './module.js'\n导入成员并不是复制一个副本，而是直接导入模块成员的引用地址，也就是说 import 得到的变量与 export 导入的变量在内存中是同一块空间。一旦模块中成员修改了，这里也会同时修改\n导入模块成员变量是只读的 name = 'tom' // 报错\n导入的是一个对象，对象的属性读写不受影响 name.xxx = 'xxx' // 正常","slug":"模块化","published":1,"updated":"2023-04-18T06:40:00.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13mlb0031tit863vdc547","content":"<p>前言<br>当你去面试的时候，被面试官问到前端模块化的问题，你的回答换来的是面试官的一句“你说了，但是好像又没说”。此时会感到备受打击，怀疑人生的问前端模块化到底是啥？说你好像知道，又好像说不出所以然来。</p>\n<ol>\n<li>模块化简述<br>把复杂代码按功能的不同划分成不同的模块单独维护，提高开发效率，降低维护成本 模块化只是思想、理论，不包含具体实现</li>\n<li>模块化的诞生<br>简单来说，就是一个人做不完的事，分成了多个人做，每人负责一个块内容（模块），最后把每个人做的东西组装一起成为整体<br>前端模块化的演进道路上虽然有很多阶段，但是其实最终的目标，就是拆分模块，分工开发，每个人做好一个模块之后，暴露一些参数、方法给到调用者，演进的道路无非是秉行如何更加优雅，高解耦，高兼容等方向优化</li>\n<li>模块化的演进<br>第一阶段：仅仅基于文件的划分模块的方式<br>具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）<br>缺点：所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，而且模块一段多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系<br>第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中<br>具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。<br>通过「命名空间」减小了命名冲突的可能，但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系。<br>第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间<br>具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现<br>有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。<br>第四阶段： 利用 IIFE 参数作为依赖声明使用<br>具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。<br>这使得每一个模块之间的关系变得更加明显。<br>第五阶段： 模块化规范<br>Require.js 提供了 AMD 模块化规范，以及一个自动化模块加载器—模块化规范的出现，再之后便有了其他更多标准紧接而来，CommonJS、CMD。。。</li>\n<li>模块化规范的出现<br>需：模块化标准+模块加载器<br>CommonJS规范(nodejs提出的一套标准)<br>标准： 一个文件就是一个模块 每个模块都有单独的作用域 通过 module.exports 导出成员 通过 require 函数载入模块<br>缺点：CommonJS是以同步模式加载模块，node执行机制是启动时加载模块，执行过程中不需要加载只需使用，在node中不会有问题；但是在浏览器端页面加载会导致大量同步请求出现，而效率低<br>AMD(Asynchronous Module Definition) — 异步模块定义规范<br>模块通过define函数定义<br>优势：目前绝大多数第三方库都支持AMD规范<br>缺点： 使用复杂 模块划分细致，模块JS文件会出现请求频繁的情况<br>Sea.js(淘宝推出) + CMD(通用模块定义规范)<br>CMD规范类似CommonJS规范 后期也被Require.js兼容了<br>Require.js<br>提供了 AMD 模块化规范，以及一个自动化模块加载器 提供require函数加载模块</li>\n<li>模块化默认规范<br>浏览器环境使用ES Modules<br>nodejs使用CommonJS</li>\n<li>关于ES Modules<br>通过给 script 添加 type = module 的属性使用 ES Modules</li>\n</ol>\n<p>ESM 自动采用严格模式，忽略 ‘use strict’<br>每个 ES Module 都是运行在单独的私有作用域中<br>ESM 是通过 CORS 的方式请求外部 JS 模块的<br>ESM 的 script 标签会延迟执行脚本<br>对于我们前端平时开发，其实用得最多的是es modules，这里也简单介绍一下这种规范的一些常用写法<br>ES Modules 导出<br>单个导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export const name = &#x27;foo module&#x27;</span><br><span class=\"line\">export function hello () &#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合并导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const name = &#x27;foo module&#x27;</span><br><span class=\"line\">function hello () &#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person &#123;&#125;</span><br><span class=\"line\">export &#123; name, hello, Person &#125;</span><br></pre></td></tr></table></figure>\n<p>合并导出，且重命名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const name = &#x27;foo module&#x27;</span><br><span class=\"line\">function hello () &#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person &#123;&#125;</span><br><span class=\"line\">export &#123;</span><br><span class=\"line\">    name1: name,</span><br><span class=\"line\">    hello2: hello,</span><br><span class=\"line\">    Person3: Person</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const name = &#x27;foo module&#x27;</span><br><span class=\"line\">function hello () &#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person &#123;&#125;</span><br><span class=\"line\">export default name;</span><br></pre></td></tr></table></figure>\n<p>ES Modules 导入导出的注意事项<br>导出字面量和导出模块的区别<br>导出字面量(如:对象):export default { name, age }<br>注意: import {name, age} from ‘modulename’导入模块无法使用到name和age的值<br>导出模块:<br>export { name, age }<br>import {name, age} from ‘modulename’ 导入模块可以使用到name和age的值<br>原因：import导入的是对模块内部的使用<br>导出模块的引用<br>注意：export暴露的是模块的引用关系(地址)，并且只读不可修改(尝试修改会报错误—Uncaught TypeError:Assignment to constant variable)<br>注意点<br>CommonJS 中是先将模块整体导入为一个对象，然后从对象中结构出需要的成员 const { name, age } = require(‘./module.js’)<br>ES Module 中 { } 是固定语法，就是直接提取模块导出成员 import { name, age } from ‘./module.js’<br>导入成员并不是复制一个副本，而是直接导入模块成员的引用地址，也就是说 import 得到的变量与 export 导入的变量在内存中是同一块空间。一旦模块中成员修改了，这里也会同时修改<br>导入模块成员变量是只读的 name = ‘tom’ // 报错<br>导入的是一个对象，对象的属性读写不受影响 name.xxx = ‘xxx’ // 正常</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<p>前言<br>当你去面试的时候，被面试官问到前端模块化的问题，你的回答换来的是面试官的一句“你说了，但是好像又没说”。此时会感到备受打击，怀疑人生的问前端模块化到底是啥？说你好像知道，又好像说不出所以然来。</p>\n<ol>\n<li>模块化简述<br>把复杂代码按功能的不同划分成不同的模块单独维护，提高开发效率，降低维护成本 模块化只是思想、理论，不包含具体实现</li>\n<li>模块化的诞生<br>简单来说，就是一个人做不完的事，分成了多个人做，每人负责一个块内容（模块），最后把每个人做的东西组装一起成为整体<br>前端模块化的演进道路上虽然有很多阶段，但是其实最终的目标，就是拆分模块，分工开发，每个人做好一个模块之后，暴露一些参数、方法给到调用者，演进的道路无非是秉行如何更加优雅，高解耦，高兼容等方向优化</li>\n<li>模块化的演进<br>第一阶段：仅仅基于文件的划分模块的方式<br>具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）<br>缺点：所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，而且模块一段多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系<br>第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中<br>具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。<br>通过「命名空间」减小了命名冲突的可能，但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系。<br>第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间<br>具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现<br>有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。<br>第四阶段： 利用 IIFE 参数作为依赖声明使用<br>具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。<br>这使得每一个模块之间的关系变得更加明显。<br>第五阶段： 模块化规范<br>Require.js 提供了 AMD 模块化规范，以及一个自动化模块加载器—模块化规范的出现，再之后便有了其他更多标准紧接而来，CommonJS、CMD。。。</li>\n<li>模块化规范的出现<br>需：模块化标准+模块加载器<br>CommonJS规范(nodejs提出的一套标准)<br>标准： 一个文件就是一个模块 每个模块都有单独的作用域 通过 module.exports 导出成员 通过 require 函数载入模块<br>缺点：CommonJS是以同步模式加载模块，node执行机制是启动时加载模块，执行过程中不需要加载只需使用，在node中不会有问题；但是在浏览器端页面加载会导致大量同步请求出现，而效率低<br>AMD(Asynchronous Module Definition) — 异步模块定义规范<br>模块通过define函数定义<br>优势：目前绝大多数第三方库都支持AMD规范<br>缺点： 使用复杂 模块划分细致，模块JS文件会出现请求频繁的情况<br>Sea.js(淘宝推出) + CMD(通用模块定义规范)<br>CMD规范类似CommonJS规范 后期也被Require.js兼容了<br>Require.js<br>提供了 AMD 模块化规范，以及一个自动化模块加载器 提供require函数加载模块</li>\n<li>模块化默认规范<br>浏览器环境使用ES Modules<br>nodejs使用CommonJS</li>\n<li>关于ES Modules<br>通过给 script 添加 type = module 的属性使用 ES Modules</li>\n</ol>\n<p>ESM 自动采用严格模式，忽略 ‘use strict’<br>每个 ES Module 都是运行在单独的私有作用域中<br>ESM 是通过 CORS 的方式请求外部 JS 模块的<br>ESM 的 script 标签会延迟执行脚本<br>对于我们前端平时开发，其实用得最多的是es modules，这里也简单介绍一下这种规范的一些常用写法<br>ES Modules 导出<br>单个导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export const name = &#x27;foo module&#x27;</span><br><span class=\"line\">export function hello () &#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合并导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const name = &#x27;foo module&#x27;</span><br><span class=\"line\">function hello () &#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person &#123;&#125;</span><br><span class=\"line\">export &#123; name, hello, Person &#125;</span><br></pre></td></tr></table></figure>\n<p>合并导出，且重命名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const name = &#x27;foo module&#x27;</span><br><span class=\"line\">function hello () &#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person &#123;&#125;</span><br><span class=\"line\">export &#123;</span><br><span class=\"line\">    name1: name,</span><br><span class=\"line\">    hello2: hello,</span><br><span class=\"line\">    Person3: Person</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const name = &#x27;foo module&#x27;</span><br><span class=\"line\">function hello () &#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person &#123;&#125;</span><br><span class=\"line\">export default name;</span><br></pre></td></tr></table></figure>\n<p>ES Modules 导入导出的注意事项<br>导出字面量和导出模块的区别<br>导出字面量(如:对象):export default { name, age }<br>注意: import {name, age} from ‘modulename’导入模块无法使用到name和age的值<br>导出模块:<br>export { name, age }<br>import {name, age} from ‘modulename’ 导入模块可以使用到name和age的值<br>原因：import导入的是对模块内部的使用<br>导出模块的引用<br>注意：export暴露的是模块的引用关系(地址)，并且只读不可修改(尝试修改会报错误—Uncaught TypeError:Assignment to constant variable)<br>注意点<br>CommonJS 中是先将模块整体导入为一个对象，然后从对象中结构出需要的成员 const { name, age } = require(‘./module.js’)<br>ES Module 中 { } 是固定语法，就是直接提取模块导出成员 import { name, age } from ‘./module.js’<br>导入成员并不是复制一个副本，而是直接导入模块成员的引用地址，也就是说 import 得到的变量与 export 导入的变量在内存中是同一块空间。一旦模块中成员修改了，这里也会同时修改<br>导入模块成员变量是只读的 name = ‘tom’ // 报错<br>导入的是一个对象，对象的属性读写不受影响 name.xxx = ‘xxx’ // 正常</p>\n"},{"title":"深浅拷贝","date":"2022-08-25T13:53:20.000Z","_content":"# 什么是浅拷贝？\n浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。\n举个例子：\n```\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=obj1;\nobj2.b=2;\nconsole.log(obj1.b);  //2\nconsole.log(obj2.b);  //2\n```\n浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。\n# 什么是深拷贝？\n深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。\n举个例子：\n```\nvar a=2;\nvar b=a;\nb=3;\nconsole.log(a);//2\nconsole.log(b);//3\n```\n深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。\n# 如何实现深拷贝？\n## ①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\n```\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=JSON.Stringify（JSON.parse（obj1））;\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n```\n## ②展开运算符   ...\n```\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=(...obj1)\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n```\n## ③Object.asssign（target,sourse）\n```\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=Object.assign({},obj1)\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n```\n## ④深拷贝函数，递归\n```\n            // target 要拷贝的对象\n            function deepClone(target){\n                //定义一个拷贝对象\n                let result;\n                // 判断拷贝目标是不是Object对象\n                if(typeof target==='object'){\n                    // 判断是否是数组类型\n                    if(Array.isArray(target)){\n                        // 定义为数组\n                        result=[];\n                        for(let i in target){\n                            result.push(deepClone(target[i]));\n                        }\n                    }else if(target===null){\n                        // 直接赋值\n                        result=null;\n                    }else if(target.constructor===RegExp){\n                        // 直接赋值\n                        result=target;\n                        // 不是特殊的对象\n                    }else{\n                        result={};\n                        for(let i in target){\n                            // 递归\n                            result[i]=deepClone(target[i]);\n                        }\n                    }\n                    // 基本数据类型  直接赋值\n                }else{\n                    result=target;\n                }\n                return result;\n            }\n```\n```\nvar obj1={\na:{z:1,c:null},\nb:[1,2,3,5],\nc:function(){console.log(this.a)}\n}\nvar obj2=deepClone(obj1);\nconsole.log(obj2);\nobj2.b[0]=2;\nobj2.a[0]=2;\nconsole.log(obj1.a)\nconsole.log(obj2.a)\nconsole.log(obj1.b)\nconsole.log(obj2.b)\nconsole.log(obj2.c())\n```\n![](深浅拷贝结果.png)","source":"_posts/深浅拷贝.md","raw":"---\ntitle: 深浅拷贝\ndate: 2022-08-25 21:53:20\ntags: 深浅拷贝\ncategories: 知识点\n---\n# 什么是浅拷贝？\n浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。\n举个例子：\n```\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=obj1;\nobj2.b=2;\nconsole.log(obj1.b);  //2\nconsole.log(obj2.b);  //2\n```\n浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。\n# 什么是深拷贝？\n深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。\n举个例子：\n```\nvar a=2;\nvar b=a;\nb=3;\nconsole.log(a);//2\nconsole.log(b);//3\n```\n深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。\n# 如何实现深拷贝？\n## ①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\n```\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=JSON.Stringify（JSON.parse（obj1））;\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n```\n## ②展开运算符   ...\n```\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=(...obj1)\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n```\n## ③Object.asssign（target,sourse）\n```\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=Object.assign({},obj1)\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n```\n## ④深拷贝函数，递归\n```\n            // target 要拷贝的对象\n            function deepClone(target){\n                //定义一个拷贝对象\n                let result;\n                // 判断拷贝目标是不是Object对象\n                if(typeof target==='object'){\n                    // 判断是否是数组类型\n                    if(Array.isArray(target)){\n                        // 定义为数组\n                        result=[];\n                        for(let i in target){\n                            result.push(deepClone(target[i]));\n                        }\n                    }else if(target===null){\n                        // 直接赋值\n                        result=null;\n                    }else if(target.constructor===RegExp){\n                        // 直接赋值\n                        result=target;\n                        // 不是特殊的对象\n                    }else{\n                        result={};\n                        for(let i in target){\n                            // 递归\n                            result[i]=deepClone(target[i]);\n                        }\n                    }\n                    // 基本数据类型  直接赋值\n                }else{\n                    result=target;\n                }\n                return result;\n            }\n```\n```\nvar obj1={\na:{z:1,c:null},\nb:[1,2,3,5],\nc:function(){console.log(this.a)}\n}\nvar obj2=deepClone(obj1);\nconsole.log(obj2);\nobj2.b[0]=2;\nobj2.a[0]=2;\nconsole.log(obj1.a)\nconsole.log(obj2.a)\nconsole.log(obj1.b)\nconsole.log(obj2.b)\nconsole.log(obj2.c())\n```\n![](深浅拷贝结果.png)","slug":"深浅拷贝","published":1,"updated":"2023-04-03T04:38:46.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13mlb0035tit8077teqie","content":"<h1 id=\"什么是浅拷贝？\"><a href=\"#什么是浅拷贝？\" class=\"headerlink\" title=\"什么是浅拷贝？\"></a>什么是浅拷贝？</h1><p>浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。<br>举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var  obj1=&#123;a:1,b:5,c:3&#125;;</span><br><span class=\"line\">var  obj2=obj1;</span><br><span class=\"line\">obj2.b=2;</span><br><span class=\"line\">console.log(obj1.b);  //2</span><br><span class=\"line\">console.log(obj2.b);  //2</span><br></pre></td></tr></table></figure>\n<p>浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。</p>\n<h1 id=\"什么是深拷贝？\"><a href=\"#什么是深拷贝？\" class=\"headerlink\" title=\"什么是深拷贝？\"></a>什么是深拷贝？</h1><p>深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。<br>举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a=2;</span><br><span class=\"line\">var b=a;</span><br><span class=\"line\">b=3;</span><br><span class=\"line\">console.log(a);//2</span><br><span class=\"line\">console.log(b);//3</span><br></pre></td></tr></table></figure>\n<p>深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。</p>\n<h1 id=\"如何实现深拷贝？\"><a href=\"#如何实现深拷贝？\" class=\"headerlink\" title=\"如何实现深拷贝？\"></a>如何实现深拷贝？</h1><h2 id=\"①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\"><a href=\"#①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\" class=\"headerlink\" title=\"①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\"></a>①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var  obj1=&#123;a:1,b:5,c:3&#125;;</span><br><span class=\"line\">var  obj2=JSON.Stringify（JSON.parse（obj1））;</span><br><span class=\"line\">obj2.b=2;</span><br><span class=\"line\">console.log(obj1.b);  //5</span><br><span class=\"line\">console.log(obj2.b);  //2</span><br></pre></td></tr></table></figure>\n<h2 id=\"②展开运算符-…\"><a href=\"#②展开运算符-…\" class=\"headerlink\" title=\"②展开运算符   …\"></a>②展开运算符   …</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var  obj1=&#123;a:1,b:5,c:3&#125;;</span><br><span class=\"line\">var  obj2=(...obj1)</span><br><span class=\"line\">obj2.b=2;</span><br><span class=\"line\">console.log(obj1.b);  //5</span><br><span class=\"line\">console.log(obj2.b);  //2</span><br></pre></td></tr></table></figure>\n<h2 id=\"③Object-asssign（target-sourse）\"><a href=\"#③Object-asssign（target-sourse）\" class=\"headerlink\" title=\"③Object.asssign（target,sourse）\"></a>③Object.asssign（target,sourse）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var  obj1=&#123;a:1,b:5,c:3&#125;;</span><br><span class=\"line\">var  obj2=Object.assign(&#123;&#125;,obj1)</span><br><span class=\"line\">obj2.b=2;</span><br><span class=\"line\">console.log(obj1.b);  //5</span><br><span class=\"line\">console.log(obj2.b);  //2</span><br></pre></td></tr></table></figure>\n<h2 id=\"④深拷贝函数，递归\"><a href=\"#④深拷贝函数，递归\" class=\"headerlink\" title=\"④深拷贝函数，递归\"></a>④深拷贝函数，递归</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// target 要拷贝的对象</span><br><span class=\"line\">function deepClone(target)&#123;</span><br><span class=\"line\">    //定义一个拷贝对象</span><br><span class=\"line\">    let result;</span><br><span class=\"line\">    // 判断拷贝目标是不是Object对象</span><br><span class=\"line\">    if(typeof target===&#x27;object&#x27;)&#123;</span><br><span class=\"line\">        // 判断是否是数组类型</span><br><span class=\"line\">        if(Array.isArray(target))&#123;</span><br><span class=\"line\">            // 定义为数组</span><br><span class=\"line\">            result=[];</span><br><span class=\"line\">            for(let i in target)&#123;</span><br><span class=\"line\">                result.push(deepClone(target[i]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else if(target===null)&#123;</span><br><span class=\"line\">            // 直接赋值</span><br><span class=\"line\">            result=null;</span><br><span class=\"line\">        &#125;else if(target.constructor===RegExp)&#123;</span><br><span class=\"line\">            // 直接赋值</span><br><span class=\"line\">            result=target;</span><br><span class=\"line\">            // 不是特殊的对象</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            result=&#123;&#125;;</span><br><span class=\"line\">            for(let i in target)&#123;</span><br><span class=\"line\">                // 递归</span><br><span class=\"line\">                result[i]=deepClone(target[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 基本数据类型  直接赋值</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        result=target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj1=&#123;</span><br><span class=\"line\">a:&#123;z:1,c:null&#125;,</span><br><span class=\"line\">b:[1,2,3,5],</span><br><span class=\"line\">c:function()&#123;console.log(this.a)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj2=deepClone(obj1);</span><br><span class=\"line\">console.log(obj2);</span><br><span class=\"line\">obj2.b[0]=2;</span><br><span class=\"line\">obj2.a[0]=2;</span><br><span class=\"line\">console.log(obj1.a)</span><br><span class=\"line\">console.log(obj2.a)</span><br><span class=\"line\">console.log(obj1.b)</span><br><span class=\"line\">console.log(obj2.b)</span><br><span class=\"line\">console.log(obj2.c())</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%BB%93%E6%9E%9C.png\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"什么是浅拷贝？\"><a href=\"#什么是浅拷贝？\" class=\"headerlink\" title=\"什么是浅拷贝？\"></a>什么是浅拷贝？</h1><p>浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。<br>举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var  obj1=&#123;a:1,b:5,c:3&#125;;</span><br><span class=\"line\">var  obj2=obj1;</span><br><span class=\"line\">obj2.b=2;</span><br><span class=\"line\">console.log(obj1.b);  //2</span><br><span class=\"line\">console.log(obj2.b);  //2</span><br></pre></td></tr></table></figure>\n<p>浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。</p>\n<h1 id=\"什么是深拷贝？\"><a href=\"#什么是深拷贝？\" class=\"headerlink\" title=\"什么是深拷贝？\"></a>什么是深拷贝？</h1><p>深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。<br>举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a=2;</span><br><span class=\"line\">var b=a;</span><br><span class=\"line\">b=3;</span><br><span class=\"line\">console.log(a);//2</span><br><span class=\"line\">console.log(b);//3</span><br></pre></td></tr></table></figure>\n<p>深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。</p>\n<h1 id=\"如何实现深拷贝？\"><a href=\"#如何实现深拷贝？\" class=\"headerlink\" title=\"如何实现深拷贝？\"></a>如何实现深拷贝？</h1><h2 id=\"①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\"><a href=\"#①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\" class=\"headerlink\" title=\"①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\"></a>①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var  obj1=&#123;a:1,b:5,c:3&#125;;</span><br><span class=\"line\">var  obj2=JSON.Stringify（JSON.parse（obj1））;</span><br><span class=\"line\">obj2.b=2;</span><br><span class=\"line\">console.log(obj1.b);  //5</span><br><span class=\"line\">console.log(obj2.b);  //2</span><br></pre></td></tr></table></figure>\n<h2 id=\"②展开运算符-…\"><a href=\"#②展开运算符-…\" class=\"headerlink\" title=\"②展开运算符   …\"></a>②展开运算符   …</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var  obj1=&#123;a:1,b:5,c:3&#125;;</span><br><span class=\"line\">var  obj2=(...obj1)</span><br><span class=\"line\">obj2.b=2;</span><br><span class=\"line\">console.log(obj1.b);  //5</span><br><span class=\"line\">console.log(obj2.b);  //2</span><br></pre></td></tr></table></figure>\n<h2 id=\"③Object-asssign（target-sourse）\"><a href=\"#③Object-asssign（target-sourse）\" class=\"headerlink\" title=\"③Object.asssign（target,sourse）\"></a>③Object.asssign（target,sourse）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var  obj1=&#123;a:1,b:5,c:3&#125;;</span><br><span class=\"line\">var  obj2=Object.assign(&#123;&#125;,obj1)</span><br><span class=\"line\">obj2.b=2;</span><br><span class=\"line\">console.log(obj1.b);  //5</span><br><span class=\"line\">console.log(obj2.b);  //2</span><br></pre></td></tr></table></figure>\n<h2 id=\"④深拷贝函数，递归\"><a href=\"#④深拷贝函数，递归\" class=\"headerlink\" title=\"④深拷贝函数，递归\"></a>④深拷贝函数，递归</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// target 要拷贝的对象</span><br><span class=\"line\">function deepClone(target)&#123;</span><br><span class=\"line\">    //定义一个拷贝对象</span><br><span class=\"line\">    let result;</span><br><span class=\"line\">    // 判断拷贝目标是不是Object对象</span><br><span class=\"line\">    if(typeof target===&#x27;object&#x27;)&#123;</span><br><span class=\"line\">        // 判断是否是数组类型</span><br><span class=\"line\">        if(Array.isArray(target))&#123;</span><br><span class=\"line\">            // 定义为数组</span><br><span class=\"line\">            result=[];</span><br><span class=\"line\">            for(let i in target)&#123;</span><br><span class=\"line\">                result.push(deepClone(target[i]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else if(target===null)&#123;</span><br><span class=\"line\">            // 直接赋值</span><br><span class=\"line\">            result=null;</span><br><span class=\"line\">        &#125;else if(target.constructor===RegExp)&#123;</span><br><span class=\"line\">            // 直接赋值</span><br><span class=\"line\">            result=target;</span><br><span class=\"line\">            // 不是特殊的对象</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            result=&#123;&#125;;</span><br><span class=\"line\">            for(let i in target)&#123;</span><br><span class=\"line\">                // 递归</span><br><span class=\"line\">                result[i]=deepClone(target[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 基本数据类型  直接赋值</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        result=target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj1=&#123;</span><br><span class=\"line\">a:&#123;z:1,c:null&#125;,</span><br><span class=\"line\">b:[1,2,3,5],</span><br><span class=\"line\">c:function()&#123;console.log(this.a)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj2=deepClone(obj1);</span><br><span class=\"line\">console.log(obj2);</span><br><span class=\"line\">obj2.b[0]=2;</span><br><span class=\"line\">obj2.a[0]=2;</span><br><span class=\"line\">console.log(obj1.a)</span><br><span class=\"line\">console.log(obj2.a)</span><br><span class=\"line\">console.log(obj1.b)</span><br><span class=\"line\">console.log(obj2.b)</span><br><span class=\"line\">console.log(obj2.c())</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"跨域","date":"2022-09-30T04:30:52.000Z","_content":"# 一、跨域是什么？\n## 1.同源策略\n跨域问题其实就是浏览器的同源策略所导致的。\n「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\n只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。\n\n# 二、如何解决跨域？\n方式一：使用 ajax 的 jsonp\n使用该方式的缺点：请求方式只能是 get 请求\n\n# 方式二：使用 jQuery 的 jsonp 插件\n特点： get 请求、 post 请求；\n但从服务器从获取的数据，依然是 jsonp 格式。\n\n# 方式三：使用 cors\n使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。\n\n# 方式四：使用 Nginx 反向代理\nNginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。","source":"_posts/跨域.md","raw":"---\ntitle: 跨域\ndate: 2022-09-30 12:30:52\ntags: 跨域\ncategories: 知识点\n---\n# 一、跨域是什么？\n## 1.同源策略\n跨域问题其实就是浏览器的同源策略所导致的。\n「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\n只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。\n\n# 二、如何解决跨域？\n方式一：使用 ajax 的 jsonp\n使用该方式的缺点：请求方式只能是 get 请求\n\n# 方式二：使用 jQuery 的 jsonp 插件\n特点： get 请求、 post 请求；\n但从服务器从获取的数据，依然是 jsonp 格式。\n\n# 方式三：使用 cors\n使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。\n\n# 方式四：使用 Nginx 反向代理\nNginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。","slug":"跨域","published":1,"updated":"2023-03-22T06:09:11.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgq13mlc0038tit83vwg4m83","content":"<h1 id=\"一、跨域是什么？\"><a href=\"#一、跨域是什么？\" class=\"headerlink\" title=\"一、跨域是什么？\"></a>一、跨域是什么？</h1><h2 id=\"1-同源策略\"><a href=\"#1-同源策略\" class=\"headerlink\" title=\"1.同源策略\"></a>1.同源策略</h2><p>跨域问题其实就是浏览器的同源策略所导致的。<br>「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。<br>只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。</p>\n<h1 id=\"二、如何解决跨域？\"><a href=\"#二、如何解决跨域？\" class=\"headerlink\" title=\"二、如何解决跨域？\"></a>二、如何解决跨域？</h1><p>方式一：使用 ajax 的 jsonp<br>使用该方式的缺点：请求方式只能是 get 请求</p>\n<h1 id=\"方式二：使用-jQuery-的-jsonp-插件\"><a href=\"#方式二：使用-jQuery-的-jsonp-插件\" class=\"headerlink\" title=\"方式二：使用 jQuery 的 jsonp 插件\"></a>方式二：使用 jQuery 的 jsonp 插件</h1><p>特点： get 请求、 post 请求；<br>但从服务器从获取的数据，依然是 jsonp 格式。</p>\n<h1 id=\"方式三：使用-cors\"><a href=\"#方式三：使用-cors\" class=\"headerlink\" title=\"方式三：使用 cors\"></a>方式三：使用 cors</h1><p>使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。</p>\n<h1 id=\"方式四：使用-Nginx-反向代理\"><a href=\"#方式四：使用-Nginx-反向代理\" class=\"headerlink\" title=\"方式四：使用 Nginx 反向代理\"></a>方式四：使用 Nginx 反向代理</h1><p>Nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。</p>\n","site":{"data":{"languages":{"en":{"site":{"title":"Site Information"}},"zh-Hans":{"site":{"title":"本站信息"}}}}},"excerpt":"","more":"<h1 id=\"一、跨域是什么？\"><a href=\"#一、跨域是什么？\" class=\"headerlink\" title=\"一、跨域是什么？\"></a>一、跨域是什么？</h1><h2 id=\"1-同源策略\"><a href=\"#1-同源策略\" class=\"headerlink\" title=\"1.同源策略\"></a>1.同源策略</h2><p>跨域问题其实就是浏览器的同源策略所导致的。<br>「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。<br>只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。</p>\n<h1 id=\"二、如何解决跨域？\"><a href=\"#二、如何解决跨域？\" class=\"headerlink\" title=\"二、如何解决跨域？\"></a>二、如何解决跨域？</h1><p>方式一：使用 ajax 的 jsonp<br>使用该方式的缺点：请求方式只能是 get 请求</p>\n<h1 id=\"方式二：使用-jQuery-的-jsonp-插件\"><a href=\"#方式二：使用-jQuery-的-jsonp-插件\" class=\"headerlink\" title=\"方式二：使用 jQuery 的 jsonp 插件\"></a>方式二：使用 jQuery 的 jsonp 插件</h1><p>特点： get 请求、 post 请求；<br>但从服务器从获取的数据，依然是 jsonp 格式。</p>\n<h1 id=\"方式三：使用-cors\"><a href=\"#方式三：使用-cors\" class=\"headerlink\" title=\"方式三：使用 cors\"></a>方式三：使用 cors</h1><p>使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。</p>\n<h1 id=\"方式四：使用-Nginx-反向代理\"><a href=\"#方式四：使用-Nginx-反向代理\" class=\"headerlink\" title=\"方式四：使用 Nginx 反向代理\"></a>方式四：使用 Nginx 反向代理</h1><p>Nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Hooks/案例1.png","post":"clgq13mkx0001tit86mx57cfq","slug":"案例1.png","modified":1,"renderable":1},{"_id":"source/_posts/Hooks/案例2.png","post":"clgq13mkx0001tit86mx57cfq","slug":"案例2.png","modified":1,"renderable":1},{"_id":"source/_posts/Hooks/案例3.png","post":"clgq13mkx0001tit86mx57cfq","slug":"案例3.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/name.png","post":"clgq13ml3000gtit85vl1a80y","slug":"name.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/名称渲染失败.png","post":"clgq13ml3000gtit85vl1a80y","slug":"名称渲染失败.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/基本变量.png","post":"clgq13ml3000gtit85vl1a80y","slug":"基本变量.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/基本数据代码.png","post":"clgq13ml3000gtit85vl1a80y","slug":"基本数据代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/基本数据类型.png","post":"clgq13ml3000gtit85vl1a80y","slug":"基本数据类型.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/复杂数据代码.png","post":"clgq13ml3000gtit85vl1a80y","slug":"复杂数据代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/复杂数据类型.png","post":"clgq13ml3000gtit85vl1a80y","slug":"复杂数据类型.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/提示找不到.png","post":"clgq13ml3000gtit85vl1a80y","slug":"提示找不到.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/渲染成功.png","post":"clgq13ml3000gtit85vl1a80y","slug":"渲染成功.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/点击代码.png","post":"clgq13ml3000gtit85vl1a80y","slug":"点击代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/被点击.png","post":"clgq13ml3000gtit85vl1a80y","slug":"被点击.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowReactive一代码.png","post":"clgq13ml3000ltit8g1vp1nwf","slug":"shallowReactive一代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowReactive一代码结果.png","post":"clgq13ml3000ltit8g1vp1nwf","slug":"shallowReactive一代码结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef二代码.png","post":"clgq13ml3000ltit8g1vp1nwf","slug":"shallowRef二代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef二代码结果.png","post":"clgq13ml3000ltit8g1vp1nwf","slug":"shallowRef二代码结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef代码.png","post":"clgq13ml3000ltit8g1vp1nwf","slug":"shallowRef代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef代码结果.png","post":"clgq13ml3000ltit8g1vp1nwf","slug":"shallowRef代码结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/indexts.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"indexts.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/安装.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"安装.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图10代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图10代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图10结果.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图10结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图11代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图11代码1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图11代码2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11结果1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图11结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11结果2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图11结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图12代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图12代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图12结果.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图12结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图13代码1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图13代码1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图13代码2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图13代码2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图13结果1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图13结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图13结果2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图13结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图14代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图14代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图14结果1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图14结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图14结果2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图14结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图15代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图15代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图15结果1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图15结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图15结果2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图15结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图16代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图16代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图16结果1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图16结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图16结果2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图16结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图17代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图17代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图17结果.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图17结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图1代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图1代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图1结果.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图1结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图2代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图2代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图2结果.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图2结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图3代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图3代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图3结果1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图3结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图3结果2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图3结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图4代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图4代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图5代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图5代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图6代码1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图6代码1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图6代码2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图6代码2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图6结果1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图6结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图6结果2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图6结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图7代码1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图7代码1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图7代码2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图7代码2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图7结果1.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图7结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图7结果2.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图7结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图8代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图8代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图8结果.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图8结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图9代码.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图9代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图9结果.png","post":"clgq13ml2000ftit8fcbcbz33","slug":"截图9结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一代码.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器一代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一控制台.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器一控制台.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一数据更新.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器一数据更新.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一数据更新代码.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器一数据更新代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一结果.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器一结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器三代码.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器三代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器三修改代码.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器三修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器三修改结果.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器三修改结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器三报错.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器三报错.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器二代码.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器二代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器二修改代码.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器二修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器二修改结果.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器二修改结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器二警告.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器二警告.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器监听reactive代码.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器监听reactive代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器监听reactive结果.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听器监听reactive结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听多个参数.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听多个参数.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听多个参数结果.png","post":"clgq13ml4000stit8eyfghsd1","slug":"侦听多个参数结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/多个侦听器代码.png","post":"clgq13ml4000stit8eyfghsd1","slug":"多个侦听器代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/reactive代码.png","post":"clgq13ml3000ntit8c66scnbc","slug":"reactive代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用代码.png","post":"clgq13ml3000ntit8c66scnbc","slug":"refs使用代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用控制台信息.png","post":"clgq13ml3000ntit8c66scnbc","slug":"refs使用控制台信息.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用正常.png","post":"clgq13ml3000ntit8c66scnbc","slug":"refs使用正常.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用结果.png","post":"clgq13ml3000ntit8c66scnbc","slug":"refs使用结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs解决代码.png","post":"clgq13ml3000ntit8c66scnbc","slug":"refs解决代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/ref函数验证代码.png","post":"clgq13ml3000ntit8c66scnbc","slug":"ref函数验证代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/ref函数验证结果.png","post":"clgq13ml3000ntit8c66scnbc","slug":"ref函数验证结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/torefbody打印结果.png","post":"clgq13ml3000ntit8c66scnbc","slug":"torefbody打印结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref代码.png","post":"clgq13ml3000ntit8c66scnbc","slug":"toref代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref修改代码.png","post":"clgq13ml3000ntit8c66scnbc","slug":"toref修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref修改结果.png","post":"clgq13ml3000ntit8c66scnbc","slug":"toref修改结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref打印body代码.png","post":"clgq13ml3000ntit8c66scnbc","slug":"toref打印body代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref源数据.png","post":"clgq13ml3000ntit8c66scnbc","slug":"toref源数据.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref页面成功.png","post":"clgq13ml3000ntit8c66scnbc","slug":"toref页面成功.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/原始数据代码.png","post":"clgq13ml3000ntit8c66scnbc","slug":"原始数据代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/截屏2022-10-17 上午11.27.38.png","post":"clgq13ml3000ntit8c66scnbc","slug":"截屏2022-10-17 上午11.27.38.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/数据源结果.png","post":"clgq13ml3000ntit8c66scnbc","slug":"数据源结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue项目SEO优化-Nuxt/nuxt渲染.png","post":"clgq13ml60016tit816ja41on","slug":"nuxt渲染.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue项目SEO优化-Nuxt/客户端渲染.png","post":"clgq13ml60016tit816ja41on","slug":"客户端渲染.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue项目SEO优化-Nuxt/服务端渲染.png","post":"clgq13ml60016tit816ja41on","slug":"服务端渲染.png","modified":1,"renderable":1},{"_id":"source/_posts/Vuex/vuex.png","post":"clgq13ml50010tit8b009aoff","slug":"vuex.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3计算属性/引入.png","post":"clgq13ml5000vtit89wsf7qyg","slug":"引入.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3计算属性/案例一.png","post":"clgq13ml5000vtit89wsf7qyg","slug":"案例一.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3计算属性/案例二.png","post":"clgq13ml5000vtit89wsf7qyg","slug":"案例二.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3计算属性/计算属性求和.png","post":"clgq13ml5000vtit89wsf7qyg","slug":"计算属性求和.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3-hooks使用/案例1.png","post":"clgq13ml7001ltit830etb747","slug":"案例1.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3-hooks使用/案例2.png","post":"clgq13ml7001ltit830etb747","slug":"案例2.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3-hooks使用/案例3.png","post":"clgq13ml7001ltit830etb747","slug":"案例3.png","modified":1,"renderable":1},{"_id":"source/_posts/serve的区别/npm区别.png","post":"clgq13ml7001ftit8774ccwae","slug":"npm区别.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例1.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例1.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例10.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例10.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例11.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例11.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例12.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例12.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例13.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例13.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例14.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例14.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例15.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例15.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例16.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例16.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例17.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例17.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例18.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例18.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例19.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例19.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例2.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例2.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例20.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例20.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例21.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例21.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例22.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例22.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例23.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例23.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例3.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例3.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例4.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例4.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例5.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例5.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例6.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例6.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例7.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例7.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例9.png","post":"clgq13ml7001stit8ej7d5f4w","slug":"案例9.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive修改代码.png","post":"clgq13ml8001vtit85nz2hhka","slug":"reactive修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象代码.png","post":"clgq13ml8001vtit85nz2hhka","slug":"reactive对象代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象修改结果.png","post":"clgq13ml8001vtit85nz2hhka","slug":"reactive对象修改结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象结果.png","post":"clgq13ml8001vtit85nz2hhka","slug":"reactive对象结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive数组代码.png","post":"clgq13ml8001vtit85nz2hhka","slug":"reactive数组代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive数组处理结果.png","post":"clgq13ml8001vtit85nz2hhka","slug":"reactive数组处理结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/refdom代码.png","post":"clgq13ml8001vtit85nz2hhka","slug":"refdom代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref修改代码.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref基本修改成功.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref基本修改成功.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref基本出错.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref基本出错.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref基本控制台.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref基本控制台.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref基本数据类型代码.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref基本数据类型代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂修改代码.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref复杂修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂修改代码成功.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref复杂修改代码成功.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂数据代码.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref复杂数据代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂结构.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref复杂结构.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref成功.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref成功.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref打印.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref打印.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref结构.png","post":"clgq13ml8001vtit85nz2hhka","slug":"ref结构.png","modified":1,"renderable":1},{"_id":"source/_posts/webpack升级/webpack4-1.png","post":"clgq13ml80027tit8hikmhjqy","slug":"webpack4-1.png","modified":1,"renderable":1},{"_id":"source/_posts/webpack升级/webpack4-2.png","post":"clgq13ml80027tit8hikmhjqy","slug":"webpack4-2.png","modified":1,"renderable":1},{"_id":"source/_posts/webpack升级/webpack4-3.png","post":"clgq13ml80027tit8hikmhjqy","slug":"webpack4-3.png","modified":1,"renderable":1},{"_id":"source/_posts/webpack升级/webpack4.png","post":"clgq13ml80027tit8hikmhjqy","slug":"webpack4.png","modified":1,"renderable":1},{"_id":"source/_posts/webpack升级/webpack5-1.png","post":"clgq13ml80027tit8hikmhjqy","slug":"webpack5-1.png","modified":1,"renderable":1},{"_id":"source/_posts/微前端-qiankun/defaultPic.png","post":"clgq13ml9002mtit88w63abak","slug":"defaultPic.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/传值前结果.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"传值前结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/传值后结果.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"传值后结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/子传父结果.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"子传父结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/子组件三代码.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"子组件三代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/子组件二代码.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"子组件二代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/子组件代码.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"子组件代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/父组件三代码.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"父组件三代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/父组件二代码.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"父组件二代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/父组件代码.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"父组件代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/祖孙结果.png","post":"clgq13ml8001ytit8fjii9lvf","slug":"祖孙结果.png","modified":1,"renderable":1},{"_id":"source/_posts/深浅拷贝/深浅拷贝结果.png","post":"clgq13mlb0035tit8077teqie","slug":"深浅拷贝结果.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"clgq13mkx0001tit86mx57cfq","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml3000htit83bm0fija"},{"post_id":"clgq13ml2000ftit8fcbcbz33","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml4000otit886xeglaj"},{"post_id":"clgq13mkz0003tit86x0t1cvp","category_id":"clgq13ml2000ctit8317ehxlo","_id":"clgq13ml5000ttit8403q67dx"},{"post_id":"clgq13ml3000gtit85vl1a80y","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml5000wtit89tpq4g8g"},{"post_id":"clgq13ml3000ltit8g1vp1nwf","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml60011tit8ee6g6cq4"},{"post_id":"clgq13ml10007tit87dmogfxu","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13ml60014tit8h4ek35ts"},{"post_id":"clgq13ml3000ntit8c66scnbc","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml60017tit81760bwml"},{"post_id":"clgq13ml4000stit8eyfghsd1","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml6001atit81kfzbh8o"},{"post_id":"clgq13ml10009tit8e6lh73ra","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13ml6001dtit8b6qkd265"},{"post_id":"clgq13ml5000vtit89wsf7qyg","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml7001gtit864w35kt2"},{"post_id":"clgq13ml50010tit8b009aoff","category_id":"clgq13ml2000ctit8317ehxlo","_id":"clgq13ml7001jtit84q2pel70"},{"post_id":"clgq13ml2000btit81kpvfmcg","category_id":"clgq13ml5000xtit85prq7gjg","_id":"clgq13ml7001mtit8gqqn4izu"},{"post_id":"clgq13ml60013tit80tb21n1z","category_id":"clgq13ml2000ctit8317ehxlo","_id":"clgq13ml7001qtit86nakd85k"},{"post_id":"clgq13ml60016tit816ja41on","category_id":"clgq13ml5000xtit85prq7gjg","_id":"clgq13ml8001ttit8gxpzab2e"},{"post_id":"clgq13ml60019tit864bdg58d","category_id":"clgq13ml2000ctit8317ehxlo","_id":"clgq13ml8001wtit8fgc2eruu"},{"post_id":"clgq13ml6001ctit8d4foehyu","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13ml8001ztit8bodvfkp7"},{"post_id":"clgq13ml7001ftit8774ccwae","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13ml80022tit825vi8g0s"},{"post_id":"clgq13ml7001itit8ccib1dyq","category_id":"clgq13ml2000ctit8317ehxlo","_id":"clgq13ml80025tit8e81xhw3h"},{"post_id":"clgq13ml7001ltit830etb747","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml90028tit898jt0rnh"},{"post_id":"clgq13ml7001ptit8gy1ec892","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml9002ctit81jnwbxwr"},{"post_id":"clgq13ml7001stit8ej7d5f4w","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml9002gtit8afzr0dis"},{"post_id":"clgq13ml8001vtit85nz2hhka","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13ml9002ktit8dwlvg83x"},{"post_id":"clgq13ml8001ytit8fjii9lvf","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13mla002otit8bi0985uc"},{"post_id":"clgq13ml80021tit8e1ymconk","category_id":"clgq13ml00004tit8fta0gst9","_id":"clgq13mla002stit82xzobeh8"},{"post_id":"clgq13ml80024tit85jgf3iq2","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13mla002vtit8goidebly"},{"post_id":"clgq13ml9002btit82yicexo1","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13mlb002ztit8f66h57k2"},{"post_id":"clgq13ml80027tit8hikmhjqy","category_id":"clgq13ml9002dtit8f43p3tvl","_id":"clgq13mlb0032tit8fprbf8cc"},{"post_id":"clgq13ml9002mtit88w63abak","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13mlb0036tit815704v1j"},{"post_id":"clgq13mla002qtit8g6ye10wp","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13mlc003atit8c8s8gr5l"},{"post_id":"clgq13ml9002ftit8fr4nfqt5","category_id":"clgq13mla002ntit889hrhl59","_id":"clgq13mlc003ctit89ktwebti"},{"post_id":"clgq13mla002utit8b87d0p8i","category_id":"clgq13ml5000xtit85prq7gjg","_id":"clgq13mlc003etit80bczg6a8"},{"post_id":"clgq13ml9002itit8cbi9gu66","category_id":"clgq13mla002ntit889hrhl59","_id":"clgq13mlc003gtit87o962p6v"},{"post_id":"clgq13mlb0035tit8077teqie","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13mlc003itit80t74hl9b"},{"post_id":"clgq13mlc0038tit83vwg4m83","category_id":"clgq13ml3000itit893rna69j","_id":"clgq13mlc003ktit8du6a6o1d"},{"post_id":"clgq13mla002xtit8br6n2t07","category_id":"clgq13mlb0033tit8cwbxdirh","_id":"clgq13mlc003mtit8g2rz2zl4"},{"post_id":"clgq13mlb0031tit863vdc547","category_id":"clgq13mlc003btit8gayb9emy","_id":"clgq13mlc003otit8dooh4h7r"}],"PostTag":[{"post_id":"clgq13mkx0001tit86mx57cfq","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml2000etit8cme5enlu"},{"post_id":"clgq13ml2000ftit8fcbcbz33","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml3000ktit8gtei166m"},{"post_id":"clgq13mkz0003tit86x0t1cvp","tag_id":"clgq13ml2000dtit84erecl1m","_id":"clgq13ml3000mtit8goilfnhh"},{"post_id":"clgq13ml3000gtit85vl1a80y","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml4000rtit85ebf6ns5"},{"post_id":"clgq13ml3000ltit8g1vp1nwf","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml5000utit86x7qhxiv"},{"post_id":"clgq13ml10007tit87dmogfxu","tag_id":"clgq13ml3000jtit8c3p2f7x0","_id":"clgq13ml5000ytit87so48a2m"},{"post_id":"clgq13ml3000ntit8c66scnbc","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml60012tit8bc6v73vg"},{"post_id":"clgq13ml4000stit8eyfghsd1","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml60015tit8h06t4rqs"},{"post_id":"clgq13ml10009tit8e6lh73ra","tag_id":"clgq13ml4000qtit899oeakol","_id":"clgq13ml60018tit82mmih6b5"},{"post_id":"clgq13ml5000vtit89wsf7qyg","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml6001btit8g1mn7qrp"},{"post_id":"clgq13ml50010tit8b009aoff","tag_id":"clgq13ml2000dtit84erecl1m","_id":"clgq13ml7001etit85yzth1lk"},{"post_id":"clgq13ml60013tit80tb21n1z","tag_id":"clgq13ml2000dtit84erecl1m","_id":"clgq13ml7001htit85vvh3qly"},{"post_id":"clgq13ml2000btit81kpvfmcg","tag_id":"clgq13ml5000ztit811khdl5a","_id":"clgq13ml7001ktit8hvnq4d1k"},{"post_id":"clgq13ml60016tit816ja41on","tag_id":"clgq13ml4000qtit899oeakol","_id":"clgq13ml7001otit82gkr7gat"},{"post_id":"clgq13ml60019tit864bdg58d","tag_id":"clgq13ml5000ztit811khdl5a","_id":"clgq13ml7001rtit84eio34kv"},{"post_id":"clgq13ml6001ctit8d4foehyu","tag_id":"clgq13ml4000qtit899oeakol","_id":"clgq13ml8001utit8ewy40img"},{"post_id":"clgq13ml7001ftit8774ccwae","tag_id":"clgq13ml4000qtit899oeakol","_id":"clgq13ml8001xtit8c97wa94x"},{"post_id":"clgq13ml7001ltit830etb747","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml80020tit854ene47m"},{"post_id":"clgq13ml7001ptit8gy1ec892","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml80023tit89l58cg14"},{"post_id":"clgq13ml7001stit8ej7d5f4w","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml80026tit87lh674qq"},{"post_id":"clgq13ml7001itit8ccib1dyq","tag_id":"clgq13ml7001ntit80at54fju","_id":"clgq13ml9002atit89bdu5co6"},{"post_id":"clgq13ml8001vtit85nz2hhka","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml9002etit8ar6ibhvd"},{"post_id":"clgq13ml8001ytit8fjii9lvf","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml9002htit8alyg5zag"},{"post_id":"clgq13ml80021tit8e1ymconk","tag_id":"clgq13ml00005tit88mwvce7g","_id":"clgq13ml9002ltit8a9xw272i"},{"post_id":"clgq13ml80024tit85jgf3iq2","tag_id":"clgq13ml90029tit8bake6zyo","_id":"clgq13mla002ptit898kjg3g9"},{"post_id":"clgq13ml80027tit8hikmhjqy","tag_id":"clgq13ml90029tit8bake6zyo","_id":"clgq13mla002ttit8fz65f6d8"},{"post_id":"clgq13mla002utit8b87d0p8i","tag_id":"clgq13ml5000ztit811khdl5a","_id":"clgq13mlb0030tit8hx7k8xlt"},{"post_id":"clgq13ml9002btit82yicexo1","tag_id":"clgq13ml90029tit8bake6zyo","_id":"clgq13mlb0034tit81o531l4m"},{"post_id":"clgq13ml9002ftit8fr4nfqt5","tag_id":"clgq13mlb002ytit8400i208d","_id":"clgq13mlc0039tit89kjy7dj1"},{"post_id":"clgq13ml9002itit8cbi9gu66","tag_id":"clgq13mlb0037tit8awyc04nb","_id":"clgq13mlc003ftit8br8meq2y"},{"post_id":"clgq13ml9002mtit88w63abak","tag_id":"clgq13mlc003dtit89rxq5xu3","_id":"clgq13mlc003jtit8elbagcte"},{"post_id":"clgq13mla002qtit8g6ye10wp","tag_id":"clgq13mlc003dtit89rxq5xu3","_id":"clgq13mlc003ntit8a9ja733x"},{"post_id":"clgq13mla002xtit8br6n2t07","tag_id":"clgq13mlc003ltit89amw7jo0","_id":"clgq13mlc003qtit8fm6m5ch0"},{"post_id":"clgq13mlb0031tit863vdc547","tag_id":"clgq13mlc003ptit8hjqa4z7g","_id":"clgq13mlc003stit8cn3t06fr"},{"post_id":"clgq13mlb0035tit8077teqie","tag_id":"clgq13mlc003rtit88e1i5jxh","_id":"clgq13mlc003utit8b3674gf8"},{"post_id":"clgq13mlc0038tit83vwg4m83","tag_id":"clgq13mlc003ttit8b7bl2cao","_id":"clgq13mlc003vtit86jbe8ue5"}],"Tag":[{"name":"vue3","_id":"clgq13ml00005tit88mwvce7g"},{"name":"Vuex","_id":"clgq13ml2000dtit84erecl1m"},{"name":"Webpack","_id":"clgq13ml3000jtit8c3p2f7x0"},{"name":"vue","_id":"clgq13ml4000qtit899oeakol"},{"name":"Vue","_id":"clgq13ml5000ztit811khdl5a"},{"name":"vue-cropper","_id":"clgq13ml7001ntit80at54fju"},{"name":"webpack","_id":"clgq13ml90029tit8bake6zyo"},{"name":"搭建博客","_id":"clgq13mlb002ytit8400i208d"},{"name":"hexo","_id":"clgq13mlb0037tit8awyc04nb"},{"name":"微前端","_id":"clgq13mlc003dtit89rxq5xu3"},{"name":"JavaScript","_id":"clgq13mlc003ltit89amw7jo0"},{"name":"模块化","_id":"clgq13mlc003ptit8hjqa4z7g"},{"name":"深浅拷贝","_id":"clgq13mlc003rtit88e1i5jxh"},{"name":"跨域","_id":"clgq13mlc003ttit8b7bl2cao"}]}}