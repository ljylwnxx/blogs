{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/defaultl.png","path":"img/defaultl.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/.DS_Store","hash":"f0cab4198b9ab039aa3822f53240cc816cf7470c","modified":1679365349089},{"_id":"source/.DS_Store","hash":"8fab1287cac5cf1c8bea05c796b3d9452bbd4d79","modified":1679366097725},{"_id":"source/about/index-1.md","hash":"3d24741fed88bcdba5e81fc2128df24a9e7f3cab","modified":1666018070017},{"_id":"source/about/index-2.md","hash":"3d2c3fb4800673c2dbf5574e98897aaea727e1eb","modified":1666081054076},{"_id":"source/about/index.md","hash":"bf4be054db5d876787e8794a67ceb5faba8eb1b6","modified":1666017128603},{"_id":"source/_posts/.DS_Store","hash":"bb49038e295c8f337f66be86e85d774a94ff5dca","modified":1679365349090},{"_id":"source/_posts/Vue3-Pinia使用.md","hash":"7838b5848caf4f40486721d11b2094738ee153a4","modified":1679466261626},{"_id":"source/_posts/Vue-axios.md","hash":"c4e1e589924c382a4d030132b035ab67bf8c9406","modified":1679465893009},{"_id":"source/_posts/Vue3计算属性.md","hash":"331a76051784ffd319a0fa348d1da26643643d45","modified":1679466296958},{"_id":"source/_posts/Vue3setup函数.md","hash":"5a99771eba4c1e8e86c923f97c4ea72d5b139cf4","modified":1679466458215},{"_id":"source/_posts/Vue3shallowRef和shallowReactive.md","hash":"2c7b130bf844d4fd37029369702ae5a522512897","modified":1679466485076},{"_id":"source/_posts/Hooks.md","hash":"4ef6c59a9b4f45e9f89cda62233b75cd1f2c6817","modified":1679465564044},{"_id":"source/_posts/Vue3toRef和toRefs函数.md","hash":"344c099a678b07278510ccc2e8afd433f7e30ba4","modified":1679466553317},{"_id":"source/_posts/serve的区别.md","hash":"0733fdb48e2b7f8aa524223b77824437e5509be6","modified":1679465694947},{"_id":"source/_posts/vue3.md","hash":"e03f5d8c011902c3b3d718594f3b4f6819a8e73c","modified":1679466275681},{"_id":"source/_posts/vue3ref和reactive函数.md","hash":"e97e58e1d04c70e4ce9cf2a1b4aafd124e2f36ea","modified":1679466395705},{"_id":"source/_posts/Vue3侦听器watch.md","hash":"9c4e356c6e6ccf34d141669d57b3f603a7a38593","modified":1679466329581},{"_id":"source/_posts/vue3API.md","hash":"b571759c2133ae5200274e366c2758f4386c897b","modified":1671439414765},{"_id":"source/_posts/vue3-hooks使用.md","hash":"cd7845d26944f1aa8f4f0533f4cdc04a2cdb0eb1","modified":1679465934484},{"_id":"source/_posts/vue3组件传值.md","hash":"df28158d6a9af93232b0a29fec830bf3a9c6c6d4","modified":1679466344254},{"_id":"source/_posts/vue3新语法细节.md","hash":"875ee34a8dd2422edca574309aad53536522f2a2","modified":1673347396914},{"_id":"source/_posts/webpack.md","hash":"3765b444c60359592c469f01535f15a66fd98f8f","modified":1679466708579},{"_id":"source/_posts/数组，对象遍历的用法总结.md","hash":"5a90469101b19d8e6f8dc59614717a723e0aeefd","modified":1679464991284},{"_id":"source/_posts/component动态组件.md","hash":"43b06979cca9454fa56c8befa316d03553ea2c44","modified":1679722557623},{"_id":"source/_posts/深浅拷贝.md","hash":"17894dce37cd147eeac9b2e78e65b96759d8ea9a","modified":1679465469180},{"_id":"source/read/index-1.md","hash":"3be0a6257633a9710a3454ffa6c87291635f39a7","modified":1666018063679},{"_id":"source/_posts/博客搭建.md","hash":"ba283baafaf06ac1dfd409ad497f708b6e08f3f2","modified":1679465303023},{"_id":"source/_posts/跨域.md","hash":"72fd84a0b769c7402b512d02b98c7058a7630e68","modified":1679465351591},{"_id":"source/tags/index-2.md","hash":"55406461367e0dce63e72043f312df19543b2498","modified":1666018056642},{"_id":"source/tags/index.md","hash":"c75144f3fb0f1c6750341ed39720101dd7142f38","modified":1666077224899},{"_id":"source/tags/.DS_Store","hash":"885d8b08da25d648ce35cc35887fabc2444147c9","modified":1679365349108},{"_id":"source/categories/.DS_Store","hash":"c38d77634d63fb2b6deea02e33e20d7e5132abbb","modified":1679365349110},{"_id":"source/read/.DS_Store","hash":"07352095c3659dec391b783ddd828d361d2c329d","modified":1679365349094},{"_id":"source/categories/index-2.md","hash":"4e35f71a44a133ab89e7fcac8b452a6c34e0a413","modified":1666018049252},{"_id":"source/categories/index.md","hash":"dd3fb2072d660cc7837d2891b26a01f19c554040","modified":1666077224899},{"_id":"source/_posts/Vue3-Pinia使用/安装.png","hash":"b35c38aa5fd70dfbf973a8ecdde913b9fb0f26f8","modified":1666691495687},{"_id":"source/_posts/Vue3-Pinia使用/截图13代码1.png","hash":"7a1368e06c525c2e034dc39142bf844215e99a72","modified":1666708344764},{"_id":"source/_posts/Vue3-Pinia使用/截图14代码.png","hash":"6b88eac576b98e1a0c97c37be505a2357c37a8d2","modified":1666709359717},{"_id":"source/_posts/Vue3-Pinia使用/截图1结果.png","hash":"602355bda5c4ba049b2b60ba7127b34643e7f15a","modified":1666702914491},{"_id":"source/_posts/Vue3setup函数/被点击.png","hash":"08aa117a094790f49408b0072342fa89b4202050","modified":1665643256308},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef代码结果.png","hash":"fd9d5456f4fa5912e8e256c65cfb582e77cd8467","modified":1666179674421},{"_id":"source/_posts/Vue3侦听器watch/侦听器一结果.png","hash":"2c6bd0186ff6e9afe79cc3be6285ebce50004974","modified":1666098668685},{"_id":"source/_posts/Vue3侦听器watch/多个侦听器代码.png","hash":"b6b5ce0a312074c007ca6c87951768a90b2914cd","modified":1666101970941},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref源数据.png","hash":"b0b445fedbc9be175e7039adbc9e601b941e5792","modified":1665756619169},{"_id":"source/_posts/Vue3toRef和toRefs函数/截屏2022-10-17 上午11.27.38.png","hash":"9b77eec67a3fb63a4cabdc29e11105b44eb39b6b","modified":1665977289220},{"_id":"source/_posts/Vue3计算属性/引入.png","hash":"fc352bb0212ecb4617ba425d65c88c0f0e81bb7e","modified":1666008886802},{"_id":"source/_posts/Vue3计算属性/案例二.png","hash":"bca10286752f9a3b70042c26480727bca5366cbc","modified":1666011378423},{"_id":"source/_posts/Vue3计算属性/计算属性求和.png","hash":"3403abc4b3d832e185d1b6602bdfa745a6cf3e70","modified":1666011494713},{"_id":"source/_posts/深浅拷贝/深浅拷贝结果.png","hash":"624d55ea479daf8bcadae7ccbfda13bf0ad17fb0","modified":1661481320994},{"_id":"source/_posts/Vue3-Pinia使用/indexts.png","hash":"8fd0b5d11e9d40dc24ede704ea6da047febbc9ad","modified":1666701836690},{"_id":"source/_posts/Vue3-Pinia使用/截图11结果2.png","hash":"661a128e4433b159d68b13fe236e034ac9d06550","modified":1666707777714},{"_id":"source/_posts/Vue3-Pinia使用/截图11结果1.png","hash":"29749e46e1cdc7c73c671cbb22f006087a91abd0","modified":1666707782602},{"_id":"source/_posts/Vue3-Pinia使用/截图12结果.png","hash":"906013a2fc77c1765c242f82aa8381f783325c37","modified":1666708101268},{"_id":"source/_posts/Vue3-Pinia使用/截图16结果2.png","hash":"2c70beda971e4bb00b1e3113b0a06dfab5eb3943","modified":1666710193214},{"_id":"source/_posts/Vue3-Pinia使用/截图1代码.png","hash":"75e9d7b5009d2fc31abb56fb8b32b4aa02509119","modified":1666702912111},{"_id":"source/_posts/Vue3-Pinia使用/截图2结果.png","hash":"4c6d26bc1876bbc2104a572d580bffecc38d81a0","modified":1666703174570},{"_id":"source/_posts/Vue3-Pinia使用/截图3结果1.png","hash":"3cdc82239094f7501a406b74e88a96eae09c42e7","modified":1666703495990},{"_id":"source/_posts/Vue3-Pinia使用/截图3结果2.png","hash":"06e73c74a04b9800a008496966a3ba7ed566dec9","modified":1666703499276},{"_id":"source/_posts/Vue3-Pinia使用/截图7代码1.png","hash":"d06e170e0c788538fedc9db212c71010173ddf21","modified":1666704822183},{"_id":"source/_posts/Vue3-Pinia使用/截图6结果1.png","hash":"5c41e4182f85564c4423eb1e9e3ea7d54eddc5ef","modified":1666704446098},{"_id":"source/_posts/Vue3-Pinia使用/截图7结果1.png","hash":"08076158cf4abb9ebf08df4b708005d1a91facaa","modified":1666704830109},{"_id":"source/_posts/Vue3-Pinia使用/截图6代码1.png","hash":"748bc17657ce5095cb54750266367126d289982d","modified":1666704438421},{"_id":"source/_posts/Vue3-Pinia使用/截图7结果2.png","hash":"4e3c93ba6f79b3a1d6a3661f055e752890af7ba4","modified":1666704832463},{"_id":"source/_posts/Vue3-Pinia使用/截图6结果2.png","hash":"52ac61cbd93d036519c8fc4db19c370b57951f9d","modified":1666704516186},{"_id":"source/_posts/Vue3setup函数/名称渲染失败.png","hash":"8ac8f3f2485d1000771164a86e07cdebcfdcd57a","modified":1665642113569},{"_id":"source/_posts/Vue3setup函数/基本变量.png","hash":"b63521e989cac21dec73a6a0da721d3ab03ec044","modified":1665646062104},{"_id":"source/_posts/Vue3setup函数/name.png","hash":"b707a7fca8686ac90273234bbc914025085ab45c","modified":1665646155747},{"_id":"source/_posts/Vue3setup函数/点击代码.png","hash":"5e515ea203ff32f9079b05c4896d421f341fbff5","modified":1665646440428},{"_id":"source/_posts/Vue3setup函数/渲染成功.png","hash":"fb63b176ea1fffce2891c61087b95465af4868cd","modified":1665642648976},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef代码.png","hash":"5d8dc074bb0e0ded665af5d195dfc2c50f8bb31c","modified":1666179567509},{"_id":"source/_posts/Vue3toRef和toRefs函数/reactive代码.png","hash":"733615b731fc230b906fe3f86ee50ff92248fe03","modified":1665975575002},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用正常.png","hash":"8db8aa94bb3b5a8200e96359df504f46b23015a3","modified":1665975136686},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs解决代码.png","hash":"1f605f0d5a6d9ddfab7934b0f399dc46f3f81527","modified":1665976047722},{"_id":"source/_posts/vue3-Hooks使用/案例1.png","hash":"41a9ed7307a5ce4974ce055eb2e1aec4ab38eeed","modified":1670575796841},{"_id":"source/_posts/vue3-Hooks使用/案例3.png","hash":"e09d51e285963ee2d4ae41a68ddb4c76ceef621d","modified":1670576655816},{"_id":"source/_posts/vue3-Hooks使用/案例2.png","hash":"c947267b51513a52ee79dda20bb8b7baa65c1e1b","modified":1670576592186},{"_id":"source/_posts/vue3API/案例6.png","hash":"55b29aea1b417c1f15ae0bf897fd764188256158","modified":1671438054538},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象代码.png","hash":"aaf3b834c26a34ea0f2de6d0998f502d337953db","modified":1665751960346},{"_id":"source/_posts/vue3ref和reactive函数/reactive数组处理结果.png","hash":"ab8274bde10d8e21feb91c9802d6179e5bccf62a","modified":1665752533490},{"_id":"source/_posts/vue3ref和reactive函数/ref基本修改成功.png","hash":"ceb47ae8580ab75ea06fd3a49c66af2072a4e868","modified":1665748816398},{"_id":"source/_posts/vue3ref和reactive函数/ref基本出错.png","hash":"89635c08525515948e4b701e8e168f606fff583d","modified":1665747137732},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂数据代码.png","hash":"0024dcd4878f05c8b732c156890bdae8839731b6","modified":1665749107567},{"_id":"source/_posts/vue3ref和reactive函数/ref成功.png","hash":"7a233c69bc9cfa196d7d263578ef9197e4598a76","modified":1665751146623},{"_id":"source/_posts/Hooks/案例1.png","hash":"868897c58cb1fd3493ab0a2e876ee893983fdf3c","modified":1670569657435},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码2.png","hash":"7198042e761f1e68a47ad1f9fbf5a683736ae8d8","modified":1666707770432},{"_id":"source/_posts/Vue3-Pinia使用/截图10结果.png","hash":"87d3a51ace6ec0a9eebbfd938e00cce00965092d","modified":1666705469703},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码.png","hash":"2ff59f992a8f17c65dad9a369925e7df7b80409d","modified":1666706957589},{"_id":"source/_posts/Vue3-Pinia使用/截图10代码.png","hash":"1395fd458a42a930c62ff3ed9ca8667db3cf120e","modified":1666705466792},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码1.png","hash":"3ec7af117e340f99ddac1d8586a3cee26f9bb8a4","modified":1666707764556},{"_id":"source/_posts/Vue3-Pinia使用/截图13结果1.png","hash":"40a3ffe728c745eea28d33e28a6f48051422c103","modified":1666708946816},{"_id":"source/_posts/Vue3-Pinia使用/截图13代码2.png","hash":"f98f2379f7c4f556be5f5e9b56f0e19a63102b93","modified":1666708400826},{"_id":"source/_posts/Vue3-Pinia使用/截图15代码.png","hash":"84dfe56a7e0020a1412adbb9a78ae77f272cc166","modified":1666709494783},{"_id":"source/_posts/Vue3-Pinia使用/截图14结果1.png","hash":"2a6e36d09632bd34d61ebc6736c57b8c18bc8100","modified":1666709362892},{"_id":"source/_posts/Vue3-Pinia使用/截图14结果2.png","hash":"60426c2088b76e54196495c373a04d7035192ce3","modified":1666709365689},{"_id":"source/_posts/Vue3-Pinia使用/截图13结果2.png","hash":"78bb5044555f9d23733854c1c97ded2d2e5ee1a2","modified":1666708944697},{"_id":"source/_posts/Vue3-Pinia使用/截图16结果1.png","hash":"73cb06309c246eca61f38a77a5d336e7fc244804","modified":1666710190350},{"_id":"source/_posts/Vue3-Pinia使用/截图3代码.png","hash":"1bb7dfdcc7fb102c1624f03173784c89c7e470e4","modified":1666703493607},{"_id":"source/_posts/Vue3-Pinia使用/截图2代码.png","hash":"21d9715a07655174901ed7fa05e92153f21a0318","modified":1666703172252},{"_id":"source/_posts/Vue3-Pinia使用/截图6代码2.png","hash":"b089d26856bee996ce18a2708b66fa7fb84099f1","modified":1666704441294},{"_id":"source/_posts/Vue3-Pinia使用/截图5代码.png","hash":"fa51f7613db86bdc4e9ee6d3e3e6353e6ec12f6e","modified":1666703997268},{"_id":"source/_posts/Vue3-Pinia使用/截图4代码.png","hash":"de9e43926f49e658ac346c7b5f591c69283642bf","modified":1666703993388},{"_id":"source/_posts/Vue3-Pinia使用/截图7代码2.png","hash":"919b9d4b0b77d4f9391b459e9659d1473a5e8165","modified":1666704825144},{"_id":"source/_posts/Vue3-Pinia使用/截图8结果.png","hash":"e7aee55a51c443f0c2ae02a6d9da924a45231c74","modified":1666705016549},{"_id":"source/_posts/Vue3-Pinia使用/截图9结果.png","hash":"1696b4942ef8cbc881e72638877c882f2c0d404d","modified":1666705250906},{"_id":"source/_posts/Vue3-Pinia使用/截图9代码.png","hash":"2b5df9557f9f5c9272757b1974d8515693b97251","modified":1666705246405},{"_id":"source/_posts/Vue3-Pinia使用/截图8代码.png","hash":"fe050cc1abc7053ad0e5c6d199f33cc18d9b642c","modified":1666705014422},{"_id":"source/_posts/Vue3setup函数/基本数据类型.png","hash":"14aa8ce4abcacbe2eab03b648c8eaf7d4d0e5ccc","modified":1665642782802},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowReactive一代码结果.png","hash":"460433078d58c9de4ad54624975cc1e6d562b66d","modified":1666179561899},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowReactive一代码.png","hash":"2384d4018de330b2c14cabebd069bc7c806ab037","modified":1666179127063},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef二代码结果.png","hash":"162d280234dad815826b1f9f2225f3f55802f91d","modified":1666180003907},{"_id":"source/_posts/Vue3侦听器watch/侦听器一控制台.png","hash":"f4513cd9a342bf2705efaeb6f185a701da422d8d","modified":1666098664984},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef二代码.png","hash":"1a00d0d541d828513b6603ba56ec15b3a7c46448","modified":1666179833684},{"_id":"source/_posts/Vue3侦听器watch/侦听器一代码.png","hash":"aee51e5ce07b91827da3c4ceb02e06f22e104094","modified":1666097002229},{"_id":"source/_posts/Vue3侦听器watch/侦听器一数据更新代码.png","hash":"8c8cab41984a0ba050a74ad3d08bdafadb78217d","modified":1666099270743},{"_id":"source/_posts/Vue3侦听器watch/侦听器三修改代码.png","hash":"7f386d5c6812c789ff065e17d6f23acea95bbd3e","modified":1666101651151},{"_id":"source/_posts/Vue3侦听器watch/侦听器三代码.png","hash":"5428081fe08ea11be13415e87e0c919a4064a46f","modified":1666101330673},{"_id":"source/_posts/Vue3侦听器watch/侦听器二修改代码.png","hash":"743dbbf2ec1250918c07b89a2a6f96157a4be45b","modified":1666100967568},{"_id":"source/_posts/Vue3侦听器watch/侦听器二代码.png","hash":"b0ad55721871383c18be9eca918260c5e0c84649","modified":1666100722095},{"_id":"source/_posts/Vue3侦听器watch/侦听器监听reactive代码.png","hash":"fdee0cf863b6c1e83d4992b4ed83750484ebccd8","modified":1666099364700},{"_id":"source/_posts/Vue3侦听器watch/侦听多个参数.png","hash":"e67f0b79227b4eb618c86f42c590cd0bb66686f6","modified":1666102062939},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用代码.png","hash":"4546360c27c51682347024e74fb608348ed026de","modified":1665973466829},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用结果.png","hash":"afad00887f811bbbeda91e16efe49c6c225bca5b","modified":1665973729015},{"_id":"source/_posts/Vue3toRef和toRefs函数/ref函数验证代码.png","hash":"06b57eec559530274780610467c6185af5189486","modified":1665757535623},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref代码.png","hash":"243d4d9ca586000df96c11df26d4ccb3a4dd133e","modified":1665755545321},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref修改代码.png","hash":"d2d1bb4ab19341a958738d24f2ab79be6a2938f3","modified":1665756104669},{"_id":"source/_posts/Vue3计算属性/案例一.png","hash":"7a6a042bf4e2e9698ef031a0bf754805abf5d66b","modified":1666011200225},{"_id":"source/_posts/Vue3toRef和toRefs函数/原始数据代码.png","hash":"77aedb1e69bc73ff51201eb308ac8214711cf53c","modified":1665976237422},{"_id":"source/_posts/vue3API/案例11.png","hash":"00fb54237ad8674adf0fe9a9886ad0ab12cd7140","modified":1671438404371},{"_id":"source/_posts/vue3API/案例12.png","hash":"92c620cd017cc7962917b0990a84d396e2edf77c","modified":1671438471064},{"_id":"source/_posts/vue3API/案例23.png","hash":"376426f6680c28e8a963cd0aa50d729e86cbd41e","modified":1671439383144},{"_id":"source/_posts/vue3API/案例3.png","hash":"84df433ef9450983bc6c71613f3ac01ffac88285","modified":1671025794148},{"_id":"source/_posts/vue3API/案例5.png","hash":"792504cf4e2e6b87009b591a8a190f327c7af420","modified":1671025965401},{"_id":"source/_posts/vue3ref和reactive函数/reactive修改代码.png","hash":"050308b60afb877775da196bb9856864dcb95e9a","modified":1665752277960},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象修改结果.png","hash":"304b185a453096c60f6bc15b70a03c1e17499ab9","modified":1665752356156},{"_id":"source/_posts/vue3ref和reactive函数/refdom代码.png","hash":"d554724f5dfe1f8552762b6b05bfc94d5b1ac1a9","modified":1665750828539},{"_id":"source/_posts/vue3ref和reactive函数/reactive数组代码.png","hash":"a93b6d0fabf13f74f0a8cacaec4f717635b4165d","modified":1665752453894},{"_id":"source/_posts/vue3ref和reactive函数/ref修改代码.png","hash":"94d645e54beecb5a81bcf0c220155d82c0cfda3f","modified":1665748503639},{"_id":"source/_posts/vue3ref和reactive函数/ref基本数据类型代码.png","hash":"fb11e49f6916cafa290d6a38bf280c9ff82ed1bc","modified":1665746888129},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂修改代码.png","hash":"054e88cf5c25e8bac9cf48acd7ed2b39a05981af","modified":1665750143955},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂修改代码成功.png","hash":"08ebd64d3de3343d66c318aa43352d08ff71345f","modified":1665750248482},{"_id":"source/_posts/vue3组件传值/子组件三代码.png","hash":"aad7ee1be4d85c10ac39a76070b3089fe2f4ec76","modified":1666321911441},{"_id":"source/_posts/vue3组件传值/子组件二代码.png","hash":"e64bef83b37d6bc0a3551955edb4ca6bf222f430","modified":1666321531738},{"_id":"source/_posts/Hooks/案例2.png","hash":"74b00eebdf721ace661d5a699d5b636935c3e654","modified":1670569677930},{"_id":"source/_posts/Vue3-Pinia使用/截图12代码.png","hash":"60c8cd99311bd5350a1281fbcf9b21a2a376ee4c","modified":1666708026094},{"_id":"source/_posts/Vue3-Pinia使用/截图16代码.png","hash":"099fe0b855e49d6b6edf4314bf92b3fb13c6e6f1","modified":1666710065911},{"_id":"source/_posts/Vue3-Pinia使用/截图15结果1.png","hash":"0f02b5e18b02dfa18bd2ed30c11c32b12583213f","modified":1666709895278},{"_id":"source/_posts/Vue3-Pinia使用/截图15结果2.png","hash":"03cea55f66253ed27722a0557392ee5971ae633b","modified":1666709897986},{"_id":"source/_posts/Vue3-Pinia使用/截图17代码.png","hash":"bc6478049274440c36ce42656644c6992d7f8077","modified":1666710561300},{"_id":"source/_posts/Vue3setup函数/提示找不到.png","hash":"77541a000deff4521d4819fdbab7d2cb8f0b44bc","modified":1665642385082},{"_id":"source/_posts/Vue3setup函数/复杂数据类型.png","hash":"043c0d8faed707cd2a24922078d1ce7bc41f5d11","modified":1665642894853},{"_id":"source/_posts/Vue3侦听器watch/侦听器二修改结果.png","hash":"9d1db9108cd46fc48764fc971d22158633de580a","modified":1666101212068},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref打印body代码.png","hash":"951b46e871a6a1106eb942d67c02cef438b7afdc","modified":1665756758872},{"_id":"source/_posts/vue3API/案例1.png","hash":"3749c2bc0a424c59dc316ffb8e0510dc1b3847cf","modified":1671025643931},{"_id":"source/_posts/serve的区别/npm区别.png","hash":"0df40dee128dd7245a783544b56e69930450f567","modified":1678677491357},{"_id":"source/_posts/vue3API/案例10.png","hash":"b9e08f7edc34dd6002b5289140b170f2ea2a4ff6","modified":1671438339741},{"_id":"source/_posts/vue3API/案例13.png","hash":"b72f3b1639e3e6e240397459b138f234e7731f10","modified":1671438559453},{"_id":"source/_posts/vue3API/案例14.png","hash":"a447452e694c2df7c9654e6152100b8d3ae777fb","modified":1671438689752},{"_id":"source/_posts/vue3API/案例15.png","hash":"30db8e13899164e1e246da2d0214852772bcc2f3","modified":1671438767849},{"_id":"source/_posts/vue3API/案例2.png","hash":"ac45a3b4102467c1661c004290592b5d3079d35e","modified":1671025716824},{"_id":"source/_posts/vue3API/案例7.png","hash":"0f4d27fb25d283beee04662a5b35b20545770fd7","modified":1671438137612},{"_id":"source/_posts/vue3ref和reactive函数/ref基本控制台.png","hash":"791cc971a4d69f5fc87568f6834312180abcb4ea","modified":1665747285406},{"_id":"source/_posts/vue3组件传值/传值后结果.png","hash":"833aa748bd0e3d8a8e51e1ec2f6d726cd269ee8c","modified":1666322038784},{"_id":"source/_posts/vue3ref和reactive函数/ref打印.png","hash":"37e9af7e01bb74f3a6dc89ff6d3cf85303670556","modified":1665751183658},{"_id":"source/_posts/vue3组件传值/传值前结果.png","hash":"a38dabf08a04fc0bcc222c9556cd03206b83a7cd","modified":1666322088828},{"_id":"source/_posts/vue3组件传值/子组件代码.png","hash":"ef8853dad1c2a331a27401ce273378d8f1210783","modified":1666319520515},{"_id":"source/_posts/vue3组件传值/父组件三代码.png","hash":"1f8caea6ab3214aaa2f25a584449d39a573cd2c9","modified":1666321728224},{"_id":"source/_posts/vue3组件传值/父组件二代码.png","hash":"a4b00c42a7da2d0469d17cfe925da35186210aee","modified":1666321442231},{"_id":"source/_posts/vue3组件传值/父组件代码.png","hash":"34be2541e55ce25a0fb2ad42f2e895d9d8d1f9ae","modified":1666319375708},{"_id":"source/_posts/vue3组件传值/祖孙结果.png","hash":"c1cff8de7aad8dadab9a032812f1a856d33b700a","modified":1666321613087},{"_id":"source/_posts/Vue3setup函数/基本数据代码.png","hash":"afb3efec654604c5b0c323213c66b735aca08028","modified":1665646352224},{"_id":"source/_posts/Vue3侦听器watch/侦听器一数据更新.png","hash":"ecc5fde8517d62bc391f4ca2c5cbdd34ad8b805a","modified":1666099058421},{"_id":"source/_posts/Vue3侦听器watch/侦听器三修改结果.png","hash":"cfc6fbc9153515388e84b5450cd41dfa1d0c275c","modified":1666101802283},{"_id":"source/_posts/Vue3侦听器watch/侦听器三报错.png","hash":"e3cf54e20af42c647cf70bb10b8af17f78fb416f","modified":1666101556075},{"_id":"source/_posts/Vue3toRef和toRefs函数/数据源结果.png","hash":"0d52c3a41f898ae79c961c1c8bb2ca23a8535073","modified":1665976762854},{"_id":"source/_posts/vue3API/案例22.png","hash":"02f636d85da47984a2ec2860a6c664289d57040a","modified":1671439309265},{"_id":"source/_posts/vue3API/案例4.png","hash":"d119b34723578142c2cdd06fccc13b1fb53457b0","modified":1671025903773},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂结构.png","hash":"685333b144015b074af204a7d3bdec8689466702","modified":1665749856366},{"_id":"source/_posts/vue3ref和reactive函数/ref结构.png","hash":"c6720f7d16db079b3294d891f3c6fb4ccb1a28ed","modified":1665748368775},{"_id":"source/_posts/Hooks/案例3.png","hash":"c901570618e6953c64d13a679ea0de943644eb31","modified":1670569692526},{"_id":"source/_posts/Vue3setup函数/复杂数据代码.png","hash":"d8108e61fcede23fe8b9448ec9e9b84ca3da2c7c","modified":1665646344619},{"_id":"source/_posts/Vue3侦听器watch/侦听器二警告.png","hash":"b9338963991e5acee941245f5ec14f713282b086","modified":1666100101586},{"_id":"source/_posts/Vue3toRef和toRefs函数/torefbody打印结果.png","hash":"500ade02277e28c474db944ec81f7d431e74a610","modified":1665757063642},{"_id":"source/_posts/vue3API/案例18.png","hash":"0b7a7ab71f0abc719726b990eba397ca86adde87","modified":1671439015007},{"_id":"source/_posts/vue3API/案例16.png","hash":"a47301b5384927cc8ea0732aec08691824e70beb","modified":1671438841004},{"_id":"source/_posts/vue3API/案例17.png","hash":"4946ce1dbfde314a97281cd87b255dc885018083","modified":1671438913991},{"_id":"source/_posts/vue3API/案例19.png","hash":"d7ae2edaea2d3fc2e444e20cbbeef9373083791d","modified":1671439097580},{"_id":"source/_posts/Vue3侦听器watch/侦听器监听reactive结果.png","hash":"880ed1c8fdb504f757f75c7b4e8198fdefce6b37","modified":1666099706287},{"_id":"source/_posts/Vue3侦听器watch/侦听多个参数结果.png","hash":"913b47f951bf57d60c5fbecb648bd5ad1c5f6a2b","modified":1666102380156},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用控制台信息.png","hash":"8d85ef57adbf571c12d510dcebb9d57b4780f962","modified":1665974936031},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref修改结果.png","hash":"77574d2b1b504b0258b096b9c706cc4ec0b86fbe","modified":1665756462928},{"_id":"source/_posts/vue3API/案例20.png","hash":"386c78383d07d79f62f4fe1862f7dbc64b3bbdc9","modified":1671439165883},{"_id":"source/_posts/vue3API/案例21.png","hash":"654ec1438a18111df14f4e7a1973d46e733adc72","modified":1671439233903},{"_id":"source/_posts/vue3API/案例9.png","hash":"3c4b30a0d297cb7f773f1ce7705fe4e0e7adf524","modified":1671438264990},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象结果.png","hash":"1e3d9f9787839ffc062cd7622661ef1a2332f9f4","modified":1665752167565},{"_id":"source/_posts/Vue3toRef和toRefs函数/ref函数验证结果.png","hash":"80ec19fd6debdd3a6fb186dddda2d5bbece3605d","modified":1665757991938},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref页面成功.png","hash":"a8256b128a9d7f9ffb1c85a1ef755c13e0204bef","modified":1665755788777},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1666080703467},{"_id":"source/_posts/Vue3-Pinia使用/截图17结果.png","hash":"6b79e742db256737f7c9b18e9040ee445f9ec13a","modified":1666710564188},{"_id":"themes/fluid/package.json","hash":"167c6a0729a9286a7f508c1dd6a9c689e8799008","modified":1666080703460},{"_id":"themes/fluid/README_en.md","hash":"8c874f309e346fffa392e174385b5cc08510f218","modified":1666080703454},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1666080703454},{"_id":"themes/fluid/_config.yml","hash":"169d74cace417829e4b9dd474a106835580f58e0","modified":1666086480320},{"_id":"themes/fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1666080703454},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1666080703459},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1666080703459},{"_id":"themes/fluid/layout/index.ejs","hash":"db000a6a0cec19d32a6e7e94cd4c478500d9c5ac","modified":1666080703460},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1666080703460},{"_id":"themes/fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1666080703455},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1666080703460},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1666080703460},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1666080703460},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1666080703460},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1666080703460},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1666080703460},{"_id":"themes/fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1666080703460},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1666080703454},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1666080703454},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1666080703454},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1666080703455},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1666080703455},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1666080703455},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1666080703455},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1666080703455},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1666080703455},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1666080703455},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1666080703455},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1666080703455},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1666080703459},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1666080703459},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1666080703468},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1666080703468},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1666080703468},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1666080703468},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1666080703469},{"_id":"themes/fluid/source/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1666080703469},{"_id":"themes/fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1666080703469},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1666080703469},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1666080703469},{"_id":"themes/fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1666080703469},{"_id":"themes/fluid/source/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1666080703469},{"_id":"themes/fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1666080703469},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1666080703460},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1666080703469},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1666080703467},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1666080703467},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1666080703468},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1666080703461},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1666080703461},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1666080703461},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1666080703463},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1666080703463},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1666080703463},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1666080703463},{"_id":"themes/fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1666080703463},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1666080703462},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1666080703462},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1666080703462},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1666080703462},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1666080703462},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1666080703462},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1666080703462},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1666080703467},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1666080703463},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1666080703463},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1666080703462},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1666080703463},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1666080703462},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1666080703462},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1666080703463},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1666080703464},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1666080703464},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1666080703463},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1666080703456},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1666080703457},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"e3713fa78e0fc14a239360b020068d8513573ae4","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"e49506e9895e255e0e53f34a11d325f83109c1b0","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1666080703458},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1666080703459},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1666080703459},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1666080703459},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"9d13392cea94b66d86422ad17c66e5ae67ce1d32","modified":1666080703459},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1666080703461},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1666080703461},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1666080703461},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1666080703461},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"97e003371b76911522fb93c5180c9fdceed29488","modified":1666080703459},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1666080703459},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1666080703461},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1666080703461},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1666080703461},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1666080703459},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1666080703464},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1666080703464},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1666080703467},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1666080703467},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1666080703464},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1666080703464},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1666080703466},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1666080703467},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1666080703467},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1666080703467},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1666080703467},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1666080703467},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1666080703464},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1666080703464},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"0aa512c21a4b74ef2e70009786a1858d7c2fae9c","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1666080703465},{"_id":"source/_posts/vue3组件传值/子传父结果.png","hash":"5eb0fea3922366bba2cc46da6c840413a59e252d","modified":1666320801573},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1666080703465},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1666080703466},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1666080703468},{"_id":"themes/fluid/source/img/defaultl.png","hash":"824077c6c5c3ce49a0d6fecfd6687118b9791267","modified":1666082775907},{"_id":"public/local-search.xml","hash":"cb5fe8929e834ac54d82ab7e36749eb205d48cb3","modified":1679722819432},{"_id":"public/about/index-1.html","hash":"bfc3c887b5a3e81316d3516b998daa98bbfdaabb","modified":1679722819432},{"_id":"public/about/index-2.html","hash":"800b5c71912db8c34ee65ede68cbbc47b8b48551","modified":1679722819432},{"_id":"public/about/index.html","hash":"edfbf8529ec26ba45e2198f6045d9db5e3cf709b","modified":1679722819432},{"_id":"public/categories/index-2.html","hash":"1e2c40a0318f97c3ccf33ff32aa825194de346e8","modified":1679722819432},{"_id":"public/tags/index-2.html","hash":"07da34b67215e9829f1ba551dcd8342b4f59df22","modified":1679722819432},{"_id":"public/tags/index.html","hash":"0485543201d052da1d3c970bd7ff84040b364272","modified":1679722819432},{"_id":"public/read/index-1.html","hash":"1b8330381692f2984b155e9c899ef1496aa6305d","modified":1679722819432},{"_id":"public/categories/vue3/index.html","hash":"02606c3b0c73759d8e91df51a6ba1013571acc1a","modified":1679722819432},{"_id":"public/categories/vue3/page/2/index.html","hash":"afcecc78a60feceb0feb9ad1e8c49cb9527e738d","modified":1679722819432},{"_id":"public/categories/知识点/index.html","hash":"8e0f42517c7091a17d1ec733790539a9dbad760d","modified":1679722819432},{"_id":"public/categories/JavaScript/index.html","hash":"fc18e5b5a952f9bb331d813ce35afb985a1f20c4","modified":1679722819432},{"_id":"public/categories/工具/index.html","hash":"b2d7923d0850ad89b31ae857bdcc09607069de03","modified":1679722819432},{"_id":"public/page/3/index.html","hash":"4f67aac0bff55064609748dbc627a3547012cfa9","modified":1679722819432},{"_id":"public/tags/vue3/page/2/index.html","hash":"27b4a838088176bdffa28d47cac53023315d977d","modified":1679722819432},{"_id":"public/tags/vue/index.html","hash":"54a3b756ad53fa4f6c6a1eb59edfca74960b5f92","modified":1679722819432},{"_id":"public/tags/深浅拷贝/index.html","hash":"c9d991954bdf88c8b605f6724c989588749160a2","modified":1679722819432},{"_id":"public/tags/webpack/index.html","hash":"73cced71d6d346b5ec3a34fe92e831723a1b121b","modified":1679722819432},{"_id":"public/tags/跨域/index.html","hash":"17dfb10b3136f6c4ae6c0f7905a3eda503b0ed2b","modified":1679722819432},{"_id":"public/tags/JavaScript/index.html","hash":"77e21dca5b3f083e662ff9ed84e8c9ca5ca99ccd","modified":1679722819432},{"_id":"public/tags/vue3/index.html","hash":"a6c5d2643d30730c040036190f3c73d76cef2756","modified":1679722819432},{"_id":"public/tags/搭建博客/index.html","hash":"bbc51b02157859f30bda3aa9d3b336b55aad0d54","modified":1679722819432},{"_id":"public/archives/index.html","hash":"a2fea83b0ede4d44159cbf915d66bffc53741d2c","modified":1679722819432},{"_id":"public/archives/page/2/index.html","hash":"979de11e7f6106446318df5a704a190a73b07bf2","modified":1679722819432},{"_id":"public/archives/page/3/index.html","hash":"e750d261ef6477de32dcd8be178d40a0682e2a55","modified":1679722819432},{"_id":"public/archives/2022/page/2/index.html","hash":"e89c5413d9fe6cf4d8624359eaa6f2a793f1e402","modified":1679722819432},{"_id":"public/archives/2022/08/index.html","hash":"c9b68543ff129d583c0ecc1f24664e9985f74c39","modified":1679722819432},{"_id":"public/archives/2022/09/index.html","hash":"7053f004d51869bff0c4224ce826f40683b5a975","modified":1679722819432},{"_id":"public/archives/2022/index.html","hash":"bc3b89493c8c701d680a1211a2b5b83700481c53","modified":1679722819432},{"_id":"public/archives/2022/12/index.html","hash":"3466af953c5f0e11d47ba9c5b09eb97596ac7deb","modified":1679722819432},{"_id":"public/archives/2023/index.html","hash":"e0efa5d183273cabf8c7074b8f4eae56be3153fb","modified":1679722819432},{"_id":"public/archives/2023/03/index.html","hash":"c2efdd08c9eb9d829adb11dcbce57e845b5a335c","modified":1679722819432},{"_id":"public/archives/2023/01/index.html","hash":"083b21b44206481d5a30b091cc21260e9a6145ba","modified":1679722819432},{"_id":"public/404.html","hash":"cc1bcd4de3b390118e5d9d7d0b4d2f441aeddcb6","modified":1679722819432},{"_id":"public/links/index.html","hash":"976a0331d427a4d4c4ede318f6525b20938e30e7","modified":1679722819432},{"_id":"public/archives/2022/10/index.html","hash":"89c17bc0079f612d641f2c2ec9eb09d4bdc15993","modified":1679722819432},{"_id":"public/categories/index.html","hash":"8becd0d825a380b719d10d23f4668e84eb81d3ae","modified":1679722819432},{"_id":"public/2023/03/23/component动态组件/index.html","hash":"f3d874ef3448a0d788ef219ddd16d83b2705406b","modified":1679722819432},{"_id":"public/2023/03/21/数组，对象遍历的用法总结/index.html","hash":"95e869ce1ce6920058d6480319854fca648a49d7","modified":1679722819432},{"_id":"public/2023/03/13/serve的区别/index.html","hash":"5b1fe2036c4787823361efb2b8e8575e30b8663a","modified":1679722819432},{"_id":"public/2023/01/10/vue3新语法细节/index.html","hash":"16bae267dbad973f6d7f85b7434e20fade4cc5f3","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/index.html","hash":"12078867b0a403e8abeebc200814e5349ac9bcaf","modified":1679722819432},{"_id":"public/2022/12/08/Hooks/index.html","hash":"01d4216993937eacf4f65edf22d8a92152dc8d4f","modified":1679722819432},{"_id":"public/2022/12/19/Vue-axios/index.html","hash":"718800d97cf2565a2aaad640707024d9a4bce003","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/index.html","hash":"3a0cf579b64032a2f64bd987100237f1af7d1d67","modified":1679722819432},{"_id":"public/2022/10/25/vue3-hooks使用/index.html","hash":"348af1347f1521c4e0faf733c51b83245be8f077","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/index.html","hash":"0e9b8f20541f9221e935ca65df66e1a65d6a366e","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/index.html","hash":"47af14bd2e795c059e9d49ac658e20ba191e742f","modified":1679722819432},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/index.html","hash":"910116968c6a77f6bebde1850214147941f5b261","modified":1679722819432},{"_id":"public/2022/10/17/Vue3计算属性/index.html","hash":"a0f3c9af809d880b64c398efb28886d230a781f3","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/index.html","hash":"1b3a8400dd97ce25da1362da486f36c1239ddf4c","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/index.html","hash":"7f4926fc6e805675565e9ee209f0ef371dfb807d","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/index.html","hash":"446413ac984647321679b43f80013677ef8ac0ae","modified":1679722819432},{"_id":"public/2022/10/10/vue3/index.html","hash":"6e44a22890eadf46f70d0a811ba93db4994891df","modified":1679722819432},{"_id":"public/2022/08/30/webpack/index.html","hash":"f9b0f7fb6448c5226ea82f46b3fce5fdfb431c28","modified":1679722819432},{"_id":"public/2022/09/30/跨域/index.html","hash":"aec502b4bb01f655d4d4a189ed1ca5079956aca8","modified":1679722819432},{"_id":"public/2022/08/25/深浅拷贝/index.html","hash":"4dcb61572bb62226b7183dcf1d94be7ec52f5af9","modified":1679722819432},{"_id":"public/2022/08/16/博客搭建/index.html","hash":"7e11a4ec88c67581d211ff850a7239565e288e25","modified":1679722819432},{"_id":"public/index.html","hash":"f9d0d1a0276e618bebaa6c0db5b26373a2342a9b","modified":1679722819432},{"_id":"public/page/2/index.html","hash":"e69d9bff38872f1e0e1622a75e441b3626ea1970","modified":1679722819432},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1679722819432},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1679722819432},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1679722819432},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1679722819432},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref源数据.png","hash":"b0b445fedbc9be175e7039adbc9e601b941e5792","modified":1679722819432},{"_id":"public/2022/10/17/Vue3计算属性/引入.png","hash":"fc352bb0212ecb4617ba425d65c88c0f0e81bb7e","modified":1679722819432},{"_id":"public/2022/10/17/Vue3计算属性/案例二.png","hash":"bca10286752f9a3b70042c26480727bca5366cbc","modified":1679722819432},{"_id":"public/2022/10/17/Vue3计算属性/计算属性求和.png","hash":"3403abc4b3d832e185d1b6602bdfa745a6cf3e70","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/截屏2022-10-17 上午11.27.38.png","hash":"9b77eec67a3fb63a4cabdc29e11105b44eb39b6b","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一结果.png","hash":"2c6bd0186ff6e9afe79cc3be6285ebce50004974","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/多个侦听器代码.png","hash":"b6b5ce0a312074c007ca6c87951768a90b2914cd","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/安装.png","hash":"b35c38aa5fd70dfbf973a8ecdde913b9fb0f26f8","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图13代码1.png","hash":"7a1368e06c525c2e034dc39142bf844215e99a72","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图14代码.png","hash":"6b88eac576b98e1a0c97c37be505a2357c37a8d2","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图1结果.png","hash":"602355bda5c4ba049b2b60ba7127b34643e7f15a","modified":1679722819432},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowRef代码结果.png","hash":"fd9d5456f4fa5912e8e256c65cfb582e77cd8467","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/被点击.png","hash":"08aa117a094790f49408b0072342fa89b4202050","modified":1679722819432},{"_id":"public/2022/08/25/深浅拷贝/深浅拷贝结果.png","hash":"624d55ea479daf8bcadae7ccbfda13bf0ad17fb0","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/reactive代码.png","hash":"733615b731fc230b906fe3f86ee50ff92248fe03","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs使用正常.png","hash":"8db8aa94bb3b5a8200e96359df504f46b23015a3","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs解决代码.png","hash":"1f605f0d5a6d9ddfab7934b0f399dc46f3f81527","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/indexts.png","hash":"8fd0b5d11e9d40dc24ede704ea6da047febbc9ad","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11结果1.png","hash":"29749e46e1cdc7c73c671cbb22f006087a91abd0","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图12结果.png","hash":"906013a2fc77c1765c242f82aa8381f783325c37","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11结果2.png","hash":"661a128e4433b159d68b13fe236e034ac9d06550","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图16结果2.png","hash":"2c70beda971e4bb00b1e3113b0a06dfab5eb3943","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图1代码.png","hash":"75e9d7b5009d2fc31abb56fb8b32b4aa02509119","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图2结果.png","hash":"4c6d26bc1876bbc2104a572d580bffecc38d81a0","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图3结果1.png","hash":"3cdc82239094f7501a406b74e88a96eae09c42e7","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图6结果1.png","hash":"5c41e4182f85564c4423eb1e9e3ea7d54eddc5ef","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图7代码1.png","hash":"d06e170e0c788538fedc9db212c71010173ddf21","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图3结果2.png","hash":"06e73c74a04b9800a008496966a3ba7ed566dec9","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图6代码1.png","hash":"748bc17657ce5095cb54750266367126d289982d","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图7结果1.png","hash":"08076158cf4abb9ebf08df4b708005d1a91facaa","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图6结果2.png","hash":"52ac61cbd93d036519c8fc4db19c370b57951f9d","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图7结果2.png","hash":"4e3c93ba6f79b3a1d6a3661f055e752890af7ba4","modified":1679722819432},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowRef代码.png","hash":"5d8dc074bb0e0ded665af5d195dfc2c50f8bb31c","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/名称渲染失败.png","hash":"8ac8f3f2485d1000771164a86e07cdebcfdcd57a","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/name.png","hash":"b707a7fca8686ac90273234bbc914025085ab45c","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/基本变量.png","hash":"b63521e989cac21dec73a6a0da721d3ab03ec044","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/渲染成功.png","hash":"fb63b176ea1fffce2891c61087b95465af4868cd","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive对象代码.png","hash":"aaf3b834c26a34ea0f2de6d0998f502d337953db","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/点击代码.png","hash":"5e515ea203ff32f9079b05c4896d421f341fbff5","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref基本修改成功.png","hash":"ceb47ae8580ab75ea06fd3a49c66af2072a4e868","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive数组处理结果.png","hash":"ab8274bde10d8e21feb91c9802d6179e5bccf62a","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref基本出错.png","hash":"89635c08525515948e4b701e8e168f606fff583d","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref复杂数据代码.png","hash":"0024dcd4878f05c8b732c156890bdae8839731b6","modified":1679722819432},{"_id":"public/2022/10/25/vue3-hooks使用/案例2.png","hash":"c947267b51513a52ee79dda20bb8b7baa65c1e1b","modified":1679722819432},{"_id":"public/2022/10/25/vue3-hooks使用/案例1.png","hash":"41a9ed7307a5ce4974ce055eb2e1aec4ab38eeed","modified":1679722819432},{"_id":"public/2022/10/25/vue3-hooks使用/案例3.png","hash":"e09d51e285963ee2d4ae41a68ddb4c76ceef621d","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref成功.png","hash":"7a233c69bc9cfa196d7d263578ef9197e4598a76","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例6.png","hash":"55b29aea1b417c1f15ae0bf897fd764188256158","modified":1679722819432},{"_id":"public/2022/12/08/Hooks/案例1.png","hash":"868897c58cb1fd3493ab0a2e876ee893983fdf3c","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs使用代码.png","hash":"4546360c27c51682347024e74fb608348ed026de","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs使用结果.png","hash":"afad00887f811bbbeda91e16efe49c6c225bca5b","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/ref函数验证代码.png","hash":"06b57eec559530274780610467c6185af5189486","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref代码.png","hash":"243d4d9ca586000df96c11df26d4ccb3a4dd133e","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref修改代码.png","hash":"d2d1bb4ab19341a958738d24f2ab79be6a2938f3","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/原始数据代码.png","hash":"77aedb1e69bc73ff51201eb308ac8214711cf53c","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一控制台.png","hash":"f4513cd9a342bf2705efaeb6f185a701da422d8d","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一代码.png","hash":"aee51e5ce07b91827da3c4ceb02e06f22e104094","modified":1679722819432},{"_id":"public/2022/10/17/Vue3计算属性/案例一.png","hash":"7a6a042bf4e2e9698ef031a0bf754805abf5d66b","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一数据更新代码.png","hash":"8c8cab41984a0ba050a74ad3d08bdafadb78217d","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器三代码.png","hash":"5428081fe08ea11be13415e87e0c919a4064a46f","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器三修改代码.png","hash":"7f386d5c6812c789ff065e17d6f23acea95bbd3e","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器二代码.png","hash":"b0ad55721871383c18be9eca918260c5e0c84649","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器二修改代码.png","hash":"743dbbf2ec1250918c07b89a2a6f96157a4be45b","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器监听reactive代码.png","hash":"fdee0cf863b6c1e83d4992b4ed83750484ebccd8","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听多个参数.png","hash":"e67f0b79227b4eb618c86f42c590cd0bb66686f6","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图10代码.png","hash":"1395fd458a42a930c62ff3ed9ca8667db3cf120e","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图10结果.png","hash":"87d3a51ace6ec0a9eebbfd938e00cce00965092d","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11代码1.png","hash":"3ec7af117e340f99ddac1d8586a3cee26f9bb8a4","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11代码2.png","hash":"7198042e761f1e68a47ad1f9fbf5a683736ae8d8","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图11代码.png","hash":"2ff59f992a8f17c65dad9a369925e7df7b80409d","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图13结果1.png","hash":"40a3ffe728c745eea28d33e28a6f48051422c103","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图13代码2.png","hash":"f98f2379f7c4f556be5f5e9b56f0e19a63102b93","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图14结果1.png","hash":"2a6e36d09632bd34d61ebc6736c57b8c18bc8100","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图15代码.png","hash":"84dfe56a7e0020a1412adbb9a78ae77f272cc166","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图13结果2.png","hash":"78bb5044555f9d23733854c1c97ded2d2e5ee1a2","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图14结果2.png","hash":"60426c2088b76e54196495c373a04d7035192ce3","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图16结果1.png","hash":"73cb06309c246eca61f38a77a5d336e7fc244804","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图3代码.png","hash":"1bb7dfdcc7fb102c1624f03173784c89c7e470e4","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图2代码.png","hash":"21d9715a07655174901ed7fa05e92153f21a0318","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图6代码2.png","hash":"b089d26856bee996ce18a2708b66fa7fb84099f1","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图4代码.png","hash":"de9e43926f49e658ac346c7b5f591c69283642bf","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图7代码2.png","hash":"919b9d4b0b77d4f9391b459e9659d1473a5e8165","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图5代码.png","hash":"fa51f7613db86bdc4e9ee6d3e3e6353e6ec12f6e","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图8结果.png","hash":"e7aee55a51c443f0c2ae02a6d9da924a45231c74","modified":1679722819432},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowReactive一代码结果.png","hash":"460433078d58c9de4ad54624975cc1e6d562b66d","modified":1679722819432},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowRef二代码.png","hash":"1a00d0d541d828513b6603ba56ec15b3a7c46448","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图9代码.png","hash":"2b5df9557f9f5c9272757b1974d8515693b97251","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图9结果.png","hash":"1696b4942ef8cbc881e72638877c882f2c0d404d","modified":1679722819432},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowReactive一代码.png","hash":"2384d4018de330b2c14cabebd069bc7c806ab037","modified":1679722819432},{"_id":"public/2022/10/19/Vue3shallowRef和shallowReactive/shallowRef二代码结果.png","hash":"162d280234dad815826b1f9f2225f3f55802f91d","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图8代码.png","hash":"fe050cc1abc7053ad0e5c6d199f33cc18d9b642c","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/基本数据类型.png","hash":"14aa8ce4abcacbe2eab03b648c8eaf7d4d0e5ccc","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive修改代码.png","hash":"050308b60afb877775da196bb9856864dcb95e9a","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive对象修改结果.png","hash":"304b185a453096c60f6bc15b70a03c1e17499ab9","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive数组代码.png","hash":"a93b6d0fabf13f74f0a8cacaec4f717635b4165d","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/refdom代码.png","hash":"d554724f5dfe1f8552762b6b05bfc94d5b1ac1a9","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref修改代码.png","hash":"94d645e54beecb5a81bcf0c220155d82c0cfda3f","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref基本数据类型代码.png","hash":"fb11e49f6916cafa290d6a38bf280c9ff82ed1bc","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref复杂修改代码.png","hash":"054e88cf5c25e8bac9cf48acd7ed2b39a05981af","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref复杂修改代码成功.png","hash":"08ebd64d3de3343d66c318aa43352d08ff71345f","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例11.png","hash":"00fb54237ad8674adf0fe9a9886ad0ab12cd7140","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例12.png","hash":"92c620cd017cc7962917b0990a84d396e2edf77c","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例23.png","hash":"376426f6680c28e8a963cd0aa50d729e86cbd41e","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例5.png","hash":"792504cf4e2e6b87009b591a8a190f327c7af420","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例3.png","hash":"84df433ef9450983bc6c71613f3ac01ffac88285","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/子组件三代码.png","hash":"aad7ee1be4d85c10ac39a76070b3089fe2f4ec76","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/子组件二代码.png","hash":"e64bef83b37d6bc0a3551955edb4ca6bf222f430","modified":1679722819432},{"_id":"public/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1679722819432},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1679722819432},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1679722819432},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1679722819432},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1679722819432},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1679722819432},{"_id":"public/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1679722819432},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1679722819432},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1679722819432},{"_id":"public/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1679722819432},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1679722819432},{"_id":"public/css/main.css","hash":"d3b6eb3ef0e222271f1453d3d1214f3ba053792d","modified":1679722819432},{"_id":"public/2022/12/08/Hooks/案例2.png","hash":"74b00eebdf721ace661d5a699d5b636935c3e654","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref打印body代码.png","hash":"951b46e871a6a1106eb942d67c02cef438b7afdc","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器二修改结果.png","hash":"9d1db9108cd46fc48764fc971d22158633de580a","modified":1679722819432},{"_id":"public/2023/03/13/serve的区别/npm区别.png","hash":"0df40dee128dd7245a783544b56e69930450f567","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图15结果1.png","hash":"0f02b5e18b02dfa18bd2ed30c11c32b12583213f","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图15结果2.png","hash":"03cea55f66253ed27722a0557392ee5971ae633b","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图12代码.png","hash":"60c8cd99311bd5350a1281fbcf9b21a2a376ee4c","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图17代码.png","hash":"bc6478049274440c36ce42656644c6992d7f8077","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图16代码.png","hash":"099fe0b855e49d6b6edf4314bf92b3fb13c6e6f1","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/复杂数据类型.png","hash":"043c0d8faed707cd2a24922078d1ce7bc41f5d11","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/提示找不到.png","hash":"77541a000deff4521d4819fdbab7d2cb8f0b44bc","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref基本控制台.png","hash":"791cc971a4d69f5fc87568f6834312180abcb4ea","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref打印.png","hash":"37e9af7e01bb74f3a6dc89ff6d3cf85303670556","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例1.png","hash":"3749c2bc0a424c59dc316ffb8e0510dc1b3847cf","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例13.png","hash":"b72f3b1639e3e6e240397459b138f234e7731f10","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例14.png","hash":"a447452e694c2df7c9654e6152100b8d3ae777fb","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例10.png","hash":"b9e08f7edc34dd6002b5289140b170f2ea2a4ff6","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例15.png","hash":"30db8e13899164e1e246da2d0214852772bcc2f3","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例2.png","hash":"ac45a3b4102467c1661c004290592b5d3079d35e","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例7.png","hash":"0f4d27fb25d283beee04662a5b35b20545770fd7","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/传值前结果.png","hash":"a38dabf08a04fc0bcc222c9556cd03206b83a7cd","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/传值后结果.png","hash":"833aa748bd0e3d8a8e51e1ec2f6d726cd269ee8c","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/子组件代码.png","hash":"ef8853dad1c2a331a27401ce273378d8f1210783","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/父组件三代码.png","hash":"1f8caea6ab3214aaa2f25a584449d39a573cd2c9","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/父组件二代码.png","hash":"a4b00c42a7da2d0469d17cfe925da35186210aee","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/父组件代码.png","hash":"34be2541e55ce25a0fb2ad42f2e895d9d8d1f9ae","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/祖孙结果.png","hash":"c1cff8de7aad8dadab9a032812f1a856d33b700a","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/数据源结果.png","hash":"0d52c3a41f898ae79c961c1c8bb2ca23a8535073","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器一数据更新.png","hash":"ecc5fde8517d62bc391f4ca2c5cbdd34ad8b805a","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器三报错.png","hash":"e3cf54e20af42c647cf70bb10b8af17f78fb416f","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器三修改结果.png","hash":"cfc6fbc9153515388e84b5450cd41dfa1d0c275c","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/基本数据代码.png","hash":"afb3efec654604c5b0c323213c66b735aca08028","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref结构.png","hash":"c6720f7d16db079b3294d891f3c6fb4ccb1a28ed","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/ref复杂结构.png","hash":"685333b144015b074af204a7d3bdec8689466702","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例22.png","hash":"02f636d85da47984a2ec2860a6c664289d57040a","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例4.png","hash":"d119b34723578142c2cdd06fccc13b1fb53457b0","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/torefbody打印结果.png","hash":"500ade02277e28c474db944ec81f7d431e74a610","modified":1679722819432},{"_id":"public/2022/12/08/Hooks/案例3.png","hash":"c901570618e6953c64d13a679ea0de943644eb31","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器二警告.png","hash":"b9338963991e5acee941245f5ec14f713282b086","modified":1679722819432},{"_id":"public/2022/10/13/Vue3setup函数/复杂数据代码.png","hash":"d8108e61fcede23fe8b9448ec9e9b84ca3da2c7c","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例16.png","hash":"a47301b5384927cc8ea0732aec08691824e70beb","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例18.png","hash":"0b7a7ab71f0abc719726b990eba397ca86adde87","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例17.png","hash":"4946ce1dbfde314a97281cd87b255dc885018083","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例19.png","hash":"d7ae2edaea2d3fc2e444e20cbbeef9373083791d","modified":1679722819432},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/refs使用控制台信息.png","hash":"8d85ef57adbf571c12d510dcebb9d57b4780f962","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref修改结果.png","hash":"77574d2b1b504b0258b096b9c706cc4ec0b86fbe","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听器监听reactive结果.png","hash":"880ed1c8fdb504f757f75c7b4e8198fdefce6b37","modified":1679722819432},{"_id":"public/2022/10/18/Vue3侦听器watch/侦听多个参数结果.png","hash":"913b47f951bf57d60c5fbecb648bd5ad1c5f6a2b","modified":1679722819432},{"_id":"public/2022/10/13/vue3ref和reactive函数/reactive对象结果.png","hash":"1e3d9f9787839ffc062cd7622661ef1a2332f9f4","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例21.png","hash":"654ec1438a18111df14f4e7a1973d46e733adc72","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例20.png","hash":"386c78383d07d79f62f4fe1862f7dbc64b3bbdc9","modified":1679722819432},{"_id":"public/2022/12/13/vue3API/案例9.png","hash":"3c4b30a0d297cb7f773f1ce7705fe4e0e7adf524","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/ref函数验证结果.png","hash":"80ec19fd6debdd3a6fb186dddda2d5bbece3605d","modified":1679722819432},{"_id":"public/2022/10/14/Vue3toRef和toRefs函数/toref页面成功.png","hash":"a8256b128a9d7f9ffb1c85a1ef755c13e0204bef","modified":1679722819432},{"_id":"public/2022/10/24/Vue3-Pinia使用/截图17结果.png","hash":"6b79e742db256737f7c9b18e9040ee445f9ec13a","modified":1679722819432},{"_id":"public/2022/10/20/vue3组件传值/子传父结果.png","hash":"5eb0fea3922366bba2cc46da6c840413a59e252d","modified":1679722819432},{"_id":"public/img/defaultl.png","hash":"824077c6c5c3ce49a0d6fecfd6687118b9791267","modified":1679722819432}],"Category":[{"name":"vue3","_id":"clfnjliq000047et82abv30ch"},{"name":"知识点","_id":"clfnjliqd000t7et84qn60a2u"},{"name":"JavaScript","_id":"clfnjliqo00237et8epf60ll9"},{"name":"工具","_id":"clfnjliqq00277et8e2wx7q76"}],"Data":[],"Page":[{"title":"about","date":"2022-10-17T14:47:50.000Z","_content":"","source":"about/index-1.md","raw":"---\ntitle: about\ndate: 2022-10-17 22:47:50\n---\n","updated":"2022-10-17T14:47:50.017Z","path":"about/index-1.html","comments":1,"layout":"page","_id":"clfnjlipo00007et878degpte","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2022-10-18T08:16:46.000Z","layout":"about","_content":"","source":"about/index-2.md","raw":"---\ntitle: about\ndate: 2022-10-18 16:16:46\nlayout: about\n---\n","updated":"2022-10-18T08:17:34.076Z","path":"about/index-2.html","comments":1,"_id":"clfnjlipv00027et81e57agiz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"read","date":"2022-10-17T14:47:43.000Z","_content":"","source":"read/index-1.md","raw":"---\ntitle: read\ndate: 2022-10-17 22:47:43\n---\n","updated":"2022-10-17T14:47:43.679Z","path":"read/index-1.html","comments":1,"layout":"page","_id":"clfnjliq200067et859hv48nn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2022-10-17T14:47:29.000Z","_content":"","source":"categories/index-2.md","raw":"---\ntitle: categories\ndate: 2022-10-17 22:47:29\n---\n","updated":"2022-10-17T14:47:29.252Z","path":"categories/index-2.html","comments":1,"layout":"page","_id":"clfnjliq300087et81by9bvqg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2022-10-17T14:32:08.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-10-17 22:32:08\n---\n","updated":"2022-10-17T14:32:08.603Z","path":"about/index.html","comments":1,"layout":"page","_id":"clfnjliq3000a7et8g8o0cc8n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2022-08-16T13:46:58.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2022-08-16 21:46:58\n---\n","updated":"2022-10-18T07:13:44.899Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clfnjliq7000f7et82agj4p6q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2022-08-16T13:47:07.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-08-16 21:47:07\n---\n","updated":"2022-10-18T07:13:44.899Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clfnjliqa000i7et83og94d5b","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2022-10-17T14:47:36.000Z","_content":"","source":"tags/index-2.md","raw":"---\ntitle: tags\ndate: 2022-10-17 22:47:36\n---\n","updated":"2022-10-17T14:47:36.642Z","path":"tags/index-2.html","comments":1,"layout":"page","_id":"clfnjliqb000o7et894nv8994","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hooks","date":"2022-12-08T13:22:28.000Z","_content":"# 1、为什么要封装 Hooks ？\n众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。\n我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。\n## 你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\n这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。\n但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。\n## 哪什么是Hooks封装呢？\nHooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。\n# 2、如何封装 Hooks 呢？\n首先我们要在setup 组合的开发模式下，\n然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，\n提取到一个以 use* 开头的自定义函数中去。\n## 把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？\n其一享受到封装带来的便利性，还有利于代码逻辑的复用。\n其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。\n# 3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：\n一种是功能类Hooks，即为了逻辑复用的封装；\n另一种是业务类Hooks，即为了逻辑解耦的封装。\n下面我给两组代码，说明这两种使用场景。\n# 4、示例：功能类 Hooks封装\n![](案例1.png)\n# 5、示例：业务类 Hooks封装\n![](案例2.png)\n## 封装Hooks不能为了封装而封装。要考虑以下几点：\n1. 是否有复用的价值？\n2. 是否有利于逻辑的分离？\n3. 是否有助提升代码的可阅读性和可维护性？\n\n\n\n\n","source":"_posts/Hooks.md","raw":"---\ntitle: Hooks\ndate: 2022-12-08 21:22:28\ntags: vue3\ncategories: vue3\n---\n# 1、为什么要封装 Hooks ？\n众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。\n我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。\n## 你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\n这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。\n但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。\n## 哪什么是Hooks封装呢？\nHooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。\n# 2、如何封装 Hooks 呢？\n首先我们要在setup 组合的开发模式下，\n然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，\n提取到一个以 use* 开头的自定义函数中去。\n## 把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？\n其一享受到封装带来的便利性，还有利于代码逻辑的复用。\n其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。\n# 3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：\n一种是功能类Hooks，即为了逻辑复用的封装；\n另一种是业务类Hooks，即为了逻辑解耦的封装。\n下面我给两组代码，说明这两种使用场景。\n# 4、示例：功能类 Hooks封装\n![](案例1.png)\n# 5、示例：业务类 Hooks封装\n![](案例2.png)\n## 封装Hooks不能为了封装而封装。要考虑以下几点：\n1. 是否有复用的价值？\n2. 是否有利于逻辑的分离？\n3. 是否有助提升代码的可阅读性和可维护性？\n\n\n\n\n","slug":"Hooks","published":1,"updated":"2023-03-22T06:12:44.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjlipr00017et86k6k4djw","content":"<h1 id=\"1、为什么要封装-Hooks-？\"><a href=\"#1、为什么要封装-Hooks-？\" class=\"headerlink\" title=\"1、为什么要封装 Hooks ？\"></a>1、为什么要封装 Hooks ？</h1><p>众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。<br>我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。</p>\n<h2 id=\"你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\"><a href=\"#你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\" class=\"headerlink\" title=\"你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\"></a>你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？</h2><p>这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。<br>但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。</p>\n<h2 id=\"哪什么是Hooks封装呢？\"><a href=\"#哪什么是Hooks封装呢？\" class=\"headerlink\" title=\"哪什么是Hooks封装呢？\"></a>哪什么是Hooks封装呢？</h2><p>Hooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。</p>\n<h1 id=\"2、如何封装-Hooks-呢？\"><a href=\"#2、如何封装-Hooks-呢？\" class=\"headerlink\" title=\"2、如何封装 Hooks 呢？\"></a>2、如何封装 Hooks 呢？</h1><p>首先我们要在setup 组合的开发模式下，<br>然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，<br>提取到一个以 use* 开头的自定义函数中去。</p>\n<h2 id=\"把它封装在以use-开头的Hooks函数中，有什么样的好处呢？\"><a href=\"#把它封装在以use-开头的Hooks函数中，有什么样的好处呢？\" class=\"headerlink\" title=\"把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？\"></a>把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？</h2><p>其一享受到封装带来的便利性，还有利于代码逻辑的复用。<br>其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。</p>\n<h1 id=\"3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：\"><a href=\"#3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：\" class=\"headerlink\" title=\"3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：\"></a>3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：</h1><p>一种是功能类Hooks，即为了逻辑复用的封装；<br>另一种是业务类Hooks，即为了逻辑解耦的封装。<br>下面我给两组代码，说明这两种使用场景。</p>\n<h1 id=\"4、示例：功能类-Hooks封装\"><a href=\"#4、示例：功能类-Hooks封装\" class=\"headerlink\" title=\"4、示例：功能类 Hooks封装\"></a>4、示例：功能类 Hooks封装</h1><p><img src=\"/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B1.png\"></p>\n<h1 id=\"5、示例：业务类-Hooks封装\"><a href=\"#5、示例：业务类-Hooks封装\" class=\"headerlink\" title=\"5、示例：业务类 Hooks封装\"></a>5、示例：业务类 Hooks封装</h1><p><img src=\"/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B2.png\"></p>\n<h2 id=\"封装Hooks不能为了封装而封装。要考虑以下几点：\"><a href=\"#封装Hooks不能为了封装而封装。要考虑以下几点：\" class=\"headerlink\" title=\"封装Hooks不能为了封装而封装。要考虑以下几点：\"></a>封装Hooks不能为了封装而封装。要考虑以下几点：</h2><ol>\n<li>是否有复用的价值？</li>\n<li>是否有利于逻辑的分离？</li>\n<li>是否有助提升代码的可阅读性和可维护性？</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、为什么要封装-Hooks-？\"><a href=\"#1、为什么要封装-Hooks-？\" class=\"headerlink\" title=\"1、为什么要封装 Hooks ？\"></a>1、为什么要封装 Hooks ？</h1><p>众所周知，在Vue2中，同一个.vue组件中，如果 data、methods、computed、watch 的体量较大，那么我们的代码就会显得很臃肿。<br>我们应该怎么解决这个问题呢？解决代码臃肿的问题，除了拆分组件，还是拆分组件。</p>\n<h2 id=\"你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\"><a href=\"#你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\" class=\"headerlink\" title=\"你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？\"></a>你会不会好奇，在Vue3中是否会出现同样的问题呢？又是怎么解决的呢？</h2><p>这个问题的答案是肯定存在同样的问题，Vue3中，每当我们的组件变得更大的时候，逻辑关注点就越多，这样就更不利于我们对组件的理解和阅读。<br>但是与Vue2不同的一点是，在Vue3中，我们除了通过拆分组件的方法来解决代码臃肿，还可以使用Hooks封装来解决这一问题。</p>\n<h2 id=\"哪什么是Hooks封装呢？\"><a href=\"#哪什么是Hooks封装呢？\" class=\"headerlink\" title=\"哪什么是Hooks封装呢？\"></a>哪什么是Hooks封装呢？</h2><p>Hooks封装，就是把不同的逻辑关注点抽离出来，以达到业务逻辑的独立性。这也是Vue3 对比Vue2的最大亮点之一。</p>\n<h1 id=\"2、如何封装-Hooks-呢？\"><a href=\"#2、如何封装-Hooks-呢？\" class=\"headerlink\" title=\"2、如何封装 Hooks 呢？\"></a>2、如何封装 Hooks 呢？</h1><p>首先我们要在setup 组合的开发模式下，<br>然后把具体某个业务功能所用到的 ref、reactive、watch、computed、watchEffect 等，<br>提取到一个以 use* 开头的自定义函数中去。</p>\n<h2 id=\"把它封装在以use-开头的Hooks函数中，有什么样的好处呢？\"><a href=\"#把它封装在以use-开头的Hooks函数中，有什么样的好处呢？\" class=\"headerlink\" title=\"把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？\"></a>把它封装在以use* 开头的Hooks函数中，有什么样的好处呢？</h2><p>其一享受到封装带来的便利性，还有利于代码逻辑的复用。<br>其二Hooks函数有一个特点，被复用时可以保持作用域的独立性，即：同一个Hooks函数被多次复用，彼此是不干扰的。</p>\n<h1 id=\"3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：\"><a href=\"#3、在哪些情况下需要封装-Hooks呢？我总结了两种场景：\" class=\"headerlink\" title=\"3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：\"></a>3、在哪些情况下需要封装 Hooks呢？我总结了两种场景：</h1><p>一种是功能类Hooks，即为了逻辑复用的封装；<br>另一种是业务类Hooks，即为了逻辑解耦的封装。<br>下面我给两组代码，说明这两种使用场景。</p>\n<h1 id=\"4、示例：功能类-Hooks封装\"><a href=\"#4、示例：功能类-Hooks封装\" class=\"headerlink\" title=\"4、示例：功能类 Hooks封装\"></a>4、示例：功能类 Hooks封装</h1><p><img src=\"/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B1.png\"></p>\n<h1 id=\"5、示例：业务类-Hooks封装\"><a href=\"#5、示例：业务类-Hooks封装\" class=\"headerlink\" title=\"5、示例：业务类 Hooks封装\"></a>5、示例：业务类 Hooks封装</h1><p><img src=\"/2022/12/08/Hooks/%E6%A1%88%E4%BE%8B2.png\"></p>\n<h2 id=\"封装Hooks不能为了封装而封装。要考虑以下几点：\"><a href=\"#封装Hooks不能为了封装而封装。要考虑以下几点：\" class=\"headerlink\" title=\"封装Hooks不能为了封装而封装。要考虑以下几点：\"></a>封装Hooks不能为了封装而封装。要考虑以下几点：</h2><ol>\n<li>是否有复用的价值？</li>\n<li>是否有利于逻辑的分离？</li>\n<li>是否有助提升代码的可阅读性和可维护性？</li>\n</ol>\n"},{"title":"Vue3toRef和toRefs函数","date":"2022-10-14T13:48:21.000Z","_content":"# toRef 函数\n我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？\n\n首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。\n什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。\n但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。\n\n# toRef 函数使用\n## 首先呢， toRef 函数有两个参数\ntoRef(操作对象, 对象属性)\n## 接下来我们使用 toRef 函数写一个案例\n![](toref代码.png)\n![](toref页面成功.png)\n\n我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。\n![](toref修改代码.png)\n然后点击按钮看一下页面效果\n![](toref修改结果.png)\n\n通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。\n这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。\n![](toref源数据.png)\n\ntoRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。\n所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。\n![](toref打印body代码.png)\n\n刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象\n![](torefbody打印结果.png)\n发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。\n记住了！\ntoRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。\n\n# ref 函数验证\n那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下\n![](ref函数验证代码.png)\n刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图\n![](ref函数验证结果.png)\n所以再记住！\nref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新\n\n# toRefs 函数\ntoRefs 函数的使用呢，其实和 toRef 函数类似。\ntoRefs 函数用于批量设置多个数据为响应式数据。\ntoRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。\ntoRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。\n\n# toRefs 函数使用\n![](refs使用代码.png)\n![](refs使用结果.png)\n![](refs使用控制台信息.png)\n修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value\n![](修改代码.png)\n查看效果\n![](refs使用正常.png)\n现在可以看到数据显示正常啦！\n这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？\n这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。\n![](reactive代码.png)\n我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。\n![](refs使用正常.png)\n我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？\n其实是有原因的。\n其实 toRefs 函数最大的用处在这里！\n我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。\n![](refs解决代码.png)\n在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。\n![](refs使用正常.png)\n但是呢，深层次的对象依旧需要通过点来实现。\n也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。\n记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。\n看下面代码：\n![](原始数据代码.png)\n![](数据源结果.png)\n从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。\n\n# 总结\n如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。\n如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。\ntoRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。\n\n\n\n\n\n","source":"_posts/Vue3toRef和toRefs函数.md","raw":"---\ntitle: Vue3toRef和toRefs函数\ndate: 2022-10-14 21:48:21\ntags: vue3\ncategories: vue3\n---\n# toRef 函数\n我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？\n\n首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。\n什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。\n但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。\n\n# toRef 函数使用\n## 首先呢， toRef 函数有两个参数\ntoRef(操作对象, 对象属性)\n## 接下来我们使用 toRef 函数写一个案例\n![](toref代码.png)\n![](toref页面成功.png)\n\n我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。\n![](toref修改代码.png)\n然后点击按钮看一下页面效果\n![](toref修改结果.png)\n\n通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。\n这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。\n![](toref源数据.png)\n\ntoRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。\n所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。\n![](toref打印body代码.png)\n\n刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象\n![](torefbody打印结果.png)\n发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。\n记住了！\ntoRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。\n\n# ref 函数验证\n那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下\n![](ref函数验证代码.png)\n刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图\n![](ref函数验证结果.png)\n所以再记住！\nref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新\n\n# toRefs 函数\ntoRefs 函数的使用呢，其实和 toRef 函数类似。\ntoRefs 函数用于批量设置多个数据为响应式数据。\ntoRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。\ntoRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。\n\n# toRefs 函数使用\n![](refs使用代码.png)\n![](refs使用结果.png)\n![](refs使用控制台信息.png)\n修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value\n![](修改代码.png)\n查看效果\n![](refs使用正常.png)\n现在可以看到数据显示正常啦！\n这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？\n这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。\n![](reactive代码.png)\n我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。\n![](refs使用正常.png)\n我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？\n其实是有原因的。\n其实 toRefs 函数最大的用处在这里！\n我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。\n![](refs解决代码.png)\n在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。\n![](refs使用正常.png)\n但是呢，深层次的对象依旧需要通过点来实现。\n也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。\n记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。\n看下面代码：\n![](原始数据代码.png)\n![](数据源结果.png)\n从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。\n\n# 总结\n如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。\n如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。\ntoRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。\n\n\n\n\n\n","slug":"Vue3toRef和toRefs函数","published":1,"updated":"2023-03-22T06:29:13.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjlipx00037et8h40bdccr","content":"<h1 id=\"toRef-函数\"><a href=\"#toRef-函数\" class=\"headerlink\" title=\"toRef 函数\"></a>toRef 函数</h1><p>我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？</p>\n<p>首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。<br>什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。<br>但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>\n<h1 id=\"toRef-函数使用\"><a href=\"#toRef-函数使用\" class=\"headerlink\" title=\"toRef 函数使用\"></a>toRef 函数使用</h1><h2 id=\"首先呢，-toRef-函数有两个参数\"><a href=\"#首先呢，-toRef-函数有两个参数\" class=\"headerlink\" title=\"首先呢， toRef 函数有两个参数\"></a>首先呢， toRef 函数有两个参数</h2><p>toRef(操作对象, 对象属性)</p>\n<h2 id=\"接下来我们使用-toRef-函数写一个案例\"><a href=\"#接下来我们使用-toRef-函数写一个案例\" class=\"headerlink\" title=\"接下来我们使用 toRef 函数写一个案例\"></a>接下来我们使用 toRef 函数写一个案例</h2><p><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E9%A1%B5%E9%9D%A2%E6%88%90%E5%8A%9F.png\"></p>\n<p>我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>然后点击按钮看一下页面效果<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"></p>\n<p>通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。<br>这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%BA%90%E6%95%B0%E6%8D%AE.png\"></p>\n<p>toRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。<br>所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%89%93%E5%8D%B0body%E4%BB%A3%E7%A0%81.png\"></p>\n<p>刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/torefbody%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png\"><br>发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。<br>记住了！<br>toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>\n<h1 id=\"ref-函数验证\"><a href=\"#ref-函数验证\" class=\"headerlink\" title=\"ref 函数验证\"></a>ref 函数验证</h1><p>那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C.png\"><br>所以再记住！<br>ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新</p>\n<h1 id=\"toRefs-函数\"><a href=\"#toRefs-函数\" class=\"headerlink\" title=\"toRefs 函数\"></a>toRefs 函数</h1><p>toRefs 函数的使用呢，其实和 toRef 函数类似。<br>toRefs 函数用于批量设置多个数据为响应式数据。<br>toRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。<br>toRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。</p>\n<h1 id=\"toRefs-函数使用\"><a href=\"#toRefs-函数使用\" class=\"headerlink\" title=\"toRefs 函数使用\"></a>toRefs 函数使用</h1><p><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%A1%E6%81%AF.png\"><br>修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value<br><img src=\"/%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>查看效果<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>现在可以看到数据显示正常啦！<br>这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？<br>这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/reactive%E4%BB%A3%E7%A0%81.png\"><br>我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？<br>其实是有原因的。<br>其实 toRefs 函数最大的用处在这里！<br>我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81.png\"><br>在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>但是呢，深层次的对象依旧需要通过点来实现。<br>也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。<br>记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。<br>看下面代码：<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E6%95%B0%E6%8D%AE%E6%BA%90%E7%BB%93%E6%9E%9C.png\"><br>从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。<br>如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。<br>toRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"toRef-函数\"><a href=\"#toRef-函数\" class=\"headerlink\" title=\"toRef 函数\"></a>toRef 函数</h1><p>我们知道，ref 函数可以创建一个响应式的数据，那 toRef 函数同样也是创建一个响应式的数据，那么它们之间的区别是什么呢？</p>\n<p>首先一点，ref 函数他的本质其实是去拷贝一份数据，脱离了与源数据的交互。<br>什么意思呢？就是 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新。<br>但是 toRefs 函数的本质是引用，也就是说，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>\n<h1 id=\"toRef-函数使用\"><a href=\"#toRef-函数使用\" class=\"headerlink\" title=\"toRef 函数使用\"></a>toRef 函数使用</h1><h2 id=\"首先呢，-toRef-函数有两个参数\"><a href=\"#首先呢，-toRef-函数有两个参数\" class=\"headerlink\" title=\"首先呢， toRef 函数有两个参数\"></a>首先呢， toRef 函数有两个参数</h2><p>toRef(操作对象, 对象属性)</p>\n<h2 id=\"接下来我们使用-toRef-函数写一个案例\"><a href=\"#接下来我们使用-toRef-函数写一个案例\" class=\"headerlink\" title=\"接下来我们使用 toRef 函数写一个案例\"></a>接下来我们使用 toRef 函数写一个案例</h2><p><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E9%A1%B5%E9%9D%A2%E6%88%90%E5%8A%9F.png\"></p>\n<p>我们可以看到数据的结构，在 value 里面直接就是 boy 下面 name 的属性值，所以说，接下来我们编写一个按钮，点击按钮，修改这个 name 值。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>然后点击按钮看一下页面效果<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"></p>\n<p>通过截图展示的效果我们可以发现，boy_toRef 的值确实被修改了，但是呢，页面并没有改变，而且页面也没有出现错误。<br>这是什么原因呢？其实这不是 Bug 哈，在本篇博文开始就说过，toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新，所以说，这就是 toRef 函数的功能。确实，视图没有数据更新我们通过上面的截图看到了，但是源数据修改这个怎么看呢？没关系，在回答这个问题之前，我们首先得知道，什么是源数据。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%BA%90%E6%95%B0%E6%8D%AE.png\"></p>\n<p>toRef 函数将 boy 对象给包裹了起来，所以说，boy 对象就是源数据。<br>所以说，想知道源数据有没有改变，在点击按钮之后，打印一下 boy 对象，看一下 boy 有没有被改变。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/toref%E6%89%93%E5%8D%B0body%E4%BB%A3%E7%A0%81.png\"></p>\n<p>刷新页面，在点击按钮修改 name 值，然后查看一下控制台打印的 boy 对象<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/torefbody%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png\"><br>发现 boy 对象的 name 值已经从 我是wn. 改为 wn.了，但是页面依旧没有更新。<br>记住了！<br>toRef 函数会与源数据交互，修改响应式数据会造成源数据的修改，但是他的修改不会造成视图层数据的更新。</p>\n<h1 id=\"ref-函数验证\"><a href=\"#ref-函数验证\" class=\"headerlink\" title=\"ref 函数验证\"></a>ref 函数验证</h1><p>那 ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新,我们测试一下<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，点击按钮查看页面控制台打印的结果，主要是看一下被 ref 函数包裹后的数据有没有修改成功，源数据有没有修改成功，最后页面有没有修改，下面看截图<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/ref%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C.png\"><br>所以再记住！<br>ref 函数可以将对象里面的属性值变成响应式的数据，修改响应式数据，是不会影响到源数据，但是视图层上的数据会被更新</p>\n<h1 id=\"toRefs-函数\"><a href=\"#toRefs-函数\" class=\"headerlink\" title=\"toRefs 函数\"></a>toRefs 函数</h1><p>toRefs 函数的使用呢，其实和 toRef 函数类似。<br>toRefs 函数用于批量设置多个数据为响应式数据。<br>toRefs 函数与原始数据相交互，修改响应式数据会影响到源数据，但是不会更新视图层。<br>toRefs 函数还可以与其他响应式数据相交互，更加方便处理视图层数据。</p>\n<h1 id=\"toRefs-函数使用\"><a href=\"#toRefs-函数使用\" class=\"headerlink\" title=\"toRefs 函数使用\"></a>toRefs 函数使用</h1><p><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%A1%E6%81%AF.png\"><br>修改一下代码，在渲染的时候除了 .属性 之外，还需要 .value<br><img src=\"/%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>查看效果<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>现在可以看到数据显示正常啦！<br>这时可能会有人有疑问，那这不是越来越复杂了吗？本来直接点属性就可以，现在还得点属性点value，不是多此一举吗？<br>这种复杂结构数据我们完全可以使用 reactive 函数来处理呀，渲染最多点一次就可以，但是 toRefs 函数却需要点两次。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/reactive%E4%BB%A3%E7%A0%81.png\"><br>我们不使用 toRefs 函数，而是用之前说的 reactive 函数处理数据。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>我们可以看到，页面是可以正常解析的，那为什么我们还有舍近求远的使用 toRefs 函数呢？<br>其实是有原因的。<br>其实 toRefs 函数最大的用处在这里！<br>我们这个 boy 对象里面只有两个参数比较少，如果我们这个对象里面有十个参数或者是更多的话，每次展示的时候都得写那么多遍的 boy 点，是不是很麻烦呢？所以说使用 toRefs 函数就可以解决这个问题，看下面的代码。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81.png\"><br>在 return 抛出 reactive 的时候，使用扩展运算符和 toRefs 函数，就可以实现直接写属性的方式展示数据了。<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/refs%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8.png\"><br>但是呢，深层次的对象依旧需要通过点来实现。<br>也许你还有疑问，直接扩展运算 reactive 函数也行啊，为啥要套上 toRefs 函数。<br>记住一点，toRefs 函数修改，原始数据被改变，页面不会被触发。<br>看下面代码：<br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/14/Vue3toRef%E5%92%8CtoRefs%E5%87%BD%E6%95%B0/%E6%95%B0%E6%8D%AE%E6%BA%90%E7%BB%93%E6%9E%9C.png\"><br>从打印结果中可以看出，原始数据被改变，页面没有被触发。但从写法上应该可以注意到，toRefs 返回的对象，随便解、随便构，丝毫不会影响值的响应性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>如果想让响应式数据和以前的数据关联起来，并且想在更新响应式数据的时候不更新视图，那么就使用 toRef 函数。<br>如果希望将对象的多个属性都变成响应式数据，并且要求响应式数据和原始数据关联，并且更新响应式数据的时候不更新视图，就使用 toRefs 函数用于批量设置多个数据为响应式数据。因为 toRef 函数一次仅能设置一个数据。<br>toRefs 函数接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用 toRef 函数执行。</p>\n"},{"title":"Vue3计算属性","date":"2022-10-17T12:06:38.000Z","_content":"# computed 计算属性说明\ncomputed 表示计算属性，通常是用来进行数据处理。\n比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型\n但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。\n计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。\n# 计算属性使用\n首先呢，使用 computed 需要引入\n![](引入.png)\n我们编写一个案例\n![](案例一.png)\n但是有一点需要注意！\n如果我们直接修改计算属性的值会报一个错误！\n![](案例二.png)\n这个意思就是计算属性是只读的不允许修改 \n如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。\n那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。\n![](计算属性求和.png)\n也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。\n# 总结\n1. vue.3.0 中要从vue 按需导入 computed 计算属性。\n2. 如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。\n3. 使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。\n4. 传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。\n5. 只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。\n6. 既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。","source":"_posts/Vue3计算属性.md","raw":"---\ntitle: Vue3计算属性\ndate: 2022-10-17 20:06:38\ntags: vue3\ncategories: vue3\n---\n# computed 计算属性说明\ncomputed 表示计算属性，通常是用来进行数据处理。\n比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型\n但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。\n计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。\n# 计算属性使用\n首先呢，使用 computed 需要引入\n![](引入.png)\n我们编写一个案例\n![](案例一.png)\n但是有一点需要注意！\n如果我们直接修改计算属性的值会报一个错误！\n![](案例二.png)\n这个意思就是计算属性是只读的不允许修改 \n如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。\n那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。\n![](计算属性求和.png)\n也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。\n# 总结\n1. vue.3.0 中要从vue 按需导入 computed 计算属性。\n2. 如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。\n3. 使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。\n4. 传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。\n5. 只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。\n6. 既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。","slug":"Vue3计算属性","published":1,"updated":"2023-03-22T06:24:56.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliq200077et8d31abbko","content":"<h1 id=\"computed-计算属性说明\"><a href=\"#computed-计算属性说明\" class=\"headerlink\" title=\"computed 计算属性说明\"></a>computed 计算属性说明</h1><p>computed 表示计算属性，通常是用来进行数据处理。<br>比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型<br>但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。<br>计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。</p>\n<h1 id=\"计算属性使用\"><a href=\"#计算属性使用\" class=\"headerlink\" title=\"计算属性使用\"></a>计算属性使用</h1><p>首先呢，使用 computed 需要引入<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E5%BC%95%E5%85%A5.png\"><br>我们编写一个案例<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%B8%80.png\"><br>但是有一点需要注意！<br>如果我们直接修改计算属性的值会报一个错误！<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%BA%8C.png\"><br>这个意思就是计算属性是只读的不允许修改<br>如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。<br>那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%B1%82%E5%92%8C.png\"><br>也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>vue.3.0 中要从vue 按需导入 computed 计算属性。</li>\n<li>如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。</li>\n<li>使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。</li>\n<li>传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。</li>\n<li>只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。</li>\n<li>既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"computed-计算属性说明\"><a href=\"#computed-计算属性说明\" class=\"headerlink\" title=\"computed 计算属性说明\"></a>computed 计算属性说明</h1><p>computed 表示计算属性，通常是用来进行数据处理。<br>比如日常在模板中我们渲染数据的时候一般是使用 双括号 来进行展示数据，但是有的时候，获取到的数据并不是我们想要的类型，我们可以在 双括号 中编写表达式转换成我们需要的类型<br>但是呢，这样做简单的还可以，如果相对复杂的格式在 双括号 中编写的话就会造成模板代码繁琐，不易维护和阅读，所以这并不是最好的编码习惯，因此，vue3 也为我们提供了一些好的解决方案，计算属性就是其中一种。<br>计算属性可以帮我们将数据转换成需要展示的数据格式，不必在模板中编写大量的表达式进行处理。</p>\n<h1 id=\"计算属性使用\"><a href=\"#计算属性使用\" class=\"headerlink\" title=\"计算属性使用\"></a>计算属性使用</h1><p>首先呢，使用 computed 需要引入<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E5%BC%95%E5%85%A5.png\"><br>我们编写一个案例<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%B8%80.png\"><br>但是有一点需要注意！<br>如果我们直接修改计算属性的值会报一个错误！<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E6%A1%88%E4%BE%8B%E4%BA%8C.png\"><br>这个意思就是计算属性是只读的不允许修改<br>如果传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。<br>那我需要修改计算属性的值，我们需要怎么操作呢？其实很简单，只需要传进去一个对象。<br><img src=\"/2022/10/17/Vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%B1%82%E5%92%8C.png\"><br>也就是说，计算属性传入一个对象， 包含get 和 set 函数， 就能实现创建一个可以修改的计算属性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>vue.3.0 中要从vue 按需导入 computed 计算属性。</li>\n<li>如果传入的是一个getter 函数， 会返回一个不允许修改的计算属性。</li>\n<li>使用ref 创建一个响应式对象， 在模板中使用不用自动解套， 直接渲染使用。</li>\n<li>传入一个对象， 包含get 和 set 函数， 就可以创建一个可以修改的计算属性。</li>\n<li>只可以获取值，不允许修改值，直接使用 computed 计算属性使用箭头函数。</li>\n<li>既可以获取值， 也可以修改值， computed 计算属性中传入一个对象， get 方法 和 set 方法。</li>\n</ol>\n"},{"title":"Vue-axios","date":"2022-12-19T10:08:31.000Z","_content":"众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。\n说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？\n在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。\n如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～\n\n# 一、前端从后端获取数据的方式通常采用http/https的方式\n方法通常有GET、POST、PUT、DELETE、PATCH这五种；\nGET==>用来获取数据，\nPOST==> 是用来新增数据表单提交或文件上传\nDELETE==>是用来删除数据\nPUT==>是用来更新数据（所有数据推送到后端）\nPATCH==>是用来更新数据（只将修改的数据推送到后端）\n# 二、从前端请求后端接口获取数据格式：\nGET方法：\n## 1、axios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n## 2、axios({method:'get',url:'xxxxx',config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。\n\n## POST方法（appcation/json或者form-data）：\n### 1、①appcation/json方式\nlet data={id:12}\naxios.post(url,data,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n\n### ②appcation/json方式：\nlet data={id:12}\naxios({method:'post',url,data:data,config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n\n### 2、①form-data方式\nlet data={id:12}\nlet formData = new FormData()\nfor(let key in data){\nformData.append(key,data[key])\n}\naxios.post(url,formData,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n\n### ②form-data方式\nlet data={id:12}\nlet formData = new FormData()\nfor(let key in data){\nformData.append(key,data[key])\n}\naxios({method:'post',url,formData:formData,config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\npost请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。\n## PUT和PATCH方式：\nput和patch跟post一样，就方法不一样而已，参考post方法。\n## DELETE方式：\n类似get方式，就方法不一样而已，参考get方法。\n可以在config中设置基础URL，超时时间、传参方式、请求头等信息，\n注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。\n# 三、axios并发请求\n## 并发请求：同时进行多个请求，并统一处理返回值。\n比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。\n这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。\n## axios.all()和axios.spread()方法\n其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。\n比如：arr[] =[axios.get(url),axios.post(url,data,config)]\n## 另一个axios.spread((A,B)=>{})\n这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。\n具体用法：\naxios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=>{}))\n# 四、axios实例\n你会不会有这样一个疑问，就是为什么要用axios实例呢？\n那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，\n那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。\n具体用法：\nlet instance = axios.create(config);\ninstance.get(url).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n# 五、关于请求中的config\nconfig的格式为：\n{\nbaseURL:'http:/xxxxxx', //基础url\ntimeout:6000, //超时时间\nurl:xxxxxx, //具体url\nmethod:'get/post/put/patch/delete', //请求方式\nheaders:{token:'xxxxx'等}, //请求头设置\nparams:{}, //请求参数对象，它会将请求参数拼接到url上\ndata:{} //请求参数对象，它会将请求参数放到请求体中\n}\n\nconfig应用场景\n## 1、全局配置\naxios.defaults.timeout = 1000\naxios.defaults.baseURL = 'http://XXXXX'\n## 2、实例配置\n在axios创建实例中配置\nlet instance = axios.create();\ninstance.defaults.timeout = 1000\n## 3、请求配置\n在请求中配置\naxios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n其中，配置优先级为：3>2>1\n# 六、axios拦截器\n## 什么是拦截器？\n拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。\n一般分为请求拦截器和响应拦截器两种。\n## 请求拦截器\n请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。\nservice.interceptors.request.use(\nconfig => {\n//在发送请求前的额外处理\nreturn config\n},\n)\n## 响应拦截器\n响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。\nservice.interceptors.response.use(\nres => {\n//响应之后做一些额外操作\nreturn res\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：\naxios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n\n例子：发送请求前，在请求头中添加token，就可以用拦截器来实现\nlet instance = axios.create(config);\ninstance.interceptors.request.use(confit=>{\nconfig.headers.token=\"sssssss\"\nreturn config\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n\n## 取消拦截器\n顾名思义就是取消掉已经配置的拦截器\n\n例子：\nlet instance = axios.create(config);\ninstance.interceptors.request.use(\nconfig=>{\nconfig.headers.token=\"sssssss\"\nreturn config\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n//取消拦截器操作：\naxios.interceptors.request.eject(instance)\n\n# 七、取消请求\n取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，\n这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法\n例子：\naxios.CancelToken.source()\naxios.get(url,{CancelToken:source,token}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n//触发取消请求：\nsource.cancel('错误信息')\n就可以了\n\n\n\n","source":"_posts/Vue-axios.md","raw":"---\ntitle: Vue-axios\ndate: 2022-12-19 18:08:31\ntags: vue\ncategories: 知识点\n---\n众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。\n说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？\n在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。\n如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～\n\n# 一、前端从后端获取数据的方式通常采用http/https的方式\n方法通常有GET、POST、PUT、DELETE、PATCH这五种；\nGET==>用来获取数据，\nPOST==> 是用来新增数据表单提交或文件上传\nDELETE==>是用来删除数据\nPUT==>是用来更新数据（所有数据推送到后端）\nPATCH==>是用来更新数据（只将修改的数据推送到后端）\n# 二、从前端请求后端接口获取数据格式：\nGET方法：\n## 1、axios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n## 2、axios({method:'get',url:'xxxxx',config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。\n\n## POST方法（appcation/json或者form-data）：\n### 1、①appcation/json方式\nlet data={id:12}\naxios.post(url,data,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n\n### ②appcation/json方式：\nlet data={id:12}\naxios({method:'post',url,data:data,config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n\n### 2、①form-data方式\nlet data={id:12}\nlet formData = new FormData()\nfor(let key in data){\nformData.append(key,data[key])\n}\naxios.post(url,formData,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n\n### ②form-data方式\nlet data={id:12}\nlet formData = new FormData()\nfor(let key in data){\nformData.append(key,data[key])\n}\naxios({method:'post',url,formData:formData,config}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\npost请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。\n## PUT和PATCH方式：\nput和patch跟post一样，就方法不一样而已，参考post方法。\n## DELETE方式：\n类似get方式，就方法不一样而已，参考get方法。\n可以在config中设置基础URL，超时时间、传参方式、请求头等信息，\n注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。\n# 三、axios并发请求\n## 并发请求：同时进行多个请求，并统一处理返回值。\n比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。\n这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。\n## axios.all()和axios.spread()方法\n其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。\n比如：arr[] =[axios.get(url),axios.post(url,data,config)]\n## 另一个axios.spread((A,B)=>{})\n这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。\n具体用法：\naxios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=>{}))\n# 四、axios实例\n你会不会有这样一个疑问，就是为什么要用axios实例呢？\n那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，\n那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。\n具体用法：\nlet instance = axios.create(config);\ninstance.get(url).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n# 五、关于请求中的config\nconfig的格式为：\n{\nbaseURL:'http:/xxxxxx', //基础url\ntimeout:6000, //超时时间\nurl:xxxxxx, //具体url\nmethod:'get/post/put/patch/delete', //请求方式\nheaders:{token:'xxxxx'等}, //请求头设置\nparams:{}, //请求参数对象，它会将请求参数拼接到url上\ndata:{} //请求参数对象，它会将请求参数放到请求体中\n}\n\nconfig应用场景\n## 1、全局配置\naxios.defaults.timeout = 1000\naxios.defaults.baseURL = 'http://XXXXX'\n## 2、实例配置\n在axios创建实例中配置\nlet instance = axios.create();\ninstance.defaults.timeout = 1000\n## 3、请求配置\n在请求中配置\naxios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n其中，配置优先级为：3>2>1\n# 六、axios拦截器\n## 什么是拦截器？\n拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。\n一般分为请求拦截器和响应拦截器两种。\n## 请求拦截器\n请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。\nservice.interceptors.request.use(\nconfig => {\n//在发送请求前的额外处理\nreturn config\n},\n)\n## 响应拦截器\n响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。\nservice.interceptors.response.use(\nres => {\n//响应之后做一些额外操作\nreturn res\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：\naxios.get(url,config).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n\n例子：发送请求前，在请求头中添加token，就可以用拦截器来实现\nlet instance = axios.create(config);\ninstance.interceptors.request.use(confit=>{\nconfig.headers.token=\"sssssss\"\nreturn config\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n\n## 取消拦截器\n顾名思义就是取消掉已经配置的拦截器\n\n例子：\nlet instance = axios.create(config);\ninstance.interceptors.request.use(\nconfig=>{\nconfig.headers.token=\"sssssss\"\nreturn config\n},\nerror => {\n//在发生错误后的额外处理\nreturn Promise.reject(error)\n}\n)\n//取消拦截器操作：\naxios.interceptors.request.eject(instance)\n\n# 七、取消请求\n取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，\n这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法\n例子：\naxios.CancelToken.source()\naxios.get(url,{CancelToken:source,token}).then(res=>{数据处理逻辑}).catch(err=>{错误处理逻辑})\n//触发取消请求：\nsource.cancel('错误信息')\n就可以了\n\n\n\n","slug":"Vue-axios","published":1,"updated":"2023-03-22T06:18:13.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliq300097et818qjhh3z","content":"<p>众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。<br>说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？<br>在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。<br>如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～</p>\n<h1 id=\"一、前端从后端获取数据的方式通常采用http-https的方式\"><a href=\"#一、前端从后端获取数据的方式通常采用http-https的方式\" class=\"headerlink\" title=\"一、前端从后端获取数据的方式通常采用http/https的方式\"></a>一、前端从后端获取数据的方式通常采用http/https的方式</h1><p>方法通常有GET、POST、PUT、DELETE、PATCH这五种；<br>GET==&gt;用来获取数据，<br>POST==&gt; 是用来新增数据表单提交或文件上传<br>DELETE==&gt;是用来删除数据<br>PUT==&gt;是用来更新数据（所有数据推送到后端）<br>PATCH==&gt;是用来更新数据（只将修改的数据推送到后端）</p>\n<h1 id=\"二、从前端请求后端接口获取数据格式：\"><a href=\"#二、从前端请求后端接口获取数据格式：\" class=\"headerlink\" title=\"二、从前端请求后端接口获取数据格式：\"></a>二、从前端请求后端接口获取数据格式：</h1><p>GET方法：</p>\n<h2 id=\"1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\"><a href=\"#1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\" class=\"headerlink\" title=\"1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})\"></a>1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><h2 id=\"2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\"><a href=\"#2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\" class=\"headerlink\" title=\"2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})\"></a>2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><p>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。</p>\n<h2 id=\"POST方法（appcation-json或者form-data）：\"><a href=\"#POST方法（appcation-json或者form-data）：\" class=\"headerlink\" title=\"POST方法（appcation/json或者form-data）：\"></a>POST方法（appcation/json或者form-data）：</h2><h3 id=\"1、①appcation-json方式\"><a href=\"#1、①appcation-json方式\" class=\"headerlink\" title=\"1、①appcation/json方式\"></a>1、①appcation/json方式</h3><p>let data={id:12}<br>axios.post(url,data,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<h3 id=\"②appcation-json方式：\"><a href=\"#②appcation-json方式：\" class=\"headerlink\" title=\"②appcation/json方式：\"></a>②appcation/json方式：</h3><p>let data={id:12}<br>axios({method:’post’,url,data:data,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<h3 id=\"2、①form-data方式\"><a href=\"#2、①form-data方式\" class=\"headerlink\" title=\"2、①form-data方式\"></a>2、①form-data方式</h3><p>let data={id:12}<br>let formData = new FormData()<br>for(let key in data){<br>formData.append(key,data[key])<br>}<br>axios.post(url,formData,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<h3 id=\"②form-data方式\"><a href=\"#②form-data方式\" class=\"headerlink\" title=\"②form-data方式\"></a>②form-data方式</h3><p>let data={id:12}<br>let formData = new FormData()<br>for(let key in data){<br>formData.append(key,data[key])<br>}<br>axios({method:’post’,url,formData:formData,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>post请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。</p>\n<h2 id=\"PUT和PATCH方式：\"><a href=\"#PUT和PATCH方式：\" class=\"headerlink\" title=\"PUT和PATCH方式：\"></a>PUT和PATCH方式：</h2><p>put和patch跟post一样，就方法不一样而已，参考post方法。</p>\n<h2 id=\"DELETE方式：\"><a href=\"#DELETE方式：\" class=\"headerlink\" title=\"DELETE方式：\"></a>DELETE方式：</h2><p>类似get方式，就方法不一样而已，参考get方法。<br>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，<br>注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。</p>\n<h1 id=\"三、axios并发请求\"><a href=\"#三、axios并发请求\" class=\"headerlink\" title=\"三、axios并发请求\"></a>三、axios并发请求</h1><h2 id=\"并发请求：同时进行多个请求，并统一处理返回值。\"><a href=\"#并发请求：同时进行多个请求，并统一处理返回值。\" class=\"headerlink\" title=\"并发请求：同时进行多个请求，并统一处理返回值。\"></a>并发请求：同时进行多个请求，并统一处理返回值。</h2><p>比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。<br>这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。</p>\n<h2 id=\"axios-all-和axios-spread-方法\"><a href=\"#axios-all-和axios-spread-方法\" class=\"headerlink\" title=\"axios.all()和axios.spread()方法\"></a>axios.all()和axios.spread()方法</h2><p>其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。<br>比如：arr[] =[axios.get(url),axios.post(url,data,config)]</p>\n<h2 id=\"另一个axios-spread-A-B-gt\"><a href=\"#另一个axios-spread-A-B-gt\" class=\"headerlink\" title=\"另一个axios.spread((A,B)=&gt;{})\"></a>另一个axios.spread((A,B)=&gt;{})</h2><p>这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。<br>具体用法：<br>axios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=&gt;{}))</p>\n<h1 id=\"四、axios实例\"><a href=\"#四、axios实例\" class=\"headerlink\" title=\"四、axios实例\"></a>四、axios实例</h1><p>你会不会有这样一个疑问，就是为什么要用axios实例呢？<br>那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，<br>那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。<br>具体用法：<br>let instance = axios.create(config);<br>instance.get(url).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<h1 id=\"五、关于请求中的config\"><a href=\"#五、关于请求中的config\" class=\"headerlink\" title=\"五、关于请求中的config\"></a>五、关于请求中的config</h1><p>config的格式为：<br>{<br>baseURL:’http:/xxxxxx’, //基础url<br>timeout:6000, //超时时间<br>url:xxxxxx, //具体url<br>method:’get/post/put/patch/delete’, //请求方式<br>headers:{token:’xxxxx’等}, //请求头设置<br>params:{}, //请求参数对象，它会将请求参数拼接到url上<br>data:{} //请求参数对象，它会将请求参数放到请求体中<br>}</p>\n<p>config应用场景</p>\n<h2 id=\"1、全局配置\"><a href=\"#1、全局配置\" class=\"headerlink\" title=\"1、全局配置\"></a>1、全局配置</h2><p>axios.defaults.timeout = 1000<br>axios.defaults.baseURL = ‘<a href=\"http://xxxxx&/#39;\">http://XXXXX&#39;</a></p>\n<h2 id=\"2、实例配置\"><a href=\"#2、实例配置\" class=\"headerlink\" title=\"2、实例配置\"></a>2、实例配置</h2><p>在axios创建实例中配置<br>let instance = axios.create();<br>instance.defaults.timeout = 1000</p>\n<h2 id=\"3、请求配置\"><a href=\"#3、请求配置\" class=\"headerlink\" title=\"3、请求配置\"></a>3、请求配置</h2><p>在请求中配置<br>axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>其中，配置优先级为：3&gt;2&gt;1</p>\n<h1 id=\"六、axios拦截器\"><a href=\"#六、axios拦截器\" class=\"headerlink\" title=\"六、axios拦截器\"></a>六、axios拦截器</h1><h2 id=\"什么是拦截器？\"><a href=\"#什么是拦截器？\" class=\"headerlink\" title=\"什么是拦截器？\"></a>什么是拦截器？</h2><p>拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。<br>一般分为请求拦截器和响应拦截器两种。</p>\n<h2 id=\"请求拦截器\"><a href=\"#请求拦截器\" class=\"headerlink\" title=\"请求拦截器\"></a>请求拦截器</h2><p>请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。<br>service.interceptors.request.use(<br>config =&gt; {<br>//在发送请求前的额外处理<br>return config<br>},<br>)</p>\n<h2 id=\"响应拦截器\"><a href=\"#响应拦截器\" class=\"headerlink\" title=\"响应拦截器\"></a>响应拦截器</h2><p>响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。<br>service.interceptors.response.use(<br>res =&gt; {<br>//响应之后做一些额外操作<br>return res<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)<br>注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：<br>axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<p>例子：发送请求前，在请求头中添加token，就可以用拦截器来实现<br>let instance = axios.create(config);<br>instance.interceptors.request.use(confit=&gt;{<br>config.headers.token=”sssssss”<br>return config<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)</p>\n<h2 id=\"取消拦截器\"><a href=\"#取消拦截器\" class=\"headerlink\" title=\"取消拦截器\"></a>取消拦截器</h2><p>顾名思义就是取消掉已经配置的拦截器</p>\n<p>例子：<br>let instance = axios.create(config);<br>instance.interceptors.request.use(<br>config=&gt;{<br>config.headers.token=”sssssss”<br>return config<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)<br>//取消拦截器操作：<br>axios.interceptors.request.eject(instance)</p>\n<h1 id=\"七、取消请求\"><a href=\"#七、取消请求\" class=\"headerlink\" title=\"七、取消请求\"></a>七、取消请求</h1><p>取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，<br>这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法<br>例子：<br>axios.CancelToken.source()<br>axios.get(url,{CancelToken:source,token}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>//触发取消请求：<br>source.cancel(‘错误信息’)<br>就可以了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>众所周知，现在开发项目大多采用前后端分离的模式，个人采用vue做前端项目比较多一点。<br>说到前端，那前端肯定只是负责渲染展示数据的，那么这里有一个问题，数据从哪里来呢？<br>在开发阶段，大多会采用mock模拟数据，做一些假数据来满足暂时的需求，但是最终生产上的数据肯定是从后端接口获取而来。<br>如何在vue项目上从后端获取数据呢？这就是我们今天要说的内容啦～</p>\n<h1 id=\"一、前端从后端获取数据的方式通常采用http-https的方式\"><a href=\"#一、前端从后端获取数据的方式通常采用http-https的方式\" class=\"headerlink\" title=\"一、前端从后端获取数据的方式通常采用http/https的方式\"></a>一、前端从后端获取数据的方式通常采用http/https的方式</h1><p>方法通常有GET、POST、PUT、DELETE、PATCH这五种；<br>GET==&gt;用来获取数据，<br>POST==&gt; 是用来新增数据表单提交或文件上传<br>DELETE==&gt;是用来删除数据<br>PUT==&gt;是用来更新数据（所有数据推送到后端）<br>PATCH==&gt;是用来更新数据（只将修改的数据推送到后端）</p>\n<h1 id=\"二、从前端请求后端接口获取数据格式：\"><a href=\"#二、从前端请求后端接口获取数据格式：\" class=\"headerlink\" title=\"二、从前端请求后端接口获取数据格式：\"></a>二、从前端请求后端接口获取数据格式：</h1><p>GET方法：</p>\n<h2 id=\"1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\"><a href=\"#1、axios-get-url-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\" class=\"headerlink\" title=\"1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})\"></a>1、axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><h2 id=\"2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\"><a href=\"#2、axios-method-’get’-url-’xxxxx’-config-then-res-gt-数据处理逻辑-catch-err-gt-错误处理逻辑\" class=\"headerlink\" title=\"2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})\"></a>2、axios({method:’get’,url:’xxxxx’,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</h2><p>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般为params，请求参数在url中。</p>\n<h2 id=\"POST方法（appcation-json或者form-data）：\"><a href=\"#POST方法（appcation-json或者form-data）：\" class=\"headerlink\" title=\"POST方法（appcation/json或者form-data）：\"></a>POST方法（appcation/json或者form-data）：</h2><h3 id=\"1、①appcation-json方式\"><a href=\"#1、①appcation-json方式\" class=\"headerlink\" title=\"1、①appcation/json方式\"></a>1、①appcation/json方式</h3><p>let data={id:12}<br>axios.post(url,data,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<h3 id=\"②appcation-json方式：\"><a href=\"#②appcation-json方式：\" class=\"headerlink\" title=\"②appcation/json方式：\"></a>②appcation/json方式：</h3><p>let data={id:12}<br>axios({method:’post’,url,data:data,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<h3 id=\"2、①form-data方式\"><a href=\"#2、①form-data方式\" class=\"headerlink\" title=\"2、①form-data方式\"></a>2、①form-data方式</h3><p>let data={id:12}<br>let formData = new FormData()<br>for(let key in data){<br>formData.append(key,data[key])<br>}<br>axios.post(url,formData,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<h3 id=\"②form-data方式\"><a href=\"#②form-data方式\" class=\"headerlink\" title=\"②form-data方式\"></a>②form-data方式</h3><p>let data={id:12}<br>let formData = new FormData()<br>for(let key in data){<br>formData.append(key,data[key])<br>}<br>axios({method:’post’,url,formData:formData,config}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>post请求同样可以在在config中设置基础URL，超时时间、传参方式、请求头等信息，但是传参方式一般用data，参数在请求体中。</p>\n<h2 id=\"PUT和PATCH方式：\"><a href=\"#PUT和PATCH方式：\" class=\"headerlink\" title=\"PUT和PATCH方式：\"></a>PUT和PATCH方式：</h2><p>put和patch跟post一样，就方法不一样而已，参考post方法。</p>\n<h2 id=\"DELETE方式：\"><a href=\"#DELETE方式：\" class=\"headerlink\" title=\"DELETE方式：\"></a>DELETE方式：</h2><p>类似get方式，就方法不一样而已，参考get方法。<br>可以在config中设置基础URL，超时时间、传参方式、请求头等信息，<br>注意请求参数，如果在url中则config中采用params方式传参，如果在请求体中，则config中采用data方式传参。</p>\n<h1 id=\"三、axios并发请求\"><a href=\"#三、axios并发请求\" class=\"headerlink\" title=\"三、axios并发请求\"></a>三、axios并发请求</h1><h2 id=\"并发请求：同时进行多个请求，并统一处理返回值。\"><a href=\"#并发请求：同时进行多个请求，并统一处理返回值。\" class=\"headerlink\" title=\"并发请求：同时进行多个请求，并统一处理返回值。\"></a>并发请求：同时进行多个请求，并统一处理返回值。</h2><p>比如说：我们需要同时请求用户信息和商品信息，然后将获得的两种信息进行拼接等统一加工到一起。<br>这涉及到axios的两种方法：axios.all(arr[])和axios.spread()。</p>\n<h2 id=\"axios-all-和axios-spread-方法\"><a href=\"#axios-all-和axios-spread-方法\" class=\"headerlink\" title=\"axios.all()和axios.spread()方法\"></a>axios.all()和axios.spread()方法</h2><p>其中axios.all(arr[])这个方法的作用就是同时去请求，它的参数是数组，数组的内容就是请求方式和路径。<br>比如：arr[] =[axios.get(url),axios.post(url,data,config)]</p>\n<h2 id=\"另一个axios-spread-A-B-gt\"><a href=\"#另一个axios-spread-A-B-gt\" class=\"headerlink\" title=\"另一个axios.spread((A,B)=&gt;{})\"></a>另一个axios.spread((A,B)=&gt;{})</h2><p>这个方法是用来处理返回的数据的，其中{}中是具体的处理逻辑，A就是第一个请求的返回值，B就是第二个请求的返回值。<br>具体用法：<br>axios.all([axios.get(url),axios.post(url,data,config)]).then(axios.spread((A,B)=&gt;{}))</p>\n<h1 id=\"四、axios实例\"><a href=\"#四、axios实例\" class=\"headerlink\" title=\"四、axios实例\"></a>四、axios实例</h1><p>你会不会有这样一个疑问，就是为什么要用axios实例呢？<br>那可能是因为在你的项目中会涉及到多个接口地址，而且每种接口的超时时间等等设置都不一样，<br>那么这个时候，你就可以针对某个接口地址某种超时时间来创建独立的axios实例，后期你就可以直接使用这种特殊axios实例去进行数据请求了。<br>具体用法：<br>let instance = axios.create(config);<br>instance.get(url).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<h1 id=\"五、关于请求中的config\"><a href=\"#五、关于请求中的config\" class=\"headerlink\" title=\"五、关于请求中的config\"></a>五、关于请求中的config</h1><p>config的格式为：<br>{<br>baseURL:’http:/xxxxxx’, //基础url<br>timeout:6000, //超时时间<br>url:xxxxxx, //具体url<br>method:’get/post/put/patch/delete’, //请求方式<br>headers:{token:’xxxxx’等}, //请求头设置<br>params:{}, //请求参数对象，它会将请求参数拼接到url上<br>data:{} //请求参数对象，它会将请求参数放到请求体中<br>}</p>\n<p>config应用场景</p>\n<h2 id=\"1、全局配置\"><a href=\"#1、全局配置\" class=\"headerlink\" title=\"1、全局配置\"></a>1、全局配置</h2><p>axios.defaults.timeout = 1000<br>axios.defaults.baseURL = ‘<a href=\"http://xxxxx&/#39;\">http://XXXXX&#39;</a></p>\n<h2 id=\"2、实例配置\"><a href=\"#2、实例配置\" class=\"headerlink\" title=\"2、实例配置\"></a>2、实例配置</h2><p>在axios创建实例中配置<br>let instance = axios.create();<br>instance.defaults.timeout = 1000</p>\n<h2 id=\"3、请求配置\"><a href=\"#3、请求配置\" class=\"headerlink\" title=\"3、请求配置\"></a>3、请求配置</h2><p>在请求中配置<br>axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>其中，配置优先级为：3&gt;2&gt;1</p>\n<h1 id=\"六、axios拦截器\"><a href=\"#六、axios拦截器\" class=\"headerlink\" title=\"六、axios拦截器\"></a>六、axios拦截器</h1><h2 id=\"什么是拦截器？\"><a href=\"#什么是拦截器？\" class=\"headerlink\" title=\"什么是拦截器？\"></a>什么是拦截器？</h2><p>拦截器就是在请求之前和响应之后能进行一些额外操作的功能实现。<br>一般分为请求拦截器和响应拦截器两种。</p>\n<h2 id=\"请求拦截器\"><a href=\"#请求拦截器\" class=\"headerlink\" title=\"请求拦截器\"></a>请求拦截器</h2><p>请求拦截器顾名思义就是在请求之前进行拦截并进行一些额外操作。<br>service.interceptors.request.use(<br>config =&gt; {<br>//在发送请求前的额外处理<br>return config<br>},<br>)</p>\n<h2 id=\"响应拦截器\"><a href=\"#响应拦截器\" class=\"headerlink\" title=\"响应拦截器\"></a>响应拦截器</h2><p>响应拦截器顾名思义就是在响应之后进行拦截并进行一些额外操作。<br>service.interceptors.response.use(<br>res =&gt; {<br>//响应之后做一些额外操作<br>return res<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)<br>注意：不管是请求拦截器还是响应拦截器，在发生错误后都会进入到请求的catch方法中，如：<br>axios.get(url,config).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})</p>\n<p>例子：发送请求前，在请求头中添加token，就可以用拦截器来实现<br>let instance = axios.create(config);<br>instance.interceptors.request.use(confit=&gt;{<br>config.headers.token=”sssssss”<br>return config<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)</p>\n<h2 id=\"取消拦截器\"><a href=\"#取消拦截器\" class=\"headerlink\" title=\"取消拦截器\"></a>取消拦截器</h2><p>顾名思义就是取消掉已经配置的拦截器</p>\n<p>例子：<br>let instance = axios.create(config);<br>instance.interceptors.request.use(<br>config=&gt;{<br>config.headers.token=”sssssss”<br>return config<br>},<br>error =&gt; {<br>//在发生错误后的额外处理<br>return Promise.reject(error)<br>}<br>)<br>//取消拦截器操作：<br>axios.interceptors.request.eject(instance)</p>\n<h1 id=\"七、取消请求\"><a href=\"#七、取消请求\" class=\"headerlink\" title=\"七、取消请求\"></a>七、取消请求</h1><p>取消请求实际中用的到不多，主要使用场景比如：用户正在批量查询一个比较耗时的数据，发起请求后用户不想查了，<br>这时候就可以取消这个请求,主要用到：axios.CancelToken.source()方法<br>例子：<br>axios.CancelToken.source()<br>axios.get(url,{CancelToken:source,token}).then(res=&gt;{数据处理逻辑}).catch(err=&gt;{错误处理逻辑})<br>//触发取消请求：<br>source.cancel(‘错误信息’)<br>就可以了</p>\n"},{"title":"Vue3:Pinia使用","date":"2022-10-24T13:44:07.000Z","_content":"在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。\n\n# 什么是 Pinia\nPinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。\n# Pinia 的优点\nPinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：\npinia 符合直觉，易于学习。\npinia 是轻量级状态管理工具，大小只有1KB.\npinia 模块化设计，方便拆分。\npinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。\nstore 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。\n支持多个 store。\n支持 Vue devtools、SSR、webpack 代码拆分。\n\n# 相关资料\nPinia 中文网：https://pinia.web3doc.top/\n\n# Pinia 安装\n安装 pinia 就很简单了，直接命令安装就可以了。\n![](安装.png)\n\n# Pinia 使用\n安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia\n## 1.Pinia 导入\n首先在 main.js 文件中引入\n vue3 的写法：\nimport {createPinia} from 'pinia'\n然后，这个 pinia 就在项目中导入了\nPinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：\nimport {PiniaVuePlugin} from 'pinia'\n我们还是以 vue3 来介绍这个 Pinia\n导入的时候是 hook ，我们需要调用一下\nconst state = createPinia()\n调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。\napp.use(state)\n## 2.Pinia 基本使用\n### 1.创建 index.ts 文件\n使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。\n创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。\n### 2.编写 index.ts 文件\n首先我们先引入 pinia\nimport { defineStore } from \"pinia\";\n由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下\n这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。\n我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出\nexport const enum Names {\n  TEST = \"TEST\"\n}\n***\n然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。\n 这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。\nstate 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。\ngetters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。\nactions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。\n![](indexts.png)\n其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。\n![](截图1代码.png)\n![](截图1结果.png)\n### 3.修改 Pinia 的值\n修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值\n修改值的方式呢，常见的有五种\n#### 方式一：直接修改\n![](截图2代码.png)\n![](截图2结果.png)\n#### 方式二：$patch 函数修改\n在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。\n![](截图3代码.png)\n![](截图3结果1.png)\n![](截图3结果2.png)\n#### 方式三：$patch 函数修改\n咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。\n![](截图4代码.png)\n效果其实和方式二是一模一样的\n#### 方式四：$state 方式\n![](截图5代码.png)\n#### 方式五： action 方式\n这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action\n![](截图6代码1.png)\n写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。\n![](截图6代码2.png)\n查看一下效果，可以看到\n![](截图6结果1.png)\n![](截图6结果2.png)\n当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。\n![](截图7代码1.png)\n![](截图7代码2.png)\n查看一下效果，可以看到\n![](截图7结果1.png)\n![](截图7结果2.png)\n以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用\n# pinia 解构\n上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的\n![](截图8代码.png)\n在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到\n![](截图8结果.png)\n我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。\n但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。\n做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染\n![](截图9代码.png)\n在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到\n![](截图9代码.png)\n通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。\n解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。\n就是 storeToRefs，使用 storeToRefs 需要导入一下。\nimport { storeToRefs } from 'pinia'\n然后把我们解构的对象包裹一下就可以了\nconst { name, age } = storeToRefs(userInfo)\n![](截图10代码.png)\n![](截图10结果.png)\n或者我们换一个写法，直接操作结构后的数据，记得，要 .value\n![](截图11代码.png)\n# Pinia 的 actions\nactions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步\n接下来我们重点介绍一下actions异步\nactions 异步\n首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用\n![](截图11代码1.png)\n![](截图11代码2.png)\n查看一下效果，可以看到\n![](截图11结果1.png)\n![](截图11结果2.png)\nactions 同步、异步连用\n这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。\n上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。\n![](截图12代码.png)\n查看一下效果，可以看到\n![](截图12结果.png)\n# getter 函数\ngetters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。\n有两种写法:\n普通函数方式写法\n![](截图13代码1.png)\n![](截图13代码2.png)\n查看一下效果，可以看到\n![](截图13结果1.png)\n然后我们点一下按钮，修改一下 name，然后看一下效果\n![](截图13结果2.png)\n我们可以看见，点击修改 name 之后getter 也会实时的渲染出来\n相互调用\n![](截图14代码.png)\n查看一下效果，可以看到\n![](截图14结果1.png)\n然后我们点一下按钮，修改一下 name和 age，然后看一下效果\n![](截图14结果2.png)\n# API 的使用\n$reset ：重置到初始值\n这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。\n![](截图15代码.png)\n我们点击修改用户按钮，查看一下效果，可以看到\n![](截图15结果1.png)\n然后我们点一下$reset按钮，然后看一下效果\n![](截图15结果2.png)\n$subscribe：监听 state 数据变化\n$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。\n![](截图16代码.png)\n我们点击修改用户按钮，查看一下效果，可以看到\n![](截图16结果1.png)\n控制台打印出监听到的变化结果\n![](截图16结果2.png)\n$onAction：一调用 actions 就触发\n![](截图17代码.png)\n控制台打印出监听到的变化结果\n![](截图17结果.png)","source":"_posts/Vue3-Pinia使用.md","raw":"---\ntitle: 'Vue3:Pinia使用'\ndate: 2022-10-24 21:44:07\ntags: vue3\ncategories: vue3\n---\n在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。\n\n# 什么是 Pinia\nPinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。\n# Pinia 的优点\nPinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：\npinia 符合直觉，易于学习。\npinia 是轻量级状态管理工具，大小只有1KB.\npinia 模块化设计，方便拆分。\npinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。\nstore 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。\n支持多个 store。\n支持 Vue devtools、SSR、webpack 代码拆分。\n\n# 相关资料\nPinia 中文网：https://pinia.web3doc.top/\n\n# Pinia 安装\n安装 pinia 就很简单了，直接命令安装就可以了。\n![](安装.png)\n\n# Pinia 使用\n安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia\n## 1.Pinia 导入\n首先在 main.js 文件中引入\n vue3 的写法：\nimport {createPinia} from 'pinia'\n然后，这个 pinia 就在项目中导入了\nPinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：\nimport {PiniaVuePlugin} from 'pinia'\n我们还是以 vue3 来介绍这个 Pinia\n导入的时候是 hook ，我们需要调用一下\nconst state = createPinia()\n调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。\napp.use(state)\n## 2.Pinia 基本使用\n### 1.创建 index.ts 文件\n使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。\n创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。\n### 2.编写 index.ts 文件\n首先我们先引入 pinia\nimport { defineStore } from \"pinia\";\n由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下\n这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。\n我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出\nexport const enum Names {\n  TEST = \"TEST\"\n}\n***\n然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。\n 这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。\nstate 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。\ngetters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。\nactions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。\n![](indexts.png)\n其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。\n![](截图1代码.png)\n![](截图1结果.png)\n### 3.修改 Pinia 的值\n修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值\n修改值的方式呢，常见的有五种\n#### 方式一：直接修改\n![](截图2代码.png)\n![](截图2结果.png)\n#### 方式二：$patch 函数修改\n在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。\n![](截图3代码.png)\n![](截图3结果1.png)\n![](截图3结果2.png)\n#### 方式三：$patch 函数修改\n咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。\n![](截图4代码.png)\n效果其实和方式二是一模一样的\n#### 方式四：$state 方式\n![](截图5代码.png)\n#### 方式五： action 方式\n这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action\n![](截图6代码1.png)\n写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。\n![](截图6代码2.png)\n查看一下效果，可以看到\n![](截图6结果1.png)\n![](截图6结果2.png)\n当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。\n![](截图7代码1.png)\n![](截图7代码2.png)\n查看一下效果，可以看到\n![](截图7结果1.png)\n![](截图7结果2.png)\n以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用\n# pinia 解构\n上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的\n![](截图8代码.png)\n在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到\n![](截图8结果.png)\n我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。\n但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。\n做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染\n![](截图9代码.png)\n在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到\n![](截图9代码.png)\n通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。\n解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。\n就是 storeToRefs，使用 storeToRefs 需要导入一下。\nimport { storeToRefs } from 'pinia'\n然后把我们解构的对象包裹一下就可以了\nconst { name, age } = storeToRefs(userInfo)\n![](截图10代码.png)\n![](截图10结果.png)\n或者我们换一个写法，直接操作结构后的数据，记得，要 .value\n![](截图11代码.png)\n# Pinia 的 actions\nactions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步\n接下来我们重点介绍一下actions异步\nactions 异步\n首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用\n![](截图11代码1.png)\n![](截图11代码2.png)\n查看一下效果，可以看到\n![](截图11结果1.png)\n![](截图11结果2.png)\nactions 同步、异步连用\n这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。\n上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。\n![](截图12代码.png)\n查看一下效果，可以看到\n![](截图12结果.png)\n# getter 函数\ngetters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。\n有两种写法:\n普通函数方式写法\n![](截图13代码1.png)\n![](截图13代码2.png)\n查看一下效果，可以看到\n![](截图13结果1.png)\n然后我们点一下按钮，修改一下 name，然后看一下效果\n![](截图13结果2.png)\n我们可以看见，点击修改 name 之后getter 也会实时的渲染出来\n相互调用\n![](截图14代码.png)\n查看一下效果，可以看到\n![](截图14结果1.png)\n然后我们点一下按钮，修改一下 name和 age，然后看一下效果\n![](截图14结果2.png)\n# API 的使用\n$reset ：重置到初始值\n这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。\n![](截图15代码.png)\n我们点击修改用户按钮，查看一下效果，可以看到\n![](截图15结果1.png)\n然后我们点一下$reset按钮，然后看一下效果\n![](截图15结果2.png)\n$subscribe：监听 state 数据变化\n$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。\n![](截图16代码.png)\n我们点击修改用户按钮，查看一下效果，可以看到\n![](截图16结果1.png)\n控制台打印出监听到的变化结果\n![](截图16结果2.png)\n$onAction：一调用 actions 就触发\n![](截图17代码.png)\n控制台打印出监听到的变化结果\n![](截图17结果.png)","slug":"Vue3-Pinia使用","published":1,"updated":"2023-03-22T06:24:21.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliq4000b7et8buh4fubn","content":"<p>在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。</p>\n<h1 id=\"什么是-Pinia\"><a href=\"#什么是-Pinia\" class=\"headerlink\" title=\"什么是 Pinia\"></a>什么是 Pinia</h1><p>Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。</p>\n<h1 id=\"Pinia-的优点\"><a href=\"#Pinia-的优点\" class=\"headerlink\" title=\"Pinia 的优点\"></a>Pinia 的优点</h1><p>Pinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：<br>pinia 符合直觉，易于学习。<br>pinia 是轻量级状态管理工具，大小只有1KB.<br>pinia 模块化设计，方便拆分。<br>pinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。<br>store 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。<br>支持多个 store。<br>支持 Vue devtools、SSR、webpack 代码拆分。</p>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p>Pinia 中文网：<a href=\"https://pinia.web3doc.top/\">https://pinia.web3doc.top/</a></p>\n<h1 id=\"Pinia-安装\"><a href=\"#Pinia-安装\" class=\"headerlink\" title=\"Pinia 安装\"></a>Pinia 安装</h1><p>安装 pinia 就很简单了，直接命令安装就可以了。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E5%AE%89%E8%A3%85.png\"></p>\n<h1 id=\"Pinia-使用\"><a href=\"#Pinia-使用\" class=\"headerlink\" title=\"Pinia 使用\"></a>Pinia 使用</h1><p>安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia</p>\n<h2 id=\"1-Pinia-导入\"><a href=\"#1-Pinia-导入\" class=\"headerlink\" title=\"1.Pinia 导入\"></a>1.Pinia 导入</h2><p>首先在 main.js 文件中引入<br> vue3 的写法：<br>import {createPinia} from ‘pinia’<br>然后，这个 pinia 就在项目中导入了<br>Pinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：<br>import {PiniaVuePlugin} from ‘pinia’<br>我们还是以 vue3 来介绍这个 Pinia<br>导入的时候是 hook ，我们需要调用一下<br>const state = createPinia()<br>调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。<br>app.use(state)</p>\n<h2 id=\"2-Pinia-基本使用\"><a href=\"#2-Pinia-基本使用\" class=\"headerlink\" title=\"2.Pinia 基本使用\"></a>2.Pinia 基本使用</h2><h3 id=\"1-创建-index-ts-文件\"><a href=\"#1-创建-index-ts-文件\" class=\"headerlink\" title=\"1.创建 index.ts 文件\"></a>1.创建 index.ts 文件</h3><p>使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。<br>创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。</p>\n<h3 id=\"2-编写-index-ts-文件\"><a href=\"#2-编写-index-ts-文件\" class=\"headerlink\" title=\"2.编写 index.ts 文件\"></a>2.编写 index.ts 文件</h3><p>首先我们先引入 pinia<br>import { defineStore } from “pinia”;<br>由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下<br>这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。<br>我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出<br>export const enum Names {<br>  TEST = “TEST”<br>}</p>\n<hr>\n<p>然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。<br> 这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。<br>state 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。<br>getters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。<br>actions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/indexts.png\"><br>其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E7%BB%93%E6%9E%9C.png\"></p>\n<h3 id=\"3-修改-Pinia-的值\"><a href=\"#3-修改-Pinia-的值\" class=\"headerlink\" title=\"3.修改 Pinia 的值\"></a>3.修改 Pinia 的值</h3><p>修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值<br>修改值的方式呢，常见的有五种</p>\n<h4 id=\"方式一：直接修改\"><a href=\"#方式一：直接修改\" class=\"headerlink\" title=\"方式一：直接修改\"></a>方式一：直接修改</h4><p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E7%BB%93%E6%9E%9C.png\"></p>\n<h4 id=\"方式二：-patch-函数修改\"><a href=\"#方式二：-patch-函数修改\" class=\"headerlink\" title=\"方式二：$patch 函数修改\"></a>方式二：$patch 函数修改</h4><p>在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C2.png\"></p>\n<h4 id=\"方式三：-patch-函数修改\"><a href=\"#方式三：-patch-函数修改\" class=\"headerlink\" title=\"方式三：$patch 函数修改\"></a>方式三：$patch 函数修改</h4><p>咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE4%E4%BB%A3%E7%A0%81.png\"><br>效果其实和方式二是一模一样的</p>\n<h4 id=\"方式四：-state-方式\"><a href=\"#方式四：-state-方式\" class=\"headerlink\" title=\"方式四：$state 方式\"></a>方式四：$state 方式</h4><p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE5%E4%BB%A3%E7%A0%81.png\"></p>\n<h4 id=\"方式五：-action-方式\"><a href=\"#方式五：-action-方式\" class=\"headerlink\" title=\"方式五： action 方式\"></a>方式五： action 方式</h4><p>这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%811.png\"><br>写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C2.png\"><br>当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C2.png\"><br>以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用</p>\n<h1 id=\"pinia-解构\"><a href=\"#pinia-解构\" class=\"headerlink\" title=\"pinia 解构\"></a>pinia 解构</h1><p>上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E4%BB%A3%E7%A0%81.png\"><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E7%BB%93%E6%9E%9C.png\"><br>我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。<br>但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。<br>做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png\"><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png\"><br>通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。<br>解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。<br>就是 storeToRefs，使用 storeToRefs 需要导入一下。<br>import { storeToRefs } from ‘pinia’<br>然后把我们解构的对象包裹一下就可以了<br>const { name, age } = storeToRefs(userInfo)<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E7%BB%93%E6%9E%9C.png\"><br>或者我们换一个写法，直接操作结构后的数据，记得，要 .value<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%81.png\"></p>\n<h1 id=\"Pinia-的-actions\"><a href=\"#Pinia-的-actions\" class=\"headerlink\" title=\"Pinia 的 actions\"></a>Pinia 的 actions</h1><p>actions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步<br>接下来我们重点介绍一下actions异步<br>actions 异步<br>首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C2.png\"><br>actions 同步、异步连用<br>这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。<br>上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E4%BB%A3%E7%A0%81.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"getter-函数\"><a href=\"#getter-函数\" class=\"headerlink\" title=\"getter 函数\"></a>getter 函数</h1><p>getters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。<br>有两种写法:<br>普通函数方式写法<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下按钮，修改一下 name，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C2.png\"><br>我们可以看见，点击修改 name 之后getter 也会实时的渲染出来<br>相互调用<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E4%BB%A3%E7%A0%81.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下按钮，修改一下 name和 age，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C2.png\"></p>\n<h1 id=\"API-的使用\"><a href=\"#API-的使用\" class=\"headerlink\" title=\"API 的使用\"></a>API 的使用</h1><p>$reset ：重置到初始值<br>这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E4%BB%A3%E7%A0%81.png\"><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下$reset按钮，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C2.png\"><br>$subscribe：监听 state 数据变化<br>$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E4%BB%A3%E7%A0%81.png\"><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C1.png\"><br>控制台打印出监听到的变化结果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C2.png\"><br>$onAction：一调用 actions 就触发<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E4%BB%A3%E7%A0%81.png\"><br>控制台打印出监听到的变化结果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E7%BB%93%E6%9E%9C.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 vue2 版本中，如果想要使用状态管理器，那么一定是集成 Vuex，首先说明一点，Vuex 在 vue3 项目中依旧是可以正常使用的，是 vue 项目的正规军。但是，今天我们学习一下Pinia 目前也已经是 vue 官方正式的状态库。适用于 vue2 和 vue3。可以简单的理解成 Pinia 就是 Vuex5。也就是说， Vue3 项目，建议使用Pinia，当然很多公司或者是项目由 vue2 转为 vue3 之后，由于习惯了使用 vuex ，所以说，在 vue3 当中继续使用 vuex 的，也不是少数，都知道就可以，根据实际情况来选择。</p>\n<h1 id=\"什么是-Pinia\"><a href=\"#什么是-Pinia\" class=\"headerlink\" title=\"什么是 Pinia\"></a>什么是 Pinia</h1><p>Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。Pinia 的成功可以归功于他管理存储数据的独特功能，例如：可扩展性、存储模块组织、状态变化分组、多存储创建等。</p>\n<h1 id=\"Pinia-的优点\"><a href=\"#Pinia-的优点\" class=\"headerlink\" title=\"Pinia 的优点\"></a>Pinia 的优点</h1><p>Pinia 被 vue 纳入正规编制，肯定是有原因的，那 pinia 有啥优点呢，主要是一下几点：<br>pinia 符合直觉，易于学习。<br>pinia 是轻量级状态管理工具，大小只有1KB.<br>pinia 模块化设计，方便拆分。<br>pinia 没有 mutations，直接在 actions 中操作 state，通过 this.xxx 访问响应的状态，尽管可以直接操作 state，但是还是推荐在 actions 中操作，保证状态不被意外的改变。<br>store 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或者是 MapAction 辅助函数，这是在 Vuex 中很常见的。<br>支持多个 store。<br>支持 Vue devtools、SSR、webpack 代码拆分。</p>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p>Pinia 中文网：<a href=\"https://pinia.web3doc.top/\">https://pinia.web3doc.top/</a></p>\n<h1 id=\"Pinia-安装\"><a href=\"#Pinia-安装\" class=\"headerlink\" title=\"Pinia 安装\"></a>Pinia 安装</h1><p>安装 pinia 就很简单了，直接命令安装就可以了。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E5%AE%89%E8%A3%85.png\"></p>\n<h1 id=\"Pinia-使用\"><a href=\"#Pinia-使用\" class=\"headerlink\" title=\"Pinia 使用\"></a>Pinia 使用</h1><p>安装完 pinia ，然后就是使用了，使用的第一步，就是在项目中引入 pinia</p>\n<h2 id=\"1-Pinia-导入\"><a href=\"#1-Pinia-导入\" class=\"headerlink\" title=\"1.Pinia 导入\"></a>1.Pinia 导入</h2><p>首先在 main.js 文件中引入<br> vue3 的写法：<br>import {createPinia} from ‘pinia’<br>然后，这个 pinia 就在项目中导入了<br>Pinia 是支持 vue2 的，如果是 vue2 的项目，导入的方式是下面的样子：<br>import {PiniaVuePlugin} from ‘pinia’<br>我们还是以 vue3 来介绍这个 Pinia<br>导入的时候是 hook ，我们需要调用一下<br>const state = createPinia()<br>调用完成，state 是以插件的形式存在的，所以说最后我们需要在项目使用一下。<br>app.use(state)</p>\n<h2 id=\"2-Pinia-基本使用\"><a href=\"#2-Pinia-基本使用\" class=\"headerlink\" title=\"2.Pinia 基本使用\"></a>2.Pinia 基本使用</h2><h3 id=\"1-创建-index-ts-文件\"><a href=\"#1-创建-index-ts-文件\" class=\"headerlink\" title=\"1.创建 index.ts 文件\"></a>1.创建 index.ts 文件</h3><p>使用起来相对简单一些，我们首先在根目录下创建一个 store 文件夹，用 vuex 的时候也是这个结构。毕竟 pinia 就是用来替换掉 vuex 的嘛。<br>创建完 store 文件夹，在里面创建一个 ts 文件，叫做 index.ts 。</p>\n<h3 id=\"2-编写-index-ts-文件\"><a href=\"#2-编写-index-ts-文件\" class=\"headerlink\" title=\"2.编写 index.ts 文件\"></a>2.编写 index.ts 文件</h3><p>首先我们先引入 pinia<br>import { defineStore } from “pinia”;<br>由于 defineStore 也是一个 hooks ，所以说我们可以直接导出一下<br>这样子写是会报错的，因为这个 defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间，我们可以写一个枚举再传值。<br>我们在同级在创建一个名字叫做 store_name.ts 的文件写一个枚举数据导出<br>export const enum Names {<br>  TEST = “TEST”<br>}</p>\n<hr>\n<p>然后在 index.ts 文件中引入一下枚举数据，然后传给这个 defineStore。<br> 这个样子还是报错的，因为还有其他的参数需要传递，第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。<br>state 和之前我们 vuex 里面的写法是不一样的，在 vuex 里面呢，state 是一个对象，但是在 pinia 中，state 必须是一个箭头函数，然后在返回一个对象。<br>getters 模块呢，类似于计算属性，是有缓存的，主要是帮助我们修饰一些值。<br>actions 呢，类似于 methods，帮助我们做一些同步的或者是异步的操作，提交 state 之类的。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/indexts.png\"><br>其实到这个地方为止呢，其实我们已经可以使用 pinia 了，我们写一个页面使用一下 pinia 的值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE1%E7%BB%93%E6%9E%9C.png\"></p>\n<h3 id=\"3-修改-Pinia-的值\"><a href=\"#3-修改-Pinia-的值\" class=\"headerlink\" title=\"3.修改 Pinia 的值\"></a>3.修改 Pinia 的值</h3><p>修改 Pinia 的值有很多中方式，修改 pinia 的值，其实就是修改 state 的值<br>修改值的方式呢，常见的有五种</p>\n<h4 id=\"方式一：直接修改\"><a href=\"#方式一：直接修改\" class=\"headerlink\" title=\"方式一：直接修改\"></a>方式一：直接修改</h4><p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE2%E7%BB%93%E6%9E%9C.png\"></p>\n<h4 id=\"方式二：-patch-函数修改\"><a href=\"#方式二：-patch-函数修改\" class=\"headerlink\" title=\"方式二：$patch 函数修改\"></a>方式二：$patch 函数修改</h4><p>在我们实例化 const userInfo = useInfoStore() 这个 state 的时候，其实这个 userInfo 中，有一个方法，就是 patch 函数，它可以帮助我们批量修改。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE3%E7%BB%93%E6%9E%9C2.png\"></p>\n<h4 id=\"方式三：-patch-函数修改\"><a href=\"#方式三：-patch-函数修改\" class=\"headerlink\" title=\"方式三：$patch 函数修改\"></a>方式三：$patch 函数修改</h4><p>咦，为什么和第二种一样，都是使用 patch 函数来实现修改，是有区别，方式二是在 patch 函数中传入修改的对象值，但是这种方式传入的是一个函数，作用是啥子呢？就是可以进行逻辑操作，比如说判断之类的。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE4%E4%BB%A3%E7%A0%81.png\"><br>效果其实和方式二是一模一样的</p>\n<h4 id=\"方式四：-state-方式\"><a href=\"#方式四：-state-方式\" class=\"headerlink\" title=\"方式四：$state 方式\"></a>方式四：$state 方式</h4><p><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE5%E4%BB%A3%E7%A0%81.png\"></p>\n<h4 id=\"方式五：-action-方式\"><a href=\"#方式五：-action-方式\" class=\"headerlink\" title=\"方式五： action 方式\"></a>方式五： action 方式</h4><p>这个方式我们需要借助 actions 来实现，所以说我们需要去 store 文件夹下的 index.ts 文件中写一个 action<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%811.png\"><br>写完 action 我们就可以使用 action 的方式修改 age 的值了。怎么使用呢，我们只需要使用实例去调用一下我们刚才写的 action 函数就行了。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE6%E7%BB%93%E6%9E%9C2.png\"><br>当然了，这个 action 是可以传参的，我们修改一下 index.ts 文件编写的 action 函数，让他接受一个参数再赋值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE7%E7%BB%93%E6%9E%9C2.png\"><br>以上就是常见的五种修改 state 数据的方式，可以根据自己的实际情况选择使用</p>\n<h1 id=\"pinia-解构\"><a href=\"#pinia-解构\" class=\"headerlink\" title=\"pinia 解构\"></a>pinia 解构</h1><p>上面的案例，我们实例化const userInfo = useInfoStore()了以后呢，这个 userInfo 是可以继续解构操作的<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E4%BB%A3%E7%A0%81.png\"><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE8%E7%BB%93%E6%9E%9C.png\"><br>我们可以看到，结构前和结构后我们在页面都可以获取到数据展示。<br>但是有个问题，就是解构后的数据是不具备响应式的，意思就是我们修改了 state 的值，页面不会跟着变化。<br>做个测试，点击按钮，age 加一，看一下结构前和解构后的数据在页面是否会实时渲染<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png\"><br>在页面分别展示一下解构前和解构后的数据，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE9%E4%BB%A3%E7%A0%81.png\"><br>通过测试我们可以看到，结构前的是可以实时渲染的，但是解构后的话是不可以的， 因为解构后的不是响应式数据。<br>解决这个问题很简单，官方提供了一个方法，可以把解构后的数据转换为响应式的数据。<br>就是 storeToRefs，使用 storeToRefs 需要导入一下。<br>import { storeToRefs } from ‘pinia’<br>然后把我们解构的对象包裹一下就可以了<br>const { name, age } = storeToRefs(userInfo)<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE10%E7%BB%93%E6%9E%9C.png\"><br>或者我们换一个写法，直接操作结构后的数据，记得，要 .value<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%81.png\"></p>\n<h1 id=\"Pinia-的-actions\"><a href=\"#Pinia-的-actions\" class=\"headerlink\" title=\"Pinia 的 actions\"></a>Pinia 的 actions</h1><p>actions 是可以处理同步，也可以处理异步，同步的话相对来说简单一点，上面我们通过 action 修改 state 的时候，就用到了 actions 的同步<br>接下来我们重点介绍一下actions异步<br>actions 异步<br>首先我们模拟一个异步函数，然后我们在 actions 中可以调用这个异步操作，在 actions 处理异步的时候，我们一般是与 async 和 await 连用<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C1.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE11%E7%BB%93%E6%9E%9C2.png\"><br>actions 同步、异步连用<br>这个 actions 里面的方法函数是可以相互调用的，意思就是你 actions 里面有好几个方法，这几个方法是可以调过来调过去的。<br>上面的代码改一下，本来异步模拟获取的 age 数据是 8 ，然后我们调用一个 action 把 age 改成 18。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E4%BB%A3%E7%A0%81.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE12%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"getter-函数\"><a href=\"#getter-函数\" class=\"headerlink\" title=\"getter 函数\"></a>getter 函数</h1><p>getters 类似于 vue 里面的计算属性，可以对已有的数据进行修饰。<br>有两种写法:<br>普通函数方式写法<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%811.png\"><br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E4%BB%A3%E7%A0%812.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下按钮，修改一下 name，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE13%E7%BB%93%E6%9E%9C2.png\"><br>我们可以看见，点击修改 name 之后getter 也会实时的渲染出来<br>相互调用<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E4%BB%A3%E7%A0%81.png\"><br>查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下按钮，修改一下 name和 age，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE14%E7%BB%93%E6%9E%9C2.png\"></p>\n<h1 id=\"API-的使用\"><a href=\"#API-的使用\" class=\"headerlink\" title=\"API 的使用\"></a>API 的使用</h1><p>$reset ：重置到初始值<br>这个 $reset 可以将 state 的数据重置到初始值，比如我们有一个数据，点击按钮改变了，然后我们可以通过这个 API ，将数据恢复到初始状态值。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E4%BB%A3%E7%A0%81.png\"><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C1.png\"><br>然后我们点一下$reset按钮，然后看一下效果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE15%E7%BB%93%E6%9E%9C2.png\"><br>$subscribe：监听 state 数据变化<br>$subscribe 使用来监听的，监听 state 数据的变化，只要 state 里面的数据发生了变化，就会自动走这个函数。<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E4%BB%A3%E7%A0%81.png\"><br>我们点击修改用户按钮，查看一下效果，可以看到<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C1.png\"><br>控制台打印出监听到的变化结果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE16%E7%BB%93%E6%9E%9C2.png\"><br>$onAction：一调用 actions 就触发<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E4%BB%A3%E7%A0%81.png\"><br>控制台打印出监听到的变化结果<br><img src=\"/2022/10/24/Vue3-Pinia%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%9B%BE17%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"Vue3侦听器watch","date":"2022-10-18T10:02:06.000Z","_content":"学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑\n\n# watch 侦听器使用\nwatch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source \n![](侦听器一代码.png)\n上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。\n![](侦听器一结果.png)\n![](侦听器一控制台.png)\n上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。\nwatch API 至少需要指定两个参数: source 和 callback。\n通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。\n\n在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。\n\n案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。\n![](侦听器一数据更新代码.png)\n![](侦听器一数据更新.png)\n我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。\n\n# 侦听器监听 reactive\n![](侦听器监听reactive代码.png)\n![](侦听器监听reactive结果.png)\n在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？\n如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。\n如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。\n![](侦听器二代码.png)\n我们监听对象直接是 num.age， 监听年龄属性值\n![](侦听器二警告.png)\n我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。\n当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。\n![](侦听器二修改代码.png)\n![](侦听器二修改结果.png)\n通过箭头函数，我们就可以实现对象属性的监听。\n很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。\n我们监听深层嵌套的 time 属性值。\n![](侦听器三代码.png)\n发现点击之后没有监听到\n![](侦听器三报错.png)\n这个时候就可以加上 deep 深度监听。\n![](侦听器三修改代码.png)\n加上深度监听 { deep:true }\n![](侦听器三修改结果.png)\n我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。\n\n监听多个参数执行各自逻辑\n比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听\n![](多个侦听器代码.png)\n\n监听多个参数执行相同逻辑\n![](侦听多个参数.png)\n修改 name 和 age 的值\n![](侦听多个参数结果.png)\n\n\n\n","source":"_posts/Vue3侦听器watch.md","raw":"---\ntitle: Vue3侦听器watch\ndate: 2022-10-18 18:02:06\ntags: vue3\ncategories: vue3\n---\n学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑\n\n# watch 侦听器使用\nwatch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source \n![](侦听器一代码.png)\n上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。\n![](侦听器一结果.png)\n![](侦听器一控制台.png)\n上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。\nwatch API 至少需要指定两个参数: source 和 callback。\n通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。\n\n在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。\n\n案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。\n![](侦听器一数据更新代码.png)\n![](侦听器一数据更新.png)\n我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。\n\n# 侦听器监听 reactive\n![](侦听器监听reactive代码.png)\n![](侦听器监听reactive结果.png)\n在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？\n如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。\n如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。\n![](侦听器二代码.png)\n我们监听对象直接是 num.age， 监听年龄属性值\n![](侦听器二警告.png)\n我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。\n当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。\n![](侦听器二修改代码.png)\n![](侦听器二修改结果.png)\n通过箭头函数，我们就可以实现对象属性的监听。\n很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。\n我们监听深层嵌套的 time 属性值。\n![](侦听器三代码.png)\n发现点击之后没有监听到\n![](侦听器三报错.png)\n这个时候就可以加上 deep 深度监听。\n![](侦听器三修改代码.png)\n加上深度监听 { deep:true }\n![](侦听器三修改结果.png)\n我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。\n\n监听多个参数执行各自逻辑\n比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听\n![](多个侦听器代码.png)\n\n监听多个参数执行相同逻辑\n![](侦听多个参数.png)\n修改 name 和 age 的值\n![](侦听多个参数结果.png)\n\n\n\n","slug":"Vue3侦听器watch","published":1,"updated":"2023-03-22T06:25:29.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliq8000g7et8d26if35x","content":"<p>学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑</p>\n<h1 id=\"watch-侦听器使用\"><a href=\"#watch-侦听器使用\" class=\"headerlink\" title=\"watch 侦听器使用\"></a>watch 侦听器使用</h1><p>watch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E4%BB%A3%E7%A0%81.png\"><br>上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%8E%A7%E5%88%B6%E5%8F%B0.png\"><br>上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。<br>watch API 至少需要指定两个参数: source 和 callback。<br>通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。</p>\n<p>在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。</p>\n<p>案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png\"><br>我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。</p>\n<h1 id=\"侦听器监听-reactive\"><a href=\"#侦听器监听-reactive\" class=\"headerlink\" title=\"侦听器监听 reactive\"></a>侦听器监听 reactive</h1><p><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E7%BB%93%E6%9E%9C.png\"><br>在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？<br>如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。<br>如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>我们监听对象直接是 num.age， 监听年龄属性值<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E8%AD%A6%E5%91%8A.png\"><br>我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。<br>当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"><br>通过箭头函数，我们就可以实现对象属性的监听。<br>很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。<br>我们监听深层嵌套的 time 属性值。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br>发现点击之后没有监听到<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E6%8A%A5%E9%94%99.png\"><br>这个时候就可以加上 deep 深度监听。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>加上深度监听 { deep:true }<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"><br>我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。</p>\n<p>监听多个参数执行各自逻辑<br>比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E5%A4%9A%E4%B8%AA%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BB%A3%E7%A0%81.png\"></p>\n<p>监听多个参数执行相同逻辑<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0.png\"><br>修改 name 和 age 的值<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%9C.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>学过 vue2 的小伙伴们肯定学习过侦听器，主要是用来监听页面数据或者是路由的变化，来执行相应的操作，在 vue3里面呢，也有侦听器的用法，功能基本一样。 侦听器是常用的 Vue API 之一，它用于监听一个数据并在数据变动时做一些自定义逻辑</p>\n<h1 id=\"watch-侦听器使用\"><a href=\"#watch-侦听器使用\" class=\"headerlink\" title=\"watch 侦听器使用\"></a>watch 侦听器使用</h1><p>watch API 使用，至少需要指定两个参数： source 和 callback，其中 callback 被明确指定只能为函数，所以不同是用方式的差别其实只在 source<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E4%BB%A3%E7%A0%81.png\"><br>上面的代码是页面上有一个数字，点击按钮一下，数字加一，然后侦听器侦听数字的变化，打印出侦听的最新值和旧值。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%8E%A7%E5%88%B6%E5%8F%B0.png\"><br>上边是 vue3 侦听器的简单案例，侦听器和计算属性一样，可以创建多个侦听器，这个是没有问题的。<br>watch API 至少需要指定两个参数: source 和 callback。<br>通过上边的案例我们看到了，确实是两个，source 是监听的数据，callback是监听回调，那为啥说是至少呢？因为他还有第三个参数 —— 配置对象。</p>\n<p>在 vue2 里面，我们打开页面就想让侦听器立即执行，而不是在第一次数据改变的时候才开始执行，这时候有一个参数叫 immediate ，设置了这个参数，创建第一次就执行，vue3 同样可以使用。</p>\n<p>案例中刷新执行的时候发现，在点击按钮之前，也就是 num 创建的时候，侦听器是没有执行的，所以加上 immediate 参数，就可以让侦听器立即执行操作。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%80%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png\"><br>我们看到，还没有点击按钮让 num 加一的时候，控制台就有数据打印了，为什么呢？就是因为我们加了 immediate 为 true，让侦听器立即执行。控制台输出最新的值也就是我们初始化的值1，旧值没有，所以输出了 undefined。</p>\n<h1 id=\"侦听器监听-reactive\"><a href=\"#侦听器监听-reactive\" class=\"headerlink\" title=\"侦听器监听 reactive\"></a>侦听器监听 reactive</h1><p><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%ACreactive%E7%BB%93%E6%9E%9C.png\"><br>在监听整个 reactive 响应式对象的时候，确实当里面的属性值发生改变了之后可以被侦听器检测到，但是 newVal 和 oldVal 的值都是新的，默认是10，点击之后，新值是 11 很正常，但是旧值不应该是 10 吗？为什么这里旧值和新值一样也是 11 呢？<br>如果监听整个 reactive 数据的话，只能回调到最新的值，获取不到旧的值。<br>如果我修改age属性，我就要获取age旧的值怎么办？其实我们只需要监听num下面的 age 就可以了。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>我们监听对象直接是 num.age， 监听年龄属性值<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E8%AD%A6%E5%91%8A.png\"><br>我们可以看到，侦听器直接报了一个警告，啥意思呢，其实不能直接这样监听。<br>当我们需要监听某个对象属性的时候，我们不能直接对象点属性的方式进行监听，需要传入一个getter方法，也就是箭头函数进行监听。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BA%8C%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"><br>通过箭头函数，我们就可以实现对象属性的监听。<br>很多人说，vue2 在监听对象的时候需要对侦听器设置深度侦听，为什么 vue3 这个不需要呢？因为它监听响应式对象，默认就是深度监听。但是，如果监听的是深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true。<br>我们监听深层嵌套的 time 属性值。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br>发现点击之后没有监听到<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E6%8A%A5%E9%94%99.png\"><br>这个时候就可以加上 deep 深度监听。<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>加上深度监听 { deep:true }<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%99%A8%E4%B8%89%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"><br>我们可以看到打印出信息来了，有一点要注意，深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请要留意性能。</p>\n<p>监听多个参数执行各自逻辑<br>比如说我们需要监听多个参数，假设两个哈，然后每个参数监听到之后，执行的逻辑是不一样的，我们可以创建多个侦听器来分别监听<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E5%A4%9A%E4%B8%AA%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BB%A3%E7%A0%81.png\"></p>\n<p>监听多个参数执行相同逻辑<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0.png\"><br>修改 name 和 age 的值<br><img src=\"/2022/10/18/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8watch/%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"浅析vue项目中npm run dev和npm run serve的区别","date":"2023-03-13T03:03:47.000Z","_content":"# 先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\n通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？\n## 在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\n# 首先看看npm是什么？\nnpm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本\n# 在看看npm install命令\n在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹\n主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下\n# 然后看看运行npm run ×××命令的原理\n大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？\n在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段\n![](npm区别.png)\n***\n我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？\n答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目\n\n# 既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？\n正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？\n我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。\n\n\n\n\n\n\n\n\n","source":"_posts/serve的区别.md","raw":"---\ntitle: 浅析vue项目中npm run dev和npm run serve的区别\ndate: 2023-03-13 11:03:47\ntags: vue\ncategories: 知识点\n---\n# 先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\n通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？\n## 在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\n# 首先看看npm是什么？\nnpm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本\n# 在看看npm install命令\n在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹\n主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下\n# 然后看看运行npm run ×××命令的原理\n大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？\n在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段\n![](npm区别.png)\n***\n我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？\n答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目\n\n# 既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？\n正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？\n我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。\n\n\n\n\n\n\n\n\n","slug":"serve的区别","published":1,"updated":"2023-03-22T06:14:54.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqa000j7et8a2jsai8f","content":"<h1 id=\"先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\"><a href=\"#先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\" class=\"headerlink\" title=\"先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\"></a>先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？</h1><p>通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？</p>\n<h2 id=\"在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\"><a href=\"#在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\" class=\"headerlink\" title=\"在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\"></a>在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。</h2><h1 id=\"首先看看npm是什么？\"><a href=\"#首先看看npm是什么？\" class=\"headerlink\" title=\"首先看看npm是什么？\"></a>首先看看npm是什么？</h1><p>npm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本</p>\n<h1 id=\"在看看npm-install命令\"><a href=\"#在看看npm-install命令\" class=\"headerlink\" title=\"在看看npm install命令\"></a>在看看npm install命令</h1><p>在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹<br>主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下</p>\n<h1 id=\"然后看看运行npm-run-×××命令的原理\"><a href=\"#然后看看运行npm-run-×××命令的原理\" class=\"headerlink\" title=\"然后看看运行npm run ×××命令的原理\"></a>然后看看运行npm run ×××命令的原理</h1><p>大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？<br>在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段<br><img src=\"/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/npm%E5%8C%BA%E5%88%AB.png\"></p>\n<hr>\n<p>我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？<br>答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目</p>\n<h1 id=\"既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？\"><a href=\"#既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？\" class=\"headerlink\" title=\"既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？\"></a>既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？</h1><p>正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？<br>我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\"><a href=\"#先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\" class=\"headerlink\" title=\"先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？\"></a>先做一个提问，你们运行项目的时候使用什么命令来启动项目呢？</h1><p>通常我们在开发前端项目的过程中，经常需要使用npm run dev或者npm run serve命令来启动项目，同样都是启动项目的命令，但是有些时候运行npm run serve会报错，而运行npm run dev则正常运行，那这两者到底有什么区别呢？</p>\n<h2 id=\"在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\"><a href=\"#在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\" class=\"headerlink\" title=\"在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。\"></a>在理解这两者的区别之前，我们应该要理解这两条命令是什么意思。</h2><h1 id=\"首先看看npm是什么？\"><a href=\"#首先看看npm是什么？\" class=\"headerlink\" title=\"首先看看npm是什么？\"></a>首先看看npm是什么？</h1><p>npm实际上是nodejs官方提供的包管理平台，npm提供了一个命令行工具npm-cli，在我们使用npm这个命令时，我们实际是通过node运行一个名为npm-cli.js的脚本</p>\n<h1 id=\"在看看npm-install命令\"><a href=\"#在看看npm-install命令\" class=\"headerlink\" title=\"在看看npm install命令\"></a>在看看npm install命令</h1><p>在构建项目时，通过npm install命令，会在项目目录下生成一个名为node_modules的文件夹<br>主要用于存放包管理工具，下载安装的包的文件夹，也就是项目依赖的外部模块的缓存，比如element-ui，echarts等一些组件库通过npm i 安装之后会被下载复制到node_modules文件夹下</p>\n<h1 id=\"然后看看运行npm-run-×××命令的原理\"><a href=\"#然后看看运行npm-run-×××命令的原理\" class=\"headerlink\" title=\"然后看看运行npm run ×××命令的原理\"></a>然后看看运行npm run ×××命令的原理</h1><p>大家都知道，通过npm run serve 和npm run dev启动项目，可以通过npm run build命令打包项目，那么在运行npm run 时，到底发生了什么呢？<br>在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段<br><img src=\"/2023/03/13/serve%E7%9A%84%E5%8C%BA%E5%88%AB/npm%E5%8C%BA%E5%88%AB.png\"></p>\n<hr>\n<p>我们可以看到，运行npm run serve命令启动项目的项目中，scripts中有一个serve字段，运行npm run dev 命令中存在一个dev字段，那么这时候我们可以大概了解到，在运行npm run命令时，实际上是去package.json这个文件的scripts中寻找对应的×××，然后去执行对应的命令，那么是不是我们想要运行npm run dev命令的话，只需要把scripts中的serve改成dev就能通过npm run dev来启动项目呢？<br>答案是可以，确实将serve改成dev之后，我们运行npm run dev命令可以启动项目</p>\n<h1 id=\"既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？\"><a href=\"#既然可以通过更改字段来进行转换，那为什么会有npm-run-serve-和npm-run-dev这两种模式呢？\" class=\"headerlink\" title=\"既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？\"></a>既然可以通过更改字段来进行转换，那为什么会有npm run serve 和npm run dev这两种模式呢？</h1><p>正如上面我们所说的，运行npm run serve的时候，实际是运行vue-cli-service serve这条命令，在上面介绍中，我们可以看到scripts中，不管serve还是dev对应的命令都是vue-cli-service serve，那么dev和serve到底区别在哪里呢？<br>我们会发现，原来npm run dev和npm run serve本质上是运行vue-cli不同版本下启动项目的脚本，dev在vue-cli2.0中使用，serve在vue-cli3.0中才开始使用。</p>\n"},{"title":"Vue3shallowRef和shallowReactive","date":"2022-10-19T11:20:37.000Z","_content":"# shallowRef 和 shallowReactive\n1. shallowRef 函数，只处理基本类型数据。\n2. shallowReactive 函数，只处理第一层数据。\n3. 两个在使用的时候都需要引入才可以。\nref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。\n但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。\n\n# 深度监听的问题：\n1. 无论 ref 函数还是 reactive 函数都是深度监听。\n2. 如果数据量过大，超级超级消耗性能。\n3. 如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。\n\n# 使用 shallowReactive 非深度监听\n记住一点，shallowReactive 函数，只能处理第一层数据。\n![](shallowReactive一代码.png)\n我们分别点击两个按钮，看一下页面变化。\n![](shallowReactive一代码结果.png)\n通过效果，我们稍微总结一下：\n1. shallowReactive只会包装第一层的数据\n2. 默认情况它只能够监听数据的第一层。\n3. 如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。\n\n# 使用 shallowRef 非深度监听\nshallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。\n![](shallowRef代码.png)\n点击按钮，修改 boy 的值\n![](shallowRef代码结果.png)\n\n有一个问题：shallowRef 函数，只处理基本类型数据吗？\n![](shallowRef二代码.png)\n在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。\n![](shallowRef二代码结果.png)\n所以说呢，shallowRef 函数，只能处理基本类型数据。\n","source":"_posts/Vue3shallowRef和shallowReactive.md","raw":"---\ntitle: Vue3shallowRef和shallowReactive\ndate: 2022-10-19 19:20:37\ntags: vue3\ncategories: vue3\n---\n# shallowRef 和 shallowReactive\n1. shallowRef 函数，只处理基本类型数据。\n2. shallowReactive 函数，只处理第一层数据。\n3. 两个在使用的时候都需要引入才可以。\nref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。\n但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。\n\n# 深度监听的问题：\n1. 无论 ref 函数还是 reactive 函数都是深度监听。\n2. 如果数据量过大，超级超级消耗性能。\n3. 如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。\n\n# 使用 shallowReactive 非深度监听\n记住一点，shallowReactive 函数，只能处理第一层数据。\n![](shallowReactive一代码.png)\n我们分别点击两个按钮，看一下页面变化。\n![](shallowReactive一代码结果.png)\n通过效果，我们稍微总结一下：\n1. shallowReactive只会包装第一层的数据\n2. 默认情况它只能够监听数据的第一层。\n3. 如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。\n\n# 使用 shallowRef 非深度监听\nshallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。\n![](shallowRef代码.png)\n点击按钮，修改 boy 的值\n![](shallowRef代码结果.png)\n\n有一个问题：shallowRef 函数，只处理基本类型数据吗？\n![](shallowRef二代码.png)\n在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。\n![](shallowRef二代码结果.png)\n所以说呢，shallowRef 函数，只能处理基本类型数据。\n","slug":"Vue3shallowRef和shallowReactive","published":1,"updated":"2023-03-22T06:28:05.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqb000p7et80gepcz4y","content":"<h1 id=\"shallowRef-和-shallowReactive\"><a href=\"#shallowRef-和-shallowReactive\" class=\"headerlink\" title=\"shallowRef 和 shallowReactive\"></a>shallowRef 和 shallowReactive</h1><ol>\n<li>shallowRef 函数，只处理基本类型数据。</li>\n<li>shallowReactive 函数，只处理第一层数据。</li>\n<li>两个在使用的时候都需要引入才可以。<br>ref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。<br>但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。</li>\n</ol>\n<h1 id=\"深度监听的问题：\"><a href=\"#深度监听的问题：\" class=\"headerlink\" title=\"深度监听的问题：\"></a>深度监听的问题：</h1><ol>\n<li>无论 ref 函数还是 reactive 函数都是深度监听。</li>\n<li>如果数据量过大，超级超级消耗性能。</li>\n<li>如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。</li>\n</ol>\n<h1 id=\"使用-shallowReactive-非深度监听\"><a href=\"#使用-shallowReactive-非深度监听\" class=\"headerlink\" title=\"使用 shallowReactive 非深度监听\"></a>使用 shallowReactive 非深度监听</h1><p>记住一点，shallowReactive 函数，只能处理第一层数据。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81.png\"><br>我们分别点击两个按钮，看一下页面变化。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"><br>通过效果，我们稍微总结一下：</p>\n<ol>\n<li>shallowReactive只会包装第一层的数据</li>\n<li>默认情况它只能够监听数据的第一层。</li>\n<li>如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。</li>\n</ol>\n<h1 id=\"使用-shallowRef-非深度监听\"><a href=\"#使用-shallowRef-非深度监听\" class=\"headerlink\" title=\"使用 shallowRef 非深度监听\"></a>使用 shallowRef 非深度监听</h1><p>shallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81.png\"><br>点击按钮，修改 boy 的值<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"></p>\n<p>有一个问题：shallowRef 函数，只处理基本类型数据吗？<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"><br>所以说呢，shallowRef 函数，只能处理基本类型数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"shallowRef-和-shallowReactive\"><a href=\"#shallowRef-和-shallowReactive\" class=\"headerlink\" title=\"shallowRef 和 shallowReactive\"></a>shallowRef 和 shallowReactive</h1><ol>\n<li>shallowRef 函数，只处理基本类型数据。</li>\n<li>shallowReactive 函数，只处理第一层数据。</li>\n<li>两个在使用的时候都需要引入才可以。<br>ref 函数和 reactive 函数，他们的作用是将数据转换成响应式的数据，在修改数据的时候，可以将数据实时展示在页面上，基本数据也好，对象也好，都是这样。<br>但是有一个问题呀，我们在把数据改为响应式数据的时候，不管是用 ref 函数还是使用 reactive 函数，它俩都是深度监听，就是 reactive 包裹的对象，就算有100层，也就是连续点一百个属性那种，去修改最深层的数据，也是可以监听到的，这样的话就会存在问题了。</li>\n</ol>\n<h1 id=\"深度监听的问题：\"><a href=\"#深度监听的问题：\" class=\"headerlink\" title=\"深度监听的问题：\"></a>深度监听的问题：</h1><ol>\n<li>无论 ref 函数还是 reactive 函数都是深度监听。</li>\n<li>如果数据量过大，超级超级消耗性能。</li>\n<li>如果我们不需要对数据进行深度监听的时候，就可以使用 shallowRef 函数和 shallowReactive 函数。</li>\n</ol>\n<h1 id=\"使用-shallowReactive-非深度监听\"><a href=\"#使用-shallowReactive-非深度监听\" class=\"headerlink\" title=\"使用 shallowReactive 非深度监听\"></a>使用 shallowReactive 非深度监听</h1><p>记住一点，shallowReactive 函数，只能处理第一层数据。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81.png\"><br>我们分别点击两个按钮，看一下页面变化。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowReactive%E4%B8%80%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"><br>通过效果，我们稍微总结一下：</p>\n<ol>\n<li>shallowReactive只会包装第一层的数据</li>\n<li>默认情况它只能够监听数据的第一层。</li>\n<li>如果想更改多层的数据，必须先更改第一层的数据，然后在去更改其他层的数据。这样视图上的数据才会发生变化。</li>\n</ol>\n<h1 id=\"使用-shallowRef-非深度监听\"><a href=\"#使用-shallowRef-非深度监听\" class=\"headerlink\" title=\"使用 shallowRef 非深度监听\"></a>使用 shallowRef 非深度监听</h1><p>shallowRef 函数，只能处理基本类型数据，为啥呢，因为 shallowRef 函数监听的是.value 变化。并不是第一层的数据的变化。所以如果要更改 shallowRef 创建的数据，应该 xxx.value = XXX。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81.png\"><br>点击按钮，修改 boy 的值<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"></p>\n<p>有一个问题：shallowRef 函数，只处理基本类型数据吗？<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>在这个代码里面，我们用 shallowRef 包裹了一个对象， 然后在页面显示 name 和 age ，然后我们通过按钮修改 name 和 age，看一下页面的效果。<br><img src=\"/2022/10/19/Vue3shallowRef%E5%92%8CshallowReactive/shallowRef%E4%BA%8C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C.png\"><br>所以说呢，shallowRef 函数，只能处理基本类型数据。</p>\n"},{"title":"vue3","date":"2022-10-10T12:17:33.000Z","_content":"# vue3 简介\n1. vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。\n2. 3.0版本的vue，开发周期长达两年多。\n3. 3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。\n# Vue3 的优势\n1. 3比2要快将近两倍。\n2. 3加入了TS以及对PWA的支持。\n3. 3没有beforeCreate、created，用setup代替。\n4. 单独功能可以抽离，比如watch、component。\n5. 没有眼花缭乱的this。\n6. 强大的proxy实现响应式。\n7. 响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。\n8. 3的组合式API可以和2的 optionAPI同时存在。\n9. 代码更利于维护和封装。","source":"_posts/vue3.md","raw":"---\ntitle: vue3\ndate: 2022-10-10 20:17:33\ntags: vue3\ncategories: vue3\n---\n# vue3 简介\n1. vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。\n2. 3.0版本的vue，开发周期长达两年多。\n3. 3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。\n# Vue3 的优势\n1. 3比2要快将近两倍。\n2. 3加入了TS以及对PWA的支持。\n3. 3没有beforeCreate、created，用setup代替。\n4. 单独功能可以抽离，比如watch、component。\n5. 没有眼花缭乱的this。\n6. 强大的proxy实现响应式。\n7. 响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。\n8. 3的组合式API可以和2的 optionAPI同时存在。\n9. 代码更利于维护和封装。","slug":"vue3","published":1,"updated":"2023-03-22T06:24:35.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqc000s7et8g0824j58","content":"<h1 id=\"vue3-简介\"><a href=\"#vue3-简介\" class=\"headerlink\" title=\"vue3 简介\"></a>vue3 简介</h1><ol>\n<li>vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。</li>\n<li>3.0版本的vue，开发周期长达两年多。</li>\n<li>3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。<h1 id=\"Vue3-的优势\"><a href=\"#Vue3-的优势\" class=\"headerlink\" title=\"Vue3 的优势\"></a>Vue3 的优势</h1></li>\n<li>3比2要快将近两倍。</li>\n<li>3加入了TS以及对PWA的支持。</li>\n<li>3没有beforeCreate、created，用setup代替。</li>\n<li>单独功能可以抽离，比如watch、component。</li>\n<li>没有眼花缭乱的this。</li>\n<li>强大的proxy实现响应式。</li>\n<li>响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。</li>\n<li>3的组合式API可以和2的 optionAPI同时存在。</li>\n<li>代码更利于维护和封装。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue3-简介\"><a href=\"#vue3-简介\" class=\"headerlink\" title=\"vue3 简介\"></a>vue3 简介</h1><ol>\n<li>vue3提供了更好的性能，更小的捆绑包体积，更好的TS集成，用于处理大规模用例的新 API。</li>\n<li>3.0版本的vue，开发周期长达两年多。</li>\n<li>3.0的发布，标志着此框架整体呈现出可用状态，尽管框架的某些子项目可能仍需要进一步开发才能打发哦稳定状态，特别是路由和VUEX的集成，不过现在仍然是开始使用vue3启动新项目的合适时机。<h1 id=\"Vue3-的优势\"><a href=\"#Vue3-的优势\" class=\"headerlink\" title=\"Vue3 的优势\"></a>Vue3 的优势</h1></li>\n<li>3比2要快将近两倍。</li>\n<li>3加入了TS以及对PWA的支持。</li>\n<li>3没有beforeCreate、created，用setup代替。</li>\n<li>单独功能可以抽离，比如watch、component。</li>\n<li>没有眼花缭乱的this。</li>\n<li>强大的proxy实现响应式。</li>\n<li>响应式方面，性能得到了很大的提升、不用初始化的时候就递归遍历属性。</li>\n<li>3的组合式API可以和2的 optionAPI同时存在。</li>\n<li>代码更利于维护和封装。</li>\n</ol>\n"},{"title":"component动态组件","date":"2023-03-23T13:27:48.000Z","_content":"# 一、什么是动态组件？\n定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。\n书写形式：<component :is=\"componentName\"></component>\n内置组件：\ncomponent：是vue里面的一个内置组件。作用是：配合is动态渲染组件。\nvue内置的组件还包括：\ntransition：作为单个元素/组件的过渡效果。\ntransition-group：作为多个元素/组件的过渡效果。\nkeep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\nslot：作为组件模板之中的内容分发插槽。\n# 二、使用方式\n通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。\n如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。\n1.在不同组件之间进行动态切换\ncomponent动态组件就是通过控制currentTabComponent来切换不同的组件。\n<div @click=\"reload\">点击切换</div> \n<component :is=\"currentTabComponent\"></component>\n<script>\nimport childOne from './childOne'\nimport childTwo from './childTwo'\nexport default {\n    componets:{\n        childOne,\n        childTwo\n    },\n    data(){\n        currentTabComponent: 'childOne'\n    },\n    methods:{\n        reload(){\n            this.currentTabComponent = 'childTwo'\n        }\n    }\n}\n</script>\n\n# 三、动态组件的缓存\n使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n<keep-alive>\n    <component :is=\"componentName\"></component>\n</keep-alive>\n","source":"_posts/component动态组件.md","raw":"---\ntitle: component动态组件\ndate: 2023-03-23 21:27:48\ntags: vue\ncategories: 知识点\n---\n# 一、什么是动态组件？\n定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。\n书写形式：<component :is=\"componentName\"></component>\n内置组件：\ncomponent：是vue里面的一个内置组件。作用是：配合is动态渲染组件。\nvue内置的组件还包括：\ntransition：作为单个元素/组件的过渡效果。\ntransition-group：作为多个元素/组件的过渡效果。\nkeep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\nslot：作为组件模板之中的内容分发插槽。\n# 二、使用方式\n通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。\n如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。\n1.在不同组件之间进行动态切换\ncomponent动态组件就是通过控制currentTabComponent来切换不同的组件。\n<div @click=\"reload\">点击切换</div> \n<component :is=\"currentTabComponent\"></component>\n<script>\nimport childOne from './childOne'\nimport childTwo from './childTwo'\nexport default {\n    componets:{\n        childOne,\n        childTwo\n    },\n    data(){\n        currentTabComponent: 'childOne'\n    },\n    methods:{\n        reload(){\n            this.currentTabComponent = 'childTwo'\n        }\n    }\n}\n</script>\n\n# 三、动态组件的缓存\n使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n<keep-alive>\n    <component :is=\"componentName\"></component>\n</keep-alive>\n","slug":"component动态组件","published":1,"updated":"2023-03-25T05:35:57.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqe000x7et8952hb7rx","content":"<h1 id=\"一、什么是动态组件？\"><a href=\"#一、什么是动态组件？\" class=\"headerlink\" title=\"一、什么是动态组件？\"></a>一、什么是动态组件？</h1><p>定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。<br>书写形式：<component :is=\"componentName\"></component><br>内置组件：<br>component：是vue里面的一个内置组件。作用是：配合is动态渲染组件。<br>vue内置的组件还包括：<br>transition：作为单个元素/组件的过渡效果。<br>transition-group：作为多个元素/组件的过渡效果。<br>keep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。<br>slot：作为组件模板之中的内容分发插槽。</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。<br>如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。<br>1.在不同组件之间进行动态切换<br>component动态组件就是通过控制currentTabComponent来切换不同的组件。</p>\n<div @click=\"reload\">点击切换</div> \n<component :is=\"currentTabComponent\"></component>\n<script>\nimport childOne from './childOne'\nimport childTwo from './childTwo'\nexport default {\n    componets:{\n        childOne,\n        childTwo\n    },\n    data(){\n        currentTabComponent: 'childOne'\n    },\n    methods:{\n        reload(){\n            this.currentTabComponent = 'childTwo'\n        }\n    }\n}\n</script>\n\n<h1 id=\"三、动态组件的缓存\"><a href=\"#三、动态组件的缓存\" class=\"headerlink\" title=\"三、动态组件的缓存\"></a>三、动态组件的缓存</h1><p>使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br><keep-alive><br>    <component :is=\"componentName\"></component><br></keep-alive></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、什么是动态组件？\"><a href=\"#一、什么是动态组件？\" class=\"headerlink\" title=\"一、什么是动态组件？\"></a>一、什么是动态组件？</h1><p>定义:多个组件挂载到同一个组件上，通过参数动态的切换不同组件就是动态组件。<br>书写形式：<component :is=\"componentName\"></component><br>内置组件：<br>component：是vue里面的一个内置组件。作用是：配合is动态渲染组件。<br>vue内置的组件还包括：<br>transition：作为单个元素/组件的过渡效果。<br>transition-group：作为多个元素/组件的过渡效果。<br>keep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。<br>slot：作为组件模板之中的内容分发插槽。</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>通过使用<component>元素动态的绑定到它的is特性，来实现动态组件的切换。<br>如果is匹配不到相应的组件的时候是不尽行任何dom元素的渲染的。<br>1.在不同组件之间进行动态切换<br>component动态组件就是通过控制currentTabComponent来切换不同的组件。</p>\n<div @click=\"reload\">点击切换</div> \n<component :is=\"currentTabComponent\"></component>\n<script>\nimport childOne from './childOne'\nimport childTwo from './childTwo'\nexport default {\n    componets:{\n        childOne,\n        childTwo\n    },\n    data(){\n        currentTabComponent: 'childOne'\n    },\n    methods:{\n        reload(){\n            this.currentTabComponent = 'childTwo'\n        }\n    }\n}\n</script>\n\n<h1 id=\"三、动态组件的缓存\"><a href=\"#三、动态组件的缓存\" class=\"headerlink\" title=\"三、动态组件的缓存\"></a>三、动态组件的缓存</h1><p>使用动态组件来回切换时，组件是要被销毁的，若不想让数据销毁可以使用<keep-alive>，它可以包裹动态组件，会缓存不活动的组件实例，这样就不会被销毁。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br><keep-alive><br>    <component :is=\"componentName\"></component><br></keep-alive></p>\n"},{"title":"Vue3setup函数","date":"2022-10-13T02:45:33.000Z","_content":"# vue2 和 vue3 开发的区别\n首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。\n\nvue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。\n\n# 使用 setup 原因\n在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。\n\n为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。\n\n# setup 用法\n1. setup 函数是组合式 API 的入口。\n2. setup 函数是启动页面后自动执行的函数。\n3. 页面中所涉及的变量和方法等，都需要写在 setup 函数中。\n4. 在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。\n5. setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。\n\n# setup 可以接受哪些参数\nsetup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。\n\n# setup 函数定义变量\n组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。\n\n## 定义一个基本类型变量\n在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。\n![](基本变量.png)\n\n上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。\n![](名称渲染失败.png)\n![](提示找不到.png)\n\n出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。\n![](name.png)\n将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。\n![](渲染成功.png)\n\n同样，创建其他基本类型也是一样的编写方式。\n![](基本数据代码.png)\n切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。\n![](基本数据类型.png)\n\n## setup 创建复杂数据类型\nsetup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。\n![](复杂数据代码.png)\n刷新页面，渲染正常\n![](复杂数据类型.png)\n\n# setup 创建方法\n除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。\n创建方法的方式有两种：\n## 第一种就是很常见的通过 function 的方式创建\n    // 一、通过 function 的方式创建\n        function btn() {\n            console.log('按钮被点击了')\n        }\n## 另一种使用过箭头函数的方式创建\n      // 二、通过箭头函数的方式创建\n      const btn = () => {\n        console.log('按钮被点击了')\n      }\n例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。\n![](点击代码.png)\n保存代码，刷新页面，点击按钮在控制台输出内容。\n![](被点击.png)","source":"_posts/Vue3setup函数.md","raw":"---\ntitle: Vue3setup函数\ndate: 2022-10-13 10:45:33\ntags: vue3\ncategories: vue3\n---\n# vue2 和 vue3 开发的区别\n首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。\n\nvue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。\n\n# 使用 setup 原因\n在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。\n\n为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。\n\n# setup 用法\n1. setup 函数是组合式 API 的入口。\n2. setup 函数是启动页面后自动执行的函数。\n3. 页面中所涉及的变量和方法等，都需要写在 setup 函数中。\n4. 在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。\n5. setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。\n\n# setup 可以接受哪些参数\nsetup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。\n\n# setup 函数定义变量\n组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。\n\n## 定义一个基本类型变量\n在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。\n![](基本变量.png)\n\n上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。\n![](名称渲染失败.png)\n![](提示找不到.png)\n\n出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。\n![](name.png)\n将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。\n![](渲染成功.png)\n\n同样，创建其他基本类型也是一样的编写方式。\n![](基本数据代码.png)\n切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。\n![](基本数据类型.png)\n\n## setup 创建复杂数据类型\nsetup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。\n![](复杂数据代码.png)\n刷新页面，渲染正常\n![](复杂数据类型.png)\n\n# setup 创建方法\n除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。\n创建方法的方式有两种：\n## 第一种就是很常见的通过 function 的方式创建\n    // 一、通过 function 的方式创建\n        function btn() {\n            console.log('按钮被点击了')\n        }\n## 另一种使用过箭头函数的方式创建\n      // 二、通过箭头函数的方式创建\n      const btn = () => {\n        console.log('按钮被点击了')\n      }\n例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。\n![](点击代码.png)\n保存代码，刷新页面，点击按钮在控制台输出内容。\n![](被点击.png)","slug":"Vue3setup函数","published":1,"updated":"2023-03-22T06:27:38.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqe00107et850mt59yy","content":"<h1 id=\"vue2-和-vue3-开发的区别\"><a href=\"#vue2-和-vue3-开发的区别\" class=\"headerlink\" title=\"vue2 和 vue3 开发的区别\"></a>vue2 和 vue3 开发的区别</h1><p>首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。</p>\n<p>vue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。</p>\n<h1 id=\"使用-setup-原因\"><a href=\"#使用-setup-原因\" class=\"headerlink\" title=\"使用 setup 原因\"></a>使用 setup 原因</h1><p>在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。</p>\n<p>为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。</p>\n<h1 id=\"setup-用法\"><a href=\"#setup-用法\" class=\"headerlink\" title=\"setup 用法\"></a>setup 用法</h1><ol>\n<li>setup 函数是组合式 API 的入口。</li>\n<li>setup 函数是启动页面后自动执行的函数。</li>\n<li>页面中所涉及的变量和方法等，都需要写在 setup 函数中。</li>\n<li>在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。</li>\n<li>setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。</li>\n</ol>\n<h1 id=\"setup-可以接受哪些参数\"><a href=\"#setup-可以接受哪些参数\" class=\"headerlink\" title=\"setup 可以接受哪些参数\"></a>setup 可以接受哪些参数</h1><p>setup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。</p>\n<h1 id=\"setup-函数定义变量\"><a href=\"#setup-函数定义变量\" class=\"headerlink\" title=\"setup 函数定义变量\"></a>setup 函数定义变量</h1><p>组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。</p>\n<h2 id=\"定义一个基本类型变量\"><a href=\"#定义一个基本类型变量\" class=\"headerlink\" title=\"定义一个基本类型变量\"></a>定义一个基本类型变量</h2><p>在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F.png\"></p>\n<p>上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%90%8D%E7%A7%B0%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5.png\"><br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0.png\"></p>\n<p>出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/name.png\"><br>将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%B8%B2%E6%9F%93%E6%88%90%E5%8A%9F.png\"></p>\n<p>同样，创建其他基本类型也是一样的编写方式。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\"></p>\n<h2 id=\"setup-创建复杂数据类型\"><a href=\"#setup-创建复杂数据类型\" class=\"headerlink\" title=\"setup 创建复杂数据类型\"></a>setup 创建复杂数据类型</h2><p>setup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，渲染正常<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\"></p>\n<h1 id=\"setup-创建方法\"><a href=\"#setup-创建方法\" class=\"headerlink\" title=\"setup 创建方法\"></a>setup 创建方法</h1><p>除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。<br>创建方法的方式有两种：</p>\n<h2 id=\"第一种就是很常见的通过-function-的方式创建\"><a href=\"#第一种就是很常见的通过-function-的方式创建\" class=\"headerlink\" title=\"第一种就是很常见的通过 function 的方式创建\"></a>第一种就是很常见的通过 function 的方式创建</h2><pre><code class=\"hljs\">// 一、通过 function 的方式创建\n    function btn() &#123;\n        console.log(&#39;按钮被点击了&#39;)\n    &#125;\n</code></pre>\n<h2 id=\"另一种使用过箭头函数的方式创建\"><a href=\"#另一种使用过箭头函数的方式创建\" class=\"headerlink\" title=\"另一种使用过箭头函数的方式创建\"></a>另一种使用过箭头函数的方式创建</h2><pre><code class=\"hljs\">  // 二、通过箭头函数的方式创建\n  const btn = () =&gt; &#123;\n    console.log(&#39;按钮被点击了&#39;)\n  &#125;\n</code></pre>\n<p>例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E7%82%B9%E5%87%BB%E4%BB%A3%E7%A0%81.png\"><br>保存代码，刷新页面，点击按钮在控制台输出内容。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E8%A2%AB%E7%82%B9%E5%87%BB.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue2-和-vue3-开发的区别\"><a href=\"#vue2-和-vue3-开发的区别\" class=\"headerlink\" title=\"vue2 和 vue3 开发的区别\"></a>vue2 和 vue3 开发的区别</h1><p>首先，目前来说 vue3 发布已经有一段时间了，但是呢，由于还处于优化完善阶段，对于 vue3 开发项目的需求不是很高，主要还是以 vue2 开发为主，但是相信，vue3 进行项目开发是大势所趋。</p>\n<p>vue2 开发项目过程中，会存在代码冗余和结构杂乱问题，这是 vue3 主要解决的问题，vue3 可以将相关功能的代码抽离分割在一起，方便开发者快速阅读，提高项目代码的可读性和可维护性。</p>\n<h1 id=\"使用-setup-原因\"><a href=\"#使用-setup-原因\" class=\"headerlink\" title=\"使用 setup 原因\"></a>使用 setup 原因</h1><p>在 vue3 版本中，引入了一个新的函数，叫做 setup，引入他的原因总结一下主要原因是：为了使用组合式 API，setup 函数是 Composition 的入口。</p>\n<p>为什么不继续使用 vue2 当中的选项 API 了呢，原因也很简单，像 data、computed、methods、watch 在组织逻辑大多数的情况下都是没有问题的，但是当组件逻辑变得更加丰富，那么逻辑处理关注点就会越来越多，很容易导致组件阅读和维护成本提高，通过 setup 函数能够将该部分逻辑抽离成函数，让开发者不必在关心该部分的逻辑问题。</p>\n<h1 id=\"setup-用法\"><a href=\"#setup-用法\" class=\"headerlink\" title=\"setup 用法\"></a>setup 用法</h1><ol>\n<li>setup 函数是组合式 API 的入口。</li>\n<li>setup 函数是启动页面后自动执行的函数。</li>\n<li>页面中所涉及的变量和方法等，都需要写在 setup 函数中。</li>\n<li>在 setup 中定义的变量、方法需要通过 return 返回出去才可以使用，否则无法在视图中使用。</li>\n<li>setup 函数位于 created 和 beforCreated 钩子之前，用来代替这两个钩子。</li>\n</ol>\n<h1 id=\"setup-可以接受哪些参数\"><a href=\"#setup-可以接受哪些参数\" class=\"headerlink\" title=\"setup 可以接受哪些参数\"></a>setup 可以接受哪些参数</h1><p>setup 函数可以接受 props、context，其中， props 由于是响应式数据，不能直接解构赋值，context 不是响应式数据，可以通过解构赋值，setup 函数必须返回一个对象，只要返回对象，便可以像 vue2 的方式一样使用返回的属性或方法。</p>\n<h1 id=\"setup-函数定义变量\"><a href=\"#setup-函数定义变量\" class=\"headerlink\" title=\"setup 函数定义变量\"></a>setup 函数定义变量</h1><p>组件中所有的变量都要在 setup 函数中定义，并且需要在 setup 函数最后通过 return 返回，才可以像 vue2 一样在模板中使用。</p>\n<h2 id=\"定义一个基本类型变量\"><a href=\"#定义一个基本类型变量\" class=\"headerlink\" title=\"定义一个基本类型变量\"></a>定义一个基本类型变量</h2><p>在 setup 函数中，创建一个 name 参数，并且在页面中渲染该字段的内容。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F.png\"></p>\n<p>上面的代码编写完成，保存刷新页面，发现名称渲染出现问题，展示不出来，同时控制台报错告警。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%90%8D%E7%A7%B0%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5.png\"><br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0.png\"></p>\n<p>出现这个问题的原因其实很简单，如果从 vue2 转到 vue3 ,很容易就遇到这种问题，因为上面提到过，在 setup 中创建的变量需要在 setup 函数最后通过 return 返回，才可以使用。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/name.png\"><br>将创建的 name 参数抛出后，重新保存刷新页面，数据渲染就正常了。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E6%B8%B2%E6%9F%93%E6%88%90%E5%8A%9F.png\"></p>\n<p>同样，创建其他基本类型也是一样的编写方式。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>切记，声明的变量如果需要在页面中展示，必须使用 return 将声明的变量抛出。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\"></p>\n<h2 id=\"setup-创建复杂数据类型\"><a href=\"#setup-创建复杂数据类型\" class=\"headerlink\" title=\"setup 创建复杂数据类型\"></a>setup 创建复杂数据类型</h2><p>setup 函数创建复杂数据类型，例如数组，对象之类的和基本数据类型相同，也是必须通过 return 抛出后，才可以在页面中使用。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，渲染正常<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\"></p>\n<h1 id=\"setup-创建方法\"><a href=\"#setup-创建方法\" class=\"headerlink\" title=\"setup 创建方法\"></a>setup 创建方法</h1><p>除了变量，方法也是需要写在 setup 函数当中的，同时和变量一样，需要 return 抛出才可以使用。<br>创建方法的方式有两种：</p>\n<h2 id=\"第一种就是很常见的通过-function-的方式创建\"><a href=\"#第一种就是很常见的通过-function-的方式创建\" class=\"headerlink\" title=\"第一种就是很常见的通过 function 的方式创建\"></a>第一种就是很常见的通过 function 的方式创建</h2><pre><code>// 一、通过 function 的方式创建\n    function btn() &#123;\n        console.log(&#39;按钮被点击了&#39;)\n    &#125;\n</code></pre>\n<h2 id=\"另一种使用过箭头函数的方式创建\"><a href=\"#另一种使用过箭头函数的方式创建\" class=\"headerlink\" title=\"另一种使用过箭头函数的方式创建\"></a>另一种使用过箭头函数的方式创建</h2><pre><code>  // 二、通过箭头函数的方式创建\n  const btn = () =&gt; &#123;\n    console.log(&#39;按钮被点击了&#39;)\n  &#125;\n</code></pre>\n<p>例如：在页面添加一个按钮，点击按钮打印一段话在控制台输出。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E7%82%B9%E5%87%BB%E4%BB%A3%E7%A0%81.png\"><br>保存代码，刷新页面，点击按钮在控制台输出内容。<br><img src=\"/2022/10/13/Vue3setup%E5%87%BD%E6%95%B0/%E8%A2%AB%E7%82%B9%E5%87%BB.png\"></p>\n"},{"title":"vue3API","date":"2022-12-13T13:10:12.000Z","_content":"为什么要使用setup组合?\nVue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。\n\nVue3中使用 setup 是如何解决这一问题的呢？\n第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；\n第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。\n\n1、ref\n作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。\n背后：ref 的背后是使用 reactive 来实现的响应式.\n语法：const x = ref(100)\n访问：在 setup 中使用 .value 来访问。\n![](案例1.png)\n\n2、isRef\n作用：判断一个变量是否为一个ref对象。\n语法：const bol = isRef(x)\n![](案例2.png)\n\n3、unref\n作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。\n语法：const x = unref(y)\n![](案例3.png)\n\n4、customRef\n作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。\n![](案例4.png)\n\n5、toRef\n作用：把一个 reactive对象中的某个属性变成 ref 变量。\n语法：const x = toRef(reactive(obj), 'key') // x.value\n![](案例5.png)\n\n6、toRefs\n作用：把一个reactive响应式对象变成ref变量。\n语法：const obj1 = toRefs(reactive(obj))\n应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。\n![](案例6.png)\n\n7、shallowRef\n作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)\n语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。\n![](案例7.png)\n\n8、triggerRef\n作用：强制更新一个 shallowRef对象的渲染。\n语法：triggerRef(shallowRef对象)\n参考代码：见shallowRef示例。\n\n9、reactive\n作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。\n语法：const info = reactive([] | {})\n![](案例9.png)\n\n10、readonly\n作用：把一个对象，变成只读的。\n语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)\n![](案例10.png)\n\n11、isReadonly\n作用: 判断一个变量是不是只读的。\n语法：const bol = isReadonly(变量)\n![](案例11.png)\n\n12、isReactive\n作用：判断一变量是不是 reactive的。\n注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。\n![](案例12.png)\n\n13、isProxy\n作用：判断一个变量是不是 readonly 或 reactive的。\n![](案例13.png)\n\n14、toRaw\n作用：得到返回 reactive变量或 readonly变量的\"原始对象\"。\n语法:：const raw = toRaw(reactive变量或readonly变量)\n说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。\n![](案例14.png)\n\n15、markRaw\n作用：把一个普通对象标记成\"永久原始\"，从此将无法再变成proxy了。\n语法：const raw = markRaw({a,b})\n![](案例15.png)\n\n16、shallowReactive\n作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。\n语法：const obj = shallowReactive({a:{b:9}})\n![](案例16.png)\n\n17、shallowReadonly\n作用：定义一个reactive变量，只有第一层是只读的。\n语法：const obj = shallowReadonly({a:{b:9}})\n![](案例17.png)\n\n18、computed\n作用：对响应式变量进行缓存计算。\n语法：const c = computed(fn / {get,set})\n![](案例18.png)\n\n19、watch\n作用：用于监听响应式变量的变化，组件初始化时，它不执行。\n语法：const stop = watch(x, (new,old)=>{})，调用stop() 可以停止监听。\n语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=>{})，调用stop()可以停止监听。\n![](案例19.png)\n\n20、watchEffect\n作用：相当于是 react中的 useEffect()，用于执行各种副作用。\n语法：const stop = watchEffect(fn)，默认其 flush:'pre'，前置执行的副作用。\nwatchPostEffect，等价于 watchEffect(fn, {flush:'post'})，后置执行的副作用。\nwatchSyncEffect，等价于 watchEffect(fn, {flush:'sync'})，同步执行的副作用。\n特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。\n![](案例20.png)\n\n21、生命周期钩子\n选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。\n选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。\n新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。\n在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。\n![](案例21.png)\n\n22、provide / inject\n作用：在组件树中自上而下地传递数据.\n语法：provide('key', value)\n语法：const value = inject('key', '默认值')\n![](案例22.png)\n\n23、getCurrentInstance\n作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。\n语法：const app = getCurrentInstance()\n场景：常用于访问 app.config.globalProperties 上的全局数据。\n![](案例23.png)\n\n24、关于setup代码范式\n只使用 setup 及组合API，不要再使用vue选项了。\n有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。\n能用 vite就尽量使用vite，能用ts 就尽量使用ts。\n\n","source":"_posts/vue3API.md","raw":"---\ntitle: vue3API\ndate: 2022-12-13 21:10:12\ntags: vue3\ncategories: vue3\n---\n为什么要使用setup组合?\nVue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。\n\nVue3中使用 setup 是如何解决这一问题的呢？\n第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；\n第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。\n\n1、ref\n作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。\n背后：ref 的背后是使用 reactive 来实现的响应式.\n语法：const x = ref(100)\n访问：在 setup 中使用 .value 来访问。\n![](案例1.png)\n\n2、isRef\n作用：判断一个变量是否为一个ref对象。\n语法：const bol = isRef(x)\n![](案例2.png)\n\n3、unref\n作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。\n语法：const x = unref(y)\n![](案例3.png)\n\n4、customRef\n作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。\n![](案例4.png)\n\n5、toRef\n作用：把一个 reactive对象中的某个属性变成 ref 变量。\n语法：const x = toRef(reactive(obj), 'key') // x.value\n![](案例5.png)\n\n6、toRefs\n作用：把一个reactive响应式对象变成ref变量。\n语法：const obj1 = toRefs(reactive(obj))\n应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。\n![](案例6.png)\n\n7、shallowRef\n作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)\n语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。\n![](案例7.png)\n\n8、triggerRef\n作用：强制更新一个 shallowRef对象的渲染。\n语法：triggerRef(shallowRef对象)\n参考代码：见shallowRef示例。\n\n9、reactive\n作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。\n语法：const info = reactive([] | {})\n![](案例9.png)\n\n10、readonly\n作用：把一个对象，变成只读的。\n语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)\n![](案例10.png)\n\n11、isReadonly\n作用: 判断一个变量是不是只读的。\n语法：const bol = isReadonly(变量)\n![](案例11.png)\n\n12、isReactive\n作用：判断一变量是不是 reactive的。\n注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。\n![](案例12.png)\n\n13、isProxy\n作用：判断一个变量是不是 readonly 或 reactive的。\n![](案例13.png)\n\n14、toRaw\n作用：得到返回 reactive变量或 readonly变量的\"原始对象\"。\n语法:：const raw = toRaw(reactive变量或readonly变量)\n说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。\n![](案例14.png)\n\n15、markRaw\n作用：把一个普通对象标记成\"永久原始\"，从此将无法再变成proxy了。\n语法：const raw = markRaw({a,b})\n![](案例15.png)\n\n16、shallowReactive\n作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。\n语法：const obj = shallowReactive({a:{b:9}})\n![](案例16.png)\n\n17、shallowReadonly\n作用：定义一个reactive变量，只有第一层是只读的。\n语法：const obj = shallowReadonly({a:{b:9}})\n![](案例17.png)\n\n18、computed\n作用：对响应式变量进行缓存计算。\n语法：const c = computed(fn / {get,set})\n![](案例18.png)\n\n19、watch\n作用：用于监听响应式变量的变化，组件初始化时，它不执行。\n语法：const stop = watch(x, (new,old)=>{})，调用stop() 可以停止监听。\n语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=>{})，调用stop()可以停止监听。\n![](案例19.png)\n\n20、watchEffect\n作用：相当于是 react中的 useEffect()，用于执行各种副作用。\n语法：const stop = watchEffect(fn)，默认其 flush:'pre'，前置执行的副作用。\nwatchPostEffect，等价于 watchEffect(fn, {flush:'post'})，后置执行的副作用。\nwatchSyncEffect，等价于 watchEffect(fn, {flush:'sync'})，同步执行的副作用。\n特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。\n![](案例20.png)\n\n21、生命周期钩子\n选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。\n选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。\n新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。\n在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。\n![](案例21.png)\n\n22、provide / inject\n作用：在组件树中自上而下地传递数据.\n语法：provide('key', value)\n语法：const value = inject('key', '默认值')\n![](案例22.png)\n\n23、getCurrentInstance\n作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。\n语法：const app = getCurrentInstance()\n场景：常用于访问 app.config.globalProperties 上的全局数据。\n![](案例23.png)\n\n24、关于setup代码范式\n只使用 setup 及组合API，不要再使用vue选项了。\n有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。\n能用 vite就尽量使用vite，能用ts 就尽量使用ts。\n\n","slug":"vue3API","published":1,"updated":"2022-12-19T08:43:34.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqg00157et84hv6b4kx","content":"<p>为什么要使用setup组合?<br>Vue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。</p>\n<p>Vue3中使用 setup 是如何解决这一问题的呢？<br>第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；<br>第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。</p>\n<p>1、ref<br>作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。<br>背后：ref 的背后是使用 reactive 来实现的响应式.<br>语法：const x = ref(100)<br>访问：在 setup 中使用 .value 来访问。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B1.png\"></p>\n<p>2、isRef<br>作用：判断一个变量是否为一个ref对象。<br>语法：const bol = isRef(x)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B2.png\"></p>\n<p>3、unref<br>作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。<br>语法：const x = unref(y)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B3.png\"></p>\n<p>4、customRef<br>作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B4.png\"></p>\n<p>5、toRef<br>作用：把一个 reactive对象中的某个属性变成 ref 变量。<br>语法：const x = toRef(reactive(obj), ‘key’) // x.value<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B5.png\"></p>\n<p>6、toRefs<br>作用：把一个reactive响应式对象变成ref变量。<br>语法：const obj1 = toRefs(reactive(obj))<br>应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B6.png\"></p>\n<p>7、shallowRef<br>作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)<br>语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B7.png\"></p>\n<p>8、triggerRef<br>作用：强制更新一个 shallowRef对象的渲染。<br>语法：triggerRef(shallowRef对象)<br>参考代码：见shallowRef示例。</p>\n<p>9、reactive<br>作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。<br>语法：const info = reactive([] | {})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B9.png\"></p>\n<p>10、readonly<br>作用：把一个对象，变成只读的。<br>语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B10.png\"></p>\n<p>11、isReadonly<br>作用: 判断一个变量是不是只读的。<br>语法：const bol = isReadonly(变量)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B11.png\"></p>\n<p>12、isReactive<br>作用：判断一变量是不是 reactive的。<br>注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B12.png\"></p>\n<p>13、isProxy<br>作用：判断一个变量是不是 readonly 或 reactive的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B13.png\"></p>\n<p>14、toRaw<br>作用：得到返回 reactive变量或 readonly变量的”原始对象”。<br>语法:：const raw = toRaw(reactive变量或readonly变量)<br>说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B14.png\"></p>\n<p>15、markRaw<br>作用：把一个普通对象标记成”永久原始”，从此将无法再变成proxy了。<br>语法：const raw = markRaw({a,b})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B15.png\"></p>\n<p>16、shallowReactive<br>作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。<br>语法：const obj = shallowReactive({a:{b:9}})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B16.png\"></p>\n<p>17、shallowReadonly<br>作用：定义一个reactive变量，只有第一层是只读的。<br>语法：const obj = shallowReadonly({a:{b:9}})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B17.png\"></p>\n<p>18、computed<br>作用：对响应式变量进行缓存计算。<br>语法：const c = computed(fn / {get,set})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B18.png\"></p>\n<p>19、watch<br>作用：用于监听响应式变量的变化，组件初始化时，它不执行。<br>语法：const stop = watch(x, (new,old)=&gt;{})，调用stop() 可以停止监听。<br>语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=&gt;{})，调用stop()可以停止监听。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B19.png\"></p>\n<p>20、watchEffect<br>作用：相当于是 react中的 useEffect()，用于执行各种副作用。<br>语法：const stop = watchEffect(fn)，默认其 flush:’pre’，前置执行的副作用。<br>watchPostEffect，等价于 watchEffect(fn, {flush:’post’})，后置执行的副作用。<br>watchSyncEffect，等价于 watchEffect(fn, {flush:’sync’})，同步执行的副作用。<br>特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B20.png\"></p>\n<p>21、生命周期钩子<br>选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。<br>选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。<br>新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。<br>在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B21.png\"></p>\n<p>22、provide / inject<br>作用：在组件树中自上而下地传递数据.<br>语法：provide(‘key’, value)<br>语法：const value = inject(‘key’, ‘默认值’)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B22.png\"></p>\n<p>23、getCurrentInstance<br>作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。<br>语法：const app = getCurrentInstance()<br>场景：常用于访问 app.config.globalProperties 上的全局数据。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B23.png\"></p>\n<p>24、关于setup代码范式<br>只使用 setup 及组合API，不要再使用vue选项了。<br>有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。<br>能用 vite就尽量使用vite，能用ts 就尽量使用ts。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为什么要使用setup组合?<br>Vue3 中新增的 setup，目的是为了解决 Vue2 中“数据和业务逻辑不分离”的问题。</p>\n<p>Vue3中使用 setup 是如何解决这一问题的呢？<br>第1步: 用setup组合API 替换 vue2 中的data/computed/watch/methods等选项；<br>第2步: 把setup中相关联的功能封装成一个个可独立可维护的hooks。</p>\n<p>1、ref<br>作用：一般用于定义基本数据类型数据，比如 String / Boolean / Number等。<br>背后：ref 的背后是使用 reactive 来实现的响应式.<br>语法：const x = ref(100)<br>访问：在 setup 中使用 .value 来访问。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B1.png\"></p>\n<p>2、isRef<br>作用：判断一个变量是否为一个ref对象。<br>语法：const bol = isRef(x)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B2.png\"></p>\n<p>3、unref<br>作用：用于返回一个值，如果访问的是ref变量，就返回其 .value值；如果不是 ref变量，就直接返回。<br>语法：const x = unref(y)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B3.png\"></p>\n<p>4、customRef<br>作用：自定义ref对象，把ref对象改写成get/set，进一步可以为它们添加 track/trigger。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B4.png\"></p>\n<p>5、toRef<br>作用：把一个 reactive对象中的某个属性变成 ref 变量。<br>语法：const x = toRef(reactive(obj), ‘key’) // x.value<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B5.png\"></p>\n<p>6、toRefs<br>作用：把一个reactive响应式对象变成ref变量。<br>语法：const obj1 = toRefs(reactive(obj))<br>应用：在子组件中接收父组件传递过来的 props时，使用 toRefs把它变成响应式的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B6.png\"></p>\n<p>7、shallowRef<br>作用：对复杂层级的对象，只将其第一层变成 ref 响应。 (性能优化)<br>语法：const x = shallowRef({a:{b:{c:1}}, d:2}) 如此a、b、c、d变化都不会自动更新，需要借助 triggerRef 来强制更新。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B7.png\"></p>\n<p>8、triggerRef<br>作用：强制更新一个 shallowRef对象的渲染。<br>语法：triggerRef(shallowRef对象)<br>参考代码：见shallowRef示例。</p>\n<p>9、reactive<br>作用：定义响应式变量，一般用于定义引用数据类型。如果是基本数据类型，建议使用ref来定义。<br>语法：const info = reactive([] | {})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B9.png\"></p>\n<p>10、readonly<br>作用：把一个对象，变成只读的。<br>语法：const rs = readonly(ref对象 | reactive对象 | 普通对象)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B10.png\"></p>\n<p>11、isReadonly<br>作用: 判断一个变量是不是只读的。<br>语法：const bol = isReadonly(变量)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B11.png\"></p>\n<p>12、isReactive<br>作用：判断一变量是不是 reactive的。<br>注意：被 readonly代理过的 reactive变量，调用 isReactive 也是返回 true的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B12.png\"></p>\n<p>13、isProxy<br>作用：判断一个变量是不是 readonly 或 reactive的。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B13.png\"></p>\n<p>14、toRaw<br>作用：得到返回 reactive变量或 readonly变量的”原始对象”。<br>语法:：const raw = toRaw(reactive变量或readonly变量)<br>说明：reactive(obj)、readonly(obj) 和 obj 之间是一种代理关系，并且它们之间是一种浅拷贝的关系。obj 变化，会导致reactive(obj) 同步变化，反之一样。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B14.png\"></p>\n<p>15、markRaw<br>作用：把一个普通对象标记成”永久原始”，从此将无法再变成proxy了。<br>语法：const raw = markRaw({a,b})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B15.png\"></p>\n<p>16、shallowReactive<br>作用：定义一个reactive变量，只对它的第一层进行Proxy,，所以只有第一层变化时视图才更新。<br>语法：const obj = shallowReactive({a:{b:9}})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B16.png\"></p>\n<p>17、shallowReadonly<br>作用：定义一个reactive变量，只有第一层是只读的。<br>语法：const obj = shallowReadonly({a:{b:9}})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B17.png\"></p>\n<p>18、computed<br>作用：对响应式变量进行缓存计算。<br>语法：const c = computed(fn / {get,set})<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B18.png\"></p>\n<p>19、watch<br>作用：用于监听响应式变量的变化，组件初始化时，它不执行。<br>语法：const stop = watch(x, (new,old)=&gt;{})，调用stop() 可以停止监听。<br>语法：const stop = watch([x,y], ([newX,newY],[oldX,oldY])=&gt;{})，调用stop()可以停止监听。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B19.png\"></p>\n<p>20、watchEffect<br>作用：相当于是 react中的 useEffect()，用于执行各种副作用。<br>语法：const stop = watchEffect(fn)，默认其 flush:’pre’，前置执行的副作用。<br>watchPostEffect，等价于 watchEffect(fn, {flush:’post’})，后置执行的副作用。<br>watchSyncEffect，等价于 watchEffect(fn, {flush:’sync’})，同步执行的副作用。<br>特点：watchEffect 会自动收集其内部响应式依赖，当响应式依赖发变化时，这个watchEffect将再次执行，直到你手动 stop() 掉它。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B20.png\"></p>\n<p>21、生命周期钩子<br>选项式的 beforeCreate、created，被setup替代了。setup表示组件被创建之前、props被解析之后执行，它是组合式 API 的入口。<br>选项式的 beforeDestroy、destroyed 被更名为 beforeUnmount、unmounted。<br>新增了两个选项式的生命周期 renderTracked、renderTriggered，它们只在开发环境有用，常用于调试。<br>在使用 setup组合时，不建议使用选项式的生命周期，建议使用 on* 系列 hooks生命周期。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B21.png\"></p>\n<p>22、provide / inject<br>作用：在组件树中自上而下地传递数据.<br>语法：provide(‘key’, value)<br>语法：const value = inject(‘key’, ‘默认值’)<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B22.png\"></p>\n<p>23、getCurrentInstance<br>作用：用于访问内部组件实例。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。<br>语法：const app = getCurrentInstance()<br>场景：常用于访问 app.config.globalProperties 上的全局数据。<br><img src=\"/2022/12/13/vue3API/%E6%A1%88%E4%BE%8B23.png\"></p>\n<p>24、关于setup代码范式<br>只使用 setup 及组合API，不要再使用vue选项了。<br>有必要封装 hooks时，建议把功能封装成hooks，以便于代码的可维护性。<br>能用 vite就尽量使用vite，能用ts 就尽量使用ts。</p>\n"},{"title":"vue3ref和reactive函数","date":"2022-10-13T09:11:20.000Z","_content":"# ref 函数介绍\n1. ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。\n2. 通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。\n3. 在vue2当中，通过给元素添加 ref='xxx'然后使用refs.xxx的方式来获取元素，vue3也可以。\n4. 当 ref 里面的值发生变化的时候，视图会自动更新数据。\n5. ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。\n\n## ref 函数使用\n使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。\n\n## ref 函数处理基本数据类型\n首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。\n![](ref基本数据类型代码.png)\n刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！\n![](ref基本出错.png)\n![](ref基本控制台.png)\n为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。\n![](ref结构.png)\n修改代码：\n![](ref修改代码.png)\n码刷新页面查看效果\n![](ref基本修改成功.png)\n有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。\n\n## ref 函数处理复杂数据类型\n不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。\n例如我们写一个案例，创建一个个人信息，放到对象里面展示\n![](ref复杂数据代码.png)\n我们先看一下对象被 ref 函数包裹后的数据结构。\n![](ref复杂结构.png)\n我们修改也通过 value 进行操作\n![](ref复杂修改代码.png)\n刷新页面，查看效果\n![](ref复杂修改代码成功.png)\n\n## ref 函数获取单个DOM元素\n和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。\n页面上有一个标签，点击按钮，获取标签的相关数据。\n![](refdom代码.png)\n运行效果\n![](ref成功.png)\n![](ref打印.png)\n\n# reactive 函数介绍\n上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。\n\n## reactive 函数使用\nreactive 函数处理对象\nreactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息\n![](reactive对象代码.png)\n![](reactive对象结果.png)\n有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。\n![](reactive修改代码.png)\n![](reactive对象修改结果.png)\n\n## reactive 函数处理数组\n处理数组的方式和处理对象的方式是一样一样的\n![](reactive数组代码.png)\n![](reactive数组处理结果.png)\n\n\n","source":"_posts/vue3ref和reactive函数.md","raw":"---\ntitle: vue3ref和reactive函数\ndate: 2022-10-13 17:11:20\ntags: vue3\ncategories: vue3\n---\n# ref 函数介绍\n1. ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。\n2. 通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。\n3. 在vue2当中，通过给元素添加 ref='xxx'然后使用refs.xxx的方式来获取元素，vue3也可以。\n4. 当 ref 里面的值发生变化的时候，视图会自动更新数据。\n5. ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。\n\n## ref 函数使用\n使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。\n\n## ref 函数处理基本数据类型\n首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。\n![](ref基本数据类型代码.png)\n刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！\n![](ref基本出错.png)\n![](ref基本控制台.png)\n为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。\n![](ref结构.png)\n修改代码：\n![](ref修改代码.png)\n码刷新页面查看效果\n![](ref基本修改成功.png)\n有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。\n\n## ref 函数处理复杂数据类型\n不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。\n例如我们写一个案例，创建一个个人信息，放到对象里面展示\n![](ref复杂数据代码.png)\n我们先看一下对象被 ref 函数包裹后的数据结构。\n![](ref复杂结构.png)\n我们修改也通过 value 进行操作\n![](ref复杂修改代码.png)\n刷新页面，查看效果\n![](ref复杂修改代码成功.png)\n\n## ref 函数获取单个DOM元素\n和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。\n页面上有一个标签，点击按钮，获取标签的相关数据。\n![](refdom代码.png)\n运行效果\n![](ref成功.png)\n![](ref打印.png)\n\n# reactive 函数介绍\n上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。\n\n## reactive 函数使用\nreactive 函数处理对象\nreactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息\n![](reactive对象代码.png)\n![](reactive对象结果.png)\n有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。\n![](reactive修改代码.png)\n![](reactive对象修改结果.png)\n\n## reactive 函数处理数组\n处理数组的方式和处理对象的方式是一样一样的\n![](reactive数组代码.png)\n![](reactive数组处理结果.png)\n\n\n","slug":"vue3ref和reactive函数","published":1,"updated":"2023-03-22T06:26:35.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqg00187et88kk12iyq","content":"<h1 id=\"ref-函数介绍\"><a href=\"#ref-函数介绍\" class=\"headerlink\" title=\"ref 函数介绍\"></a>ref 函数介绍</h1><ol>\n<li>ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。</li>\n<li>通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。</li>\n<li>在vue2当中，通过给元素添加 ref=’xxx’然后使用refs.xxx的方式来获取元素，vue3也可以。</li>\n<li>当 ref 里面的值发生变化的时候，视图会自动更新数据。</li>\n<li>ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。</li>\n</ol>\n<h2 id=\"ref-函数使用\"><a href=\"#ref-函数使用\" class=\"headerlink\" title=\"ref 函数使用\"></a>ref 函数使用</h2><p>使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。</p>\n<h2 id=\"ref-函数处理基本数据类型\"><a href=\"#ref-函数处理基本数据类型\" class=\"headerlink\" title=\"ref 函数处理基本数据类型\"></a>ref 函数处理基本数据类型</h2><p>首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81.png\"><br>刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E5%87%BA%E9%94%99.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8F%B0.png\"><br>为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E7%BB%93%E6%9E%84.png\"><br>修改代码：<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>码刷新页面查看效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png\"><br>有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。</p>\n<h2 id=\"ref-函数处理复杂数据类型\"><a href=\"#ref-函数处理复杂数据类型\" class=\"headerlink\" title=\"ref 函数处理复杂数据类型\"></a>ref 函数处理复杂数据类型</h2><p>不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。<br>例如我们写一个案例，创建一个个人信息，放到对象里面展示<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>我们先看一下对象被 ref 函数包裹后的数据结构。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84.png\"><br>我们修改也通过 value 进行操作<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，查看效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%88%90%E5%8A%9F.png\"></p>\n<h2 id=\"ref-函数获取单个DOM元素\"><a href=\"#ref-函数获取单个DOM元素\" class=\"headerlink\" title=\"ref 函数获取单个DOM元素\"></a>ref 函数获取单个DOM元素</h2><p>和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。<br>页面上有一个标签，点击按钮，获取标签的相关数据。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/refdom%E4%BB%A3%E7%A0%81.png\"><br>运行效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%88%90%E5%8A%9F.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%89%93%E5%8D%B0.png\"></p>\n<h1 id=\"reactive-函数介绍\"><a href=\"#reactive-函数介绍\" class=\"headerlink\" title=\"reactive 函数介绍\"></a>reactive 函数介绍</h1><p>上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。</p>\n<h2 id=\"reactive-函数使用\"><a href=\"#reactive-函数使用\" class=\"headerlink\" title=\"reactive 函数使用\"></a>reactive 函数使用</h2><p>reactive 函数处理对象<br>reactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%9C.png\"><br>有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"></p>\n<h2 id=\"reactive-函数处理数组\"><a href=\"#reactive-函数处理数组\" class=\"headerlink\" title=\"reactive 函数处理数组\"></a>reactive 函数处理数组</h2><p>处理数组的方式和处理对象的方式是一样一样的<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ref-函数介绍\"><a href=\"#ref-函数介绍\" class=\"headerlink\" title=\"ref 函数介绍\"></a>ref 函数介绍</h1><ol>\n<li>ref 作用就是将基础数据转换为响应式数据，把数据包装成响应式的引用数据类型的数据。</li>\n<li>通过对参数返回值的 value 属性获取响应式的值，并且修改的时候也需要对 value 进行修改。</li>\n<li>在vue2当中，通过给元素添加 ref=’xxx’然后使用refs.xxx的方式来获取元素，vue3也可以。</li>\n<li>当 ref 里面的值发生变化的时候，视图会自动更新数据。</li>\n<li>ref 可以操作基本数据类型和复杂数据类型，建议使用 ref 操作只对基本数据类型进行操作。</li>\n</ol>\n<h2 id=\"ref-函数使用\"><a href=\"#ref-函数使用\" class=\"headerlink\" title=\"ref 函数使用\"></a>ref 函数使用</h2><p>使用 ref 函数很简单，首先要在页面引用，然后就可以直接使用了，具体怎么使用呢，下面为了方便介绍，简单来几个案例。</p>\n<h2 id=\"ref-函数处理基本数据类型\"><a href=\"#ref-函数处理基本数据类型\" class=\"headerlink\" title=\"ref 函数处理基本数据类型\"></a>ref 函数处理基本数据类型</h2><p>首先提一个需求：页面有一个名称需要显示，有一个按钮，点击按钮的时候修改页面展示的这个名字。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81.png\"><br>刷新，可以正常渲染数据，但是点击按钮修改名字的时候，出现问题！<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E5%87%BA%E9%94%99.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8F%B0.png\"><br>为什么使用过 ref 将数据映射为响应式数据还是报错呢？我们可以先打印一下 ref 包裹后，也就是 name_ref 这个参数，看一下结构。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E7%BB%93%E6%9E%84.png\"><br>修改代码：<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>码刷新页面查看效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%9F%BA%E6%9C%AC%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png\"><br>有一点需要说一下哈，就是在单文件组件中，不必写value，因为setup方法会自动解析，简单的可以理解成 html 代码不需要额外操作 value，但是逻辑层需要。</p>\n<h2 id=\"ref-函数处理复杂数据类型\"><a href=\"#ref-函数处理复杂数据类型\" class=\"headerlink\" title=\"ref 函数处理复杂数据类型\"></a>ref 函数处理复杂数据类型</h2><p>不建议使用 ref 函数处理复杂数据类型（数组、对象等），用 ref 函数处理基本数据类型（数字、字符串等）就可以了。<br>例如我们写一个案例，创建一个个人信息，放到对象里面展示<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81.png\"><br>我们先看一下对象被 ref 函数包裹后的数据结构。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84.png\"><br>我们修改也通过 value 进行操作<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br>刷新页面，查看效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E5%A4%8D%E6%9D%82%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%88%90%E5%8A%9F.png\"></p>\n<h2 id=\"ref-函数获取单个DOM元素\"><a href=\"#ref-函数获取单个DOM元素\" class=\"headerlink\" title=\"ref 函数获取单个DOM元素\"></a>ref 函数获取单个DOM元素</h2><p>和 vue2 一样，可以使用 ref 获取元素，用法和操作数据类型相似。<br>页面上有一个标签，点击按钮，获取标签的相关数据。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/refdom%E4%BB%A3%E7%A0%81.png\"><br>运行效果<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%88%90%E5%8A%9F.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/ref%E6%89%93%E5%8D%B0.png\"></p>\n<h1 id=\"reactive-函数介绍\"><a href=\"#reactive-函数介绍\" class=\"headerlink\" title=\"reactive 函数介绍\"></a>reactive 函数介绍</h1><p>上面说了 ref 函数的基本用法，接下来是 reactive 函数，它的用法与 ref 函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是 ref 用于基本数据类型，而 reactive 是用于复杂数据类型，所以说，不建议用 ref 函数来处理复杂数据类型的原因就是，有 reactive 来处理复杂类型数据。</p>\n<h2 id=\"reactive-函数使用\"><a href=\"#reactive-函数使用\" class=\"headerlink\" title=\"reactive 函数使用\"></a>reactive 函数使用</h2><p>reactive 函数处理对象<br>reactive 函数用来处理数组或者是对象,写一个案例，操作人的基本信息<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%9C.png\"><br>有打印的结果我们可以看见，这时候的数据就不是被包裹在 value 下面了，所以说我们可以直接获取到。<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E5%AF%B9%E8%B1%A1%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png\"></p>\n<h2 id=\"reactive-函数处理数组\"><a href=\"#reactive-函数处理数组\" class=\"headerlink\" title=\"reactive 函数处理数组\"></a>reactive 函数处理数组</h2><p>处理数组的方式和处理对象的方式是一样一样的<br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/13/vue3ref%E5%92%8Creactive%E5%87%BD%E6%95%B0/reactive%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"vue3-hooks使用","date":"2022-10-25T15:21:17.000Z","_content":"# 我们来说一下vue3 项目中的 hooks 的使用\nhooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。\n一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n这两者主要的区别，主要是 hooks 是函数。\n\n# 我们先看一下hooks优点有哪些？\nhooks 特点：\n1. vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。\n2. vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。\n3. hooks 函数可以与 mixin 连用，但是不建议。\n\n# hooks 基本使用\n![](案例1.png)\n我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。\n如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。\n但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。\n\n# 我们针对上面的案例，我们使用 hooks 简单的实现一下。\n首先，我们在 src 文件夹下创建一个 hooks 文件夹。\n在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件\n接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。\n![](案例2.png)\n然后在需要使用 hooks 的文件引入就可以使用了。\n![](案例3.png)\n","source":"_posts/vue3-hooks使用.md","raw":"---\ntitle: vue3-hooks使用\ndate: 2022-10-25 23:21:17\ntags: vue3\ncategories: vue3\n---\n# 我们来说一下vue3 项目中的 hooks 的使用\nhooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。\n一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n这两者主要的区别，主要是 hooks 是函数。\n\n# 我们先看一下hooks优点有哪些？\nhooks 特点：\n1. vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。\n2. vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。\n3. hooks 函数可以与 mixin 连用，但是不建议。\n\n# hooks 基本使用\n![](案例1.png)\n我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。\n如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。\n但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。\n\n# 我们针对上面的案例，我们使用 hooks 简单的实现一下。\n首先，我们在 src 文件夹下创建一个 hooks 文件夹。\n在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件\n接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。\n![](案例2.png)\n然后在需要使用 hooks 的文件引入就可以使用了。\n![](案例3.png)\n","slug":"vue3-hooks使用","published":1,"updated":"2023-03-22T06:18:54.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqh001b7et8dlcn2jgd","content":"<h1 id=\"我们来说一下vue3-项目中的-hooks-的使用\"><a href=\"#我们来说一下vue3-项目中的-hooks-的使用\" class=\"headerlink\" title=\"我们来说一下vue3 项目中的 hooks 的使用\"></a>我们来说一下vue3 项目中的 hooks 的使用</h1><p>hooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。<br>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>这两者主要的区别，主要是 hooks 是函数。</p>\n<h1 id=\"我们先看一下hooks优点有哪些？\"><a href=\"#我们先看一下hooks优点有哪些？\" class=\"headerlink\" title=\"我们先看一下hooks优点有哪些？\"></a>我们先看一下hooks优点有哪些？</h1><p>hooks 特点：</p>\n<ol>\n<li>vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。</li>\n<li>vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。</li>\n<li>hooks 函数可以与 mixin 连用，但是不建议。</li>\n</ol>\n<h1 id=\"hooks-基本使用\"><a href=\"#hooks-基本使用\" class=\"headerlink\" title=\"hooks 基本使用\"></a>hooks 基本使用</h1><p><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B1.png\"><br>我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。<br>如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。<br>但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。</p>\n<h1 id=\"我们针对上面的案例，我们使用-hooks-简单的实现一下。\"><a href=\"#我们针对上面的案例，我们使用-hooks-简单的实现一下。\" class=\"headerlink\" title=\"我们针对上面的案例，我们使用 hooks 简单的实现一下。\"></a>我们针对上面的案例，我们使用 hooks 简单的实现一下。</h1><p>首先，我们在 src 文件夹下创建一个 hooks 文件夹。<br>在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件<br>接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。<br><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B2.png\"><br>然后在需要使用 hooks 的文件引入就可以使用了。<br><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B3.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我们来说一下vue3-项目中的-hooks-的使用\"><a href=\"#我们来说一下vue3-项目中的-hooks-的使用\" class=\"headerlink\" title=\"我们来说一下vue3 项目中的 hooks 的使用\"></a>我们来说一下vue3 项目中的 hooks 的使用</h1><p>hooks 和 vue2 当中的 mixin 是类似的，mixin就是混入，通过 mixin 混入来分发 vue 组件中的可复用功能。<br>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>这两者主要的区别，主要是 hooks 是函数。</p>\n<h1 id=\"我们先看一下hooks优点有哪些？\"><a href=\"#我们先看一下hooks优点有哪些？\" class=\"headerlink\" title=\"我们先看一下hooks优点有哪些？\"></a>我们先看一下hooks优点有哪些？</h1><p>hooks 特点：</p>\n<ol>\n<li>vue3 中的 hooks 函数相当于 vue2 里面的 mixin 混入，不同在于 hooks 是函数。</li>\n<li>vue3 中的 hooks 函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks 函数。</li>\n<li>hooks 函数可以与 mixin 连用，但是不建议。</li>\n</ol>\n<h1 id=\"hooks-基本使用\"><a href=\"#hooks-基本使用\" class=\"headerlink\" title=\"hooks 基本使用\"></a>hooks 基本使用</h1><p><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B1.png\"><br>我们写了一个简单的小案例，上面的代码其实很简单了就，有两个标签，显示可视页面的长度和宽度，然后有一个按钮获取最新的长宽进行显示。<br>如果我们需要在另一个页面也想实现这个功能的话，也很简单，在直接把上面的代码复制一下到另一个需要实现的页面就可以了。<br>但是，有没有发现一个问题，就是一个页面需要就复制一遍，一个页面需要就复制一遍，如果有一百个页面就复制一百遍，代码一两行还好，如果是一个超级庞大的工具类，那么在像这样实现的话，是不是就过于复杂了，而且还不好实现，那这个问题怎么解决呢？就是 hooks 。</p>\n<h1 id=\"我们针对上面的案例，我们使用-hooks-简单的实现一下。\"><a href=\"#我们针对上面的案例，我们使用-hooks-简单的实现一下。\" class=\"headerlink\" title=\"我们针对上面的案例，我们使用 hooks 简单的实现一下。\"></a>我们针对上面的案例，我们使用 hooks 简单的实现一下。</h1><p>首先，我们在 src 文件夹下创建一个 hooks 文件夹。<br>在 hooks 文件夹下创建一个文件，名字就叫做 useScreenWh.js 文件<br>接下来，我们把获取可视化界面的代码放进这个 js 文件，然后导出去，给其他页面使用就可以了。<br><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B2.png\"><br>然后在需要使用 hooks 的文件引入就可以使用了。<br><img src=\"/2022/10/25/vue3-hooks%E4%BD%BF%E7%94%A8/%E6%A1%88%E4%BE%8B3.png\"></p>\n"},{"title":"vue3新语法细节","date":"2023-01-10T10:40:55.000Z","_content":"1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。\n\n2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。\n\n3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。\n\n4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。\n\n5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。\n\n6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。\n\n7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。\n\n8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。\n\n9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。\n\n10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。\n\n11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 `@vitejs/plugin-vue-jsx` 插件来支持 JSX语法，那么定义函数式组件就更加方便了。\n\n12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。\n\n13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。\n\n14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。\n\n15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。\n\n","source":"_posts/vue3新语法细节.md","raw":"---\ntitle: vue3新语法细节\ndate: 2023-01-10 18:40:55\ntags: vue3\ncategories: vue3\n---\n1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。\n\n2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。\n\n3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。\n\n4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。\n\n5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。\n\n6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。\n\n7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。\n\n8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。\n\n9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。\n\n10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。\n\n11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 `@vitejs/plugin-vue-jsx` 插件来支持 JSX语法，那么定义函数式组件就更加方便了。\n\n12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。\n\n13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。\n\n14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。\n\n15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。\n\n","slug":"vue3新语法细节","published":1,"updated":"2023-01-10T10:43:16.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliql001o7et84uxl8l5y","content":"<p>1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。</p>\n<p>2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。</p>\n<p>3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。</p>\n<p>4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。</p>\n<p>5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。</p>\n<p>6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。</p>\n<p>7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。</p>\n<p>8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。</p>\n<p>9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。</p>\n<p>10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。</p>\n<p>11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 <code>@vitejs/plugin-vue-jsx</code> 插件来支持 JSX语法，那么定义函数式组件就更加方便了。</p>\n<p>12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。</p>\n<p>13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。</p>\n<p>14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。</p>\n<p>15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1、在Vue2中，v-for 和 ref 同时使用，这会自动收集 $refs。当存在嵌套的v-for时，这种行为会变得不明确且效率低下。在Vue3中，v-for 和 ref 同时使用，这不再自动收集$refs。我们可以手动封装收集 ref 对象的方法，将其绑定在 ref 属性上。</p>\n<p>2、在Vue3中，使用 defineAsyncComponent 可以异步地加载组件。需要注意的是，这种异步组件是不能用在Vue-Router的路由懒加载中。</p>\n<p>3、Vue3.0中的 $attrs，包含了父组件传递过来的所有属性，包括 class 和 style 。在Vue2中，$attrs 是接到不到 class 和 style 的。在 setup 组件中，使用 useAttrs() 访问；在非 setup组件中，使用 this.$attrs /setupCtx.attrs 来访问。</p>\n<p>4、Vue3中，移除了 $children 属性，要想访问子组件只能使用 ref 来实现了。在Vue2中，我们使用 $children 可以方便地访问到子组件，在组件树中“肆意”穿梭。</p>\n<p>5、Vue3中，使用 app.directive() 来定义全局指令，并且定义指令时的钩子函数们也发生了若干变化。</p>\n<p>6、data 选项，只支持工厂函数的写法，不再支持对象的写法了。在Vue2中，创建 new Vue({ data }) 时，是可以写成对象语法的。</p>\n<p>7、Vue3中新增了 emits 选项。在非<script setup>写法中，使用 emits选项 接收父组件传递过来的自定义，使用 ctx.emit() / this.$emit() 来触发事件。在<script setup>中，使用 defineEmits 来接收自定义事件，使用 defineProps 来接收自定义事件。</p>\n<p>8、Vue3中 移除了 $on / $off / $once 这三个事件 API，只保留了 $emit 。</p>\n<p>9、Vue3中，移除了全局过滤器（Vue.filter）、移除了局部过滤器 filters选项。取而代之，你可以封装自定义函数或使用 computed 计算属性来处理数据。</p>\n<p>10、Vue3 现在正式支持了多根节点的组件，也就是片段，类似 React 中的 Fragment。使用片段的好处是，当我们要在 template 中添加多个节点时，没必要在外层套一个 div 了，套一层 div 这会导致多了一层 DOM结构。可见，片段 可以减少没有必要的 DOM 嵌套。</p>\n<p>11、函数式组件的变化：在Vue2中，要使用 functional 选项来支持函数式组件的封装。在Vue3中，函数式组件可以直接用普通函数进行创建。如果你在 vite 环境中安装了 <code>@vitejs/plugin-vue-jsx</code> 插件来支持 JSX语法，那么定义函数式组件就更加方便了。</p>\n<p>12、Vue2中的Vue构造函数，在Vue3中已经不能再使用了。所以Vue构造函数上的静态方法、静态属性，比如 Vue.use/Vue.mixin/Vue.prototype 等都不能使用了。在Vue3中新增了一套实例方法来代替，比如 app.use()等。</p>\n<p>13、在Vue3中，使用 getCurrentInstance 访问内部组件实例，进而可以获取到 app.config 上的全局数据，比如 $route、$router、$store 和自定义数据等。这个 API 只能在 setup 或 生命周期钩子 中调用。</p>\n<p>14、我们已经知道，使用 provide 和 inject 这两个组合 API 可以组件树中传递数据。除此之外，我们还可以应用级别的 app.provide() 来注入全局数据。在编写插件时使用 app.provide() 尤其有用，可以替代app.config.globalProperties。</p>\n<p>15、在Vue2中，Vue.nextTick() / this.$nextTick 不能支持 Webpack 的 Tree-Shaking 功能的。在 Vue3 中的 nextTick ，考虑到了对 Tree-Shaking 的支持。</p>\n"},{"title":"vue3组件传值","date":"2022-10-20T14:39:21.000Z","_content":"# 父子组件传值 props\n父组件\n![](父组件代码.png)\n子组件\n![](子组件代码.png)\n![](子传父结果.png)\n\n# 祖孙组件传值 provide 和 inject\n父组件\n![](父组件二代码.png)\n子组件\n![](子组件二代码.png)\n![](祖孙结果.png)\n\n# 父组件中点击按钮向子组件传值\n父组件\n![](父组件三代码.png)\n子组件\n![](子组件三代码.png)\n![](传值前结果.png)\n![](传值后结果.png)\n\n","source":"_posts/vue3组件传值.md","raw":"---\ntitle: vue3组件传值\ndate: 2022-10-20 22:39:21\ntags: vue3\ncategories: vue3\n---\n# 父子组件传值 props\n父组件\n![](父组件代码.png)\n子组件\n![](子组件代码.png)\n![](子传父结果.png)\n\n# 祖孙组件传值 provide 和 inject\n父组件\n![](父组件二代码.png)\n子组件\n![](子组件二代码.png)\n![](祖孙结果.png)\n\n# 父组件中点击按钮向子组件传值\n父组件\n![](父组件三代码.png)\n子组件\n![](子组件三代码.png)\n![](传值前结果.png)\n![](传值后结果.png)\n\n","slug":"vue3组件传值","published":1,"updated":"2023-03-22T06:25:44.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliql001p7et8a54u0psn","content":"<h1 id=\"父子组件传值-props\"><a href=\"#父子组件传值-props\" class=\"headerlink\" title=\"父子组件传值 props\"></a>父子组件传值 props</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E4%BC%A0%E7%88%B6%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"祖孙组件传值-provide-和-inject\"><a href=\"#祖孙组件传值-provide-和-inject\" class=\"headerlink\" title=\"祖孙组件传值 provide 和 inject\"></a>祖孙组件传值 provide 和 inject</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%A5%96%E5%AD%99%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"父组件中点击按钮向子组件传值\"><a href=\"#父组件中点击按钮向子组件传值\" class=\"headerlink\" title=\"父组件中点击按钮向子组件传值\"></a>父组件中点击按钮向子组件传值</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%89%8D%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%90%8E%E7%BB%93%E6%9E%9C.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"父子组件传值-props\"><a href=\"#父子组件传值-props\" class=\"headerlink\" title=\"父子组件传值 props\"></a>父子组件传值 props</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E4%BC%A0%E7%88%B6%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"祖孙组件传值-provide-和-inject\"><a href=\"#祖孙组件传值-provide-和-inject\" class=\"headerlink\" title=\"祖孙组件传值 provide 和 inject\"></a>祖孙组件传值 provide 和 inject</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8C%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%A5%96%E5%AD%99%E7%BB%93%E6%9E%9C.png\"></p>\n<h1 id=\"父组件中点击按钮向子组件传值\"><a href=\"#父组件中点击按钮向子组件传值\" class=\"headerlink\" title=\"父组件中点击按钮向子组件传值\"></a>父组件中点击按钮向子组件传值</h1><p>父组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br>子组件<br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%89%E4%BB%A3%E7%A0%81.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%89%8D%E7%BB%93%E6%9E%9C.png\"><br><img src=\"/2022/10/20/vue3%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/%E4%BC%A0%E5%80%BC%E5%90%8E%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"深浅拷贝","date":"2022-08-25T13:53:20.000Z","_content":"# 什么是浅拷贝？\n浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。\n举个例子：\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=obj1;\nobj2.b=2;\nconsole.log(obj1.b);  //2\nconsole.log(obj2.b);  //2\n***\n浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。\n# 什么是深拷贝？\n深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。\n举个例子：\nvar a=2;\nvar b=a;\nb=3;\nconsole.log(a);//2\nconsole.log(b);//3\n***\n深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。\n# 如何实现深拷贝？\n## ①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=JSON.Stringify（JSON.parse（obj1））;\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n***\n## ②展开运算符   ...\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=(...obj1)\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n***\n## ③Object.asssign（target,sourse）\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=Object.assign({},obj1)\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n***\n## ④深拷贝函数，递归\n            // target 要拷贝的对象\n            function deepClone(target){\n                //定义一个拷贝对象\n                let result;\n                // 判断拷贝目标是不是Object对象\n                if(typeof target==='object'){\n                    // 判断是否是数组类型\n                    if(Array.isArray(target)){\n                        // 定义为数组\n                        result=[];\n                        for(let i in target){\n                            result.push(deepClone(target[i]));\n                        }\n                    }else if(target===null){\n                        // 直接赋值\n                        result=null;\n                    }else if(target.constructor===RegExp){\n                        // 直接赋值\n                        result=target;\n                        // 不是特殊的对象\n                    }else{\n                        result={};\n                        for(let i in target){\n                            // 递归\n                            result[i]=deepClone(target[i]);\n                        }\n                    }\n                    // 基本数据类型  直接赋值\n                }else{\n                    result=target;\n                }\n                return result;\n            }\n***\nvar obj1={\na:{z:1,c:null},\nb:[1,2,3,5],\nc:function(){console.log(this.a)}\n}\nvar obj2=deepClone(obj1);\nconsole.log(obj2);\nobj2.b[0]=2;\nobj2.a[0]=2;\nconsole.log(obj1.a)\nconsole.log(obj2.a)\nconsole.log(obj1.b)\nconsole.log(obj2.b)\nconsole.log(obj2.c())\n![](深浅拷贝结果.png)","source":"_posts/深浅拷贝.md","raw":"---\ntitle: 深浅拷贝\ndate: 2022-08-25 21:53:20\ntags: 深浅拷贝\ncategories: 知识点\n---\n# 什么是浅拷贝？\n浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。\n举个例子：\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=obj1;\nobj2.b=2;\nconsole.log(obj1.b);  //2\nconsole.log(obj2.b);  //2\n***\n浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。\n# 什么是深拷贝？\n深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。\n举个例子：\nvar a=2;\nvar b=a;\nb=3;\nconsole.log(a);//2\nconsole.log(b);//3\n***\n深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。\n# 如何实现深拷贝？\n## ①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=JSON.Stringify（JSON.parse（obj1））;\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n***\n## ②展开运算符   ...\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=(...obj1)\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n***\n## ③Object.asssign（target,sourse）\nvar  obj1={a:1,b:5,c:3};\nvar  obj2=Object.assign({},obj1)\nobj2.b=2;\nconsole.log(obj1.b);  //5\nconsole.log(obj2.b);  //2\n***\n## ④深拷贝函数，递归\n            // target 要拷贝的对象\n            function deepClone(target){\n                //定义一个拷贝对象\n                let result;\n                // 判断拷贝目标是不是Object对象\n                if(typeof target==='object'){\n                    // 判断是否是数组类型\n                    if(Array.isArray(target)){\n                        // 定义为数组\n                        result=[];\n                        for(let i in target){\n                            result.push(deepClone(target[i]));\n                        }\n                    }else if(target===null){\n                        // 直接赋值\n                        result=null;\n                    }else if(target.constructor===RegExp){\n                        // 直接赋值\n                        result=target;\n                        // 不是特殊的对象\n                    }else{\n                        result={};\n                        for(let i in target){\n                            // 递归\n                            result[i]=deepClone(target[i]);\n                        }\n                    }\n                    // 基本数据类型  直接赋值\n                }else{\n                    result=target;\n                }\n                return result;\n            }\n***\nvar obj1={\na:{z:1,c:null},\nb:[1,2,3,5],\nc:function(){console.log(this.a)}\n}\nvar obj2=deepClone(obj1);\nconsole.log(obj2);\nobj2.b[0]=2;\nobj2.a[0]=2;\nconsole.log(obj1.a)\nconsole.log(obj2.a)\nconsole.log(obj1.b)\nconsole.log(obj2.b)\nconsole.log(obj2.c())\n![](深浅拷贝结果.png)","slug":"深浅拷贝","published":1,"updated":"2023-03-22T06:11:09.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqm001r7et8hhyjdrci","content":"<h1 id=\"什么是浅拷贝？\"><a href=\"#什么是浅拷贝？\" class=\"headerlink\" title=\"什么是浅拷贝？\"></a>什么是浅拷贝？</h1><p>浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。<br>举个例子：<br>var  obj1={a:1,b:5,c:3};<br>var  obj2=obj1;<br>obj2.b=2;<br>console.log(obj1.b);  //2<br>console.log(obj2.b);  //2</p>\n<hr>\n<p>浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。</p>\n<h1 id=\"什么是深拷贝？\"><a href=\"#什么是深拷贝？\" class=\"headerlink\" title=\"什么是深拷贝？\"></a>什么是深拷贝？</h1><p>深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。<br>举个例子：<br>var a=2;<br>var b=a;<br>b=3;<br>console.log(a);//2<br>console.log(b);//3</p>\n<hr>\n<p>深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。</p>\n<h1 id=\"如何实现深拷贝？\"><a href=\"#如何实现深拷贝？\" class=\"headerlink\" title=\"如何实现深拷贝？\"></a>如何实现深拷贝？</h1><h2 id=\"①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\"><a href=\"#①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\" class=\"headerlink\" title=\"①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\"></a>①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=JSON.Stringify（JSON.parse（obj1））;<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p>\n<hr>\n<h2 id=\"②展开运算符-…\"><a href=\"#②展开运算符-…\" class=\"headerlink\" title=\"②展开运算符   …\"></a>②展开运算符   …</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=(…obj1)<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p>\n<hr>\n<h2 id=\"③Object-asssign（target-sourse）\"><a href=\"#③Object-asssign（target-sourse）\" class=\"headerlink\" title=\"③Object.asssign（target,sourse）\"></a>③Object.asssign（target,sourse）</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=Object.assign({},obj1)<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p>\n<hr>\n<h2 id=\"④深拷贝函数，递归\"><a href=\"#④深拷贝函数，递归\" class=\"headerlink\" title=\"④深拷贝函数，递归\"></a>④深拷贝函数，递归</h2><pre><code class=\"hljs\">        // target 要拷贝的对象\n        function deepClone(target)&#123;\n            //定义一个拷贝对象\n            let result;\n            // 判断拷贝目标是不是Object对象\n            if(typeof target===&#39;object&#39;)&#123;\n                // 判断是否是数组类型\n                if(Array.isArray(target))&#123;\n                    // 定义为数组\n                    result=[];\n                    for(let i in target)&#123;\n                        result.push(deepClone(target[i]));\n                    &#125;\n                &#125;else if(target===null)&#123;\n                    // 直接赋值\n                    result=null;\n                &#125;else if(target.constructor===RegExp)&#123;\n                    // 直接赋值\n                    result=target;\n                    // 不是特殊的对象\n                &#125;else&#123;\n                    result=&#123;&#125;;\n                    for(let i in target)&#123;\n                        // 递归\n                        result[i]=deepClone(target[i]);\n                    &#125;\n                &#125;\n                // 基本数据类型  直接赋值\n            &#125;else&#123;\n                result=target;\n            &#125;\n            return result;\n        &#125;\n</code></pre>\n<hr>\n<p>var obj1={<br>a:{z:1,c:null},<br>b:[1,2,3,5],<br>c:function(){console.log(this.a)}<br>}<br>var obj2=deepClone(obj1);<br>console.log(obj2);<br>obj2.b[0]=2;<br>obj2.a[0]=2;<br>console.log(obj1.a)<br>console.log(obj2.a)<br>console.log(obj1.b)<br>console.log(obj2.b)<br>console.log(obj2.c())<br><img src=\"/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%BB%93%E6%9E%9C.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是浅拷贝？\"><a href=\"#什么是浅拷贝？\" class=\"headerlink\" title=\"什么是浅拷贝？\"></a>什么是浅拷贝？</h1><p>浅拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值也随之改变。<br>举个例子：<br>var  obj1={a:1,b:5,c:3};<br>var  obj2=obj1;<br>obj2.b=2;<br>console.log(obj1.b);  //2<br>console.log(obj2.b);  //2</p>\n<hr>\n<p>浅拷贝：就是拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，，任何一个修改都会是使得所有对象的值被修改，因为它们公用一条数据。</p>\n<h1 id=\"什么是深拷贝？\"><a href=\"#什么是深拷贝？\" class=\"headerlink\" title=\"什么是深拷贝？\"></a>什么是深拷贝？</h1><p>深拷贝：简单来说就是一个对象B复制另一个对象A，当改变B对象的值是A对象的值不会改变。<br>举个例子：<br>var a=2;<br>var b=a;<br>b=3;<br>console.log(a);//2<br>console.log(b);//3</p>\n<hr>\n<p>深拷贝：深拷贝不会拷贝引用类型的引用，拷贝的是引用类型的值，形成一个新的引用类型。</p>\n<h1 id=\"如何实现深拷贝？\"><a href=\"#如何实现深拷贝？\" class=\"headerlink\" title=\"如何实现深拷贝？\"></a>如何实现深拷贝？</h1><h2 id=\"①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\"><a href=\"#①JSON-Stringify-JSON-pare-不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\" class=\"headerlink\" title=\"①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据\"></a>①JSON.Stringify(JSON.pare())   不支持多层引用嵌套，不支持函数Map、Sep等类型的数据</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=JSON.Stringify（JSON.parse（obj1））;<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p>\n<hr>\n<h2 id=\"②展开运算符-…\"><a href=\"#②展开运算符-…\" class=\"headerlink\" title=\"②展开运算符   …\"></a>②展开运算符   …</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=(…obj1)<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p>\n<hr>\n<h2 id=\"③Object-asssign（target-sourse）\"><a href=\"#③Object-asssign（target-sourse）\" class=\"headerlink\" title=\"③Object.asssign（target,sourse）\"></a>③Object.asssign（target,sourse）</h2><p>var  obj1={a:1,b:5,c:3};<br>var  obj2=Object.assign({},obj1)<br>obj2.b=2;<br>console.log(obj1.b);  //5<br>console.log(obj2.b);  //2</p>\n<hr>\n<h2 id=\"④深拷贝函数，递归\"><a href=\"#④深拷贝函数，递归\" class=\"headerlink\" title=\"④深拷贝函数，递归\"></a>④深拷贝函数，递归</h2><pre><code>        // target 要拷贝的对象\n        function deepClone(target)&#123;\n            //定义一个拷贝对象\n            let result;\n            // 判断拷贝目标是不是Object对象\n            if(typeof target===&#39;object&#39;)&#123;\n                // 判断是否是数组类型\n                if(Array.isArray(target))&#123;\n                    // 定义为数组\n                    result=[];\n                    for(let i in target)&#123;\n                        result.push(deepClone(target[i]));\n                    &#125;\n                &#125;else if(target===null)&#123;\n                    // 直接赋值\n                    result=null;\n                &#125;else if(target.constructor===RegExp)&#123;\n                    // 直接赋值\n                    result=target;\n                    // 不是特殊的对象\n                &#125;else&#123;\n                    result=&#123;&#125;;\n                    for(let i in target)&#123;\n                        // 递归\n                        result[i]=deepClone(target[i]);\n                    &#125;\n                &#125;\n                // 基本数据类型  直接赋值\n            &#125;else&#123;\n                result=target;\n            &#125;\n            return result;\n        &#125;\n</code></pre>\n<hr>\n<p>var obj1={<br>a:{z:1,c:null},<br>b:[1,2,3,5],<br>c:function(){console.log(this.a)}<br>}<br>var obj2=deepClone(obj1);<br>console.log(obj2);<br>obj2.b[0]=2;<br>obj2.a[0]=2;<br>console.log(obj1.a)<br>console.log(obj2.a)<br>console.log(obj1.b)<br>console.log(obj2.b)<br>console.log(obj2.c())<br><img src=\"/2022/08/25/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%BB%93%E6%9E%9C.png\"></p>\n"},{"title":"webpack","date":"2022-08-30T06:25:44.000Z","_content":"# webpack 打包原理是什么？\n## 打包原理\nwebpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当 webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。\n## webpack构建流程：\n初始化参数—>开始编译---->确定入口---->编译模块—>完成编译---->输出数据---->输出完成\n## 优势：\n代码层面：\n1. 体积更小，加载更快\n2. 编译高级语言和语法\n3. 兼容性和错误检查\n## 研发流程层面：\n1.统一高效的开发环境\n2.统一的构建流程和产出标准\n3.集成公司构建规范（提测、上线）\n## 核心概念：\nentry：入口，webpack的执行从entry开始，\noutput：出口，输出结果，webpack的输出位置，\nloader：模块转换器，用于把webpack不能直接打包的文件类型转换\nplugins：插件，用于把模块原内容按需求转换成新内容mode：通过选择development或者production来设置mode参数\nchunk：代码块，即打包后输出的文件\n## 基本功能和工作原理\n当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括\n1.代码转换：将无法直接运行的文件代码编译成可以执行的代码\n2.文件优化：压缩文件代码、压缩合并图片等\n3.代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载\n4.模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件\n5.自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器\n6.代码校验：在代码被提交前需要校验代码格式等是否符合规范\n7.自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统\n# 常见问题\n### 1、loader和plugin的区别：\n### 不同的作用：\nloader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具\nplugins：插件，可以扩展fwebpack的功能，让其更具有灵活性\n### 不同的用法：\nloader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，\nplugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入\n### 2、什么事模块化，为什么要用模块化\n模块化是指把一个复杂的系统分解到多个模块以方便编码\n不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码\n### 3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。\ndevServer: {\n    contentBase: resolve(__dirname, 'build'),\n    compress: true,\n    port: 3000,\n    open: true,\n    // 开启HMR功能\n    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务\n    hot: true\n  }\n### 4、什么是HMR功能\nHMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览\n优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式\n### 5、什么是Tree-sharking?\n指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等\n### 6、babel和webpack的区别\nbabel JS新语法编译工具，只关心语法，不关心模块化\nwebpack -打包构建工具，是多个Loader plugin的集合\n### 7、类似webpack的工具还有哪些\n(1)、webpack适用于大型复杂的前端站点构建\n(2)、rollup适用于基础库的打包，如vue、react\n(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel\n### 8、常见loader\nfile-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去\nbabel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。\n### 9、常见的plugins\ndefine-plugin：定义环境变量\ncommons-chunk-plugin：提取公共代码\nuglifyjs-webpack-plugin：通过UglifyES压缩ES6代码","source":"_posts/webpack.md","raw":"---\ntitle: webpack\ndate: 2022-08-30 14:25:44\ntags: webpack\ncategories: 知识点\n---\n# webpack 打包原理是什么？\n## 打包原理\nwebpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当 webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。\n## webpack构建流程：\n初始化参数—>开始编译---->确定入口---->编译模块—>完成编译---->输出数据---->输出完成\n## 优势：\n代码层面：\n1. 体积更小，加载更快\n2. 编译高级语言和语法\n3. 兼容性和错误检查\n## 研发流程层面：\n1.统一高效的开发环境\n2.统一的构建流程和产出标准\n3.集成公司构建规范（提测、上线）\n## 核心概念：\nentry：入口，webpack的执行从entry开始，\noutput：出口，输出结果，webpack的输出位置，\nloader：模块转换器，用于把webpack不能直接打包的文件类型转换\nplugins：插件，用于把模块原内容按需求转换成新内容mode：通过选择development或者production来设置mode参数\nchunk：代码块，即打包后输出的文件\n## 基本功能和工作原理\n当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括\n1.代码转换：将无法直接运行的文件代码编译成可以执行的代码\n2.文件优化：压缩文件代码、压缩合并图片等\n3.代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载\n4.模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件\n5.自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器\n6.代码校验：在代码被提交前需要校验代码格式等是否符合规范\n7.自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统\n# 常见问题\n### 1、loader和plugin的区别：\n### 不同的作用：\nloader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具\nplugins：插件，可以扩展fwebpack的功能，让其更具有灵活性\n### 不同的用法：\nloader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，\nplugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入\n### 2、什么事模块化，为什么要用模块化\n模块化是指把一个复杂的系统分解到多个模块以方便编码\n不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码\n### 3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。\ndevServer: {\n    contentBase: resolve(__dirname, 'build'),\n    compress: true,\n    port: 3000,\n    open: true,\n    // 开启HMR功能\n    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务\n    hot: true\n  }\n### 4、什么是HMR功能\nHMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览\n优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式\n### 5、什么是Tree-sharking?\n指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等\n### 6、babel和webpack的区别\nbabel JS新语法编译工具，只关心语法，不关心模块化\nwebpack -打包构建工具，是多个Loader plugin的集合\n### 7、类似webpack的工具还有哪些\n(1)、webpack适用于大型复杂的前端站点构建\n(2)、rollup适用于基础库的打包，如vue、react\n(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel\n### 8、常见loader\nfile-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去\nbabel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。\n### 9、常见的plugins\ndefine-plugin：定义环境变量\ncommons-chunk-plugin：提取公共代码\nuglifyjs-webpack-plugin：通过UglifyES压缩ES6代码","slug":"webpack","published":1,"updated":"2023-03-22T06:31:48.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqm001t7et8ay7q5k62","content":"<h1 id=\"webpack-打包原理是什么？\"><a href=\"#webpack-打包原理是什么？\" class=\"headerlink\" title=\"webpack 打包原理是什么？\"></a>webpack 打包原理是什么？</h1><h2 id=\"打包原理\"><a href=\"#打包原理\" class=\"headerlink\" title=\"打包原理\"></a>打包原理</h2><p>webpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当 webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。</p>\n<h2 id=\"webpack构建流程：\"><a href=\"#webpack构建流程：\" class=\"headerlink\" title=\"webpack构建流程：\"></a>webpack构建流程：</h2><p>初始化参数—&gt;开始编译—-&gt;确定入口—-&gt;编译模块—&gt;完成编译—-&gt;输出数据—-&gt;输出完成</p>\n<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><p>代码层面：</p>\n<ol>\n<li>体积更小，加载更快</li>\n<li>编译高级语言和语法</li>\n<li>兼容性和错误检查<h2 id=\"研发流程层面：\"><a href=\"#研发流程层面：\" class=\"headerlink\" title=\"研发流程层面：\"></a>研发流程层面：</h2></li>\n<li>统一高效的开发环境</li>\n<li>统一的构建流程和产出标准</li>\n<li>集成公司构建规范（提测、上线）<h2 id=\"核心概念：\"><a href=\"#核心概念：\" class=\"headerlink\" title=\"核心概念：\"></a>核心概念：</h2>entry：入口，webpack的执行从entry开始，<br>output：出口，输出结果，webpack的输出位置，<br>loader：模块转换器，用于把webpack不能直接打包的文件类型转换<br>plugins：插件，用于把模块原内容按需求转换成新内容mode：通过选择development或者production来设置mode参数<br>chunk：代码块，即打包后输出的文件<h2 id=\"基本功能和工作原理\"><a href=\"#基本功能和工作原理\" class=\"headerlink\" title=\"基本功能和工作原理\"></a>基本功能和工作原理</h2>当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括</li>\n<li>代码转换：将无法直接运行的文件代码编译成可以执行的代码</li>\n<li>文件优化：压缩文件代码、压缩合并图片等</li>\n<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载</li>\n<li>模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件</li>\n<li>自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器</li>\n<li>代码校验：在代码被提交前需要校验代码格式等是否符合规范</li>\n<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h3 id=\"1、loader和plugin的区别：\"><a href=\"#1、loader和plugin的区别：\" class=\"headerlink\" title=\"1、loader和plugin的区别：\"></a>1、loader和plugin的区别：</h3><h3 id=\"不同的作用：\"><a href=\"#不同的作用：\" class=\"headerlink\" title=\"不同的作用：\"></a>不同的作用：</h3>loader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具<br>plugins：插件，可以扩展fwebpack的功能，让其更具有灵活性<h3 id=\"不同的用法：\"><a href=\"#不同的用法：\" class=\"headerlink\" title=\"不同的用法：\"></a>不同的用法：</h3>loader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，<br>plugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入<h3 id=\"2、什么事模块化，为什么要用模块化\"><a href=\"#2、什么事模块化，为什么要用模块化\" class=\"headerlink\" title=\"2、什么事模块化，为什么要用模块化\"></a>2、什么事模块化，为什么要用模块化</h3>模块化是指把一个复杂的系统分解到多个模块以方便编码<br>不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码<h3 id=\"3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。\"><a href=\"#3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。\" class=\"headerlink\" title=\"3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。\"></a>3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。</h3>devServer: {<br>  contentBase: resolve(__dirname, ‘build’),<br>  compress: true,<br>  port: 3000,<br>  open: true,<br>  // 开启HMR功能<br>  // 当修改了webpack配置，新配置要想生效，必须重新webpack服务<br>  hot: true<br>}<h3 id=\"4、什么是HMR功能\"><a href=\"#4、什么是HMR功能\" class=\"headerlink\" title=\"4、什么是HMR功能\"></a>4、什么是HMR功能</h3>HMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览<br>优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式<h3 id=\"5、什么是Tree-sharking\"><a href=\"#5、什么是Tree-sharking\" class=\"headerlink\" title=\"5、什么是Tree-sharking?\"></a>5、什么是Tree-sharking?</h3>指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等<h3 id=\"6、babel和webpack的区别\"><a href=\"#6、babel和webpack的区别\" class=\"headerlink\" title=\"6、babel和webpack的区别\"></a>6、babel和webpack的区别</h3>babel JS新语法编译工具，只关心语法，不关心模块化<br>webpack -打包构建工具，是多个Loader plugin的集合<h3 id=\"7、类似webpack的工具还有哪些\"><a href=\"#7、类似webpack的工具还有哪些\" class=\"headerlink\" title=\"7、类似webpack的工具还有哪些\"></a>7、类似webpack的工具还有哪些</h3>(1)、webpack适用于大型复杂的前端站点构建<br>(2)、rollup适用于基础库的打包，如vue、react<br>(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel<h3 id=\"8、常见loader\"><a href=\"#8、常见loader\" class=\"headerlink\" title=\"8、常见loader\"></a>8、常见loader</h3>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<h3 id=\"9、常见的plugins\"><a href=\"#9、常见的plugins\" class=\"headerlink\" title=\"9、常见的plugins\"></a>9、常见的plugins</h3>define-plugin：定义环境变量<br>commons-chunk-plugin：提取公共代码<br>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"webpack-打包原理是什么？\"><a href=\"#webpack-打包原理是什么？\" class=\"headerlink\" title=\"webpack 打包原理是什么？\"></a>webpack 打包原理是什么？</h1><h2 id=\"打包原理\"><a href=\"#打包原理\" class=\"headerlink\" title=\"打包原理\"></a>打包原理</h2><p>webpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当 webpack处理程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，将所有这些模块打包成一个或多个bundle。</p>\n<h2 id=\"webpack构建流程：\"><a href=\"#webpack构建流程：\" class=\"headerlink\" title=\"webpack构建流程：\"></a>webpack构建流程：</h2><p>初始化参数—&gt;开始编译—-&gt;确定入口—-&gt;编译模块—&gt;完成编译—-&gt;输出数据—-&gt;输出完成</p>\n<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><p>代码层面：</p>\n<ol>\n<li>体积更小，加载更快</li>\n<li>编译高级语言和语法</li>\n<li>兼容性和错误检查<h2 id=\"研发流程层面：\"><a href=\"#研发流程层面：\" class=\"headerlink\" title=\"研发流程层面：\"></a>研发流程层面：</h2></li>\n<li>统一高效的开发环境</li>\n<li>统一的构建流程和产出标准</li>\n<li>集成公司构建规范（提测、上线）<h2 id=\"核心概念：\"><a href=\"#核心概念：\" class=\"headerlink\" title=\"核心概念：\"></a>核心概念：</h2>entry：入口，webpack的执行从entry开始，<br>output：出口，输出结果，webpack的输出位置，<br>loader：模块转换器，用于把webpack不能直接打包的文件类型转换<br>plugins：插件，用于把模块原内容按需求转换成新内容mode：通过选择development或者production来设置mode参数<br>chunk：代码块，即打包后输出的文件<h2 id=\"基本功能和工作原理\"><a href=\"#基本功能和工作原理\" class=\"headerlink\" title=\"基本功能和工作原理\"></a>基本功能和工作原理</h2>当源代码没办法直接运行的时候，通过转化将源代码换成可执行的代码，一般包括</li>\n<li>代码转换：将无法直接运行的文件代码编译成可以执行的代码</li>\n<li>文件优化：压缩文件代码、压缩合并图片等</li>\n<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分的代码让其异步加载</li>\n<li>模块合并：在有很多模块文件的环境中，需要将模块分类合并成一个文件</li>\n<li>自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器</li>\n<li>代码校验：在代码被提交前需要校验代码格式等是否符合规范</li>\n<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h3 id=\"1、loader和plugin的区别：\"><a href=\"#1、loader和plugin的区别：\" class=\"headerlink\" title=\"1、loader和plugin的区别：\"></a>1、loader和plugin的区别：</h3><h3 id=\"不同的作用：\"><a href=\"#不同的作用：\" class=\"headerlink\" title=\"不同的作用：\"></a>不同的作用：</h3>loader：webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想打包其他文件的话，就会用到相应的loader，它是用来让webpack拥有加载解析非JS文件的工具<br>plugins：插件，可以扩展fwebpack的功能，让其更具有灵活性<h3 id=\"不同的用法：\"><a href=\"#不同的用法：\" class=\"headerlink\" title=\"不同的用法：\"></a>不同的用法：</h3>loader：在module.rules中配置，也就是说它作为模块的规则存在，类型是数组，数组中的每一项是对象，<br>plugins是在插件中单独配置，类型是数组，每一项是插件实例，参数都通过构造函数传入<h3 id=\"2、什么事模块化，为什么要用模块化\"><a href=\"#2、什么事模块化，为什么要用模块化\" class=\"headerlink\" title=\"2、什么事模块化，为什么要用模块化\"></a>2、什么事模块化，为什么要用模块化</h3>模块化是指把一个复杂的系统分解到多个模块以方便编码<br>不用模块化的话，会出现喝多问题，比如无法合理地管理项目依赖跟版本，也无法方便的控制依赖的加载顺序，当项目变大时难以维护，这时候需要模块化来组织代码<h3 id=\"3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。\"><a href=\"#3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack-在启动时可以开启监听模式，开启监听模式后-Webpack-会监听本地文件系统的变化，发生变化时重新构建出新的结果。\" class=\"headerlink\" title=\"3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。\"></a>3、DevServer开发工具用来自动化（自动编译，自动打开浏览器，自动刷新浏览器）Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。</h3>devServer: {<br>  contentBase: resolve(__dirname, ‘build’),<br>  compress: true,<br>  port: 3000,<br>  open: true,<br>  // 开启HMR功能<br>  // 当修改了webpack配置，新配置要想生效，必须重新webpack服务<br>  hot: true<br>}<h3 id=\"4、什么是HMR功能\"><a href=\"#4、什么是HMR功能\" class=\"headerlink\" title=\"4、什么是HMR功能\"></a>4、什么是HMR功能</h3>HMR又叫热替换，它能在不重新加载整个页面的前提下，通过将更改的模块替换掉被更改的模块，再重新执行实现实时预览<br>优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式<h3 id=\"5、什么是Tree-sharking\"><a href=\"#5、什么是Tree-sharking\" class=\"headerlink\" title=\"5、什么是Tree-sharking?\"></a>5、什么是Tree-sharking?</h3>指打包中去除那些引入了但在代码中没用到的死代码（传统的DCE方法是除去不可能执行的代码）包括空格、注释等<h3 id=\"6、babel和webpack的区别\"><a href=\"#6、babel和webpack的区别\" class=\"headerlink\" title=\"6、babel和webpack的区别\"></a>6、babel和webpack的区别</h3>babel JS新语法编译工具，只关心语法，不关心模块化<br>webpack -打包构建工具，是多个Loader plugin的集合<h3 id=\"7、类似webpack的工具还有哪些\"><a href=\"#7、类似webpack的工具还有哪些\" class=\"headerlink\" title=\"7、类似webpack的工具还有哪些\"></a>7、类似webpack的工具还有哪些</h3>(1)、webpack适用于大型复杂的前端站点构建<br>(2)、rollup适用于基础库的打包，如vue、react<br>(3)、parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel<h3 id=\"8、常见loader\"><a href=\"#8、常见loader\" class=\"headerlink\" title=\"8、常见loader\"></a>8、常见loader</h3>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<h3 id=\"9、常见的plugins\"><a href=\"#9、常见的plugins\" class=\"headerlink\" title=\"9、常见的plugins\"></a>9、常见的plugins</h3>define-plugin：定义环境变量<br>commons-chunk-plugin：提取公共代码<br>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li>\n</ol>\n"},{"title":"跨域","date":"2022-09-30T04:30:52.000Z","_content":"# 一、跨域是什么？\n## 1.同源策略\n跨域问题其实就是浏览器的同源策略所导致的。\n「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\n只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。\n\n# 二、如何解决跨域？\n方式一：使用 ajax 的 jsonp\n使用该方式的缺点：请求方式只能是 get 请求\n\n# 方式二：使用 jQuery 的 jsonp 插件\n特点： get 请求、 post 请求；\n但从服务器从获取的数据，依然是 jsonp 格式。\n\n# 方式三：使用 cors\n使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。\n\n# 方式四：使用 Nginx 反向代理\nNginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。","source":"_posts/跨域.md","raw":"---\ntitle: 跨域\ndate: 2022-09-30 12:30:52\ntags: 跨域\ncategories: 知识点\n---\n# 一、跨域是什么？\n## 1.同源策略\n跨域问题其实就是浏览器的同源策略所导致的。\n「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\n只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。\n\n# 二、如何解决跨域？\n方式一：使用 ajax 的 jsonp\n使用该方式的缺点：请求方式只能是 get 请求\n\n# 方式二：使用 jQuery 的 jsonp 插件\n特点： get 请求、 post 请求；\n但从服务器从获取的数据，依然是 jsonp 格式。\n\n# 方式三：使用 cors\n使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。\n\n# 方式四：使用 Nginx 反向代理\nNginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。","slug":"跨域","published":1,"updated":"2023-03-22T06:09:11.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqn001w7et89fkz7srs","content":"<h1 id=\"一、跨域是什么？\"><a href=\"#一、跨域是什么？\" class=\"headerlink\" title=\"一、跨域是什么？\"></a>一、跨域是什么？</h1><h2 id=\"1-同源策略\"><a href=\"#1-同源策略\" class=\"headerlink\" title=\"1.同源策略\"></a>1.同源策略</h2><p>跨域问题其实就是浏览器的同源策略所导致的。<br>「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。<br>只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。</p>\n<h1 id=\"二、如何解决跨域？\"><a href=\"#二、如何解决跨域？\" class=\"headerlink\" title=\"二、如何解决跨域？\"></a>二、如何解决跨域？</h1><p>方式一：使用 ajax 的 jsonp<br>使用该方式的缺点：请求方式只能是 get 请求</p>\n<h1 id=\"方式二：使用-jQuery-的-jsonp-插件\"><a href=\"#方式二：使用-jQuery-的-jsonp-插件\" class=\"headerlink\" title=\"方式二：使用 jQuery 的 jsonp 插件\"></a>方式二：使用 jQuery 的 jsonp 插件</h1><p>特点： get 请求、 post 请求；<br>但从服务器从获取的数据，依然是 jsonp 格式。</p>\n<h1 id=\"方式三：使用-cors\"><a href=\"#方式三：使用-cors\" class=\"headerlink\" title=\"方式三：使用 cors\"></a>方式三：使用 cors</h1><p>使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。</p>\n<h1 id=\"方式四：使用-Nginx-反向代理\"><a href=\"#方式四：使用-Nginx-反向代理\" class=\"headerlink\" title=\"方式四：使用 Nginx 反向代理\"></a>方式四：使用 Nginx 反向代理</h1><p>Nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、跨域是什么？\"><a href=\"#一、跨域是什么？\" class=\"headerlink\" title=\"一、跨域是什么？\"></a>一、跨域是什么？</h1><h2 id=\"1-同源策略\"><a href=\"#1-同源策略\" class=\"headerlink\" title=\"1.同源策略\"></a>1.同源策略</h2><p>跨域问题其实就是浏览器的同源策略所导致的。<br>「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。<br>只有当「protocol（协议）、domain（域名）、port（端口）三者一致。」才是同源。</p>\n<h1 id=\"二、如何解决跨域？\"><a href=\"#二、如何解决跨域？\" class=\"headerlink\" title=\"二、如何解决跨域？\"></a>二、如何解决跨域？</h1><p>方式一：使用 ajax 的 jsonp<br>使用该方式的缺点：请求方式只能是 get 请求</p>\n<h1 id=\"方式二：使用-jQuery-的-jsonp-插件\"><a href=\"#方式二：使用-jQuery-的-jsonp-插件\" class=\"headerlink\" title=\"方式二：使用 jQuery 的 jsonp 插件\"></a>方式二：使用 jQuery 的 jsonp 插件</h1><p>特点： get 请求、 post 请求；<br>但从服务器从获取的数据，依然是 jsonp 格式。</p>\n<h1 id=\"方式三：使用-cors\"><a href=\"#方式三：使用-cors\" class=\"headerlink\" title=\"方式三：使用 cors\"></a>方式三：使用 cors</h1><p>使用该方式的特点：与前两种方式相比，前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。</p>\n<h1 id=\"方式四：使用-Nginx-反向代理\"><a href=\"#方式四：使用-Nginx-反向代理\" class=\"headerlink\" title=\"方式四：使用 Nginx 反向代理\"></a>方式四：使用 Nginx 反向代理</h1><p>Nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。</p>\n"},{"title":"数组，对象遍历的用法总结","date":"2023-03-21T03:06:45.000Z","_content":"作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。\n前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。\n\n# 一、遍历数组\n## 方法一：for循环\n### for 循环是使用最多，也是性能优化最好的一种遍历方式。\nvar arr = [\"a\", \"b\", \"c\"]\nfor (var i = 0; i < arr.length; i++) {\n  console.log(arr[i])\n}\n// Expected output:a b c\n## 方法二：for-of 遍历\nvar arr = [\"a\", \"b\", \"c\"]\nfor (let item of arr) {\n  console.log(item)\n}\n// Expected output:a b c\n## 方法三：数组方法\n### 1.forEach()方法，对原数组没有影响\nvar arr = [\"a\", \"b\", \"c\"]\narr.forEach((index, item) => {\n  console.log(index, item)\n})\n//Expected output:\n// a 0\n// b 1\n// c 2\n****\n### 2.map()方法\nvar arr = [1, 2, 3]\nvar newArr = arr.map(item => {\n  return item * 2\n});\nconsole.log(newArr); \n// Expected output:[2, 4, 6]\n****\n### 3.filter()方法，不改变原始数组\nvar arr = [1, 2, 3]\nvar newArr = arr.filter(item => {\n  return item > 1\n});\nconsole.log(newArr)\n// Expected output:[2, 3]\n****\n### 4.reduce()方法\nvar arr = [1, 2, 3]\nvar sum = arr.reduce((pre, cur) => {\n  return pre + cur\n});\nconsole.log(sum)\n// Expected output:6\n****\n### 5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\nvar arr = [1, 2, 3]\nvar bool = arr.every(item => {\n  return item < 5\n});\nconsole.log(bool)\n// Expected output:true\n****\n### 6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。\n#### 下面的例子是检测数组元素是否存在 Number 类型。\nvar arr = [\"a\", 1, \"b\"]\nvar bool = arr.some(item => {\n  return typeof item === \"number\"\n})\nconsole.log(bool)\n// Expected output:true\n****\n### 7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。\nlet arr = [1, 2, 3, 4, 5]\nlet find = arr.find((item) => {\n  return item % 2 === 0\n})\n// Expected output:find =2\n****\nvar arr = [1, 2, 3]\nvar ret = arr.find(ele => ele > 2)\nconsole.log(ret)\n// Expected output:3\nconsole.log(arr)\n// Expected output:[1, 2, 3]\n****\n### 8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。\nlet arr = [1, 2, 3, 4, 5]\nlet findIndex = arr.findIndex((item) => {\n  return item % 2 === 0\n}) \n// Expected output:findIndex = 1\n****\nvar arr = [1, 2, 3, 4 ,5]\nvar ret = arr.findIndex(ele => ele > 2) \nconsole.log(ret)\n// Expected output:2\n console.log(arr)\n// Expected output:[1, 2, 3, 4, 5]\n****\n\n# 二、遍历对象\n## 方法一：for-in 循环\nvar obj = { a: 2, b: 4, c: 6 }\nfor (let key in obj) {\n  console.log(key)\n}\n// Expected output:a b c\n## 方法二：Object.keys() 可理解为返回里面的key属性\n### 1.处理对象时：返回可枚举的属性数组\nvar w_n = Object.keys({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:['name', 'address']\n****\n### 2.处理数组时：返回索引值数组\nvar w_n = Object.keys([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:['0','1','2','3']\n****\n### 3.处理字符串数据时：返回索引值数组\nvar str='hello';\nconsole.log(Object.keys(str))\n// Expected output:['0','1','2','3','4']\n## 方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。\n### 1.处理对象数据时：返回可枚举的值组成的数组\nvar w_n = Object.values({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:['wn', '中国']\n****\n### 2.处理数组数据时：返回原数组\nvar w_n = Object.values([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:[11,22,33,44]\n****\n### 属性名为数值的属性，是按照数值大小，从小到大遍历的。\nconst obj = {10 : \"a\", 6 : \"b\", 9 : \"c\"}\nconsole.log(Object.values(obj))\n// Expected output:['b', 'c', 'a']\n****\n### 3.处理字符串数据时：返回每个字符组成的数组\nconsole.log(Object.values('hello'))\n// Expected output:['h', 'e', 'l', 'l', 'o']\n****\n### 4.Object.values会过滤属性名为 Symbol 值的属性\nObject.values({ [Symbol()]: 123, foo: 'abc' })\n// Expected output:['abc']\n## 方法四：Object.entries()方法\n### 1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。\nvar w_n = Object.entries({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:[['name', 'wn'], ['address', '中国']]\n****\n### 2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。\nvar w_n = Object.entries([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:[ ['0',11], ['1',22], ['2',33], ['3',44] ]\n****\n### 数组中包含对象：\nvar w_n = Object.entries([{a:11},22,33,44]) \nconsole.log(w_n)\n// Expected output:[ ['0',{a:11}], ['1',22], ['2',33], ['3',44] ]\n****\n### 3.处理字符串数据时：返回也是一个二维数组。\nvar str='hello'\nconsole.log(Object.entries(str)) \n// Expected output:[ ['0','h'], ['1','e'], ['2','l'], ['3','l'] ,['4','o'] ]\n## 方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。\n### 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target);\n// Expected output: Object { a: 1, b: 4, c: 5 }\n## 方法六：Object.getOwnPropertyNames()\n### Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for...in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\nvar arr = [\"a\", \"b\", \"c\"]\nconsole.log(Object.getOwnPropertyNames(arr).sort()) \n// [\"0\", \"1\", \"2\", \"length\"]\n****\n### // 类数组对象\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"}\nconsole.log(Object.getOwnPropertyNames(obj).sort())\n// Expected output:[\"0\", \"1\", \"2\"]\n****\n### // 使用 Array.forEach 输出属性名和属性值\nObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n  console.log(val + \" -> \" + obj[val])\n})\n// Expected output:\n// 0 -> a\n// 1 -> b\n// 2 -> c\n****\n### //不可枚举属性\nvar my_obj = Object.create({}, {\n  getFoo: {\n    value: function() { return this.foo; },\n    enumerable: false\n  }\n})\nmy_obj.foo = 1\nconsole.log(Object.getOwnPropertyNames(my_obj).sort())\n// Expected output:[\"foo\", \"getFoo\"]\n\n","source":"_posts/数组，对象遍历的用法总结.md","raw":"---\ntitle: 数组，对象遍历的用法总结\ndate: 2023-03-21 11:06:45\ntags: JavaScript\ncategories: JavaScript\n---\n作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。\n前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。\n\n# 一、遍历数组\n## 方法一：for循环\n### for 循环是使用最多，也是性能优化最好的一种遍历方式。\nvar arr = [\"a\", \"b\", \"c\"]\nfor (var i = 0; i < arr.length; i++) {\n  console.log(arr[i])\n}\n// Expected output:a b c\n## 方法二：for-of 遍历\nvar arr = [\"a\", \"b\", \"c\"]\nfor (let item of arr) {\n  console.log(item)\n}\n// Expected output:a b c\n## 方法三：数组方法\n### 1.forEach()方法，对原数组没有影响\nvar arr = [\"a\", \"b\", \"c\"]\narr.forEach((index, item) => {\n  console.log(index, item)\n})\n//Expected output:\n// a 0\n// b 1\n// c 2\n****\n### 2.map()方法\nvar arr = [1, 2, 3]\nvar newArr = arr.map(item => {\n  return item * 2\n});\nconsole.log(newArr); \n// Expected output:[2, 4, 6]\n****\n### 3.filter()方法，不改变原始数组\nvar arr = [1, 2, 3]\nvar newArr = arr.filter(item => {\n  return item > 1\n});\nconsole.log(newArr)\n// Expected output:[2, 3]\n****\n### 4.reduce()方法\nvar arr = [1, 2, 3]\nvar sum = arr.reduce((pre, cur) => {\n  return pre + cur\n});\nconsole.log(sum)\n// Expected output:6\n****\n### 5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\nvar arr = [1, 2, 3]\nvar bool = arr.every(item => {\n  return item < 5\n});\nconsole.log(bool)\n// Expected output:true\n****\n### 6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。\n#### 下面的例子是检测数组元素是否存在 Number 类型。\nvar arr = [\"a\", 1, \"b\"]\nvar bool = arr.some(item => {\n  return typeof item === \"number\"\n})\nconsole.log(bool)\n// Expected output:true\n****\n### 7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。\nlet arr = [1, 2, 3, 4, 5]\nlet find = arr.find((item) => {\n  return item % 2 === 0\n})\n// Expected output:find =2\n****\nvar arr = [1, 2, 3]\nvar ret = arr.find(ele => ele > 2)\nconsole.log(ret)\n// Expected output:3\nconsole.log(arr)\n// Expected output:[1, 2, 3]\n****\n### 8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。\nlet arr = [1, 2, 3, 4, 5]\nlet findIndex = arr.findIndex((item) => {\n  return item % 2 === 0\n}) \n// Expected output:findIndex = 1\n****\nvar arr = [1, 2, 3, 4 ,5]\nvar ret = arr.findIndex(ele => ele > 2) \nconsole.log(ret)\n// Expected output:2\n console.log(arr)\n// Expected output:[1, 2, 3, 4, 5]\n****\n\n# 二、遍历对象\n## 方法一：for-in 循环\nvar obj = { a: 2, b: 4, c: 6 }\nfor (let key in obj) {\n  console.log(key)\n}\n// Expected output:a b c\n## 方法二：Object.keys() 可理解为返回里面的key属性\n### 1.处理对象时：返回可枚举的属性数组\nvar w_n = Object.keys({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:['name', 'address']\n****\n### 2.处理数组时：返回索引值数组\nvar w_n = Object.keys([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:['0','1','2','3']\n****\n### 3.处理字符串数据时：返回索引值数组\nvar str='hello';\nconsole.log(Object.keys(str))\n// Expected output:['0','1','2','3','4']\n## 方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。\n### 1.处理对象数据时：返回可枚举的值组成的数组\nvar w_n = Object.values({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:['wn', '中国']\n****\n### 2.处理数组数据时：返回原数组\nvar w_n = Object.values([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:[11,22,33,44]\n****\n### 属性名为数值的属性，是按照数值大小，从小到大遍历的。\nconst obj = {10 : \"a\", 6 : \"b\", 9 : \"c\"}\nconsole.log(Object.values(obj))\n// Expected output:['b', 'c', 'a']\n****\n### 3.处理字符串数据时：返回每个字符组成的数组\nconsole.log(Object.values('hello'))\n// Expected output:['h', 'e', 'l', 'l', 'o']\n****\n### 4.Object.values会过滤属性名为 Symbol 值的属性\nObject.values({ [Symbol()]: 123, foo: 'abc' })\n// Expected output:['abc']\n## 方法四：Object.entries()方法\n### 1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。\nvar w_n = Object.entries({name: \"wn\", address: \"中国\"}) \nconsole.log(w_n)\n// Expected output:[['name', 'wn'], ['address', '中国']]\n****\n### 2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。\nvar w_n = Object.entries([11,22,33,44]) \nconsole.log(w_n)\n// Expected output:[ ['0',11], ['1',22], ['2',33], ['3',44] ]\n****\n### 数组中包含对象：\nvar w_n = Object.entries([{a:11},22,33,44]) \nconsole.log(w_n)\n// Expected output:[ ['0',{a:11}], ['1',22], ['2',33], ['3',44] ]\n****\n### 3.处理字符串数据时：返回也是一个二维数组。\nvar str='hello'\nconsole.log(Object.entries(str)) \n// Expected output:[ ['0','h'], ['1','e'], ['2','l'], ['3','l'] ,['4','o'] ]\n## 方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。\n### 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target);\n// Expected output: Object { a: 1, b: 4, c: 5 }\n## 方法六：Object.getOwnPropertyNames()\n### Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for...in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\nvar arr = [\"a\", \"b\", \"c\"]\nconsole.log(Object.getOwnPropertyNames(arr).sort()) \n// [\"0\", \"1\", \"2\", \"length\"]\n****\n### // 类数组对象\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"}\nconsole.log(Object.getOwnPropertyNames(obj).sort())\n// Expected output:[\"0\", \"1\", \"2\"]\n****\n### // 使用 Array.forEach 输出属性名和属性值\nObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n  console.log(val + \" -> \" + obj[val])\n})\n// Expected output:\n// 0 -> a\n// 1 -> b\n// 2 -> c\n****\n### //不可枚举属性\nvar my_obj = Object.create({}, {\n  getFoo: {\n    value: function() { return this.foo; },\n    enumerable: false\n  }\n})\nmy_obj.foo = 1\nconsole.log(Object.getOwnPropertyNames(my_obj).sort())\n// Expected output:[\"foo\", \"getFoo\"]\n\n","slug":"数组，对象遍历的用法总结","published":1,"updated":"2023-03-22T06:03:11.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqn001y7et84hwp4ikv","content":"<p>作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。<br>前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。</p>\n<h1 id=\"一、遍历数组\"><a href=\"#一、遍历数组\" class=\"headerlink\" title=\"一、遍历数组\"></a>一、遍历数组</h1><h2 id=\"方法一：for循环\"><a href=\"#方法一：for循环\" class=\"headerlink\" title=\"方法一：for循环\"></a>方法一：for循环</h2><h3 id=\"for-循环是使用最多，也是性能优化最好的一种遍历方式。\"><a href=\"#for-循环是使用最多，也是性能优化最好的一种遍历方式。\" class=\"headerlink\" title=\"for 循环是使用最多，也是性能优化最好的一种遍历方式。\"></a>for 循环是使用最多，也是性能优化最好的一种遍历方式。</h3><p>var arr = [“a”, “b”, “c”]<br>for (var i = 0; i &lt; arr.length; i++) {<br>  console.log(arr[i])<br>}<br>// Expected output:a b c</p>\n<h2 id=\"方法二：for-of-遍历\"><a href=\"#方法二：for-of-遍历\" class=\"headerlink\" title=\"方法二：for-of 遍历\"></a>方法二：for-of 遍历</h2><p>var arr = [“a”, “b”, “c”]<br>for (let item of arr) {<br>  console.log(item)<br>}<br>// Expected output:a b c</p>\n<h2 id=\"方法三：数组方法\"><a href=\"#方法三：数组方法\" class=\"headerlink\" title=\"方法三：数组方法\"></a>方法三：数组方法</h2><h3 id=\"1-forEach-方法，对原数组没有影响\"><a href=\"#1-forEach-方法，对原数组没有影响\" class=\"headerlink\" title=\"1.forEach()方法，对原数组没有影响\"></a>1.forEach()方法，对原数组没有影响</h3><p>var arr = [“a”, “b”, “c”]<br>arr.forEach((index, item) =&gt; {<br>  console.log(index, item)<br>})<br>//Expected output:<br>// a 0<br>// b 1<br>// c 2</p>\n<hr>\n<h3 id=\"2-map-方法\"><a href=\"#2-map-方法\" class=\"headerlink\" title=\"2.map()方法\"></a>2.map()方法</h3><p>var arr = [1, 2, 3]<br>var newArr = arr.map(item =&gt; {<br>  return item * 2<br>});<br>console.log(newArr);<br>// Expected output:[2, 4, 6]</p>\n<hr>\n<h3 id=\"3-filter-方法，不改变原始数组\"><a href=\"#3-filter-方法，不改变原始数组\" class=\"headerlink\" title=\"3.filter()方法，不改变原始数组\"></a>3.filter()方法，不改变原始数组</h3><p>var arr = [1, 2, 3]<br>var newArr = arr.filter(item =&gt; {<br>  return item &gt; 1<br>});<br>console.log(newArr)<br>// Expected output:[2, 3]</p>\n<hr>\n<h3 id=\"4-reduce-方法\"><a href=\"#4-reduce-方法\" class=\"headerlink\" title=\"4.reduce()方法\"></a>4.reduce()方法</h3><p>var arr = [1, 2, 3]<br>var sum = arr.reduce((pre, cur) =&gt; {<br>  return pre + cur<br>});<br>console.log(sum)<br>// Expected output:6</p>\n<hr>\n<h3 id=\"5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\"><a href=\"#5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\" class=\"headerlink\" title=\"5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\"></a>5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。</h3><p>var arr = [1, 2, 3]<br>var bool = arr.every(item =&gt; {<br>  return item &lt; 5<br>});<br>console.log(bool)<br>// Expected output:true</p>\n<hr>\n<h3 id=\"6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。\"><a href=\"#6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。\" class=\"headerlink\" title=\"6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。\"></a>6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。</h3><h4 id=\"下面的例子是检测数组元素是否存在-Number-类型。\"><a href=\"#下面的例子是检测数组元素是否存在-Number-类型。\" class=\"headerlink\" title=\"下面的例子是检测数组元素是否存在 Number 类型。\"></a>下面的例子是检测数组元素是否存在 Number 类型。</h4><p>var arr = [“a”, 1, “b”]<br>var bool = arr.some(item =&gt; {<br>  return typeof item === “number”<br>})<br>console.log(bool)<br>// Expected output:true</p>\n<hr>\n<h3 id=\"7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。\"><a href=\"#7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。\" class=\"headerlink\" title=\"7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。\"></a>7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。</h3><p>let arr = [1, 2, 3, 4, 5]<br>let find = arr.find((item) =&gt; {<br>  return item % 2 === 0<br>})<br>// Expected output:find =2</p>\n<hr>\n<p>var arr = [1, 2, 3]<br>var ret = arr.find(ele =&gt; ele &gt; 2)<br>console.log(ret)<br>// Expected output:3<br>console.log(arr)<br>// Expected output:[1, 2, 3]</p>\n<hr>\n<h3 id=\"8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。\"><a href=\"#8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。\" class=\"headerlink\" title=\"8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。\"></a>8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。</h3><p>let arr = [1, 2, 3, 4, 5]<br>let findIndex = arr.findIndex((item) =&gt; {<br>  return item % 2 === 0<br>})<br>// Expected output:findIndex = 1</p>\n<hr>\n<p>var arr = [1, 2, 3, 4 ,5]<br>var ret = arr.findIndex(ele =&gt; ele &gt; 2)<br>console.log(ret)<br>// Expected output:2<br> console.log(arr)<br>// Expected output:[1, 2, 3, 4, 5]</p>\n<hr>\n<h1 id=\"二、遍历对象\"><a href=\"#二、遍历对象\" class=\"headerlink\" title=\"二、遍历对象\"></a>二、遍历对象</h1><h2 id=\"方法一：for-in-循环\"><a href=\"#方法一：for-in-循环\" class=\"headerlink\" title=\"方法一：for-in 循环\"></a>方法一：for-in 循环</h2><p>var obj = { a: 2, b: 4, c: 6 }<br>for (let key in obj) {<br>  console.log(key)<br>}<br>// Expected output:a b c</p>\n<h2 id=\"方法二：Object-keys-可理解为返回里面的key属性\"><a href=\"#方法二：Object-keys-可理解为返回里面的key属性\" class=\"headerlink\" title=\"方法二：Object.keys() 可理解为返回里面的key属性\"></a>方法二：Object.keys() 可理解为返回里面的key属性</h2><h3 id=\"1-处理对象时：返回可枚举的属性数组\"><a href=\"#1-处理对象时：返回可枚举的属性数组\" class=\"headerlink\" title=\"1.处理对象时：返回可枚举的属性数组\"></a>1.处理对象时：返回可枚举的属性数组</h3><p>var w_n = Object.keys({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[‘name’, ‘address’]</p>\n<hr>\n<h3 id=\"2-处理数组时：返回索引值数组\"><a href=\"#2-处理数组时：返回索引值数组\" class=\"headerlink\" title=\"2.处理数组时：返回索引值数组\"></a>2.处理数组时：返回索引值数组</h3><p>var w_n = Object.keys([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[‘0’,’1’,’2’,’3’]</p>\n<hr>\n<h3 id=\"3-处理字符串数据时：返回索引值数组\"><a href=\"#3-处理字符串数据时：返回索引值数组\" class=\"headerlink\" title=\"3.处理字符串数据时：返回索引值数组\"></a>3.处理字符串数据时：返回索引值数组</h3><p>var str=’hello’;<br>console.log(Object.keys(str))<br>// Expected output:[‘0’,’1’,’2’,’3’,’4’]</p>\n<h2 id=\"方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。\"><a href=\"#方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。\" class=\"headerlink\" title=\"方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。\"></a>方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。</h2><h3 id=\"1-处理对象数据时：返回可枚举的值组成的数组\"><a href=\"#1-处理对象数据时：返回可枚举的值组成的数组\" class=\"headerlink\" title=\"1.处理对象数据时：返回可枚举的值组成的数组\"></a>1.处理对象数据时：返回可枚举的值组成的数组</h3><p>var w_n = Object.values({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[‘wn’, ‘中国’]</p>\n<hr>\n<h3 id=\"2-处理数组数据时：返回原数组\"><a href=\"#2-处理数组数据时：返回原数组\" class=\"headerlink\" title=\"2.处理数组数据时：返回原数组\"></a>2.处理数组数据时：返回原数组</h3><p>var w_n = Object.values([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[11,22,33,44]</p>\n<hr>\n<h3 id=\"属性名为数值的属性，是按照数值大小，从小到大遍历的。\"><a href=\"#属性名为数值的属性，是按照数值大小，从小到大遍历的。\" class=\"headerlink\" title=\"属性名为数值的属性，是按照数值大小，从小到大遍历的。\"></a>属性名为数值的属性，是按照数值大小，从小到大遍历的。</h3><p>const obj = {10 : “a”, 6 : “b”, 9 : “c”}<br>console.log(Object.values(obj))<br>// Expected output:[‘b’, ‘c’, ‘a’]</p>\n<hr>\n<h3 id=\"3-处理字符串数据时：返回每个字符组成的数组\"><a href=\"#3-处理字符串数据时：返回每个字符组成的数组\" class=\"headerlink\" title=\"3.处理字符串数据时：返回每个字符组成的数组\"></a>3.处理字符串数据时：返回每个字符组成的数组</h3><p>console.log(Object.values(‘hello’))<br>// Expected output:[‘h’, ‘e’, ‘l’, ‘l’, ‘o’]</p>\n<hr>\n<h3 id=\"4-Object-values会过滤属性名为-Symbol-值的属性\"><a href=\"#4-Object-values会过滤属性名为-Symbol-值的属性\" class=\"headerlink\" title=\"4.Object.values会过滤属性名为 Symbol 值的属性\"></a>4.Object.values会过滤属性名为 Symbol 值的属性</h3><p>Object.values({ [Symbol()]: 123, foo: ‘abc’ })<br>// Expected output:[‘abc’]</p>\n<h2 id=\"方法四：Object-entries-方法\"><a href=\"#方法四：Object-entries-方法\" class=\"headerlink\" title=\"方法四：Object.entries()方法\"></a>方法四：Object.entries()方法</h2><h3 id=\"1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。\"><a href=\"#1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。\" class=\"headerlink\" title=\"1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。\"></a>1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。</h3><p>var w_n = Object.entries({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[[‘name’, ‘wn’], [‘address’, ‘中国’]]</p>\n<hr>\n<h3 id=\"2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。\"><a href=\"#2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。\" class=\"headerlink\" title=\"2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。\"></a>2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。</h3><p>var w_n = Object.entries([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[ [‘0’,11], [‘1’,22], [‘2’,33], [‘3’,44] ]</p>\n<hr>\n<h3 id=\"数组中包含对象：\"><a href=\"#数组中包含对象：\" class=\"headerlink\" title=\"数组中包含对象：\"></a>数组中包含对象：</h3><p>var w_n = Object.entries([{a:11},22,33,44])<br>console.log(w_n)<br>// Expected output:[ [‘0’,{a:11}], [‘1’,22], [‘2’,33], [‘3’,44] ]</p>\n<hr>\n<h3 id=\"3-处理字符串数据时：返回也是一个二维数组。\"><a href=\"#3-处理字符串数据时：返回也是一个二维数组。\" class=\"headerlink\" title=\"3.处理字符串数据时：返回也是一个二维数组。\"></a>3.处理字符串数据时：返回也是一个二维数组。</h3><p>var str=’hello’<br>console.log(Object.entries(str))<br>// Expected output:[ [‘0’,’h’], [‘1’,’e’], [‘2’,’l’], [‘3’,’l’] ,[‘4’,’o’] ]</p>\n<h2 id=\"方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。\"><a href=\"#方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。\" class=\"headerlink\" title=\"方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。\"></a>方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</h2><h3 id=\"注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\"><a href=\"#注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\" class=\"headerlink\" title=\"注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\"></a>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</h3><p>const target = { a: 1, b: 2 };<br>const source = { b: 4, c: 5 };<br>const returnedTarget = Object.assign(target, source);<br>console.log(target);<br>// Expected output: Object { a: 1, b: 4, c: 5 }</p>\n<h2 id=\"方法六：Object-getOwnPropertyNames\"><a href=\"#方法六：Object-getOwnPropertyNames\" class=\"headerlink\" title=\"方法六：Object.getOwnPropertyNames()\"></a>方法六：Object.getOwnPropertyNames()</h2><h3 id=\"Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\"><a href=\"#Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\" class=\"headerlink\" title=\"Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\"></a>Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。</h3><p>var arr = [“a”, “b”, “c”]<br>console.log(Object.getOwnPropertyNames(arr).sort())<br>// [“0”, “1”, “2”, “length”]</p>\n<hr>\n<h3 id=\"类数组对象\"><a href=\"#类数组对象\" class=\"headerlink\" title=\"// 类数组对象\"></a>// 类数组对象</h3><p>var obj = { 0: “a”, 1: “b”, 2: “c”}<br>console.log(Object.getOwnPropertyNames(obj).sort())<br>// Expected output:[“0”, “1”, “2”]</p>\n<hr>\n<h3 id=\"使用-Array-forEach-输出属性名和属性值\"><a href=\"#使用-Array-forEach-输出属性名和属性值\" class=\"headerlink\" title=\"// 使用 Array.forEach 输出属性名和属性值\"></a>// 使用 Array.forEach 输出属性名和属性值</h3><p>Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) {<br>  console.log(val + “ -&gt; “ + obj[val])<br>})<br>// Expected output:<br>// 0 -&gt; a<br>// 1 -&gt; b<br>// 2 -&gt; c</p>\n<hr>\n<h3 id=\"不可枚举属性\"><a href=\"#不可枚举属性\" class=\"headerlink\" title=\"//不可枚举属性\"></a>//不可枚举属性</h3><p>var my_obj = Object.create({}, {<br>  getFoo: {<br>    value: function() { return this.foo; },<br>    enumerable: false<br>  }<br>})<br>my_obj.foo = 1<br>console.log(Object.getOwnPropertyNames(my_obj).sort())<br>// Expected output:[“foo”, “getFoo”]</p>\n","site":{"data":{}},"excerpt":"","more":"<p>作为一个前端开发，我们在完成前端开发的过程中，经常会遇到很多数据处理的需求，开发者会根据不同的业务需求来实现对应的业务功能。<br>前端在渲染页面时，通常会涉及到要对拿到的数据进行处理。这里介绍几种数组，对象遍历的数据处理方法。</p>\n<h1 id=\"一、遍历数组\"><a href=\"#一、遍历数组\" class=\"headerlink\" title=\"一、遍历数组\"></a>一、遍历数组</h1><h2 id=\"方法一：for循环\"><a href=\"#方法一：for循环\" class=\"headerlink\" title=\"方法一：for循环\"></a>方法一：for循环</h2><h3 id=\"for-循环是使用最多，也是性能优化最好的一种遍历方式。\"><a href=\"#for-循环是使用最多，也是性能优化最好的一种遍历方式。\" class=\"headerlink\" title=\"for 循环是使用最多，也是性能优化最好的一种遍历方式。\"></a>for 循环是使用最多，也是性能优化最好的一种遍历方式。</h3><p>var arr = [“a”, “b”, “c”]<br>for (var i = 0; i &lt; arr.length; i++) {<br>  console.log(arr[i])<br>}<br>// Expected output:a b c</p>\n<h2 id=\"方法二：for-of-遍历\"><a href=\"#方法二：for-of-遍历\" class=\"headerlink\" title=\"方法二：for-of 遍历\"></a>方法二：for-of 遍历</h2><p>var arr = [“a”, “b”, “c”]<br>for (let item of arr) {<br>  console.log(item)<br>}<br>// Expected output:a b c</p>\n<h2 id=\"方法三：数组方法\"><a href=\"#方法三：数组方法\" class=\"headerlink\" title=\"方法三：数组方法\"></a>方法三：数组方法</h2><h3 id=\"1-forEach-方法，对原数组没有影响\"><a href=\"#1-forEach-方法，对原数组没有影响\" class=\"headerlink\" title=\"1.forEach()方法，对原数组没有影响\"></a>1.forEach()方法，对原数组没有影响</h3><p>var arr = [“a”, “b”, “c”]<br>arr.forEach((index, item) =&gt; {<br>  console.log(index, item)<br>})<br>//Expected output:<br>// a 0<br>// b 1<br>// c 2</p>\n<hr>\n<h3 id=\"2-map-方法\"><a href=\"#2-map-方法\" class=\"headerlink\" title=\"2.map()方法\"></a>2.map()方法</h3><p>var arr = [1, 2, 3]<br>var newArr = arr.map(item =&gt; {<br>  return item * 2<br>});<br>console.log(newArr);<br>// Expected output:[2, 4, 6]</p>\n<hr>\n<h3 id=\"3-filter-方法，不改变原始数组\"><a href=\"#3-filter-方法，不改变原始数组\" class=\"headerlink\" title=\"3.filter()方法，不改变原始数组\"></a>3.filter()方法，不改变原始数组</h3><p>var arr = [1, 2, 3]<br>var newArr = arr.filter(item =&gt; {<br>  return item &gt; 1<br>});<br>console.log(newArr)<br>// Expected output:[2, 3]</p>\n<hr>\n<h3 id=\"4-reduce-方法\"><a href=\"#4-reduce-方法\" class=\"headerlink\" title=\"4.reduce()方法\"></a>4.reduce()方法</h3><p>var arr = [1, 2, 3]<br>var sum = arr.reduce((pre, cur) =&gt; {<br>  return pre + cur<br>});<br>console.log(sum)<br>// Expected output:6</p>\n<hr>\n<h3 id=\"5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\"><a href=\"#5-every-方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every-是对数组中的每一项运行给定函数，如果该函数对每一项返回true-则返回true-在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\" class=\"headerlink\" title=\"5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。\"></a>5.every()方法用于检测数组元素是否全部符合指定条件，只有全部满足条件时才会返回true。every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true;在执行的过程中，如果遇到了false的情况，就停止继续往下执行；直接返回false。</h3><p>var arr = [1, 2, 3]<br>var bool = arr.every(item =&gt; {<br>  return item &lt; 5<br>});<br>console.log(bool)<br>// Expected output:true</p>\n<hr>\n<h3 id=\"6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。\"><a href=\"#6-some-方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some-是对数组中的每一项运行指定函数；该函数对其中任意一项返回true-就返回true-返回true就不再往下执行。\" class=\"headerlink\" title=\"6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。\"></a>6.some()方法用于检测数组是否存在一个符合指定条件的元素，只有一个满足条件就返回true。some()是对数组中的每一项运行指定函数；该函数对其中任意一项返回true, 就返回true; 返回true就不再往下执行。</h3><h4 id=\"下面的例子是检测数组元素是否存在-Number-类型。\"><a href=\"#下面的例子是检测数组元素是否存在-Number-类型。\" class=\"headerlink\" title=\"下面的例子是检测数组元素是否存在 Number 类型。\"></a>下面的例子是检测数组元素是否存在 Number 类型。</h4><p>var arr = [“a”, 1, “b”]<br>var bool = arr.some(item =&gt; {<br>  return typeof item === “number”<br>})<br>console.log(bool)<br>// Expected output:true</p>\n<hr>\n<h3 id=\"7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。\"><a href=\"#7-find-返回数组中符合条件的第一个元素；没有就返回undefined-不改变原始数组-find对空数组不执行。\" class=\"headerlink\" title=\"7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。\"></a>7.find() 返回数组中符合条件的第一个元素；没有就返回undefined,不改变原始数组,find对空数组不执行。</h3><p>let arr = [1, 2, 3, 4, 5]<br>let find = arr.find((item) =&gt; {<br>  return item % 2 === 0<br>})<br>// Expected output:find =2</p>\n<hr>\n<p>var arr = [1, 2, 3]<br>var ret = arr.find(ele =&gt; ele &gt; 2)<br>console.log(ret)<br>// Expected output:3<br>console.log(arr)<br>// Expected output:[1, 2, 3]</p>\n<hr>\n<h3 id=\"8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。\"><a href=\"#8-findIndex-返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组-findIndex对空数组不执行。\" class=\"headerlink\" title=\"8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。\"></a>8.findIndex() 返回符合条件的第一个元素的下标，没有符合条件的元素则返回-1，不改变原始数组,findIndex对空数组不执行。</h3><p>let arr = [1, 2, 3, 4, 5]<br>let findIndex = arr.findIndex((item) =&gt; {<br>  return item % 2 === 0<br>})<br>// Expected output:findIndex = 1</p>\n<hr>\n<p>var arr = [1, 2, 3, 4 ,5]<br>var ret = arr.findIndex(ele =&gt; ele &gt; 2)<br>console.log(ret)<br>// Expected output:2<br> console.log(arr)<br>// Expected output:[1, 2, 3, 4, 5]</p>\n<hr>\n<h1 id=\"二、遍历对象\"><a href=\"#二、遍历对象\" class=\"headerlink\" title=\"二、遍历对象\"></a>二、遍历对象</h1><h2 id=\"方法一：for-in-循环\"><a href=\"#方法一：for-in-循环\" class=\"headerlink\" title=\"方法一：for-in 循环\"></a>方法一：for-in 循环</h2><p>var obj = { a: 2, b: 4, c: 6 }<br>for (let key in obj) {<br>  console.log(key)<br>}<br>// Expected output:a b c</p>\n<h2 id=\"方法二：Object-keys-可理解为返回里面的key属性\"><a href=\"#方法二：Object-keys-可理解为返回里面的key属性\" class=\"headerlink\" title=\"方法二：Object.keys() 可理解为返回里面的key属性\"></a>方法二：Object.keys() 可理解为返回里面的key属性</h2><h3 id=\"1-处理对象时：返回可枚举的属性数组\"><a href=\"#1-处理对象时：返回可枚举的属性数组\" class=\"headerlink\" title=\"1.处理对象时：返回可枚举的属性数组\"></a>1.处理对象时：返回可枚举的属性数组</h3><p>var w_n = Object.keys({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[‘name’, ‘address’]</p>\n<hr>\n<h3 id=\"2-处理数组时：返回索引值数组\"><a href=\"#2-处理数组时：返回索引值数组\" class=\"headerlink\" title=\"2.处理数组时：返回索引值数组\"></a>2.处理数组时：返回索引值数组</h3><p>var w_n = Object.keys([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[‘0’,’1’,’2’,’3’]</p>\n<hr>\n<h3 id=\"3-处理字符串数据时：返回索引值数组\"><a href=\"#3-处理字符串数据时：返回索引值数组\" class=\"headerlink\" title=\"3.处理字符串数据时：返回索引值数组\"></a>3.处理字符串数据时：返回索引值数组</h3><p>var str=’hello’;<br>console.log(Object.keys(str))<br>// Expected output:[‘0’,’1’,’2’,’3’,’4’]</p>\n<h2 id=\"方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。\"><a href=\"#方法三：Object-values-方法，可理解为返回里面的value值，Object-values只返回对象自身的可遍历属性。\" class=\"headerlink\" title=\"方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。\"></a>方法三：Object.values()方法，可理解为返回里面的value值，Object.values只返回对象自身的可遍历属性。</h2><h3 id=\"1-处理对象数据时：返回可枚举的值组成的数组\"><a href=\"#1-处理对象数据时：返回可枚举的值组成的数组\" class=\"headerlink\" title=\"1.处理对象数据时：返回可枚举的值组成的数组\"></a>1.处理对象数据时：返回可枚举的值组成的数组</h3><p>var w_n = Object.values({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[‘wn’, ‘中国’]</p>\n<hr>\n<h3 id=\"2-处理数组数据时：返回原数组\"><a href=\"#2-处理数组数据时：返回原数组\" class=\"headerlink\" title=\"2.处理数组数据时：返回原数组\"></a>2.处理数组数据时：返回原数组</h3><p>var w_n = Object.values([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[11,22,33,44]</p>\n<hr>\n<h3 id=\"属性名为数值的属性，是按照数值大小，从小到大遍历的。\"><a href=\"#属性名为数值的属性，是按照数值大小，从小到大遍历的。\" class=\"headerlink\" title=\"属性名为数值的属性，是按照数值大小，从小到大遍历的。\"></a>属性名为数值的属性，是按照数值大小，从小到大遍历的。</h3><p>const obj = {10 : “a”, 6 : “b”, 9 : “c”}<br>console.log(Object.values(obj))<br>// Expected output:[‘b’, ‘c’, ‘a’]</p>\n<hr>\n<h3 id=\"3-处理字符串数据时：返回每个字符组成的数组\"><a href=\"#3-处理字符串数据时：返回每个字符组成的数组\" class=\"headerlink\" title=\"3.处理字符串数据时：返回每个字符组成的数组\"></a>3.处理字符串数据时：返回每个字符组成的数组</h3><p>console.log(Object.values(‘hello’))<br>// Expected output:[‘h’, ‘e’, ‘l’, ‘l’, ‘o’]</p>\n<hr>\n<h3 id=\"4-Object-values会过滤属性名为-Symbol-值的属性\"><a href=\"#4-Object-values会过滤属性名为-Symbol-值的属性\" class=\"headerlink\" title=\"4.Object.values会过滤属性名为 Symbol 值的属性\"></a>4.Object.values会过滤属性名为 Symbol 值的属性</h3><p>Object.values({ [Symbol()]: 123, foo: ‘abc’ })<br>// Expected output:[‘abc’]</p>\n<h2 id=\"方法四：Object-entries-方法\"><a href=\"#方法四：Object-entries-方法\" class=\"headerlink\" title=\"方法四：Object.entries()方法\"></a>方法四：Object.entries()方法</h2><h3 id=\"1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。\"><a href=\"#1-处理对象数据时：返回是一个二维数组。每一项是-key-value-形式。\" class=\"headerlink\" title=\"1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。\"></a>1.处理对象数据时：返回是一个二维数组。每一项是[key, value]形式。</h3><p>var w_n = Object.entries({name: “wn”, address: “中国”})<br>console.log(w_n)<br>// Expected output:[[‘name’, ‘wn’], [‘address’, ‘中国’]]</p>\n<hr>\n<h3 id=\"2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。\"><a href=\"#2-处理数组数据时：返回也是一个二维数组，数组里面的每一项-index-value-形式。\" class=\"headerlink\" title=\"2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。\"></a>2.处理数组数据时：返回也是一个二维数组，数组里面的每一项[index, value] 形式。</h3><p>var w_n = Object.entries([11,22,33,44])<br>console.log(w_n)<br>// Expected output:[ [‘0’,11], [‘1’,22], [‘2’,33], [‘3’,44] ]</p>\n<hr>\n<h3 id=\"数组中包含对象：\"><a href=\"#数组中包含对象：\" class=\"headerlink\" title=\"数组中包含对象：\"></a>数组中包含对象：</h3><p>var w_n = Object.entries([{a:11},22,33,44])<br>console.log(w_n)<br>// Expected output:[ [‘0’,{a:11}], [‘1’,22], [‘2’,33], [‘3’,44] ]</p>\n<hr>\n<h3 id=\"3-处理字符串数据时：返回也是一个二维数组。\"><a href=\"#3-处理字符串数据时：返回也是一个二维数组。\" class=\"headerlink\" title=\"3.处理字符串数据时：返回也是一个二维数组。\"></a>3.处理字符串数据时：返回也是一个二维数组。</h3><p>var str=’hello’<br>console.log(Object.entries(str))<br>// Expected output:[ [‘0’,’h’], [‘1’,’e’], [‘2’,’l’], [‘3’,’l’] ,[‘4’,’o’] ]</p>\n<h2 id=\"方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。\"><a href=\"#方法五：Object-assign-：Object-assign-方法的第一个参数是目标对象，后面的参数都是源对象。\" class=\"headerlink\" title=\"方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。\"></a>方法五：Object.assign()：Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</h2><h3 id=\"注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\"><a href=\"#注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\" class=\"headerlink\" title=\"注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\"></a>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</h3><p>const target = { a: 1, b: 2 };<br>const source = { b: 4, c: 5 };<br>const returnedTarget = Object.assign(target, source);<br>console.log(target);<br>// Expected output: Object { a: 1, b: 4, c: 5 }</p>\n<h2 id=\"方法六：Object-getOwnPropertyNames\"><a href=\"#方法六：Object-getOwnPropertyNames\" class=\"headerlink\" title=\"方法六：Object.getOwnPropertyNames()\"></a>方法六：Object.getOwnPropertyNames()</h2><h3 id=\"Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\"><a href=\"#Object-getOwnPropertyNames-返回一个数组，该数组对元素是-obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过-for…in-循环（或-Object-keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\" class=\"headerlink\" title=\"Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\"></a>Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。</h3><p>var arr = [“a”, “b”, “c”]<br>console.log(Object.getOwnPropertyNames(arr).sort())<br>// [“0”, “1”, “2”, “length”]</p>\n<hr>\n<h3 id=\"类数组对象\"><a href=\"#类数组对象\" class=\"headerlink\" title=\"// 类数组对象\"></a>// 类数组对象</h3><p>var obj = { 0: “a”, 1: “b”, 2: “c”}<br>console.log(Object.getOwnPropertyNames(obj).sort())<br>// Expected output:[“0”, “1”, “2”]</p>\n<hr>\n<h3 id=\"使用-Array-forEach-输出属性名和属性值\"><a href=\"#使用-Array-forEach-输出属性名和属性值\" class=\"headerlink\" title=\"// 使用 Array.forEach 输出属性名和属性值\"></a>// 使用 Array.forEach 输出属性名和属性值</h3><p>Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) {<br>  console.log(val + “ -&gt; “ + obj[val])<br>})<br>// Expected output:<br>// 0 -&gt; a<br>// 1 -&gt; b<br>// 2 -&gt; c</p>\n<hr>\n<h3 id=\"不可枚举属性\"><a href=\"#不可枚举属性\" class=\"headerlink\" title=\"//不可枚举属性\"></a>//不可枚举属性</h3><p>var my_obj = Object.create({}, {<br>  getFoo: {<br>    value: function() { return this.foo; },<br>    enumerable: false<br>  }<br>})<br>my_obj.foo = 1<br>console.log(Object.getOwnPropertyNames(my_obj).sort())<br>// Expected output:[“foo”, “getFoo”]</p>\n"},{"title":"博客搭建","date":"2022-08-16T13:45:54.000Z","_content":"# 1.安装hexo\n# 2.初始化项目\n## 现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\n## // 初始化生成blog项目\nhexo init blog\n# 3.配置主题\n## hexo默认的主题是_landscape，现在我们将主题配置为 keep。\n## // 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\ncd blog\n## // 安装keep主题\nnpm install hexo-theme-keep\n## // 修改_config.yml配置文件\ntheme: keep\n##// 预览网站\nhexo server\n在浏览器中打开http://localhost:4000\n# 4.添加文章\n## 现在，让我们新建一篇博客\n## // 在blog项目中，执行如下命令：新建文章\nhexo new post xxxx\n## 新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。\n## 编辑\n## 添加正文\n## 现在我们打开【xxxx.md】，写下我们的xxxxx。\n## 然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\n\n##  添加分类和标签\n接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下\ntags:xxxx\ncategories: xxxx\n## 然后，打开终端分别执行如下命令。\nhexo new page categories\nhexo new page tags\n\n## hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片\n\n## 为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:\nmenu:\n  主页: /\n  归档: /archives\n  分类: /categories\n  标签: /tags\n再次刷新http://localhost:4000\n# 5.发布草稿\n## 如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\nhexo new draft xxxx\n图片刷新http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令\n\n## // 发布草稿\nhexo publish draft xxxx\n## 现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片\n\n# 6.部署博客\n## 现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\n## 新建仓库\n1.我们打开 github，然后点击New repository按钮\n2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址\n## 部署\n// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\ncd blog\n// 安装部署插件\nnpm install hexo-deployer-git --save\n// 修改_config.yml配置文件\n// 将复制的地址，黏贴到如下repo字段中\ndeploy:\n type: git\n  repo: https://github.com/xxxx/xxxx.github.io.git\n branch: master\n// 部署网站到创建的仓库\nhexo deploy\n部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。","source":"_posts/博客搭建.md","raw":"---\ntitle: 博客搭建\ndate: 2022-08-16 21:45:54\ntags: 搭建博客\ncategories: 工具\n---\n# 1.安装hexo\n# 2.初始化项目\n## 现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\n## // 初始化生成blog项目\nhexo init blog\n# 3.配置主题\n## hexo默认的主题是_landscape，现在我们将主题配置为 keep。\n## // 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\ncd blog\n## // 安装keep主题\nnpm install hexo-theme-keep\n## // 修改_config.yml配置文件\ntheme: keep\n##// 预览网站\nhexo server\n在浏览器中打开http://localhost:4000\n# 4.添加文章\n## 现在，让我们新建一篇博客\n## // 在blog项目中，执行如下命令：新建文章\nhexo new post xxxx\n## 新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。\n## 编辑\n## 添加正文\n## 现在我们打开【xxxx.md】，写下我们的xxxxx。\n## 然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\n\n##  添加分类和标签\n接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下\ntags:xxxx\ncategories: xxxx\n## 然后，打开终端分别执行如下命令。\nhexo new page categories\nhexo new page tags\n\n## hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片\n\n## 为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:\nmenu:\n  主页: /\n  归档: /archives\n  分类: /categories\n  标签: /tags\n再次刷新http://localhost:4000\n# 5.发布草稿\n## 如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\nhexo new draft xxxx\n图片刷新http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令\n\n## // 发布草稿\nhexo publish draft xxxx\n## 现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片\n\n# 6.部署博客\n## 现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\n## 新建仓库\n1.我们打开 github，然后点击New repository按钮\n2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址\n## 部署\n// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\ncd blog\n// 安装部署插件\nnpm install hexo-deployer-git --save\n// 修改_config.yml配置文件\n// 将复制的地址，黏贴到如下repo字段中\ndeploy:\n type: git\n  repo: https://github.com/xxxx/xxxx.github.io.git\n branch: master\n// 部署网站到创建的仓库\nhexo deploy\n部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。","slug":"博客搭建","published":1,"updated":"2023-03-22T06:08:23.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnjliqo00207et830d1galc","content":"<h1 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h1><h1 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2.初始化项目\"></a>2.初始化项目</h1><h2 id=\"现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\"><a href=\"#现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\" class=\"headerlink\" title=\"现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\"></a>现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。</h2><h2 id=\"初始化生成blog项目\"><a href=\"#初始化生成blog项目\" class=\"headerlink\" title=\"// 初始化生成blog项目\"></a>// 初始化生成blog项目</h2><p>hexo init blog</p>\n<h1 id=\"3-配置主题\"><a href=\"#3-配置主题\" class=\"headerlink\" title=\"3.配置主题\"></a>3.配置主题</h1><h2 id=\"hexo默认的主题是-landscape，现在我们将主题配置为-keep。\"><a href=\"#hexo默认的主题是-landscape，现在我们将主题配置为-keep。\" class=\"headerlink\" title=\"hexo默认的主题是_landscape，现在我们将主题配置为 keep。\"></a>hexo默认的主题是_landscape，现在我们将主题配置为 keep。</h2><h2 id=\"确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\"><a href=\"#确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\" class=\"headerlink\" title=\"// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\"></a>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中</h2><p>cd blog</p>\n<h2 id=\"安装keep主题\"><a href=\"#安装keep主题\" class=\"headerlink\" title=\"// 安装keep主题\"></a>// 安装keep主题</h2><p>npm install hexo-theme-keep</p>\n<h2 id=\"修改-config-yml配置文件\"><a href=\"#修改-config-yml配置文件\" class=\"headerlink\" title=\"// 修改_config.yml配置文件\"></a>// 修改_config.yml配置文件</h2><p>theme: keep<br>##// 预览网站<br>hexo server<br>在浏览器中打开<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h1 id=\"4-添加文章\"><a href=\"#4-添加文章\" class=\"headerlink\" title=\"4.添加文章\"></a>4.添加文章</h1><h2 id=\"现在，让我们新建一篇博客\"><a href=\"#现在，让我们新建一篇博客\" class=\"headerlink\" title=\"现在，让我们新建一篇博客\"></a>现在，让我们新建一篇博客</h2><h2 id=\"在blog项目中，执行如下命令：新建文章\"><a href=\"#在blog项目中，执行如下命令：新建文章\" class=\"headerlink\" title=\"// 在blog项目中，执行如下命令：新建文章\"></a>// 在blog项目中，执行如下命令：新建文章</h2><p>hexo new post xxxx</p>\n<h2 id=\"新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。\"><a href=\"#新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。\" class=\"headerlink\" title=\"新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。\"></a>新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。</h2><h2 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h2><h2 id=\"添加正文\"><a href=\"#添加正文\" class=\"headerlink\" title=\"添加正文\"></a>添加正文</h2><h2 id=\"现在我们打开【xxxx-md】，写下我们的xxxxx。\"><a href=\"#现在我们打开【xxxx-md】，写下我们的xxxxx。\" class=\"headerlink\" title=\"现在我们打开【xxxx.md】，写下我们的xxxxx。\"></a>现在我们打开【xxxx.md】，写下我们的xxxxx。</h2><h2 id=\"然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了\"><a href=\"#然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了\" class=\"headerlink\" title=\"然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\"></a>然后保存。刷新<a href=\"http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\">http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了</a></h2><h2 id=\"添加分类和标签\"><a href=\"#添加分类和标签\" class=\"headerlink\" title=\"添加分类和标签\"></a>添加分类和标签</h2><p>接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下<br>tags:xxxx<br>categories: xxxx</p>\n<h2 id=\"然后，打开终端分别执行如下命令。\"><a href=\"#然后，打开终端分别执行如下命令。\" class=\"headerlink\" title=\"然后，打开终端分别执行如下命令。\"></a>然后，打开终端分别执行如下命令。</h2><p>hexo new page categories<br>hexo new page tags</p>\n<h2 id=\"hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片\"><a href=\"#hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片\" class=\"headerlink\" title=\"hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片\"></a>hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。<a href=\"http://localhost:4000/categories/%E5%9B%BE%E7%89%87\">http://localhost:4000/categories/图片</a>, <a href=\"http://localhost:4000/tags/%E5%9B%BE%E7%89%87\">http://localhost:4000/tags/图片</a></h2><h2 id=\"为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改\"><a href=\"#为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改\" class=\"headerlink\" title=\"为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:\"></a>为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:</h2><p>menu:<br>  主页: /<br>  归档: /archives<br>  分类: /categories<br>  标签: /tags<br>再次刷新<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h1 id=\"5-发布草稿\"><a href=\"#5-发布草稿\" class=\"headerlink\" title=\"5.发布草稿\"></a>5.发布草稿</h1><h2 id=\"如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\"><a href=\"#如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\" class=\"headerlink\" title=\"如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\"></a>如果你暂时还不想要文章被公开访问，可以先创建草稿。如下</h2><p>hexo new draft xxxx<br>图片刷新<a href=\"http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令\">http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令</a></p>\n<h2 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"// 发布草稿\"></a>// 发布草稿</h2><p>hexo publish draft xxxx</p>\n<h2 id=\"现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片\"><a href=\"#现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片\" class=\"headerlink\" title=\"现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片\"></a>现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新<a href=\"http://localhost:4000，便可以看到这篇文章了图片\">http://localhost:4000，便可以看到这篇文章了图片</a></h2><h1 id=\"6-部署博客\"><a href=\"#6-部署博客\" class=\"headerlink\" title=\"6.部署博客\"></a>6.部署博客</h1><h2 id=\"现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\"><a href=\"#现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\" class=\"headerlink\" title=\"现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\"></a>现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。</h2><h2 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h2><p>1.我们打开 github，然后点击New repository按钮<br>2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中<br>cd blog<br>// 安装部署插件<br>npm install hexo-deployer-git –save<br>// 修改_config.yml配置文件<br>// 将复制的地址，黏贴到如下repo字段中<br>deploy:<br> type: git<br>  repo: <a href=\"https://github.com/xxxx/xxxx.github.io.git\">https://github.com/xxxx/xxxx.github.io.git</a><br> branch: master<br>// 部署网站到创建的仓库<br>hexo deploy<br>部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h1><h1 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2.初始化项目\"></a>2.初始化项目</h1><h2 id=\"现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\"><a href=\"#现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\" class=\"headerlink\" title=\"现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。\"></a>现在我们已经安装完成hexo了。接下来使用hexo初始化博客项目。</h2><h2 id=\"初始化生成blog项目\"><a href=\"#初始化生成blog项目\" class=\"headerlink\" title=\"// 初始化生成blog项目\"></a>// 初始化生成blog项目</h2><p>hexo init blog</p>\n<h1 id=\"3-配置主题\"><a href=\"#3-配置主题\" class=\"headerlink\" title=\"3.配置主题\"></a>3.配置主题</h1><h2 id=\"hexo默认的主题是-landscape，现在我们将主题配置为-keep。\"><a href=\"#hexo默认的主题是-landscape，现在我们将主题配置为-keep。\" class=\"headerlink\" title=\"hexo默认的主题是_landscape，现在我们将主题配置为 keep。\"></a>hexo默认的主题是_landscape，现在我们将主题配置为 keep。</h2><h2 id=\"确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\"><a href=\"#确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\" class=\"headerlink\" title=\"// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中\"></a>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中</h2><p>cd blog</p>\n<h2 id=\"安装keep主题\"><a href=\"#安装keep主题\" class=\"headerlink\" title=\"// 安装keep主题\"></a>// 安装keep主题</h2><p>npm install hexo-theme-keep</p>\n<h2 id=\"修改-config-yml配置文件\"><a href=\"#修改-config-yml配置文件\" class=\"headerlink\" title=\"// 修改_config.yml配置文件\"></a>// 修改_config.yml配置文件</h2><p>theme: keep<br>##// 预览网站<br>hexo server<br>在浏览器中打开<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h1 id=\"4-添加文章\"><a href=\"#4-添加文章\" class=\"headerlink\" title=\"4.添加文章\"></a>4.添加文章</h1><h2 id=\"现在，让我们新建一篇博客\"><a href=\"#现在，让我们新建一篇博客\" class=\"headerlink\" title=\"现在，让我们新建一篇博客\"></a>现在，让我们新建一篇博客</h2><h2 id=\"在blog项目中，执行如下命令：新建文章\"><a href=\"#在blog项目中，执行如下命令：新建文章\" class=\"headerlink\" title=\"// 在blog项目中，执行如下命令：新建文章\"></a>// 在blog项目中，执行如下命令：新建文章</h2><p>hexo new post xxxx</p>\n<h2 id=\"新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。\"><a href=\"#新建的这篇博客以markdown的格式形式存储在了blog-source-posts目录下。\" class=\"headerlink\" title=\"新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。\"></a>新建的这篇博客以markdown的格式形式存储在了blog/source/_posts目录下。</h2><h2 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h2><h2 id=\"添加正文\"><a href=\"#添加正文\" class=\"headerlink\" title=\"添加正文\"></a>添加正文</h2><h2 id=\"现在我们打开【xxxx-md】，写下我们的xxxxx。\"><a href=\"#现在我们打开【xxxx-md】，写下我们的xxxxx。\" class=\"headerlink\" title=\"现在我们打开【xxxx.md】，写下我们的xxxxx。\"></a>现在我们打开【xxxx.md】，写下我们的xxxxx。</h2><h2 id=\"然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了\"><a href=\"#然后保存。刷新http-localhost-4000该链接。便可以看到看到我们刚刚更新的最新文章了\" class=\"headerlink\" title=\"然后保存。刷新http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\"></a>然后保存。刷新<a href=\"http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了\">http://localhost:4000该链接。便可以看到看到我们刚刚更新的最新文章了</a></h2><h2 id=\"添加分类和标签\"><a href=\"#添加分类和标签\" class=\"headerlink\" title=\"添加分类和标签\"></a>添加分类和标签</h2><p>接着我们为文章添加分类和标签：打开【xxxx.md】，修改如下<br>tags:xxxx<br>categories: xxxx</p>\n<h2 id=\"然后，打开终端分别执行如下命令。\"><a href=\"#然后，打开终端分别执行如下命令。\" class=\"headerlink\" title=\"然后，打开终端分别执行如下命令。\"></a>然后，打开终端分别执行如下命令。</h2><p>hexo new page categories<br>hexo new page tags</p>\n<h2 id=\"hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片\"><a href=\"#hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index-md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http-localhost-4000-categories-图片-http-localhost-4000-tags-图片\" class=\"headerlink\" title=\"hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。http://localhost:4000/categories/图片, http://localhost:4000/tags/图片\"></a>hexo会在souce目录下，创建一个categories和tags文件夹，里面都包含一个index.md文件。现在我们在浏览器中分别访问如下地址，便可以分别看到我们添加的分类和标签了。点击【xxxx】分类和【xxxx】标签便可以看到属于它们的文章。<a href=\"http://localhost:4000/categories/%E5%9B%BE%E7%89%87\">http://localhost:4000/categories/图片</a>, <a href=\"http://localhost:4000/tags/%E5%9B%BE%E7%89%87\">http://localhost:4000/tags/图片</a></h2><h2 id=\"为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改\"><a href=\"#为了能在主页直接访问标签和分类，我们可以对node-moduels-hexo-theme-keep-config-yml配置文件做如下修改\" class=\"headerlink\" title=\"为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:\"></a>为了能在主页直接访问标签和分类，我们可以对node_moduels/hexo-theme-keep/_config.yml配置文件做如下修改:</h2><p>menu:<br>  主页: /<br>  归档: /archives<br>  分类: /categories<br>  标签: /tags<br>再次刷新<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h1 id=\"5-发布草稿\"><a href=\"#5-发布草稿\" class=\"headerlink\" title=\"5.发布草稿\"></a>5.发布草稿</h1><h2 id=\"如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\"><a href=\"#如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\" class=\"headerlink\" title=\"如果你暂时还不想要文章被公开访问，可以先创建草稿。如下\"></a>如果你暂时还不想要文章被公开访问，可以先创建草稿。如下</h2><p>hexo new draft xxxx<br>图片刷新<a href=\"http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令\">http://localhost:4000暂时还无法访问我们新创建的这篇文章，如果想要访问这篇文章，我们则需要发布该文章，执行如下命令</a></p>\n<h2 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"// 发布草稿\"></a>// 发布草稿</h2><p>hexo publish draft xxxx</p>\n<h2 id=\"现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片\"><a href=\"#现在这篇文章从-draft目录移动到了-post目录。图片接着，我们再刷新http-localhost-4000，便可以看到这篇文章了图片\" class=\"headerlink\" title=\"现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新http://localhost:4000，便可以看到这篇文章了图片\"></a>现在这篇文章从_draft目录移动到了_post目录。图片接着，我们再刷新<a href=\"http://localhost:4000，便可以看到这篇文章了图片\">http://localhost:4000，便可以看到这篇文章了图片</a></h2><h1 id=\"6-部署博客\"><a href=\"#6-部署博客\" class=\"headerlink\" title=\"6.部署博客\"></a>6.部署博客</h1><h2 id=\"现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\"><a href=\"#现在我们使用github-page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\" class=\"headerlink\" title=\"现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。\"></a>现在我们使用github page来部署我们的博客。首先你需要有一个github账号，如果没有则需要先去注册一个。</h2><h2 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h2><p>1.我们打开 github，然后点击New repository按钮<br>2.创建一个名为「username .github.io」的存储库，其中username是你在GitHub上的用户名图片3.成功创建长仓库后，复制仓库的https地址</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>// 确认目录是否切换到了blog中，如果没有，则将目录切换到blog中<br>cd blog<br>// 安装部署插件<br>npm install hexo-deployer-git –save<br>// 修改_config.yml配置文件<br>// 将复制的地址，黏贴到如下repo字段中<br>deploy:<br> type: git<br>  repo: <a href=\"https://github.com/xxxx/xxxx.github.io.git\">https://github.com/xxxx/xxxx.github.io.git</a><br> branch: master<br>// 部署网站到创建的仓库<br>hexo deploy<br>部署完成后，我们刷新one-cheese.github.io仓库，本地生成的public中的静态资源全都上传到了该仓库中，如图。图片现在，访问github page地址one-cheese.github.io，便可以看到部署成功的博客了。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Hooks/案例1.png","post":"clfnjlipr00017et86k6k4djw","slug":"案例1.png","modified":1,"renderable":1},{"_id":"source/_posts/Hooks/案例2.png","post":"clfnjlipr00017et86k6k4djw","slug":"案例2.png","modified":1,"renderable":1},{"_id":"source/_posts/Hooks/案例3.png","post":"clfnjlipr00017et86k6k4djw","slug":"案例3.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/reactive代码.png","post":"clfnjlipx00037et8h40bdccr","slug":"reactive代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用代码.png","post":"clfnjlipx00037et8h40bdccr","slug":"refs使用代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用控制台信息.png","post":"clfnjlipx00037et8h40bdccr","slug":"refs使用控制台信息.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用正常.png","post":"clfnjlipx00037et8h40bdccr","slug":"refs使用正常.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs使用结果.png","post":"clfnjlipx00037et8h40bdccr","slug":"refs使用结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/refs解决代码.png","post":"clfnjlipx00037et8h40bdccr","slug":"refs解决代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/ref函数验证代码.png","post":"clfnjlipx00037et8h40bdccr","slug":"ref函数验证代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/ref函数验证结果.png","post":"clfnjlipx00037et8h40bdccr","slug":"ref函数验证结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/torefbody打印结果.png","post":"clfnjlipx00037et8h40bdccr","slug":"torefbody打印结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref代码.png","post":"clfnjlipx00037et8h40bdccr","slug":"toref代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref修改代码.png","post":"clfnjlipx00037et8h40bdccr","slug":"toref修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref修改结果.png","post":"clfnjlipx00037et8h40bdccr","slug":"toref修改结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref打印body代码.png","post":"clfnjlipx00037et8h40bdccr","slug":"toref打印body代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref源数据.png","post":"clfnjlipx00037et8h40bdccr","slug":"toref源数据.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/toref页面成功.png","post":"clfnjlipx00037et8h40bdccr","slug":"toref页面成功.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/原始数据代码.png","post":"clfnjlipx00037et8h40bdccr","slug":"原始数据代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/截屏2022-10-17 上午11.27.38.png","post":"clfnjlipx00037et8h40bdccr","slug":"截屏2022-10-17 上午11.27.38.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3toRef和toRefs函数/数据源结果.png","post":"clfnjlipx00037et8h40bdccr","slug":"数据源结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3计算属性/引入.png","post":"clfnjliq200077et8d31abbko","slug":"引入.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3计算属性/案例一.png","post":"clfnjliq200077et8d31abbko","slug":"案例一.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3计算属性/案例二.png","post":"clfnjliq200077et8d31abbko","slug":"案例二.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3计算属性/计算属性求和.png","post":"clfnjliq200077et8d31abbko","slug":"计算属性求和.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一代码.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器一代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一控制台.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器一控制台.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一数据更新.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器一数据更新.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一数据更新代码.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器一数据更新代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器一结果.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器一结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器三代码.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器三代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器三修改代码.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器三修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器三修改结果.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器三修改结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器三报错.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器三报错.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器二代码.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器二代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器二修改代码.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器二修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器二修改结果.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器二修改结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器二警告.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器二警告.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器监听reactive代码.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器监听reactive代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听器监听reactive结果.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听器监听reactive结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听多个参数.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听多个参数.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/侦听多个参数结果.png","post":"clfnjliq8000g7et8d26if35x","slug":"侦听多个参数结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3侦听器watch/多个侦听器代码.png","post":"clfnjliq8000g7et8d26if35x","slug":"多个侦听器代码.png","modified":1,"renderable":1},{"_id":"source/_posts/serve的区别/npm区别.png","post":"clfnjliqa000j7et8a2jsai8f","slug":"npm区别.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/indexts.png","post":"clfnjliq4000b7et8buh4fubn","slug":"indexts.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/安装.png","post":"clfnjliq4000b7et8buh4fubn","slug":"安装.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图10代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图10代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图10结果.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图10结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图11代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图11代码1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11代码2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图11代码2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11结果1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图11结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图11结果2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图11结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图12代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图12代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图12结果.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图12结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图13代码1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图13代码1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图13代码2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图13代码2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图13结果1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图13结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图13结果2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图13结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图14代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图14代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图14结果1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图14结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图14结果2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图14结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图15代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图15代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图15结果1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图15结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图15结果2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图15结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图16代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图16代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图16结果1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图16结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图16结果2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图16结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图17代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图17代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图17结果.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图17结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图1代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图1代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图1结果.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图1结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图2代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图2代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图2结果.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图2结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图3代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图3代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图3结果1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图3结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图3结果2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图3结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图4代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图4代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图5代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图5代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图6代码1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图6代码1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图6代码2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图6代码2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图6结果1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图6结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图6结果2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图6结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图7代码1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图7代码1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图7代码2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图7代码2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图7结果1.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图7结果1.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图7结果2.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图7结果2.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图8代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图8代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图8结果.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图8结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图9代码.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图9代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3-Pinia使用/截图9结果.png","post":"clfnjliq4000b7et8buh4fubn","slug":"截图9结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowReactive一代码.png","post":"clfnjliqb000p7et80gepcz4y","slug":"shallowReactive一代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowReactive一代码结果.png","post":"clfnjliqb000p7et80gepcz4y","slug":"shallowReactive一代码结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef二代码.png","post":"clfnjliqb000p7et80gepcz4y","slug":"shallowRef二代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef二代码结果.png","post":"clfnjliqb000p7et80gepcz4y","slug":"shallowRef二代码结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef代码.png","post":"clfnjliqb000p7et80gepcz4y","slug":"shallowRef代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3shallowRef和shallowReactive/shallowRef代码结果.png","post":"clfnjliqb000p7et80gepcz4y","slug":"shallowRef代码结果.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/name.png","post":"clfnjliqe00107et850mt59yy","slug":"name.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/名称渲染失败.png","post":"clfnjliqe00107et850mt59yy","slug":"名称渲染失败.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/基本变量.png","post":"clfnjliqe00107et850mt59yy","slug":"基本变量.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/基本数据代码.png","post":"clfnjliqe00107et850mt59yy","slug":"基本数据代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/基本数据类型.png","post":"clfnjliqe00107et850mt59yy","slug":"基本数据类型.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/复杂数据代码.png","post":"clfnjliqe00107et850mt59yy","slug":"复杂数据代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/复杂数据类型.png","post":"clfnjliqe00107et850mt59yy","slug":"复杂数据类型.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/提示找不到.png","post":"clfnjliqe00107et850mt59yy","slug":"提示找不到.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/渲染成功.png","post":"clfnjliqe00107et850mt59yy","slug":"渲染成功.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/点击代码.png","post":"clfnjliqe00107et850mt59yy","slug":"点击代码.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue3setup函数/被点击.png","post":"clfnjliqe00107et850mt59yy","slug":"被点击.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive修改代码.png","post":"clfnjliqg00187et88kk12iyq","slug":"reactive修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象代码.png","post":"clfnjliqg00187et88kk12iyq","slug":"reactive对象代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象修改结果.png","post":"clfnjliqg00187et88kk12iyq","slug":"reactive对象修改结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive对象结果.png","post":"clfnjliqg00187et88kk12iyq","slug":"reactive对象结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive数组代码.png","post":"clfnjliqg00187et88kk12iyq","slug":"reactive数组代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/reactive数组处理结果.png","post":"clfnjliqg00187et88kk12iyq","slug":"reactive数组处理结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/refdom代码.png","post":"clfnjliqg00187et88kk12iyq","slug":"refdom代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref修改代码.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref基本修改成功.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref基本修改成功.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref基本出错.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref基本出错.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref基本控制台.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref基本控制台.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref基本数据类型代码.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref基本数据类型代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂修改代码.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref复杂修改代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂修改代码成功.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref复杂修改代码成功.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂数据代码.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref复杂数据代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref复杂结构.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref复杂结构.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref成功.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref成功.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref打印.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref打印.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3ref和reactive函数/ref结构.png","post":"clfnjliqg00187et88kk12iyq","slug":"ref结构.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3-hooks使用/案例1.png","post":"clfnjliqh001b7et8dlcn2jgd","slug":"案例1.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3-hooks使用/案例2.png","post":"clfnjliqh001b7et8dlcn2jgd","slug":"案例2.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3-hooks使用/案例3.png","post":"clfnjliqh001b7et8dlcn2jgd","slug":"案例3.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例1.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例1.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例10.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例10.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例11.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例11.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例12.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例12.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例13.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例13.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例14.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例14.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例15.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例15.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例16.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例16.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例17.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例17.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例18.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例18.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例19.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例19.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例2.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例2.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例20.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例20.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例21.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例21.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例22.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例22.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例23.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例23.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例3.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例3.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例4.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例4.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例5.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例5.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例6.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例6.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例7.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例7.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3API/案例9.png","post":"clfnjliqg00157et84hv6b4kx","slug":"案例9.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/传值前结果.png","post":"clfnjliql001p7et8a54u0psn","slug":"传值前结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/传值后结果.png","post":"clfnjliql001p7et8a54u0psn","slug":"传值后结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/子传父结果.png","post":"clfnjliql001p7et8a54u0psn","slug":"子传父结果.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/子组件三代码.png","post":"clfnjliql001p7et8a54u0psn","slug":"子组件三代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/子组件二代码.png","post":"clfnjliql001p7et8a54u0psn","slug":"子组件二代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/子组件代码.png","post":"clfnjliql001p7et8a54u0psn","slug":"子组件代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/父组件三代码.png","post":"clfnjliql001p7et8a54u0psn","slug":"父组件三代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/父组件二代码.png","post":"clfnjliql001p7et8a54u0psn","slug":"父组件二代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/父组件代码.png","post":"clfnjliql001p7et8a54u0psn","slug":"父组件代码.png","modified":1,"renderable":1},{"_id":"source/_posts/vue3组件传值/祖孙结果.png","post":"clfnjliql001p7et8a54u0psn","slug":"祖孙结果.png","modified":1,"renderable":1},{"_id":"source/_posts/深浅拷贝/深浅拷贝结果.png","post":"clfnjliqm001r7et8hhyjdrci","slug":"深浅拷贝结果.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"clfnjlipr00017et86k6k4djw","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqb000l7et801lqcq9h"},{"post_id":"clfnjliq4000b7et8buh4fubn","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqc000q7et8fzs822yl"},{"post_id":"clfnjliq8000g7et8d26if35x","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqd000u7et8etpwhmyt"},{"post_id":"clfnjlipx00037et8h40bdccr","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqe000y7et82dbig0f5"},{"post_id":"clfnjliqb000p7et80gepcz4y","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqe00117et85nke5o3q"},{"post_id":"clfnjliq200077et8d31abbko","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqg00167et846u047b1"},{"post_id":"clfnjliqc000s7et8g0824j58","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqh00197et8husua6fu"},{"post_id":"clfnjliqe000x7et8952hb7rx","category_id":"clfnjliqd000t7et84qn60a2u","_id":"clfnjliqh001c7et88a564nqz"},{"post_id":"clfnjliq300097et818qjhh3z","category_id":"clfnjliqd000t7et84qn60a2u","_id":"clfnjliqh001e7et8235m7fm7"},{"post_id":"clfnjliqe00107et850mt59yy","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqi001g7et8din1ba5k"},{"post_id":"clfnjliqg00157et84hv6b4kx","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqi001i7et8hspuanqf"},{"post_id":"clfnjliqa000j7et8a2jsai8f","category_id":"clfnjliqd000t7et84qn60a2u","_id":"clfnjliqi001k7et83pbg5yga"},{"post_id":"clfnjliqg00187et88kk12iyq","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqi001m7et80p8s3fiz"},{"post_id":"clfnjliqh001b7et8dlcn2jgd","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqi001n7et8gqtf8drf"},{"post_id":"clfnjliql001o7et84uxl8l5y","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqn001u7et8hcpfc35r"},{"post_id":"clfnjliql001p7et8a54u0psn","category_id":"clfnjliq000047et82abv30ch","_id":"clfnjliqn001x7et85amd6i6c"},{"post_id":"clfnjliqm001r7et8hhyjdrci","category_id":"clfnjliqd000t7et84qn60a2u","_id":"clfnjliqn001z7et86givf74f"},{"post_id":"clfnjliqm001t7et8ay7q5k62","category_id":"clfnjliqd000t7et84qn60a2u","_id":"clfnjliqo00227et89b9sb8uq"},{"post_id":"clfnjliqn001w7et89fkz7srs","category_id":"clfnjliqd000t7et84qn60a2u","_id":"clfnjliqp00257et88ydud5rg"},{"post_id":"clfnjliqn001y7et84hwp4ikv","category_id":"clfnjliqo00237et8epf60ll9","_id":"clfnjliqs002a7et8gl5560m2"},{"post_id":"clfnjliqo00207et830d1galc","category_id":"clfnjliqq00277et8e2wx7q76","_id":"clfnjliqs002d7et85ehv49sr"}],"PostTag":[{"post_id":"clfnjlipr00017et86k6k4djw","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliq7000e7et8f2yx5cn0"},{"post_id":"clfnjliq4000b7et8buh4fubn","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqa000h7et8hvhecb84"},{"post_id":"clfnjliq8000g7et8d26if35x","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqb000n7et8666vczcz"},{"post_id":"clfnjlipx00037et8h40bdccr","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqc000r7et84mox8xz2"},{"post_id":"clfnjliqb000p7et80gepcz4y","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqe000w7et83l0k53ic"},{"post_id":"clfnjliq200077et8d31abbko","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqe000z7et838cr4lvt"},{"post_id":"clfnjliqc000s7et8g0824j58","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqg00147et82dg66gg2"},{"post_id":"clfnjliqe000x7et8952hb7rx","tag_id":"clfnjliqd000v7et820izhujd","_id":"clfnjliqg00177et89pfwdfy9"},{"post_id":"clfnjliq300097et818qjhh3z","tag_id":"clfnjliqd000v7et820izhujd","_id":"clfnjliqh001a7et86tnnfg1o"},{"post_id":"clfnjliqe00107et850mt59yy","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqh001d7et8480u4fi0"},{"post_id":"clfnjliqg00157et84hv6b4kx","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqh001f7et8bxuofo2v"},{"post_id":"clfnjliqa000j7et8a2jsai8f","tag_id":"clfnjliqd000v7et820izhujd","_id":"clfnjliqi001h7et8fon0f9df"},{"post_id":"clfnjliqg00187et88kk12iyq","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqi001j7et8bcp739ux"},{"post_id":"clfnjliqh001b7et8dlcn2jgd","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqi001l7et849js01ho"},{"post_id":"clfnjliql001o7et84uxl8l5y","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqm001q7et82ihl80w1"},{"post_id":"clfnjliql001p7et8a54u0psn","tag_id":"clfnjliq100057et82pxbekt7","_id":"clfnjliqm001s7et82nl6gzac"},{"post_id":"clfnjliqm001r7et8hhyjdrci","tag_id":"clfnjliqn001v7et8aewkhruu","_id":"clfnjliqp00247et8aghue22d"},{"post_id":"clfnjliqm001t7et8ay7q5k62","tag_id":"clfnjliqo00217et8363y2vxe","_id":"clfnjliqr00287et85r7zdtok"},{"post_id":"clfnjliqn001w7et89fkz7srs","tag_id":"clfnjliqp00267et85ryoc1nc","_id":"clfnjliqs002b7et8c3844z65"},{"post_id":"clfnjliqn001y7et84hwp4ikv","tag_id":"clfnjliqr00297et8b0m6c0r0","_id":"clfnjliqs002e7et8dpa87ak7"},{"post_id":"clfnjliqo00207et830d1galc","tag_id":"clfnjliqs002c7et8avo5914i","_id":"clfnjliqs002f7et86pco03u0"}],"Tag":[{"name":"vue3","_id":"clfnjliq100057et82pxbekt7"},{"name":"vue","_id":"clfnjliqd000v7et820izhujd"},{"name":"深浅拷贝","_id":"clfnjliqn001v7et8aewkhruu"},{"name":"webpack","_id":"clfnjliqo00217et8363y2vxe"},{"name":"跨域","_id":"clfnjliqp00267et85ryoc1nc"},{"name":"JavaScript","_id":"clfnjliqr00297et8b0m6c0r0"},{"name":"搭建博客","_id":"clfnjliqs002c7et8avo5914i"}]}}