---
title: 模块化
date: 2023-04-11 22:32:31
tags: 模块化
categories: 模块化
---
前言
当你去面试的时候，被面试官问到前端模块化的问题，你的回答换来的是面试官的一句“你说了，但是好像又没说”。此时会感到备受打击，怀疑人生的问前端模块化到底是啥？说你好像知道，又好像说不出所以然来。

1. 模块化简述
把复杂代码按功能的不同划分成不同的模块单独维护，提高开发效率，降低维护成本 模块化只是思想、理论，不包含具体实现
2. 模块化的诞生
简单来说，就是一个人做不完的事，分成了多个人做，每人负责一个块内容（模块），最后把每个人做的东西组装一起成为整体
前端模块化的演进道路上虽然有很多阶段，但是其实最终的目标，就是拆分模块，分工开发，每个人做好一个模块之后，暴露一些参数、方法给到调用者，演进的道路无非是秉行如何更加优雅，高解耦，高兼容等方向优化
3. 模块化的演进
第一阶段：仅仅基于文件的划分模块的方式
具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）
缺点：所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，而且模块一段多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系
第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中
具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。
通过「命名空间」减小了命名冲突的可能，但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系。
第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间
具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现
有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。
第四阶段： 利用 IIFE 参数作为依赖声明使用
具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。
这使得每一个模块之间的关系变得更加明显。
第五阶段： 模块化规范
Require.js 提供了 AMD 模块化规范，以及一个自动化模块加载器---模块化规范的出现，再之后便有了其他更多标准紧接而来，CommonJS、CMD。。。
4. 模块化规范的出现
需：模块化标准+模块加载器
CommonJS规范(nodejs提出的一套标准)
标准： 一个文件就是一个模块 每个模块都有单独的作用域 通过 module.exports 导出成员 通过 require 函数载入模块
缺点：CommonJS是以同步模式加载模块，node执行机制是启动时加载模块，执行过程中不需要加载只需使用，在node中不会有问题；但是在浏览器端页面加载会导致大量同步请求出现，而效率低
AMD(Asynchronous Module Definition) --- 异步模块定义规范
模块通过define函数定义
优势：目前绝大多数第三方库都支持AMD规范
缺点： 使用复杂 模块划分细致，模块JS文件会出现请求频繁的情况
Sea.js(淘宝推出) + CMD(通用模块定义规范)
CMD规范类似CommonJS规范 后期也被Require.js兼容了
Require.js
提供了 AMD 模块化规范，以及一个自动化模块加载器 提供require函数加载模块
5. 模块化默认规范
浏览器环境使用ES Modules
nodejs使用CommonJS